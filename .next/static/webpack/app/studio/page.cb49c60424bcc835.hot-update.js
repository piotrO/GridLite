"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/studio/page",{

/***/ "(app-pages-browser)/./src/lib/manifest-utils.ts":
/*!***********************************!*\
  !*** ./src/lib/manifest-utils.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyDynamicValues: function() { return /* binding */ applyDynamicValues; },\n/* harmony export */   deepMerge: function() { return /* binding */ deepMerge; },\n/* harmony export */   fixRelativePaths: function() { return /* binding */ fixRelativePaths; },\n/* harmony export */   generateDynamicDataScript: function() { return /* binding */ generateDynamicDataScript; },\n/* harmony export */   parseManifestJs: function() { return /* binding */ parseManifestJs; },\n/* harmony export */   serializeManifest: function() { return /* binding */ serializeManifest; }\n/* harmony export */ });\n/**\n * Utilities for parsing and manipulating Grid8 ad manifests\n */ /**\n * Deep merge two objects, with source values overriding target\n */ function deepMerge(target, source) {\n    const output = {\n        ...target\n    };\n    for(const key in source){\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            const sourceValue = source[key];\n            const targetValue = target[key];\n            if (sourceValue && typeof sourceValue === \"object\" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === \"object\" && !Array.isArray(targetValue)) {\n                // Recursively merge nested objects\n                output[key] = deepMerge(targetValue, sourceValue);\n            } else if (sourceValue !== undefined) {\n                // Direct assignment for primitives, arrays, and when target doesn't have the key\n                output[key] = sourceValue;\n            }\n        }\n    }\n    return output;\n}\n/**\n * Parse a manifest.js file content into a JavaScript object\n * The file format is: window.manifest = { ... };\n */ function parseManifestJs(jsContent) {\n    // Remove the \"window.manifest = \" prefix and trailing semicolon\n    const jsonMatch = jsContent.match(/window\\.manifest\\s*=\\s*(\\{[\\s\\S]*\\});?\\s*$/);\n    if (!jsonMatch) {\n        throw new Error(\"Invalid manifest.js format: could not find window.manifest assignment\");\n    }\n    try {\n        // The manifest is a JS object literal, not strict JSON\n        // We need to evaluate it safely\n        // Using Function constructor to parse JS object literal\n        const manifestObj = new Function(\"return \".concat(jsonMatch[1]))();\n        return manifestObj;\n    } catch (error) {\n        throw new Error(\"Failed to parse manifest.js: \".concat(error));\n    }\n}\n/**\n * Serialize a manifest object back to a manifest.js string\n */ function serializeManifest(manifest) {\n    return \"window.manifest = \".concat(JSON.stringify(manifest, null, 2), \";\");\n}\n/**\n * Fix relative paths in HTML content by converting them to absolute paths\n * This is necessary when serving HTML from a Blob URL\n */ function fixRelativePaths(html, basePath) {\n    // Ensure basePath doesn't have trailing slash\n    const base = basePath.replace(/\\/$/, \"\");\n    // Helper to check if a path is already absolute\n    const isAbsolute = (path)=>{\n        return path.startsWith(\"/\") || path.startsWith(\"http://\") || path.startsWith(\"https://\") || path.startsWith(\"//\") || path.startsWith(\"data:\") || path.startsWith(\"blob:\") || path.startsWith(\"#\");\n    };\n    // Helper to fix a single path\n    const fixPath = (path)=>{\n        if (isAbsolute(path)) return path;\n        // Remove ./ prefix if present\n        const cleanPath = path.replace(/^\\.\\//, \"\");\n        return \"\".concat(base, \"/\").concat(cleanPath);\n    };\n    // Fix src attributes\n    html = html.replace(/(<(?:script|img|source|video|audio|embed|iframe)[^>]*\\s+src\\s*=\\s*[\"'])([^\"']+)([\"'])/gi, (match, prefix, path, suffix)=>{\n        return \"\".concat(prefix).concat(fixPath(path)).concat(suffix);\n    });\n    // Fix href attributes (for link, a tags)\n    html = html.replace(/(<(?:link|a)[^>]*\\s+href\\s*=\\s*[\"'])([^\"']+)([\"'])/gi, (match, prefix, path, suffix)=>{\n        // Don't fix anchor links or javascript:\n        if (path.startsWith(\"#\") || path.startsWith(\"javascript:\")) {\n            return match;\n        }\n        return \"\".concat(prefix).concat(fixPath(path)).concat(suffix);\n    });\n    // Fix url() in CSS (inline styles and style tags)\n    html = html.replace(/url\\(\\s*[\"']?([^\"')]+)[\"']?\\s*\\)/gi, (match, path)=>{\n        if (isAbsolute(path)) return match;\n        const cleanPath = path.replace(/^\\.\\//, \"\");\n        return \"url('\".concat(base, \"/\").concat(cleanPath, \"')\");\n    });\n    return html;\n}\n/**\n * Apply dynamic values from the UI to the manifest\n * This updates the defaultValue fields in the manifest's dynamicValues settings\n */ function applyDynamicValues(manifest, data) {\n    // Clone the manifest to avoid mutation\n    const newManifest = JSON.parse(JSON.stringify(manifest));\n    const settings = newManifest.settings;\n    if (!settings) return newManifest;\n    const dynamicValues = settings.dynamicValues;\n    if (!dynamicValues) return newManifest;\n    // Map UI field names to manifest dynamic value names\n    const fieldMapping = {\n        headline: \"s0_header\",\n        bodyCopy: \"s0_sub\",\n        ctaText: \"s0_cta\",\n        imageUrl: \"s0_bgr\",\n        logoUrl: \"s0_logo\"\n    };\n    // Update each dynamic value\n    for (const [uiField, manifestName] of Object.entries(fieldMapping)){\n        const value = data[uiField];\n        if (value && typeof value === \"string\") {\n            const dynamicValue = dynamicValues.find((dv)=>dv.name === manifestName);\n            if (dynamicValue) {\n                dynamicValue.defaultValue = value;\n            }\n        }\n    }\n    // Handle colors separately (they need to be joined with |)\n    if (data.colors && data.colors.length > 0) {\n        // Colors are applied via the globalScripts in the template's HTML\n        // We'll inject them as a dynamicData override in the HTML\n        // Store them in a custom field for later use\n        newManifest.__colors = data.colors;\n    }\n    return newManifest;\n}\n/**\n * Generate the inline script that sets up dynamicData with colors\n */ function generateDynamicDataScript(colors) {\n    if (!colors || colors.length === 0) {\n        return \"\";\n    }\n    const colorString = colors.slice(0, 3).join(\"|\");\n    return '\\n    <script>\\n      // Injected by Studio preview\\n      window.__studioColors = \"'.concat(colorString, '\";\\n    </script>\\n  ');\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbWFuaWZlc3QtdXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FFRDs7Q0FFQyxHQUNNLFNBQVNBLFVBQ1pDLE1BQVMsRUFDVEMsTUFBa0I7SUFFbEIsTUFBTUMsU0FBUztRQUFFLEdBQUdGLE1BQU07SUFBQztJQUUzQixJQUFLLE1BQU1HLE9BQU9GLE9BQVE7UUFDdEIsSUFBSUcsT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ04sUUFBUUUsTUFBTTtZQUNuRCxNQUFNSyxjQUFjUCxNQUFNLENBQUNFLElBQUk7WUFDL0IsTUFBTU0sY0FBY1QsTUFBTSxDQUFDRyxJQUFJO1lBRS9CLElBQ0lLLGVBQ0EsT0FBT0EsZ0JBQWdCLFlBQ3ZCLENBQUNFLE1BQU1DLE9BQU8sQ0FBQ0gsZ0JBQ2ZDLGVBQ0EsT0FBT0EsZ0JBQWdCLFlBQ3ZCLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0YsY0FDakI7Z0JBQ0UsbUNBQW1DO2dCQUNsQ1AsTUFBa0MsQ0FBQ0MsSUFBSSxHQUFHSixVQUN2Q1UsYUFDQUQ7WUFFUixPQUFPLElBQUlBLGdCQUFnQkksV0FBVztnQkFDbEMsaUZBQWlGO2dCQUNoRlYsTUFBa0MsQ0FBQ0MsSUFBSSxHQUFHSztZQUMvQztRQUNKO0lBQ0o7SUFFQSxPQUFPTjtBQUNYO0FBRUE7OztDQUdDLEdBQ00sU0FBU1csZ0JBQWdCQyxTQUFpQjtJQUM3QyxnRUFBZ0U7SUFDaEUsTUFBTUMsWUFBWUQsVUFBVUUsS0FBSyxDQUFDO0lBRWxDLElBQUksQ0FBQ0QsV0FBVztRQUNaLE1BQU0sSUFBSUUsTUFBTTtJQUNwQjtJQUVBLElBQUk7UUFDQSx1REFBdUQ7UUFDdkQsZ0NBQWdDO1FBQ2hDLHdEQUF3RDtRQUN4RCxNQUFNQyxjQUFjLElBQUlDLFNBQVMsVUFBdUIsT0FBYkosU0FBUyxDQUFDLEVBQUU7UUFDdkQsT0FBT0c7SUFDWCxFQUFFLE9BQU9FLE9BQU87UUFDWixN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Q0MsTUFBTSxHQUFHLEdBQUc7UUFDdkMsa0VBQWtFO1FBQ2xFLDBEQUEwRDtRQUMxRCw2Q0FBNkM7UUFDNUNwQixZQUF3Q3FCLFFBQVEsR0FBR3RCLEtBQUtvQixNQUFNO0lBQ25FO0lBRUEsT0FBT25CO0FBQ1g7QUFFQTs7Q0FFQyxHQUNNLFNBQVNzQiwwQkFBMEJILE1BQWlCO0lBQ3ZELElBQUksQ0FBQ0EsVUFBVUEsT0FBT0MsTUFBTSxLQUFLLEdBQUc7UUFDaEMsT0FBTztJQUNYO0lBRUEsTUFBTUcsY0FBY0osT0FBT0ssS0FBSyxDQUFDLEdBQUcsR0FBR0MsSUFBSSxDQUFDO0lBQzVDLE9BQU8sdUZBR2tDLE9BQVpGLGFBQVk7QUFHN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9tYW5pZmVzdC11dGlscy50cz8yYjY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0aWVzIGZvciBwYXJzaW5nIGFuZCBtYW5pcHVsYXRpbmcgR3JpZDggYWQgbWFuaWZlc3RzXG4gKi9cblxuLyoqXG4gKiBEZWVwIG1lcmdlIHR3byBvYmplY3RzLCB3aXRoIHNvdXJjZSB2YWx1ZXMgb3ZlcnJpZGluZyB0YXJnZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBNZXJnZTxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KFxuICAgIHRhcmdldDogVCxcbiAgICBzb3VyY2U6IFBhcnRpYWw8VD5cbik6IFQge1xuICAgIGNvbnN0IG91dHB1dCA9IHsgLi4udGFyZ2V0IH07XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IHRhcmdldFtrZXldO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc291cmNlVmFsdWUgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygc291cmNlVmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShzb3VyY2VWYWx1ZSkgJiZcbiAgICAgICAgICAgICAgICB0YXJnZXRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgICFBcnJheS5pc0FycmF5KHRhcmdldFZhbHVlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2UgbmVzdGVkIG9iamVjdHNcbiAgICAgICAgICAgICAgICAob3V0cHV0IGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVtrZXldID0gZGVlcE1lcmdlKFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRWYWx1ZSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWUgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gRGlyZWN0IGFzc2lnbm1lbnQgZm9yIHByaW1pdGl2ZXMsIGFycmF5cywgYW5kIHdoZW4gdGFyZ2V0IGRvZXNuJ3QgaGF2ZSB0aGUga2V5XG4gICAgICAgICAgICAgICAgKG91dHB1dCBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilba2V5XSA9IHNvdXJjZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIG1hbmlmZXN0LmpzIGZpbGUgY29udGVudCBpbnRvIGEgSmF2YVNjcmlwdCBvYmplY3RcbiAqIFRoZSBmaWxlIGZvcm1hdCBpczogd2luZG93Lm1hbmlmZXN0ID0geyAuLi4gfTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWFuaWZlc3RKcyhqc0NvbnRlbnQ6IHN0cmluZyk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgICAvLyBSZW1vdmUgdGhlIFwid2luZG93Lm1hbmlmZXN0ID0gXCIgcHJlZml4IGFuZCB0cmFpbGluZyBzZW1pY29sb25cbiAgICBjb25zdCBqc29uTWF0Y2ggPSBqc0NvbnRlbnQubWF0Y2goL3dpbmRvd1xcLm1hbmlmZXN0XFxzKj1cXHMqKFxce1tcXHNcXFNdKlxcfSk7P1xccyokLyk7XG5cbiAgICBpZiAoIWpzb25NYXRjaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1hbmlmZXN0LmpzIGZvcm1hdDogY291bGQgbm90IGZpbmQgd2luZG93Lm1hbmlmZXN0IGFzc2lnbm1lbnRcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVGhlIG1hbmlmZXN0IGlzIGEgSlMgb2JqZWN0IGxpdGVyYWwsIG5vdCBzdHJpY3QgSlNPTlxuICAgICAgICAvLyBXZSBuZWVkIHRvIGV2YWx1YXRlIGl0IHNhZmVseVxuICAgICAgICAvLyBVc2luZyBGdW5jdGlvbiBjb25zdHJ1Y3RvciB0byBwYXJzZSBKUyBvYmplY3QgbGl0ZXJhbFxuICAgICAgICBjb25zdCBtYW5pZmVzdE9iaiA9IG5ldyBGdW5jdGlvbihgcmV0dXJuICR7anNvbk1hdGNoWzFdfWApKCk7XG4gICAgICAgIHJldHVybiBtYW5pZmVzdE9iajtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBtYW5pZmVzdC5qczogJHtlcnJvcn1gKTtcbiAgICB9XG59XG5cbi8qKlxuICogU2VyaWFsaXplIGEgbWFuaWZlc3Qgb2JqZWN0IGJhY2sgdG8gYSBtYW5pZmVzdC5qcyBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZU1hbmlmZXN0KG1hbmlmZXN0OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHN0cmluZyB7XG4gICAgcmV0dXJuIGB3aW5kb3cubWFuaWZlc3QgPSAke0pTT04uc3RyaW5naWZ5KG1hbmlmZXN0LCBudWxsLCAyKX07YDtcbn1cblxuLyoqXG4gKiBGaXggcmVsYXRpdmUgcGF0aHMgaW4gSFRNTCBjb250ZW50IGJ5IGNvbnZlcnRpbmcgdGhlbSB0byBhYnNvbHV0ZSBwYXRoc1xuICogVGhpcyBpcyBuZWNlc3Nhcnkgd2hlbiBzZXJ2aW5nIEhUTUwgZnJvbSBhIEJsb2IgVVJMXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhSZWxhdGl2ZVBhdGhzKGh0bWw6IHN0cmluZywgYmFzZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgLy8gRW5zdXJlIGJhc2VQYXRoIGRvZXNuJ3QgaGF2ZSB0cmFpbGluZyBzbGFzaFxuICAgIGNvbnN0IGJhc2UgPSBiYXNlUGF0aC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG5cbiAgICAvLyBIZWxwZXIgdG8gY2hlY2sgaWYgYSBwYXRoIGlzIGFscmVhZHkgYWJzb2x1dGVcbiAgICBjb25zdCBpc0Fic29sdXRlID0gKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcGF0aC5zdGFydHNXaXRoKFwiL1wiKSB8fFxuICAgICAgICAgICAgcGF0aC5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fFxuICAgICAgICAgICAgcGF0aC5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikgfHxcbiAgICAgICAgICAgIHBhdGguc3RhcnRzV2l0aChcIi8vXCIpIHx8XG4gICAgICAgICAgICBwYXRoLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSB8fFxuICAgICAgICAgICAgcGF0aC5zdGFydHNXaXRoKFwiYmxvYjpcIikgfHxcbiAgICAgICAgICAgIHBhdGguc3RhcnRzV2l0aChcIiNcIilcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gSGVscGVyIHRvIGZpeCBhIHNpbmdsZSBwYXRoXG4gICAgY29uc3QgZml4UGF0aCA9IChwYXRoOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgICAgICBpZiAoaXNBYnNvbHV0ZShwYXRoKSkgcmV0dXJuIHBhdGg7XG4gICAgICAgIC8vIFJlbW92ZSAuLyBwcmVmaXggaWYgcHJlc2VudFxuICAgICAgICBjb25zdCBjbGVhblBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIGAke2Jhc2V9LyR7Y2xlYW5QYXRofWA7XG4gICAgfTtcblxuICAgIC8vIEZpeCBzcmMgYXR0cmlidXRlc1xuICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoXG4gICAgICAgIC8oPCg/OnNjcmlwdHxpbWd8c291cmNlfHZpZGVvfGF1ZGlvfGVtYmVkfGlmcmFtZSlbXj5dKlxccytzcmNcXHMqPVxccypbXCInXSkoW15cIiddKykoW1wiJ10pL2dpLFxuICAgICAgICAobWF0Y2gsIHByZWZpeCwgcGF0aCwgc3VmZml4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYCR7cHJlZml4fSR7Zml4UGF0aChwYXRoKX0ke3N1ZmZpeH1gO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIEZpeCBocmVmIGF0dHJpYnV0ZXMgKGZvciBsaW5rLCBhIHRhZ3MpXG4gICAgaHRtbCA9IGh0bWwucmVwbGFjZShcbiAgICAgICAgLyg8KD86bGlua3xhKVtePl0qXFxzK2hyZWZcXHMqPVxccypbXCInXSkoW15cIiddKykoW1wiJ10pL2dpLFxuICAgICAgICAobWF0Y2gsIHByZWZpeCwgcGF0aCwgc3VmZml4KSA9PiB7XG4gICAgICAgICAgICAvLyBEb24ndCBmaXggYW5jaG9yIGxpbmtzIG9yIGphdmFzY3JpcHQ6XG4gICAgICAgICAgICBpZiAocGF0aC5zdGFydHNXaXRoKFwiI1wiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCJqYXZhc2NyaXB0OlwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgJHtwcmVmaXh9JHtmaXhQYXRoKHBhdGgpfSR7c3VmZml4fWA7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gRml4IHVybCgpIGluIENTUyAoaW5saW5lIHN0eWxlcyBhbmQgc3R5bGUgdGFncylcbiAgICBodG1sID0gaHRtbC5yZXBsYWNlKFxuICAgICAgICAvdXJsXFwoXFxzKltcIiddPyhbXlwiJyldKylbXCInXT9cXHMqXFwpL2dpLFxuICAgICAgICAobWF0Y2gsIHBhdGgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Fic29sdXRlKHBhdGgpKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICBjb25zdCBjbGVhblBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiBgdXJsKCcke2Jhc2V9LyR7Y2xlYW5QYXRofScpYDtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gaHRtbDtcbn1cblxuLyoqXG4gKiBEeW5hbWljIHZhbHVlIGRhdGEgZnJvbSB0aGUgU3R1ZGlvIFVJXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRHluYW1pY1ZhbHVlRGF0YSB7XG4gICAgaGVhZGxpbmU/OiBzdHJpbmc7XG4gICAgYm9keUNvcHk/OiBzdHJpbmc7XG4gICAgY3RhVGV4dD86IHN0cmluZztcbiAgICBpbWFnZVVybD86IHN0cmluZztcbiAgICBsb2dvVXJsPzogc3RyaW5nO1xuICAgIGNvbG9ycz86IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIEFwcGx5IGR5bmFtaWMgdmFsdWVzIGZyb20gdGhlIFVJIHRvIHRoZSBtYW5pZmVzdFxuICogVGhpcyB1cGRhdGVzIHRoZSBkZWZhdWx0VmFsdWUgZmllbGRzIGluIHRoZSBtYW5pZmVzdCdzIGR5bmFtaWNWYWx1ZXMgc2V0dGluZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RHluYW1pY1ZhbHVlcyhcbiAgICBtYW5pZmVzdDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgZGF0YTogRHluYW1pY1ZhbHVlRGF0YVxuKTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICAgIC8vIENsb25lIHRoZSBtYW5pZmVzdCB0byBhdm9pZCBtdXRhdGlvblxuICAgIGNvbnN0IG5ld01hbmlmZXN0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtYW5pZmVzdCkpO1xuXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBuZXdNYW5pZmVzdC5zZXR0aW5ncyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IHVuZGVmaW5lZDtcbiAgICBpZiAoIXNldHRpbmdzKSByZXR1cm4gbmV3TWFuaWZlc3Q7XG5cbiAgICBjb25zdCBkeW5hbWljVmFsdWVzID0gc2V0dGluZ3MuZHluYW1pY1ZhbHVlcyBhcyBBcnJheTx7XG4gICAgICAgIGlkOiBzdHJpbmc7XG4gICAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgICAgZGVmYXVsdFZhbHVlPzogc3RyaW5nO1xuICAgIH0+IHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKCFkeW5hbWljVmFsdWVzKSByZXR1cm4gbmV3TWFuaWZlc3Q7XG5cbiAgICAvLyBNYXAgVUkgZmllbGQgbmFtZXMgdG8gbWFuaWZlc3QgZHluYW1pYyB2YWx1ZSBuYW1lc1xuICAgIGNvbnN0IGZpZWxkTWFwcGluZzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICAgaGVhZGxpbmU6IFwiczBfaGVhZGVyXCIsXG4gICAgICAgIGJvZHlDb3B5OiBcInMwX3N1YlwiLFxuICAgICAgICBjdGFUZXh0OiBcInMwX2N0YVwiLFxuICAgICAgICBpbWFnZVVybDogXCJzMF9iZ3JcIixcbiAgICAgICAgbG9nb1VybDogXCJzMF9sb2dvXCIsXG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSBlYWNoIGR5bmFtaWMgdmFsdWVcbiAgICBmb3IgKGNvbnN0IFt1aUZpZWxkLCBtYW5pZmVzdE5hbWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkTWFwcGluZykpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW3VpRmllbGQgYXMga2V5b2YgRHluYW1pY1ZhbHVlRGF0YV07XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNWYWx1ZSA9IGR5bmFtaWNWYWx1ZXMuZmluZCgoZHYpID0+IGR2Lm5hbWUgPT09IG1hbmlmZXN0TmFtZSk7XG4gICAgICAgICAgICBpZiAoZHluYW1pY1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pY1ZhbHVlLmRlZmF1bHRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbG9ycyBzZXBhcmF0ZWx5ICh0aGV5IG5lZWQgdG8gYmUgam9pbmVkIHdpdGggfClcbiAgICBpZiAoZGF0YS5jb2xvcnMgJiYgZGF0YS5jb2xvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBDb2xvcnMgYXJlIGFwcGxpZWQgdmlhIHRoZSBnbG9iYWxTY3JpcHRzIGluIHRoZSB0ZW1wbGF0ZSdzIEhUTUxcbiAgICAgICAgLy8gV2UnbGwgaW5qZWN0IHRoZW0gYXMgYSBkeW5hbWljRGF0YSBvdmVycmlkZSBpbiB0aGUgSFRNTFxuICAgICAgICAvLyBTdG9yZSB0aGVtIGluIGEgY3VzdG9tIGZpZWxkIGZvciBsYXRlciB1c2VcbiAgICAgICAgKG5ld01hbmlmZXN0IGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KS5fX2NvbG9ycyA9IGRhdGEuY29sb3JzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdNYW5pZmVzdDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgaW5saW5lIHNjcmlwdCB0aGF0IHNldHMgdXAgZHluYW1pY0RhdGEgd2l0aCBjb2xvcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlRHluYW1pY0RhdGFTY3JpcHQoY29sb3JzPzogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgIGlmICghY29sb3JzIHx8IGNvbG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgY29uc3QgY29sb3JTdHJpbmcgPSBjb2xvcnMuc2xpY2UoMCwgMykuam9pbihcInxcIik7XG4gICAgcmV0dXJuIGBcbiAgICA8c2NyaXB0PlxuICAgICAgLy8gSW5qZWN0ZWQgYnkgU3R1ZGlvIHByZXZpZXdcbiAgICAgIHdpbmRvdy5fX3N0dWRpb0NvbG9ycyA9IFwiJHtjb2xvclN0cmluZ31cIjtcbiAgICA8L3NjcmlwdD5cbiAgYDtcbn1cbiJdLCJuYW1lcyI6WyJkZWVwTWVyZ2UiLCJ0YXJnZXQiLCJzb3VyY2UiLCJvdXRwdXQiLCJrZXkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJzb3VyY2VWYWx1ZSIsInRhcmdldFZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwidW5kZWZpbmVkIiwicGFyc2VNYW5pZmVzdEpzIiwianNDb250ZW50IiwianNvbk1hdGNoIiwibWF0Y2giLCJFcnJvciIsIm1hbmlmZXN0T2JqIiwiRnVuY3Rpb24iLCJlcnJvciIsInNlcmlhbGl6ZU1hbmlmZXN0IiwibWFuaWZlc3QiLCJKU09OIiwic3RyaW5naWZ5IiwiZml4UmVsYXRpdmVQYXRocyIsImh0bWwiLCJiYXNlUGF0aCIsImJhc2UiLCJyZXBsYWNlIiwiaXNBYnNvbHV0ZSIsInBhdGgiLCJzdGFydHNXaXRoIiwiZml4UGF0aCIsImNsZWFuUGF0aCIsInByZWZpeCIsInN1ZmZpeCIsImFwcGx5RHluYW1pY1ZhbHVlcyIsImRhdGEiLCJuZXdNYW5pZmVzdCIsInBhcnNlIiwic2V0dGluZ3MiLCJkeW5hbWljVmFsdWVzIiwiZmllbGRNYXBwaW5nIiwiaGVhZGxpbmUiLCJib2R5Q29weSIsImN0YVRleHQiLCJpbWFnZVVybCIsImxvZ29VcmwiLCJ1aUZpZWxkIiwibWFuaWZlc3ROYW1lIiwiZW50cmllcyIsInZhbHVlIiwiZHluYW1pY1ZhbHVlIiwiZmluZCIsImR2IiwibmFtZSIsImRlZmF1bHRWYWx1ZSIsImNvbG9ycyIsImxlbmd0aCIsIl9fY29sb3JzIiwiZ2VuZXJhdGVEeW5hbWljRGF0YVNjcmlwdCIsImNvbG9yU3RyaW5nIiwic2xpY2UiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/manifest-utils.ts\n"));

/***/ })

});