"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/studio/page",{

/***/ "(app-pages-browser)/./src/hooks/useAdPreviewBlob.ts":
/*!***************************************!*\
  !*** ./src/hooks/useAdPreviewBlob.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAdPreviewBlob: function() { return /* binding */ useAdPreviewBlob; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_manifest_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/manifest-utils */ \"(app-pages-browser)/./src/lib/manifest-utils.ts\");\n/* __next_internal_client_entry_do_not_use__ useAdPreviewBlob auto */ \n\n/**\n * Hook that generates a Blob URL for ad preview with modified manifest\n *\n * This hook:\n * 1. Fetches the template's index.html and manifest.js\n * 2. Parses and modifies the manifest with dynamic values\n * 3. Injects the modified manifest inline into the HTML\n * 4. Fixes relative asset paths\n * 5. Returns a Blob URL that can be used as iframe src\n */ function useAdPreviewBlob(param) {\n    let { templatePath, size, data, debounceMs = 300 } = param;\n    const [blobUrl, setBlobUrl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Keep track of previous blob URL for cleanup\n    const previousBlobUrl = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Cache for fetched resources to avoid re-fetching\n    const resourceCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    // Debounce timer ref\n    const debounceTimer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Generation counter to handle stale updates\n    const generationRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const generateBlob = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        const currentGeneration = ++generationRef.current;\n        setIsLoading(true);\n        setError(null);\n        try {\n            const basePath = \"\".concat(templatePath, \"/\").concat(size);\n            // Fetch HTML (with caching)\n            let html;\n            const htmlCacheKey = \"\".concat(basePath, \"/index.html\");\n            if (resourceCache.current.has(htmlCacheKey)) {\n                html = resourceCache.current.get(htmlCacheKey);\n            } else {\n                const htmlRes = await fetch(\"\".concat(basePath, \"/index.html\"));\n                if (!htmlRes.ok) {\n                    throw new Error(\"Failed to fetch template HTML: \".concat(htmlRes.status));\n                }\n                html = await htmlRes.text();\n                resourceCache.current.set(htmlCacheKey, html);\n            }\n            // Fetch manifest.js (with caching)\n            let manifestJs;\n            const manifestCacheKey = \"\".concat(basePath, \"/manifest.js\");\n            if (resourceCache.current.has(manifestCacheKey)) {\n                manifestJs = resourceCache.current.get(manifestCacheKey);\n            } else {\n                const manifestRes = await fetch(\"\".concat(basePath, \"/manifest.js\"));\n                if (!manifestRes.ok) {\n                    throw new Error(\"Failed to fetch manifest.js: \".concat(manifestRes.status));\n                }\n                manifestJs = await manifestRes.text();\n                resourceCache.current.set(manifestCacheKey, manifestJs);\n            }\n            // Parse the manifest\n            const baseManifest = (0,_lib_manifest_utils__WEBPACK_IMPORTED_MODULE_1__.parseManifestJs)(manifestJs);\n            // Apply dynamic values\n            const modifiedManifest = (0,_lib_manifest_utils__WEBPACK_IMPORTED_MODULE_1__.applyDynamicValues)(baseManifest, data);\n            // Extract colors for injection (stored by applyDynamicValues)\n            const colors = modifiedManifest.__colors;\n            delete modifiedManifest.__colors;\n            // Serialize the modified manifest\n            const inlineManifest = (0,_lib_manifest_utils__WEBPACK_IMPORTED_MODULE_1__.serializeManifest)(modifiedManifest);\n            // Replace the external manifest.js script with inline script\n            html = html.replace(/<script\\s+src=[\"']manifest\\.js[\"']\\s*><\\/script>/i, \"<script>\".concat(inlineManifest, \"</script>\"));\n            // Inject color override into dynamicData initialization\n            if (colors && colors.length > 0) {\n                const colorString = colors.slice(0, 3).join(\"|\");\n                // Find the dynamicData initialization and inject colors\n                html = html.replace(/grid8player\\.dynamicData\\s*=\\s*dynamicData;/, 'dynamicData[\"s0_colors\"] = \"'.concat(colorString, '\";\\n      grid8player.dynamicData = dynamicData;'));\n            }\n            // Fix relative paths to absolute\n            html = (0,_lib_manifest_utils__WEBPACK_IMPORTED_MODULE_1__.fixRelativePaths)(html, basePath);\n            // Inject a <base> tag to help the browser resolve paths from blob context\n            // This ensures absolute paths like /templates/... are resolved against the origin\n            const baseTag = '<base href=\"'.concat(window.location.origin).concat(basePath, '/\">');\n            html = html.replace(/<head([^>]*)>/i, \"<head$1>\\n    \".concat(baseTag));\n            // Debug: Log a snippet to verify paths were fixed\n            if (true) {\n                const scriptMatch = html.match(/<script[^>]+src=[\"'][^\"']+[\"'][^>]*>/gi);\n                console.log(\"[AdPreviewBlob] Script tags after path fix:\", scriptMatch === null || scriptMatch === void 0 ? void 0 : scriptMatch.slice(0, 5));\n            }\n            // Check if this generation is still current\n            if (currentGeneration !== generationRef.current) {\n                return; // Stale update, discard\n            }\n            // Create blob URL\n            const blob = new Blob([\n                html\n            ], {\n                type: \"text/html\"\n            });\n            const url = URL.createObjectURL(blob);\n            // Cleanup previous blob URL\n            if (previousBlobUrl.current) {\n                URL.revokeObjectURL(previousBlobUrl.current);\n            }\n            previousBlobUrl.current = url;\n            setBlobUrl(url);\n            setIsLoading(false);\n        } catch (err) {\n            if (currentGeneration === generationRef.current) {\n                setError(err instanceof Error ? err : new Error(String(err)));\n                setIsLoading(false);\n            }\n        }\n    }, [\n        templatePath,\n        size,\n        data\n    ]);\n    // Debounced effect to regenerate blob when inputs change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Clear any pending debounce\n        if (debounceTimer.current) {\n            clearTimeout(debounceTimer.current);\n        }\n        // Set up debounced regeneration\n        debounceTimer.current = setTimeout(()=>{\n            generateBlob();\n        }, debounceMs);\n        return ()=>{\n            if (debounceTimer.current) {\n                clearTimeout(debounceTimer.current);\n            }\n        };\n    }, [\n        generateBlob,\n        debounceMs\n    ]);\n    // Cleanup on unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            if (previousBlobUrl.current) {\n                URL.revokeObjectURL(previousBlobUrl.current);\n            }\n            resourceCache.current.clear();\n        };\n    }, []);\n    const refresh = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        // Clear cache and regenerate\n        resourceCache.current.clear();\n        generateBlob();\n    }, [\n        generateBlob\n    ]);\n    return {\n        blobUrl,\n        isLoading,\n        error,\n        refresh\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VBZFByZXZpZXdCbG9iLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7c0VBRWlFO0FBT25DO0FBd0I5Qjs7Ozs7Ozs7O0NBU0MsR0FDTSxTQUFTUSxpQkFBaUIsS0FLUDtRQUxPLEVBQzdCQyxZQUFZLEVBQ1pDLElBQUksRUFDSkMsSUFBSSxFQUNKQyxhQUFhLEdBQUcsRUFDTSxHQUxPO0lBTTdCLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHZCwrQ0FBUUEsQ0FBZ0I7SUFDdEQsTUFBTSxDQUFDZSxXQUFXQyxhQUFhLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUNpQixPQUFPQyxTQUFTLEdBQUdsQiwrQ0FBUUEsQ0FBZTtJQUVqRCw4Q0FBOEM7SUFDOUMsTUFBTW1CLGtCQUFrQmpCLDZDQUFNQSxDQUFnQjtJQUU5QyxtREFBbUQ7SUFDbkQsTUFBTWtCLGdCQUFnQmxCLDZDQUFNQSxDQUFzQixJQUFJbUI7SUFFdEQscUJBQXFCO0lBQ3JCLE1BQU1DLGdCQUFnQnBCLDZDQUFNQSxDQUF3QjtJQUVwRCw2Q0FBNkM7SUFDN0MsTUFBTXFCLGdCQUFnQnJCLDZDQUFNQSxDQUFDO0lBRTdCLE1BQU1zQixlQUFlckIsa0RBQVdBLENBQUM7UUFDN0IsTUFBTXNCLG9CQUFvQixFQUFFRixjQUFjRyxPQUFPO1FBQ2pEVixhQUFhO1FBQ2JFLFNBQVM7UUFFVCxJQUFJO1lBQ0EsTUFBTVMsV0FBVyxHQUFtQmpCLE9BQWhCRCxjQUFhLEtBQVEsT0FBTEM7WUFFcEMsNEJBQTRCO1lBQzVCLElBQUlrQjtZQUNKLE1BQU1DLGVBQWUsR0FBWSxPQUFURixVQUFTO1lBQ2pDLElBQUlQLGNBQWNNLE9BQU8sQ0FBQ0ksR0FBRyxDQUFDRCxlQUFlO2dCQUN6Q0QsT0FBT1IsY0FBY00sT0FBTyxDQUFDSyxHQUFHLENBQUNGO1lBQ3JDLE9BQU87Z0JBQ0gsTUFBTUcsVUFBVSxNQUFNQyxNQUFNLEdBQVksT0FBVE4sVUFB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LGFBQWE7WUFDakI7UUFDSjtJQUNKLEdBQUc7UUFBQ1A7UUFBY0M7UUFBTUM7S0FBSztJQUU3Qix5REFBeUQ7SUFDekRWLGdEQUFTQSxDQUFDO1FBQ04sNkJBQTZCO1FBQzdCLElBQUlxQixjQUFjSSxPQUFPLEVBQUU7WUFDdkIyQyxhQUFhL0MsY0FBY0ksT0FBTztRQUN0QztRQUVBLGdDQUFnQztRQUNoQ0osY0FBY0ksT0FBTyxHQUFHNEMsV0FBVztZQUMvQjlDO1FBQ0osR0FBR1o7UUFFSCxPQUFPO1lBQ0gsSUFBSVUsY0FBY0ksT0FBTyxFQUFFO2dCQUN2QjJDLGFBQWEvQyxjQUFjSSxPQUFPO1lBQ3RDO1FBQ0o7SUFDSixHQUFHO1FBQUNGO1FBQWNaO0tBQVc7SUFFN0IscUJBQXFCO0lBQ3JCWCxnREFBU0EsQ0FBQztRQUNOLE9BQU87WUFDSCxJQUFJa0IsZ0JBQWdCTyxPQUFPLEVBQUU7Z0JBQ3pCc0MsSUFBSUUsZUFBZSxDQUFDL0MsZ0JBQWdCTyxPQUFPO1lBQy9DO1lBQ0FOLGNBQWNNLE9BQU8sQ0FBQzZDLEtBQUs7UUFDL0I7SUFDSixHQUFHLEVBQUU7SUFFTCxNQUFNQyxVQUFVckUsa0RBQVdBLENBQUM7UUFDeEIsNkJBQTZCO1FBQzdCaUIsY0FBY00sT0FBTyxDQUFDNkMsS0FBSztRQUMzQi9DO0lBQ0osR0FBRztRQUFDQTtLQUFhO0lBRWpCLE9BQU87UUFBRVg7UUFBU0U7UUFBV0U7UUFBT3VEO0lBQVE7QUFDaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZUFkUHJldmlld0Jsb2IudHM/YjMwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtcbiAgICBwYXJzZU1hbmlmZXN0SnMsXG4gICAgc2VyaWFsaXplTWFuaWZlc3QsXG4gICAgZml4UmVsYXRpdmVQYXRocyxcbiAgICBhcHBseUR5bmFtaWNWYWx1ZXMsXG4gICAgRHluYW1pY1ZhbHVlRGF0YSxcbn0gZnJvbSBcIkAvbGliL21hbmlmZXN0LXV0aWxzXCI7XG5cbmludGVyZmFjZSBVc2VBZFByZXZpZXdCbG9iT3B0aW9ucyB7XG4gICAgLyoqIFRlbXBsYXRlIHBhdGggcmVsYXRpdmUgdG8gL3B1YmxpYywgZS5nLiwgXCIvdGVtcGxhdGVzL3RlbXBsYXRlMDAwXCIgKi9cbiAgICB0ZW1wbGF0ZVBhdGg6IHN0cmluZztcbiAgICAvKiogQWQgc2l6ZSwgZS5nLiwgXCIzMDB4MjUwXCIgKi9cbiAgICBzaXplOiBzdHJpbmc7XG4gICAgLyoqIER5bmFtaWMgZGF0YSBmcm9tIHRoZSBVSSAqL1xuICAgIGRhdGE6IER5bmFtaWNWYWx1ZURhdGE7XG4gICAgLyoqIERlYm91bmNlIGRlbGF5IGluIG1zIChkZWZhdWx0OiAzMDApICovXG4gICAgZGVib3VuY2VNcz86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFVzZUFkUHJldmlld0Jsb2JSZXN1bHQge1xuICAgIC8qKiBUaGUgQmxvYiBVUkwgdG8gdXNlIGFzIGlmcmFtZSBzcmMgKi9cbiAgICBibG9iVXJsOiBzdHJpbmcgfCBudWxsO1xuICAgIC8qKiBXaGV0aGVyIHRoZSBibG9iIGlzIGN1cnJlbnRseSBiZWluZyBnZW5lcmF0ZWQgKi9cbiAgICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gICAgLyoqIEFueSBlcnJvciB0aGF0IG9jY3VycmVkICovXG4gICAgZXJyb3I6IEVycm9yIHwgbnVsbDtcbiAgICAvKiogRm9yY2UgcmVnZW5lcmF0ZSB0aGUgYmxvYiAqL1xuICAgIHJlZnJlc2g6ICgpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogSG9vayB0aGF0IGdlbmVyYXRlcyBhIEJsb2IgVVJMIGZvciBhZCBwcmV2aWV3IHdpdGggbW9kaWZpZWQgbWFuaWZlc3RcbiAqXG4gKiBUaGlzIGhvb2s6XG4gKiAxLiBGZXRjaGVzIHRoZSB0ZW1wbGF0ZSdzIGluZGV4Lmh0bWwgYW5kIG1hbmlmZXN0LmpzXG4gKiAyLiBQYXJzZXMgYW5kIG1vZGlmaWVzIHRoZSBtYW5pZmVzdCB3aXRoIGR5bmFtaWMgdmFsdWVzXG4gKiAzLiBJbmplY3RzIHRoZSBtb2RpZmllZCBtYW5pZmVzdCBpbmxpbmUgaW50byB0aGUgSFRNTFxuICogNC4gRml4ZXMgcmVsYXRpdmUgYXNzZXQgcGF0aHNcbiAqIDUuIFJldHVybnMgYSBCbG9iIFVSTCB0aGF0IGNhbiBiZSB1c2VkIGFzIGlmcmFtZSBzcmNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFkUHJldmlld0Jsb2Ioe1xuICAgIHRlbXBsYXRlUGF0aCxcbiAgICBzaXplLFxuICAgIGRhdGEsXG4gICAgZGVib3VuY2VNcyA9IDMwMCxcbn06IFVzZUFkUHJldmlld0Jsb2JPcHRpb25zKTogVXNlQWRQcmV2aWV3QmxvYlJlc3VsdCB7XG4gICAgY29uc3QgW2Jsb2JVcmwsIHNldEJsb2JVcmxdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8RXJyb3IgfCBudWxsPihudWxsKTtcblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgcHJldmlvdXMgYmxvYiBVUkwgZm9yIGNsZWFudXBcbiAgICBjb25zdCBwcmV2aW91c0Jsb2JVcmwgPSB1c2VSZWY8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgICAvLyBDYWNoZSBmb3IgZmV0Y2hlZCByZXNvdXJjZXMgdG8gYXZvaWQgcmUtZmV0Y2hpbmdcbiAgICBjb25zdCByZXNvdXJjZUNhY2hlID0gdXNlUmVmPE1hcDxzdHJpbmcsIHN0cmluZz4+KG5ldyBNYXAoKSk7XG5cbiAgICAvLyBEZWJvdW5jZSB0aW1lciByZWZcbiAgICBjb25zdCBkZWJvdW5jZVRpbWVyID0gdXNlUmVmPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7XG5cbiAgICAvLyBHZW5lcmF0aW9uIGNvdW50ZXIgdG8gaGFuZGxlIHN0YWxlIHVwZGF0ZXNcbiAgICBjb25zdCBnZW5lcmF0aW9uUmVmID0gdXNlUmVmKDApO1xuXG4gICAgY29uc3QgZ2VuZXJhdGVCbG9iID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50R2VuZXJhdGlvbiA9ICsrZ2VuZXJhdGlvblJlZi5jdXJyZW50O1xuICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlUGF0aCA9IGAke3RlbXBsYXRlUGF0aH0vJHtzaXplfWA7XG5cbiAgICAgICAgICAgIC8vIEZldGNoIEhUTUwgKHdpdGggY2FjaGluZylcbiAgICAgICAgICAgIGxldCBodG1sOiBzdHJpbmc7XG4gICAgICAgICAgICBjb25zdCBodG1sQ2FjaGVLZXkgPSBgJHtiYXNlUGF0aH0vaW5kZXguaHRtbGA7XG4gICAgICAgICAgICBpZiAocmVzb3VyY2VDYWNoZS5jdXJyZW50LmhhcyhodG1sQ2FjaGVLZXkpKSB7XG4gICAgICAgICAgICAgICAgaHRtbCA9IHJlc291cmNlQ2FjaGUuY3VycmVudC5nZXQoaHRtbENhY2hlS2V5KSE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGh0bWxSZXMgPSBhd2FpdCBmZXRjaChgJHtiYXNlUGF0aH0vaW5kZXguaHRtbGApO1xuICAgICAgICAgICAgICAgIGlmICghaHRtbFJlcy5vaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCB0ZW1wbGF0ZSBIVE1MOiAke2h0bWxSZXMuc3RhdHVzfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBodG1sID0gYXdhaXQgaHRtbFJlcy50ZXh0KCk7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2VDYWNoZS5jdXJyZW50LnNldChodG1sQ2FjaGVLZXksIGh0bWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGZXRjaCBtYW5pZmVzdC5qcyAod2l0aCBjYWNoaW5nKVxuICAgICAgICAgICAgbGV0IG1hbmlmZXN0SnM6IHN0cmluZztcbiAgICAgICAgICAgIGNvbnN0IG1hbmlmZXN0Q2FjaGVLZXkgPSBgJHtiYXNlUGF0aH0vbWFuaWZlc3QuanNgO1xuICAgICAgICAgICAgaWYgKHJlc291cmNlQ2FjaGUuY3VycmVudC5oYXMobWFuaWZlc3RDYWNoZUtleSkpIHtcbiAgICAgICAgICAgICAgICBtYW5pZmVzdEpzID0gcmVzb3VyY2VDYWNoZS5jdXJyZW50LmdldChtYW5pZmVzdENhY2hlS2V5KSE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hbmlmZXN0UmVzID0gYXdhaXQgZmV0Y2goYCR7YmFzZVBhdGh9L21hbmlmZXN0LmpzYCk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYW5pZmVzdFJlcy5vaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBtYW5pZmVzdC5qczogJHttYW5pZmVzdFJlcy5zdGF0dXN9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hbmlmZXN0SnMgPSBhd2FpdCBtYW5pZmVzdFJlcy50ZXh0KCk7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2VDYWNoZS5jdXJyZW50LnNldChtYW5pZmVzdENhY2hlS2V5LCBtYW5pZmVzdEpzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIG1hbmlmZXN0XG4gICAgICAgICAgICBjb25zdCBiYXNlTWFuaWZlc3QgPSBwYXJzZU1hbmlmZXN0SnMobWFuaWZlc3RKcyk7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IGR5bmFtaWMgdmFsdWVzXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZE1hbmlmZXN0ID0gYXBwbHlEeW5hbWljVmFsdWVzKGJhc2VNYW5pZmVzdCwgZGF0YSk7XG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgY29sb3JzIGZvciBpbmplY3Rpb24gKHN0b3JlZCBieSBhcHBseUR5bmFtaWNWYWx1ZXMpXG4gICAgICAgICAgICBjb25zdCBjb2xvcnMgPSAobW9kaWZpZWRNYW5pZmVzdCBhcyB7IF9fY29sb3JzPzogc3RyaW5nW10gfSkuX19jb2xvcnM7XG4gICAgICAgICAgICBkZWxldGUgKG1vZGlmaWVkTWFuaWZlc3QgYXMgeyBfX2NvbG9ycz86IHN0cmluZ1tdIH0pLl9fY29sb3JzO1xuXG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgdGhlIG1vZGlmaWVkIG1hbmlmZXN0XG4gICAgICAgICAgICBjb25zdCBpbmxpbmVNYW5pZmVzdCA9IHNlcmlhbGl6ZU1hbmlmZXN0KG1vZGlmaWVkTWFuaWZlc3QpO1xuXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBleHRlcm5hbCBtYW5pZmVzdC5qcyBzY3JpcHQgd2l0aCBpbmxpbmUgc2NyaXB0XG4gICAgICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC88c2NyaXB0XFxzK3NyYz1bXCInXW1hbmlmZXN0XFwuanNbXCInXVxccyo+PFxcL3NjcmlwdD4vaSxcbiAgICAgICAgICAgICAgICBgPHNjcmlwdD4ke2lubGluZU1hbmlmZXN0fTwvc2NyaXB0PmBcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEluamVjdCBjb2xvciBvdmVycmlkZSBpbnRvIGR5bmFtaWNEYXRhIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICBpZiAoY29sb3JzICYmIGNvbG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JTdHJpbmcgPSBjb2xvcnMuc2xpY2UoMCwgMykuam9pbihcInxcIik7XG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgZHluYW1pY0RhdGEgaW5pdGlhbGl6YXRpb24gYW5kIGluamVjdCBjb2xvcnNcbiAgICAgICAgICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAvZ3JpZDhwbGF5ZXJcXC5keW5hbWljRGF0YVxccyo9XFxzKmR5bmFtaWNEYXRhOy8sXG4gICAgICAgICAgICAgICAgICAgIGBkeW5hbWljRGF0YVtcInMwX2NvbG9yc1wiXSA9IFwiJHtjb2xvclN0cmluZ31cIjtcXG4gICAgICBncmlkOHBsYXllci5keW5hbWljRGF0YSA9IGR5bmFtaWNEYXRhO2BcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXggcmVsYXRpdmUgcGF0aHMgdG8gYWJzb2x1dGVcbiAgICAgICAgICAgIGh0bWwgPSBmaXhSZWxhdGl2ZVBhdGhzKGh0bWwsIGJhc2VQYXRoKTtcblxuICAgICAgICAgICAgLy8gSW5qZWN0IGEgPGJhc2U+IHRhZyB0byBoZWxwIHRoZSBicm93c2VyIHJlc29sdmUgcGF0aHMgZnJvbSBibG9iIGNvbnRleHRcbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyBhYnNvbHV0ZSBwYXRocyBsaWtlIC90ZW1wbGF0ZXMvLi4uIGFyZSByZXNvbHZlZCBhZ2FpbnN0IHRoZSBvcmlnaW5cbiAgICAgICAgICAgIGNvbnN0IGJhc2VUYWcgPSBgPGJhc2UgaHJlZj1cIiR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0ke2Jhc2VQYXRofS9cIj5gO1xuICAgICAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvPGhlYWQoW14+XSopPi9pLCBgPGhlYWQkMT5cXG4gICAgJHtiYXNlVGFnfWApO1xuXG4gICAgICAgICAgICAvLyBEZWJ1ZzogTG9nIGEgc25pcHBldCB0byB2ZXJpZnkgcGF0aHMgd2VyZSBmaXhlZFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0TWF0Y2ggPSBodG1sLm1hdGNoKC88c2NyaXB0W14+XStzcmM9W1wiJ11bXlwiJ10rW1wiJ11bXj5dKj4vZ2kpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQWRQcmV2aWV3QmxvYl0gU2NyaXB0IHRhZ3MgYWZ0ZXIgcGF0aCBmaXg6Jywgc2NyaXB0TWF0Y2g/LnNsaWNlKDAsIDUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBnZW5lcmF0aW9uIGlzIHN0aWxsIGN1cnJlbnRcbiAgICAgICAgICAgIGlmIChjdXJyZW50R2VuZXJhdGlvbiAhPT0gZ2VuZXJhdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBTdGFsZSB1cGRhdGUsIGRpc2NhcmRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGJsb2IgVVJMXG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2h0bWxdLCB7IHR5cGU6IFwidGV4dC9odG1sXCIgfSk7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG4gICAgICAgICAgICAvLyBDbGVhbnVwIHByZXZpb3VzIGJsb2IgVVJMXG4gICAgICAgICAgICBpZiAocHJldmlvdXNCbG9iVXJsLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHByZXZpb3VzQmxvYlVybC5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzQmxvYlVybC5jdXJyZW50ID0gdXJsO1xuXG4gICAgICAgICAgICBzZXRCbG9iVXJsKHVybCk7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50R2VuZXJhdGlvbiA9PT0gZ2VuZXJhdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycikpKTtcbiAgICAgICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3RlbXBsYXRlUGF0aCwgc2l6ZSwgZGF0YV0pO1xuXG4gICAgLy8gRGVib3VuY2VkIGVmZmVjdCB0byByZWdlbmVyYXRlIGJsb2Igd2hlbiBpbnB1dHMgY2hhbmdlXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gQ2xlYXIgYW55IHBlbmRpbmcgZGVib3VuY2VcbiAgICAgICAgaWYgKGRlYm91bmNlVGltZXIuY3VycmVudCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlVGltZXIuY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdXAgZGVib3VuY2VkIHJlZ2VuZXJhdGlvblxuICAgICAgICBkZWJvdW5jZVRpbWVyLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGdlbmVyYXRlQmxvYigpO1xuICAgICAgICB9LCBkZWJvdW5jZU1zKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRlYm91bmNlVGltZXIuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVyLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtnZW5lcmF0ZUJsb2IsIGRlYm91bmNlTXNdKTtcblxuICAgIC8vIENsZWFudXAgb24gdW5tb3VudFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNCbG9iVXJsLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHByZXZpb3VzQmxvYlVybC5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc291cmNlQ2FjaGUuY3VycmVudC5jbGVhcigpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHJlZnJlc2ggPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIC8vIENsZWFyIGNhY2hlIGFuZCByZWdlbmVyYXRlXG4gICAgICAgIHJlc291cmNlQ2FjaGUuY3VycmVudC5jbGVhcigpO1xuICAgICAgICBnZW5lcmF0ZUJsb2IoKTtcbiAgICB9LCBbZ2VuZXJhdGVCbG9iXSk7XG5cbiAgICByZXR1cm4geyBibG9iVXJsLCBpc0xvYWRpbmcsIGVycm9yLCByZWZyZXNoIH07XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsInBhcnNlTWFuaWZlc3RKcyIsInNlcmlhbGl6ZU1hbmlmZXN0IiwiZml4UmVsYXRpdmVQYXRocyIsImFwcGx5RHluYW1pY1ZhbHVlcyIsInVzZUFkUHJldmlld0Jsb2IiLCJ0ZW1wbGF0ZVBhdGgiLCJzaXplIiwiZGF0YSIsImRlYm91bmNlTXMiLCJibG9iVXJsIiwic2V0QmxvYlVybCIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJwcmV2aW91c0Jsb2JVcmwiLCJyZXNvdXJjZUNhY2hlIiwiTWFwIiwiZGVib3VuY2VUaW1lciIsImdlbmVyYXRpb25SZWYiLCJnZW5lcmF0ZUJsb2IiLCJjdXJyZW50R2VuZXJhdGlvbiIsImN1cnJlbnQiLCJiYXNlUGF0aCIsImh0bWwiLCJodG1sQ2FjaGVLZXkiLCJoYXMiLCJnZXQiLCJodG1sUmVzIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzIiwidGV4dCIsInNldCIsIm1hbmlmZXN0SnMiLCJtYW5pZmVzdENhY2hlS2V5IiwibWFuaWZlc3RSZXMiLCJiYXNlTWFuaWZlc3QiLCJtb2RpZmllZE1hbmlmZXN0IiwiY29sb3JzIiwiX19jb2xvcnMiLCJpbmxpbmVNYW5pZmVzdCIsInJlcGxhY2UiLCJsZW5ndGgiLCJjb2xvclN0cmluZyIsInNsaWNlIiwiam9pbiIsImJhc2VUYWciLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsInNjcmlwdE1hdGNoIiwibWF0Y2giLCJjb25zb2xlIiwibG9nIiwiYmxvYiIsIkJsb2IiLCJ0eXBlIiwidXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwicmV2b2tlT2JqZWN0VVJMIiwiZXJyIiwiU3RyaW5nIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImNsZWFyIiwicmVmcmVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useAdPreviewBlob.ts\n"));

/***/ })

});