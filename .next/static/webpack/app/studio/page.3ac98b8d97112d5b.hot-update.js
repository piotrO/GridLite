"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/studio/page",{

/***/ "(app-pages-browser)/./src/hooks/useAdPreviewBlob.ts":
/*!***************************************!*\
  !*** ./src/hooks/useAdPreviewBlob.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAdPreviewBlob: function() { return /* binding */ useAdPreviewBlob; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_manifest_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/manifest-utils */ \"(app-pages-browser)/./src/lib/manifest-utils.ts\");\n/* __next_internal_client_entry_do_not_use__ useAdPreviewBlob auto */ \n\n/**\n * Hook that generates a Blob URL for ad preview with modified manifest\n *\n * This hook:\n * 1. Fetches the template's index.html and manifest.js\n * 2. Parses and modifies the manifest with dynamic values\n * 3. Injects the modified manifest inline into the HTML\n * 4. Fixes relative asset paths\n * 5. Returns a Blob URL that can be used as iframe src\n */ function useAdPreviewBlob(param) {\n    let { templatePath, size, data, debounceMs = 300 } = param;\n    const [blobUrl, setBlobUrl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Keep track of previous blob URL for cleanup\n    const previousBlobUrl = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Cache for fetched resources to avoid re-fetching\n    const resourceCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    // Debounce timer ref\n    const debounceTimer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Generation counter to handle stale updates\n    const generationRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const generateBlob = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        const currentGeneration = ++generationRef.current;\n        setIsLoading(true);\n        setError(null);\n        try {\n            const basePath = \"\".concat(templatePath, \"/\").concat(size);\n            // Fetch HTML (with caching)\n            let html;\n            const htmlCacheKey = \"\".concat(basePath, \"/index.html\");\n            if (resourceCache.current.has(htmlCacheKey)) {\n                html = resourceCache.current.get(htmlCacheKey);\n            } else {\n                const htmlRes = await fetch(\"\".concat(basePath, \"/index.html\"));\n                if (!htmlRes.ok) {\n                    throw new Error(\"Failed to fetch template HTML: \".concat(htmlRes.status));\n                }\n                html = await htmlRes.text();\n                resourceCache.current.set(htmlCacheKey, html);\n            }\n            // Fetch manifest.js (with caching)\n            let manifestJs;\n            const manifestCacheKey = \"\".concat(basePath, \"/manifest.js\");\n            if (resourceCache.current.has(manifestCacheKey)) {\n                manifestJs = resourceCache.current.get(manifestCacheKey);\n            } else {\n                const manifestRes = await fetch(\"\".concat(basePath, \"/manifest.js\"));\n                if (!manifestRes.ok) {\n                    throw new Error(\"Failed to fetch manifest.js: \".concat(manifestRes.status));\n                }\n                manifestJs = await manifestRes.text();\n                resourceCache.current.set(manifestCacheKey, manifestJs);\n            }\n            // Parse the manifest\n            const baseManifest = (0,_lib_manifest_utils__WEBPACK_IMPORTED_MODULE_1__.parseManifestJs)(manifestJs);\n            // Apply dynamic values\n            const modifiedManifest = (0,_lib_manifest_utils__WEBPACK_IMPORTED_MODULE_1__.applyDynamicValues)(baseManifest, data);\n            // Extract colors for injection (stored by applyDynamicValues)\n            const colors = modifiedManifest.__colors;\n            delete modifiedManifest.__colors;\n            // Serialize the modified manifest\n            const inlineManifest = (0,_lib_manifest_utils__WEBPACK_IMPORTED_MODULE_1__.serializeManifest)(modifiedManifest);\n            // Replace the external manifest.js script with inline script\n            html = html.replace(/<script\\s+src=[\"']manifest\\.js[\"']\\s*><\\/script>/i, \"<script>\".concat(inlineManifest, \"</script>\"));\n            // Inject color override into dynamicData initialization\n            if (colors && colors.length > 0) {\n                const colorString = colors.slice(0, 3).join(\"|\");\n                // Find the dynamicData initialization and inject colors\n                html = html.replace(/grid8player\\.dynamicData\\s*=\\s*dynamicData;/, 'dynamicData[\"s0_colors\"] = \"'.concat(colorString, '\";\\n      grid8player.dynamicData = dynamicData;'));\n            }\n            // Fix relative paths to absolute\n            html = (0,_lib_manifest_utils__WEBPACK_IMPORTED_MODULE_1__.fixRelativePaths)(html, basePath);\n            // Debug: Log a snippet to verify paths were fixed\n            if (true) {\n                const scriptMatch = html.match(/<script[^>]+src=[\"'][^\"']+[\"'][^>]*>/gi);\n                console.log(\"[AdPreviewBlob] Script tags after path fix:\", scriptMatch === null || scriptMatch === void 0 ? void 0 : scriptMatch.slice(0, 5));\n            }\n            // Check if this generation is still current\n            if (currentGeneration !== generationRef.current) {\n                return; // Stale update, discard\n            }\n            // Create blob URL\n            const blob = new Blob([\n                html\n            ], {\n                type: \"text/html\"\n            });\n            const url = URL.createObjectURL(blob);\n            // Cleanup previous blob URL\n            if (previousBlobUrl.current) {\n                URL.revokeObjectURL(previousBlobUrl.current);\n            }\n            previousBlobUrl.current = url;\n            setBlobUrl(url);\n            setIsLoading(false);\n        } catch (err) {\n            if (currentGeneration === generationRef.current) {\n                setError(err instanceof Error ? err : new Error(String(err)));\n                setIsLoading(false);\n            }\n        }\n    }, [\n        templatePath,\n        size,\n        data\n    ]);\n    // Debounced effect to regenerate blob when inputs change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // Clear any pending debounce\n        if (debounceTimer.current) {\n            clearTimeout(debounceTimer.current);\n        }\n        // Set up debounced regeneration\n        debounceTimer.current = setTimeout(()=>{\n            generateBlob();\n        }, debounceMs);\n        return ()=>{\n            if (debounceTimer.current) {\n                clearTimeout(debounceTimer.current);\n            }\n        };\n    }, [\n        generateBlob,\n        debounceMs\n    ]);\n    // Cleanup on unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            if (previousBlobUrl.current) {\n                URL.revokeObjectURL(previousBlobUrl.current);\n            }\n            resourceCache.current.clear();\n        };\n    }, []);\n    const refresh = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        // Clear cache and regenerate\n        resourceCache.current.clear();\n        generateBlob();\n    }, [\n        generateBlob\n    ]);\n    return {\n        blobUrl,\n        isLoading,\n        error,\n        refresh\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VBZFByZXZpZXdCbG9iLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7c0VBRWlFO0FBT25DO0FBd0I5Qjs7Ozs7Ozs7O0NBU0MsR0FDTSxTQUFTUSxpQkFBaUIsS0FLUDtRQUxPLEVBQzdCQyxZQUFZLEVBQ1pDLElBQUksRUFDSkMsSUFBSSxFQUNKQyxhQUFhLEdBQUcsRUFDTSxHQUxPO0lBTTdCLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHZCwrQ0FBUUEsQ0FBZ0I7SUFDdEQsTUFBTSxDQUFDZSxXQUFXQyxhQUFhLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUNpQixPQUFPQyxTQUFTLEdBQUdsQiwrQ0FBUUEsQ0FBZTtJQUVqRCw4Q0FBOEM7SUFDOUMsTUFBTW1CLGtCQUFrQmpCLDZDQUFNQSxDQUFnQjtJQUU5QyxtREFBbUQ7SUFDbkQsTUFBTWtCLGdCQUFnQmxCLDZDQUFNQSxDQUFzQixJQUFJbUI7SUFFdEQscUJBQXFCO0lBQ3JCLE1BQU1DLGdCQUFnQnBCLDZDQUFNQSxDQUF3QjtJQUVwRCw2Q0FBNkM7SUFDN0MsTUFBTXFCLGdCQUFnQnJCLDZDQUFNQSxDQUFDO0lBRTdCLE1BQU1zQixlQUFlckIsa0RBQVdBLENBQUM7UUFDN0IsTUFBTXNCLG9CQUFvQixFQUFFRixjQUFjRyxPQUFPO1FBQ2pEVixhQUFhO1FBQ2JFLFNBQVM7UUFFVCxJQUFJO1lBQ0EsTUFBTVMsV0FBVyxHQUFtQmpCLE9BQWhCRCxjQUFhLEtBQVEsT0FBTEM7WUFFcEMsNEJBQTRCO1lBQzVCLElBQUlrQjtZQUNKLE1BQU1DLGVBQWUsR0FBWSxPQUFURixVQUFTO1lBQ2pDLElBQUlQLGNBQWNNLE9BQU8sQ0FBQ0ksR0FBRyxDQUFDRCxlQUFlO2dCQUN6Q0QsT0FBT1IsY0FBY00sT0FBTyxDQUFDSyxHQUFHLENBQUNGO1lBQ3JDLE9BQU87Z0JBQ0gsTUFBTUcsVUFBVSxNQUFNQyxNQUFNLEdBQVksT0FBVE4sVUFB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O1FBQ3RDO1FBRUEsZ0NBQWdDO1FBQ2hDSixjQUFjSSxPQUFPLEdBQUd3QyxXQUFXO1lBQy9CMUM7UUFDSixHQUFHWjtRQUVILE9BQU87WUFDSCxJQUFJVSxjQUFjSSxPQUFPLEVBQUU7Z0JBQ3ZCdUMsYUFBYTNDLGNBQWNJLE9BQU87WUFDdEM7UUFDSjtJQUNKLEdBQUc7UUFBQ0Y7UUFBY1o7S0FBVztJQUU3QixxQkFBcUI7SUFDckJYLGdEQUFTQSxDQUFDO1FBQ04sT0FBTztZQUNILElBQUlrQixnQkFBZ0JPLE9BQU8sRUFBRTtnQkFDekJrQyxJQUFJRSxlQUFlLENBQUMzQyxnQkFBZ0JPLE9BQU87WUFDL0M7WUFDQU4sY0FBY00sT0FBTyxDQUFDeUMsS0FBSztRQUMvQjtJQUNKLEdBQUcsRUFBRTtJQUVMLE1BQU1DLFVBQVVqRSxrREFBV0EsQ0FBQztRQUN4Qiw2QkFBNkI7UUFDN0JpQixjQUFjTSxPQUFPLENBQUN5QyxLQUFLO1FBQzNCM0M7SUFDSixHQUFHO1FBQUNBO0tBQWE7SUFFakIsT0FBTztRQUFFWDtRQUFTRTtRQUFXRTtRQUFPbUQ7SUFBUTtBQUNoRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvdXNlQWRQcmV2aWV3QmxvYi50cz9iMzA2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge1xuICAgIHBhcnNlTWFuaWZlc3RKcyxcbiAgICBzZXJpYWxpemVNYW5pZmVzdCxcbiAgICBmaXhSZWxhdGl2ZVBhdGhzLFxuICAgIGFwcGx5RHluYW1pY1ZhbHVlcyxcbiAgICBEeW5hbWljVmFsdWVEYXRhLFxufSBmcm9tIFwiQC9saWIvbWFuaWZlc3QtdXRpbHNcIjtcblxuaW50ZXJmYWNlIFVzZUFkUHJldmlld0Jsb2JPcHRpb25zIHtcbiAgICAvKiogVGVtcGxhdGUgcGF0aCByZWxhdGl2ZSB0byAvcHVibGljLCBlLmcuLCBcIi90ZW1wbGF0ZXMvdGVtcGxhdGUwMDBcIiAqL1xuICAgIHRlbXBsYXRlUGF0aDogc3RyaW5nO1xuICAgIC8qKiBBZCBzaXplLCBlLmcuLCBcIjMwMHgyNTBcIiAqL1xuICAgIHNpemU6IHN0cmluZztcbiAgICAvKiogRHluYW1pYyBkYXRhIGZyb20gdGhlIFVJICovXG4gICAgZGF0YTogRHluYW1pY1ZhbHVlRGF0YTtcbiAgICAvKiogRGVib3VuY2UgZGVsYXkgaW4gbXMgKGRlZmF1bHQ6IDMwMCkgKi9cbiAgICBkZWJvdW5jZU1zPzogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgVXNlQWRQcmV2aWV3QmxvYlJlc3VsdCB7XG4gICAgLyoqIFRoZSBCbG9iIFVSTCB0byB1c2UgYXMgaWZyYW1lIHNyYyAqL1xuICAgIGJsb2JVcmw6IHN0cmluZyB8IG51bGw7XG4gICAgLyoqIFdoZXRoZXIgdGhlIGJsb2IgaXMgY3VycmVudGx5IGJlaW5nIGdlbmVyYXRlZCAqL1xuICAgIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgICAvKiogQW55IGVycm9yIHRoYXQgb2NjdXJyZWQgKi9cbiAgICBlcnJvcjogRXJyb3IgfCBudWxsO1xuICAgIC8qKiBGb3JjZSByZWdlbmVyYXRlIHRoZSBibG9iICovXG4gICAgcmVmcmVzaDogKCkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBIb29rIHRoYXQgZ2VuZXJhdGVzIGEgQmxvYiBVUkwgZm9yIGFkIHByZXZpZXcgd2l0aCBtb2RpZmllZCBtYW5pZmVzdFxuICpcbiAqIFRoaXMgaG9vazpcbiAqIDEuIEZldGNoZXMgdGhlIHRlbXBsYXRlJ3MgaW5kZXguaHRtbCBhbmQgbWFuaWZlc3QuanNcbiAqIDIuIFBhcnNlcyBhbmQgbW9kaWZpZXMgdGhlIG1hbmlmZXN0IHdpdGggZHluYW1pYyB2YWx1ZXNcbiAqIDMuIEluamVjdHMgdGhlIG1vZGlmaWVkIG1hbmlmZXN0IGlubGluZSBpbnRvIHRoZSBIVE1MXG4gKiA0LiBGaXhlcyByZWxhdGl2ZSBhc3NldCBwYXRoc1xuICogNS4gUmV0dXJucyBhIEJsb2IgVVJMIHRoYXQgY2FuIGJlIHVzZWQgYXMgaWZyYW1lIHNyY1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQWRQcmV2aWV3QmxvYih7XG4gICAgdGVtcGxhdGVQYXRoLFxuICAgIHNpemUsXG4gICAgZGF0YSxcbiAgICBkZWJvdW5jZU1zID0gMzAwLFxufTogVXNlQWRQcmV2aWV3QmxvYk9wdGlvbnMpOiBVc2VBZFByZXZpZXdCbG9iUmVzdWx0IHtcbiAgICBjb25zdCBbYmxvYlVybCwgc2V0QmxvYlVybF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxFcnJvciB8IG51bGw+KG51bGwpO1xuXG4gICAgLy8gS2VlcCB0cmFjayBvZiBwcmV2aW91cyBibG9iIFVSTCBmb3IgY2xlYW51cFxuICAgIGNvbnN0IHByZXZpb3VzQmxvYlVybCA9IHVzZVJlZjxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICAgIC8vIENhY2hlIGZvciBmZXRjaGVkIHJlc291cmNlcyB0byBhdm9pZCByZS1mZXRjaGluZ1xuICAgIGNvbnN0IHJlc291cmNlQ2FjaGUgPSB1c2VSZWY8TWFwPHN0cmluZywgc3RyaW5nPj4obmV3IE1hcCgpKTtcblxuICAgIC8vIERlYm91bmNlIHRpbWVyIHJlZlxuICAgIGNvbnN0IGRlYm91bmNlVGltZXIgPSB1c2VSZWY8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKTtcblxuICAgIC8vIEdlbmVyYXRpb24gY291bnRlciB0byBoYW5kbGUgc3RhbGUgdXBkYXRlc1xuICAgIGNvbnN0IGdlbmVyYXRpb25SZWYgPSB1c2VSZWYoMCk7XG5cbiAgICBjb25zdCBnZW5lcmF0ZUJsb2IgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRHZW5lcmF0aW9uID0gKytnZW5lcmF0aW9uUmVmLmN1cnJlbnQ7XG4gICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VQYXRoID0gYCR7dGVtcGxhdGVQYXRofS8ke3NpemV9YDtcblxuICAgICAgICAgICAgLy8gRmV0Y2ggSFRNTCAod2l0aCBjYWNoaW5nKVxuICAgICAgICAgICAgbGV0IGh0bWw6IHN0cmluZztcbiAgICAgICAgICAgIGNvbnN0IGh0bWxDYWNoZUtleSA9IGAke2Jhc2VQYXRofS9pbmRleC5odG1sYDtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZUNhY2hlLmN1cnJlbnQuaGFzKGh0bWxDYWNoZUtleSkpIHtcbiAgICAgICAgICAgICAgICBodG1sID0gcmVzb3VyY2VDYWNoZS5jdXJyZW50LmdldChodG1sQ2FjaGVLZXkpITtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaHRtbFJlcyA9IGF3YWl0IGZldGNoKGAke2Jhc2VQYXRofS9pbmRleC5odG1sYCk7XG4gICAgICAgICAgICAgICAgaWYgKCFodG1sUmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHRlbXBsYXRlIEhUTUw6ICR7aHRtbFJlcy5zdGF0dXN9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGh0bWwgPSBhd2FpdCBodG1sUmVzLnRleHQoKTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZUNhY2hlLmN1cnJlbnQuc2V0KGh0bWxDYWNoZUtleSwgaHRtbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZldGNoIG1hbmlmZXN0LmpzICh3aXRoIGNhY2hpbmcpXG4gICAgICAgICAgICBsZXQgbWFuaWZlc3RKczogc3RyaW5nO1xuICAgICAgICAgICAgY29uc3QgbWFuaWZlc3RDYWNoZUtleSA9IGAke2Jhc2VQYXRofS9tYW5pZmVzdC5qc2A7XG4gICAgICAgICAgICBpZiAocmVzb3VyY2VDYWNoZS5jdXJyZW50LmhhcyhtYW5pZmVzdENhY2hlS2V5KSkge1xuICAgICAgICAgICAgICAgIG1hbmlmZXN0SnMgPSByZXNvdXJjZUNhY2hlLmN1cnJlbnQuZ2V0KG1hbmlmZXN0Q2FjaGVLZXkpITtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFuaWZlc3RSZXMgPSBhd2FpdCBmZXRjaChgJHtiYXNlUGF0aH0vbWFuaWZlc3QuanNgKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hbmlmZXN0UmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIG1hbmlmZXN0LmpzOiAke21hbmlmZXN0UmVzLnN0YXR1c31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFuaWZlc3RKcyA9IGF3YWl0IG1hbmlmZXN0UmVzLnRleHQoKTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZUNhY2hlLmN1cnJlbnQuc2V0KG1hbmlmZXN0Q2FjaGVLZXksIG1hbmlmZXN0SnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgbWFuaWZlc3RcbiAgICAgICAgICAgIGNvbnN0IGJhc2VNYW5pZmVzdCA9IHBhcnNlTWFuaWZlc3RKcyhtYW5pZmVzdEpzKTtcblxuICAgICAgICAgICAgLy8gQXBwbHkgZHluYW1pYyB2YWx1ZXNcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTWFuaWZlc3QgPSBhcHBseUR5bmFtaWNWYWx1ZXMoYmFzZU1hbmlmZXN0LCBkYXRhKTtcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCBjb2xvcnMgZm9yIGluamVjdGlvbiAoc3RvcmVkIGJ5IGFwcGx5RHluYW1pY1ZhbHVlcylcbiAgICAgICAgICAgIGNvbnN0IGNvbG9ycyA9IChtb2RpZmllZE1hbmlmZXN0IGFzIHsgX19jb2xvcnM/OiBzdHJpbmdbXSB9KS5fX2NvbG9ycztcbiAgICAgICAgICAgIGRlbGV0ZSAobW9kaWZpZWRNYW5pZmVzdCBhcyB7IF9fY29sb3JzPzogc3RyaW5nW10gfSkuX19jb2xvcnM7XG5cbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSB0aGUgbW9kaWZpZWQgbWFuaWZlc3RcbiAgICAgICAgICAgIGNvbnN0IGlubGluZU1hbmlmZXN0ID0gc2VyaWFsaXplTWFuaWZlc3QobW9kaWZpZWRNYW5pZmVzdCk7XG5cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGV4dGVybmFsIG1hbmlmZXN0LmpzIHNjcmlwdCB3aXRoIGlubGluZSBzY3JpcHRcbiAgICAgICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgLzxzY3JpcHRcXHMrc3JjPVtcIiddbWFuaWZlc3RcXC5qc1tcIiddXFxzKj48XFwvc2NyaXB0Pi9pLFxuICAgICAgICAgICAgICAgIGA8c2NyaXB0PiR7aW5saW5lTWFuaWZlc3R9PC9zY3JpcHQ+YFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gSW5qZWN0IGNvbG9yIG92ZXJyaWRlIGludG8gZHluYW1pY0RhdGEgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICAgIGlmIChjb2xvcnMgJiYgY29sb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvclN0cmluZyA9IGNvbG9ycy5zbGljZSgwLCAzKS5qb2luKFwifFwiKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBkeW5hbWljRGF0YSBpbml0aWFsaXphdGlvbiBhbmQgaW5qZWN0IGNvbG9yc1xuICAgICAgICAgICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIC9ncmlkOHBsYXllclxcLmR5bmFtaWNEYXRhXFxzKj1cXHMqZHluYW1pY0RhdGE7LyxcbiAgICAgICAgICAgICAgICAgICAgYGR5bmFtaWNEYXRhW1wiczBfY29sb3JzXCJdID0gXCIke2NvbG9yU3RyaW5nfVwiO1xcbiAgICAgIGdyaWQ4cGxheWVyLmR5bmFtaWNEYXRhID0gZHluYW1pY0RhdGE7YFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpeCByZWxhdGl2ZSBwYXRocyB0byBhYnNvbHV0ZVxuICAgICAgICAgICAgaHRtbCA9IGZpeFJlbGF0aXZlUGF0aHMoaHRtbCwgYmFzZVBhdGgpO1xuXG4gICAgICAgICAgICAvLyBEZWJ1ZzogTG9nIGEgc25pcHBldCB0byB2ZXJpZnkgcGF0aHMgd2VyZSBmaXhlZFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0TWF0Y2ggPSBodG1sLm1hdGNoKC88c2NyaXB0W14+XStzcmM9W1wiJ11bXlwiJ10rW1wiJ11bXj5dKj4vZ2kpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbQWRQcmV2aWV3QmxvYl0gU2NyaXB0IHRhZ3MgYWZ0ZXIgcGF0aCBmaXg6Jywgc2NyaXB0TWF0Y2g/LnNsaWNlKDAsIDUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBnZW5lcmF0aW9uIGlzIHN0aWxsIGN1cnJlbnRcbiAgICAgICAgICAgIGlmIChjdXJyZW50R2VuZXJhdGlvbiAhPT0gZ2VuZXJhdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBTdGFsZSB1cGRhdGUsIGRpc2NhcmRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGJsb2IgVVJMXG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2h0bWxdLCB7IHR5cGU6IFwidGV4dC9odG1sXCIgfSk7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG4gICAgICAgICAgICAvLyBDbGVhbnVwIHByZXZpb3VzIGJsb2IgVVJMXG4gICAgICAgICAgICBpZiAocHJldmlvdXNCbG9iVXJsLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHByZXZpb3VzQmxvYlVybC5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzQmxvYlVybC5jdXJyZW50ID0gdXJsO1xuXG4gICAgICAgICAgICBzZXRCbG9iVXJsKHVybCk7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50R2VuZXJhdGlvbiA9PT0gZ2VuZXJhdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycikpKTtcbiAgICAgICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3RlbXBsYXRlUGF0aCwgc2l6ZSwgZGF0YV0pO1xuXG4gICAgLy8gRGVib3VuY2VkIGVmZmVjdCB0byByZWdlbmVyYXRlIGJsb2Igd2hlbiBpbnB1dHMgY2hhbmdlXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gQ2xlYXIgYW55IHBlbmRpbmcgZGVib3VuY2VcbiAgICAgICAgaWYgKGRlYm91bmNlVGltZXIuY3VycmVudCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlVGltZXIuY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdXAgZGVib3VuY2VkIHJlZ2VuZXJhdGlvblxuICAgICAgICBkZWJvdW5jZVRpbWVyLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGdlbmVyYXRlQmxvYigpO1xuICAgICAgICB9LCBkZWJvdW5jZU1zKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRlYm91bmNlVGltZXIuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVyLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtnZW5lcmF0ZUJsb2IsIGRlYm91bmNlTXNdKTtcblxuICAgIC8vIENsZWFudXAgb24gdW5tb3VudFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNCbG9iVXJsLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHByZXZpb3VzQmxvYlVybC5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc291cmNlQ2FjaGUuY3VycmVudC5jbGVhcigpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHJlZnJlc2ggPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIC8vIENsZWFyIGNhY2hlIGFuZCByZWdlbmVyYXRlXG4gICAgICAgIHJlc291cmNlQ2FjaGUuY3VycmVudC5jbGVhcigpO1xuICAgICAgICBnZW5lcmF0ZUJsb2IoKTtcbiAgICB9LCBbZ2VuZXJhdGVCbG9iXSk7XG5cbiAgICByZXR1cm4geyBibG9iVXJsLCBpc0xvYWRpbmcsIGVycm9yLCByZWZyZXNoIH07XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsInBhcnNlTWFuaWZlc3RKcyIsInNlcmlhbGl6ZU1hbmlmZXN0IiwiZml4UmVsYXRpdmVQYXRocyIsImFwcGx5RHluYW1pY1ZhbHVlcyIsInVzZUFkUHJldmlld0Jsb2IiLCJ0ZW1wbGF0ZVBhdGgiLCJzaXplIiwiZGF0YSIsImRlYm91bmNlTXMiLCJibG9iVXJsIiwic2V0QmxvYlVybCIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJwcmV2aW91c0Jsb2JVcmwiLCJyZXNvdXJjZUNhY2hlIiwiTWFwIiwiZGVib3VuY2VUaW1lciIsImdlbmVyYXRpb25SZWYiLCJnZW5lcmF0ZUJsb2IiLCJjdXJyZW50R2VuZXJhdGlvbiIsImN1cnJlbnQiLCJiYXNlUGF0aCIsImh0bWwiLCJodG1sQ2FjaGVLZXkiLCJoYXMiLCJnZXQiLCJodG1sUmVzIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzIiwidGV4dCIsInNldCIsIm1hbmlmZXN0SnMiLCJtYW5pZmVzdENhY2hlS2V5IiwibWFuaWZlc3RSZXMiLCJiYXNlTWFuaWZlc3QiLCJtb2RpZmllZE1hbmlmZXN0IiwiY29sb3JzIiwiX19jb2xvcnMiLCJpbmxpbmVNYW5pZmVzdCIsInJlcGxhY2UiLCJsZW5ndGgiLCJjb2xvclN0cmluZyIsInNsaWNlIiwiam9pbiIsInNjcmlwdE1hdGNoIiwibWF0Y2giLCJjb25zb2xlIiwibG9nIiwiYmxvYiIsIkJsb2IiLCJ0eXBlIiwidXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwicmV2b2tlT2JqZWN0VVJMIiwiZXJyIiwiU3RyaW5nIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImNsZWFyIiwicmVmcmVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useAdPreviewBlob.ts\n"));

/***/ })

});