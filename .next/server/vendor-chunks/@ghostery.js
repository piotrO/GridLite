"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ghostery";
exports.ids = ["vendor-chunks/@ghostery"];
exports.modules = {

/***/ "(rsc)/./node_modules/@ghostery/adblocker-content/dist/esm/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker-content/dist/esm/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOMMonitor: () => (/* binding */ DOMMonitor),\n/* harmony export */   autoRemoveScript: () => (/* binding */ autoRemoveScript),\n/* harmony export */   extractFeaturesFromDOM: () => (/* binding */ extractFeaturesFromDOM),\n/* harmony export */   injectScript: () => (/* binding */ injectScript)\n/* harmony export */ });\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nconst SCRIPT_ID = 'cliqz-adblocker-script';\nconst IGNORED_TAGS = new Set(['br', 'head', 'link', 'meta', 'script', 'style', 's']);\nfunction debounce(fn, { waitFor, maxWait, }) {\n    let delayedTimer;\n    let maxWaitTimer;\n    const clear = () => {\n        clearTimeout(delayedTimer);\n        clearTimeout(maxWaitTimer);\n        delayedTimer = undefined;\n        maxWaitTimer = undefined;\n    };\n    const run = () => {\n        clear();\n        fn();\n    };\n    return [\n        () => {\n            if (maxWait > 0 && maxWaitTimer === undefined) {\n                maxWaitTimer = setTimeout(run, maxWait);\n            }\n            clearTimeout(delayedTimer);\n            delayedTimer = setTimeout(run, waitFor);\n        },\n        clear,\n    ];\n}\nfunction isElement(node) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType#node_type_constants\n    return node.nodeType === 1; // Node.ELEMENT_NODE;\n}\nfunction getElementsFromMutations(mutations) {\n    // Accumulate all nodes which were updated in `nodes`\n    const elements = [];\n    for (const mutation of mutations) {\n        if (mutation.type === 'attributes') {\n            if (isElement(mutation.target)) {\n                elements.push(mutation.target);\n            }\n        }\n        else if (mutation.type === 'childList') {\n            for (const addedNode of mutation.addedNodes) {\n                if (isElement(addedNode) && addedNode.id !== SCRIPT_ID) {\n                    elements.push(addedNode);\n                }\n            }\n        }\n    }\n    return elements;\n}\n/**\n * WARNING: this function should be self-contained and not rely on any global\n * symbol. That constraint needs to be fulfilled because this function can\n * potentially be injected in content-script (e.g.: see PuppeteerBlocker for\n * more details).\n */\nfunction extractFeaturesFromDOM(roots) {\n    // NOTE: This cannot be global as puppeteer needs to be able to serialize this function.\n    const ignoredTags = new Set(['br', 'head', 'link', 'meta', 'script', 'style', 's']);\n    const classes = new Set();\n    const hrefs = new Set();\n    const ids = new Set();\n    const seenElements = new Set();\n    for (const root of roots) {\n        for (const element of [\n            root,\n            ...root.querySelectorAll('[id]:not(html):not(body),[class]:not(html):not(body),[href]:not(html):not(body)'),\n        ]) {\n            // If one of root belongs to another root which is parent node of the one, querySelectorAll can return duplicates.\n            if (seenElements.has(element)) {\n                continue;\n            }\n            seenElements.add(element);\n            // Any conditions to filter this element out should be placed under this line:\n            if (ignoredTags.has(element.nodeName.toLowerCase())) {\n                continue;\n            }\n            // Update ids\n            const id = element.getAttribute('id');\n            if (typeof id === 'string') {\n                ids.add(id);\n            }\n            // Update classes\n            const classList = element.classList;\n            for (const classEntry of classList) {\n                classes.add(classEntry);\n            }\n            // Update href\n            const href = element.getAttribute('href');\n            if (typeof href === 'string') {\n                hrefs.add(href);\n            }\n        }\n    }\n    return {\n        classes: Array.from(classes),\n        hrefs: Array.from(hrefs),\n        ids: Array.from(ids),\n    };\n}\nclass DOMMonitor {\n    constructor(cb) {\n        this.cb = cb;\n        this.knownIds = new Set();\n        this.knownHrefs = new Set();\n        this.knownClasses = new Set();\n        this.observer = null;\n    }\n    queryAll(window) {\n        this.cb({ type: 'elements', elements: [window.document.documentElement] });\n        this.handleUpdatedNodes([window.document.documentElement]);\n    }\n    start(window) {\n        if (this.observer === null && window.MutationObserver !== undefined) {\n            const nodes = new Set();\n            const handleUpdatedNodesCallback = () => {\n                this.handleUpdatedNodes(Array.from(nodes));\n                nodes.clear();\n            };\n            const [debouncedHandleUpdatedNodes, cancelHandleUpdatedNodes] = debounce(handleUpdatedNodesCallback, {\n                waitFor: 25,\n                maxWait: 1000,\n            });\n            this.observer = new window.MutationObserver((mutations) => {\n                getElementsFromMutations(mutations).forEach(nodes.add, nodes);\n                // Set a threshold to prevent websites continuously\n                // causing DOM mutations making the set being filled up infinitely.\n                if (nodes.size > 512) {\n                    cancelHandleUpdatedNodes();\n                    handleUpdatedNodesCallback();\n                }\n                else {\n                    debouncedHandleUpdatedNodes();\n                }\n            });\n            this.observer.observe(window.document.documentElement, {\n                // Monitor some attributes\n                attributes: true,\n                attributeFilter: ['class', 'id', 'href'],\n                childList: true,\n                subtree: true,\n            });\n        }\n    }\n    stop() {\n        if (this.observer !== null) {\n            this.observer.disconnect();\n            this.observer = null;\n        }\n    }\n    handleNewFeatures({ hrefs, ids, classes, }) {\n        const newIds = [];\n        const newClasses = [];\n        const newHrefs = [];\n        // Update ids\n        for (const id of ids) {\n            if (this.knownIds.has(id) === false) {\n                newIds.push(id);\n                this.knownIds.add(id);\n            }\n        }\n        for (const cls of classes) {\n            if (this.knownClasses.has(cls) === false) {\n                newClasses.push(cls);\n                this.knownClasses.add(cls);\n            }\n        }\n        for (const href of hrefs) {\n            if (this.knownHrefs.has(href) === false) {\n                newHrefs.push(href);\n                this.knownHrefs.add(href);\n            }\n        }\n        if (newIds.length !== 0 || newClasses.length !== 0 || newHrefs.length !== 0) {\n            this.cb({\n                type: 'features',\n                classes: newClasses,\n                hrefs: newHrefs,\n                ids: newIds,\n            });\n            return true;\n        }\n        return false;\n    }\n    handleUpdatedNodes(elements) {\n        if (elements.length !== 0) {\n            this.cb({\n                type: 'elements',\n                elements: elements.filter((e) => IGNORED_TAGS.has(e.nodeName.toLowerCase()) === false),\n            });\n            return this.handleNewFeatures(extractFeaturesFromDOM(elements));\n        }\n        return false;\n    }\n}\n/**\n * Wrap a self-executing script into a block of custom logic to remove the\n * script tag once execution is terminated. This can be useful to not leave\n * traces in the DOM after injections.\n */\nfunction autoRemoveScript(script) {\n    // Minified using 'terser'\n    return `try{${script}}catch(c){}!function(){var c=document.currentScript,e=c&&c.parentNode;e&&e.removeChild(c)}();`;\n    // Original:\n    //\n    //    try {\n    //      ${script}\n    //    } catch (ex) { }\n    //\n    //    (function() {\n    //      var currentScript = document.currentScript;\n    //      var parent = currentScript && currentScript.parentNode;\n    //\n    //      if (parent) {\n    //        parent.removeChild(currentScript);\n    //      }\n    //    })();\n}\nfunction insertNode(node, document) {\n    const parent = document.head || document.documentElement || document;\n    if (parent !== null) {\n        parent.appendChild(node);\n    }\n}\nfunction injectScriptlet(s, doc) {\n    const script = doc.createElement('script');\n    script.type = 'text/javascript';\n    script.id = SCRIPT_ID;\n    script.async = false;\n    script.appendChild(doc.createTextNode(autoRemoveScript(s)));\n    insertNode(script, doc);\n}\nfunction isFirefox(doc) {\n    var _a, _b, _c;\n    try {\n        return ((_c = (_b = (_a = doc.defaultView) === null || _a === void 0 ? void 0 : _a.navigator) === null || _b === void 0 ? void 0 : _b.userAgent) === null || _c === void 0 ? void 0 : _c.indexOf('Firefox')) !== -1;\n    }\n    catch (e) {\n        return false;\n    }\n}\nasync function injectScriptletFirefox(s, doc) {\n    const win = doc.defaultView;\n    const script = doc.createElement('script');\n    script.async = false;\n    script.id = SCRIPT_ID;\n    const blob = new win.Blob([autoRemoveScript(s)], { type: 'text/javascript; charset=utf-8' });\n    const url = win.URL.createObjectURL(blob);\n    // a hack for tests to that allows for async URL.createObjectURL\n    // eslint-disable-next-line @typescript-eslint/await-thenable\n    script.src = await url;\n    insertNode(script, doc);\n    win.URL.revokeObjectURL(url);\n}\nfunction injectScript(s, doc) {\n    if (isFirefox(doc)) {\n        injectScriptletFirefox(s, doc);\n    }\n    else {\n        injectScriptlet(s, doc);\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci1jb250ZW50L2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0RBQStEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0JBQWdCLEVBQUUsUUFBUSxVQUFVLFlBQVksK0NBQStDLG9CQUFvQixHQUFHO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHdCQUF3QixnQkFBZ0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvYWRibG9ja2VyLWNvbnRlbnQvZGlzdC9lc20vaW5kZXguanM/Zjg5YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50IEdob3N0ZXJ5IEdtYkguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmNvbnN0IFNDUklQVF9JRCA9ICdjbGlxei1hZGJsb2NrZXItc2NyaXB0JztcbmNvbnN0IElHTk9SRURfVEFHUyA9IG5ldyBTZXQoWydicicsICdoZWFkJywgJ2xpbmsnLCAnbWV0YScsICdzY3JpcHQnLCAnc3R5bGUnLCAncyddKTtcbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCB7IHdhaXRGb3IsIG1heFdhaXQsIH0pIHtcbiAgICBsZXQgZGVsYXllZFRpbWVyO1xuICAgIGxldCBtYXhXYWl0VGltZXI7XG4gICAgY29uc3QgY2xlYXIgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChkZWxheWVkVGltZXIpO1xuICAgICAgICBjbGVhclRpbWVvdXQobWF4V2FpdFRpbWVyKTtcbiAgICAgICAgZGVsYXllZFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICBtYXhXYWl0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBjb25zdCBydW4gPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyKCk7XG4gICAgICAgIGZuKCk7XG4gICAgfTtcbiAgICByZXR1cm4gW1xuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBpZiAobWF4V2FpdCA+IDAgJiYgbWF4V2FpdFRpbWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXhXYWl0VGltZXIgPSBzZXRUaW1lb3V0KHJ1biwgbWF4V2FpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVsYXllZFRpbWVyKTtcbiAgICAgICAgICAgIGRlbGF5ZWRUaW1lciA9IHNldFRpbWVvdXQocnVuLCB3YWl0Rm9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXIsXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUvbm9kZVR5cGUjbm9kZV90eXBlX2NvbnN0YW50c1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxOyAvLyBOb2RlLkVMRU1FTlRfTk9ERTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRzRnJvbU11dGF0aW9ucyhtdXRhdGlvbnMpIHtcbiAgICAvLyBBY2N1bXVsYXRlIGFsbCBub2RlcyB3aGljaCB3ZXJlIHVwZGF0ZWQgaW4gYG5vZGVzYFxuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgICAgICAgaWYgKGlzRWxlbWVudChtdXRhdGlvbi50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChtdXRhdGlvbi50YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFkZGVkTm9kZSBvZiBtdXRhdGlvbi5hZGRlZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRWxlbWVudChhZGRlZE5vZGUpICYmIGFkZGVkTm9kZS5pZCAhPT0gU0NSSVBUX0lEKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYWRkZWROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xufVxuLyoqXG4gKiBXQVJOSU5HOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBzZWxmLWNvbnRhaW5lZCBhbmQgbm90IHJlbHkgb24gYW55IGdsb2JhbFxuICogc3ltYm9sLiBUaGF0IGNvbnN0cmFpbnQgbmVlZHMgdG8gYmUgZnVsZmlsbGVkIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBjYW5cbiAqIHBvdGVudGlhbGx5IGJlIGluamVjdGVkIGluIGNvbnRlbnQtc2NyaXB0IChlLmcuOiBzZWUgUHVwcGV0ZWVyQmxvY2tlciBmb3JcbiAqIG1vcmUgZGV0YWlscykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0RmVhdHVyZXNGcm9tRE9NKHJvb3RzKSB7XG4gICAgLy8gTk9URTogVGhpcyBjYW5ub3QgYmUgZ2xvYmFsIGFzIHB1cHBldGVlciBuZWVkcyB0byBiZSBhYmxlIHRvIHNlcmlhbGl6ZSB0aGlzIGZ1bmN0aW9uLlxuICAgIGNvbnN0IGlnbm9yZWRUYWdzID0gbmV3IFNldChbJ2JyJywgJ2hlYWQnLCAnbGluaycsICdtZXRhJywgJ3NjcmlwdCcsICdzdHlsZScsICdzJ10pO1xuICAgIGNvbnN0IGNsYXNzZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgaHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgaWRzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHNlZW5FbGVtZW50cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAuLi5yb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZF06bm90KGh0bWwpOm5vdChib2R5KSxbY2xhc3NdOm5vdChodG1sKTpub3QoYm9keSksW2hyZWZdOm5vdChodG1sKTpub3QoYm9keSknKSxcbiAgICAgICAgXSkge1xuICAgICAgICAgICAgLy8gSWYgb25lIG9mIHJvb3QgYmVsb25ncyB0byBhbm90aGVyIHJvb3Qgd2hpY2ggaXMgcGFyZW50IG5vZGUgb2YgdGhlIG9uZSwgcXVlcnlTZWxlY3RvckFsbCBjYW4gcmV0dXJuIGR1cGxpY2F0ZXMuXG4gICAgICAgICAgICBpZiAoc2VlbkVsZW1lbnRzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VlbkVsZW1lbnRzLmFkZChlbGVtZW50KTtcbiAgICAgICAgICAgIC8vIEFueSBjb25kaXRpb25zIHRvIGZpbHRlciB0aGlzIGVsZW1lbnQgb3V0IHNob3VsZCBiZSBwbGFjZWQgdW5kZXIgdGhpcyBsaW5lOlxuICAgICAgICAgICAgaWYgKGlnbm9yZWRUYWdzLmhhcyhlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgaWRzXG4gICAgICAgICAgICBjb25zdCBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZHMuYWRkKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjbGFzc2VzXG4gICAgICAgICAgICBjb25zdCBjbGFzc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2xhc3NFbnRyeSBvZiBjbGFzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLmFkZChjbGFzc0VudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBocmVmXG4gICAgICAgICAgICBjb25zdCBocmVmID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaHJlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBocmVmcy5hZGQoaHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xhc3NlczogQXJyYXkuZnJvbShjbGFzc2VzKSxcbiAgICAgICAgaHJlZnM6IEFycmF5LmZyb20oaHJlZnMpLFxuICAgICAgICBpZHM6IEFycmF5LmZyb20oaWRzKSxcbiAgICB9O1xufVxuZXhwb3J0IGNsYXNzIERPTU1vbml0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGNiKSB7XG4gICAgICAgIHRoaXMuY2IgPSBjYjtcbiAgICAgICAgdGhpcy5rbm93bklkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5rbm93bkhyZWZzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmtub3duQ2xhc3NlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICAgIHF1ZXJ5QWxsKHdpbmRvdykge1xuICAgICAgICB0aGlzLmNiKHsgdHlwZTogJ2VsZW1lbnRzJywgZWxlbWVudHM6IFt3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSB9KTtcbiAgICAgICAgdGhpcy5oYW5kbGVVcGRhdGVkTm9kZXMoW3dpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKTtcbiAgICB9XG4gICAgc3RhcnQod2luZG93KSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyID09PSBudWxsICYmIHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlVXBkYXRlZE5vZGVzQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVVcGRhdGVkTm9kZXMoQXJyYXkuZnJvbShub2RlcykpO1xuICAgICAgICAgICAgICAgIG5vZGVzLmNsZWFyKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgW2RlYm91bmNlZEhhbmRsZVVwZGF0ZWROb2RlcywgY2FuY2VsSGFuZGxlVXBkYXRlZE5vZGVzXSA9IGRlYm91bmNlKGhhbmRsZVVwZGF0ZWROb2Rlc0NhbGxiYWNrLCB7XG4gICAgICAgICAgICAgICAgd2FpdEZvcjogMjUsXG4gICAgICAgICAgICAgICAgbWF4V2FpdDogMTAwMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2V0RWxlbWVudHNGcm9tTXV0YXRpb25zKG11dGF0aW9ucykuZm9yRWFjaChub2Rlcy5hZGQsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgYSB0aHJlc2hvbGQgdG8gcHJldmVudCB3ZWJzaXRlcyBjb250aW51b3VzbHlcbiAgICAgICAgICAgICAgICAvLyBjYXVzaW5nIERPTSBtdXRhdGlvbnMgbWFraW5nIHRoZSBzZXQgYmVpbmcgZmlsbGVkIHVwIGluZmluaXRlbHkuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLnNpemUgPiA1MTIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsSGFuZGxlVXBkYXRlZE5vZGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVVwZGF0ZWROb2Rlc0NhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWJvdW5jZWRIYW5kbGVVcGRhdGVkTm9kZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgLy8gTW9uaXRvciBzb21lIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogWydjbGFzcycsICdpZCcsICdocmVmJ10sXG4gICAgICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVOZXdGZWF0dXJlcyh7IGhyZWZzLCBpZHMsIGNsYXNzZXMsIH0pIHtcbiAgICAgICAgY29uc3QgbmV3SWRzID0gW107XG4gICAgICAgIGNvbnN0IG5ld0NsYXNzZXMgPSBbXTtcbiAgICAgICAgY29uc3QgbmV3SHJlZnMgPSBbXTtcbiAgICAgICAgLy8gVXBkYXRlIGlkc1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgICAgICAgaWYgKHRoaXMua25vd25JZHMuaGFzKGlkKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBuZXdJZHMucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5rbm93bklkcy5hZGQoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2xzIG9mIGNsYXNzZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmtub3duQ2xhc3Nlcy5oYXMoY2xzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBuZXdDbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmtub3duQ2xhc3Nlcy5hZGQoY2xzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGhyZWYgb2YgaHJlZnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmtub3duSHJlZnMuaGFzKGhyZWYpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG5ld0hyZWZzLnB1c2goaHJlZik7XG4gICAgICAgICAgICAgICAgdGhpcy5rbm93bkhyZWZzLmFkZChocmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3SWRzLmxlbmd0aCAhPT0gMCB8fCBuZXdDbGFzc2VzLmxlbmd0aCAhPT0gMCB8fCBuZXdIcmVmcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2Ioe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdmZWF0dXJlcycsXG4gICAgICAgICAgICAgICAgY2xhc3NlczogbmV3Q2xhc3NlcyxcbiAgICAgICAgICAgICAgICBocmVmczogbmV3SHJlZnMsXG4gICAgICAgICAgICAgICAgaWRzOiBuZXdJZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFuZGxlVXBkYXRlZE5vZGVzKGVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2Ioe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdlbGVtZW50cycsXG4gICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLmZpbHRlcigoZSkgPT4gSUdOT1JFRF9UQUdTLmhhcyhlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpID09PSBmYWxzZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZU5ld0ZlYXR1cmVzKGV4dHJhY3RGZWF0dXJlc0Zyb21ET00oZWxlbWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBXcmFwIGEgc2VsZi1leGVjdXRpbmcgc2NyaXB0IGludG8gYSBibG9jayBvZiBjdXN0b20gbG9naWMgdG8gcmVtb3ZlIHRoZVxuICogc2NyaXB0IHRhZyBvbmNlIGV4ZWN1dGlvbiBpcyB0ZXJtaW5hdGVkLiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gbm90IGxlYXZlXG4gKiB0cmFjZXMgaW4gdGhlIERPTSBhZnRlciBpbmplY3Rpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXV0b1JlbW92ZVNjcmlwdChzY3JpcHQpIHtcbiAgICAvLyBNaW5pZmllZCB1c2luZyAndGVyc2VyJ1xuICAgIHJldHVybiBgdHJ5eyR7c2NyaXB0fX1jYXRjaChjKXt9IWZ1bmN0aW9uKCl7dmFyIGM9ZG9jdW1lbnQuY3VycmVudFNjcmlwdCxlPWMmJmMucGFyZW50Tm9kZTtlJiZlLnJlbW92ZUNoaWxkKGMpfSgpO2A7XG4gICAgLy8gT3JpZ2luYWw6XG4gICAgLy9cbiAgICAvLyAgICB0cnkge1xuICAgIC8vICAgICAgJHtzY3JpcHR9XG4gICAgLy8gICAgfSBjYXRjaCAoZXgpIHsgfVxuICAgIC8vXG4gICAgLy8gICAgKGZ1bmN0aW9uKCkge1xuICAgIC8vICAgICAgdmFyIGN1cnJlbnRTY3JpcHQgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0O1xuICAgIC8vICAgICAgdmFyIHBhcmVudCA9IGN1cnJlbnRTY3JpcHQgJiYgY3VycmVudFNjcmlwdC5wYXJlbnROb2RlO1xuICAgIC8vXG4gICAgLy8gICAgICBpZiAocGFyZW50KSB7XG4gICAgLy8gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjdXJyZW50U2NyaXB0KTtcbiAgICAvLyAgICAgIH1cbiAgICAvLyAgICB9KSgpO1xufVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShub2RlLCBkb2N1bWVudCkge1xuICAgIGNvbnN0IHBhcmVudCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50O1xuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluamVjdFNjcmlwdGxldChzLCBkb2MpIHtcbiAgICBjb25zdCBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICBzY3JpcHQuaWQgPSBTQ1JJUFRfSUQ7XG4gICAgc2NyaXB0LmFzeW5jID0gZmFsc2U7XG4gICAgc2NyaXB0LmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZShhdXRvUmVtb3ZlU2NyaXB0KHMpKSk7XG4gICAgaW5zZXJ0Tm9kZShzY3JpcHQsIGRvYyk7XG59XG5mdW5jdGlvbiBpc0ZpcmVmb3goZG9jKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgoX2MgPSAoX2IgPSAoX2EgPSBkb2MuZGVmYXVsdFZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYXZpZ2F0b3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi51c2VyQWdlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pbmRleE9mKCdGaXJlZm94JykpICE9PSAtMTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGluamVjdFNjcmlwdGxldEZpcmVmb3gocywgZG9jKSB7XG4gICAgY29uc3Qgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xuICAgIGNvbnN0IHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICBzY3JpcHQuYXN5bmMgPSBmYWxzZTtcbiAgICBzY3JpcHQuaWQgPSBTQ1JJUFRfSUQ7XG4gICAgY29uc3QgYmxvYiA9IG5ldyB3aW4uQmxvYihbYXV0b1JlbW92ZVNjcmlwdChzKV0sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdDsgY2hhcnNldD11dGYtOCcgfSk7XG4gICAgY29uc3QgdXJsID0gd2luLlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgLy8gYSBoYWNrIGZvciB0ZXN0cyB0byB0aGF0IGFsbG93cyBmb3IgYXN5bmMgVVJMLmNyZWF0ZU9iamVjdFVSTFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYXdhaXQtdGhlbmFibGVcbiAgICBzY3JpcHQuc3JjID0gYXdhaXQgdXJsO1xuICAgIGluc2VydE5vZGUoc2NyaXB0LCBkb2MpO1xuICAgIHdpbi5VUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0U2NyaXB0KHMsIGRvYykge1xuICAgIGlmIChpc0ZpcmVmb3goZG9jKSkge1xuICAgICAgICBpbmplY3RTY3JpcHRsZXRGaXJlZm94KHMsIGRvYyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbmplY3RTY3JpcHRsZXQocywgZG9jKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker-content/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/eval.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/eval.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   matchPattern: () => (/* binding */ matchPattern),\n/* harmony export */   matches: () => (/* binding */ matches),\n/* harmony export */   querySelectorAll: () => (/* binding */ querySelectorAll)\n/* harmony export */ });\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/**\n * Evaluates an XPath expression and returns matching Element nodes.\n * @param element - The context element for XPath evaluation\n * @param xpathExpression - The XPath expression to evaluate\n * @returns Array of Element nodes that match the XPath expression\n */\nfunction handleXPathSelector(element, xpathExpression) {\n    try {\n        if (typeof Node === 'undefined' || typeof XPathResult === 'undefined') {\n            return []; // unsupported (not running in the browser)\n        }\n        const result = element.ownerDocument.evaluate(xpathExpression, element, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);\n        if (result.resultType !== XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) {\n            return [];\n        }\n        const elements = [];\n        for (let i = 0; i < result.snapshotLength; i++) {\n            const node = result.snapshotItem(i);\n            if ((node === null || node === void 0 ? void 0 : node.nodeType) === Node.ELEMENT_NODE) {\n                elements.push(node);\n            }\n        }\n        return elements;\n    }\n    catch (e) {\n        return [];\n    }\n}\nfunction parseCSSValue(cssValue) {\n    const firstColonIndex = cssValue.indexOf(':');\n    if (firstColonIndex === -1) {\n        throw new Error('Invalid CSS value format: no colon found');\n    }\n    const property = cssValue.slice(0, firstColonIndex).trim();\n    const value = cssValue.slice(firstColonIndex + 1).trim();\n    const isRegex = value.startsWith('/') && value.lastIndexOf('/') > 0;\n    return { property, value, isRegex };\n}\nfunction matchCSSProperty(element, cssValue, pseudoElement) {\n    const { property, value, isRegex } = parseCSSValue(cssValue);\n    const win = element.ownerDocument && element.ownerDocument.defaultView;\n    if (!win)\n        throw new Error('No window context for element');\n    const computedStyle = win.getComputedStyle(element, pseudoElement);\n    const actualValue = computedStyle[property];\n    if (isRegex) {\n        const regex = parseRegex(value);\n        return regex.test(actualValue);\n    }\n    return actualValue === value;\n}\nfunction parseRegex(str) {\n    if (str.startsWith('/') && str.lastIndexOf('/') > 0) {\n        const lastSlashIndex = str.lastIndexOf('/');\n        const pattern = str.slice(1, lastSlashIndex);\n        const flags = str.slice(lastSlashIndex + 1);\n        if (!/^[gimsuyd]*$/.test(flags)) {\n            throw new Error(`Invalid regex flags: ${flags}`);\n        }\n        return new RegExp(pattern, flags);\n    }\n    else {\n        return new RegExp(str);\n    }\n}\nfunction stripsWrappingQuotes(str) {\n    if ((str.startsWith('\"') && str.endsWith('\"')) || (str.startsWith(\"'\") && str.endsWith(\"'\"))) {\n        return str.slice(1, -1);\n    }\n    return str;\n}\nfunction matchPattern(pattern, text) {\n    pattern = stripsWrappingQuotes(pattern);\n    // TODO - support 'm' RegExp argument\n    if (pattern.startsWith('/') && (pattern.endsWith('/') || pattern.endsWith('/i'))) {\n        let caseSensitive = true;\n        pattern = pattern.slice(1);\n        if (pattern.endsWith('/')) {\n            pattern = pattern.slice(0, -1);\n        }\n        else {\n            pattern = pattern.slice(0, -2);\n            caseSensitive = false;\n        }\n        return new RegExp(pattern, caseSensitive === false ? 'i' : undefined).test(text);\n    }\n    return text.includes(pattern);\n}\n/**\n * Checks if the given element complies with the given selector.\n * @param element The subjective element.\n * @param selector The selector.\n */\nfunction matches(element, selector) {\n    var _a;\n    if (selector.type === 'id' ||\n        selector.type === 'class' ||\n        selector.type === 'type' ||\n        selector.type === 'attribute') {\n        return element.matches(selector.content);\n    }\n    else if (selector.type === 'list') {\n        return selector.list.some((s) => matches(element, s));\n    }\n    else if (selector.type === 'compound') {\n        // Compound selectors contain only simple selectors (id, class, type, attribute, pseudo-class)\n        // that must all match the same element. Complex selectors (with combinators like >, +, ~)\n        // are processed at a higher level by the parser, so they can never be children of compound selectors.\n        return selector.compound.every((s) => matches(element, s));\n    }\n    else if (selector.type === 'pseudo-class') {\n        if (selector.name === 'has') {\n            // The subjective element of `:has` check may be the given element or its children:\n            // - e.g. `html:has(body)`, `body` is the expected subjective to be filtered by `traverse`.\n            // - e.g. `html:has(>body)`, `html` is the subjective element to be filtered by `branch` then `traverse`.\n            // `querySelectorAll` already describes the all.\n            return (selector.subtree !== undefined && querySelectorAll(element, selector.subtree).length !== 0);\n        }\n        else if (selector.name === 'not') {\n            // Unlike `:has`, `:not` assumes the subtree to be the condition for the given element.\n            return selector.subtree !== undefined && traverse(element, [selector.subtree]).length === 0;\n        }\n        else if (selector.name === 'has-text') {\n            const { argument } = selector;\n            if (argument === undefined) {\n                return false;\n            }\n            const text = element.textContent;\n            if (text === null) {\n                return false;\n            }\n            return matchPattern(argument, text.trim());\n        }\n        else if (selector.name === 'min-text-length') {\n            const minLength = Number(selector.argument);\n            if (Number.isNaN(minLength) || minLength < 0) {\n                return false;\n            }\n            const text = element.textContent;\n            if (text === null) {\n                return false;\n            }\n            return text.length >= minLength;\n        }\n        else if (selector.name === 'matches-path') {\n            const { argument } = selector;\n            if (argument === undefined) {\n                return false;\n            }\n            const window = (_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n            if (!window) {\n                return false;\n            }\n            // Get both pathname and search (query parameters)\n            const path = window.location.pathname;\n            const search = window.location.search;\n            const fullUrl = path + search;\n            const regex = parseRegex(argument);\n            return regex.test(fullUrl);\n        }\n        else if (selector.name === 'matches-attr') {\n            const { argument } = selector;\n            if (argument === undefined) {\n                return false;\n            }\n            const indexOfEqual = argument.indexOf('=');\n            let namePattern;\n            let valuePattern;\n            if (indexOfEqual === -1) {\n                namePattern = argument;\n            }\n            else {\n                namePattern = argument.slice(0, indexOfEqual);\n                valuePattern = argument.slice(indexOfEqual + 1);\n            }\n            namePattern = stripsWrappingQuotes(namePattern);\n            valuePattern = valuePattern ? stripsWrappingQuotes(valuePattern) : undefined;\n            let valueRegex = null;\n            if ((valuePattern === null || valuePattern === void 0 ? void 0 : valuePattern.startsWith('/')) && valuePattern.lastIndexOf('/') > 0) {\n                valueRegex = parseRegex(valuePattern);\n            }\n            if (namePattern.startsWith('/') && namePattern.lastIndexOf('/') > 0) {\n                // matching attribute name by regex\n                const regex = parseRegex(namePattern);\n                const matchingAttrs = [...element.attributes].filter((attr) => regex.test(attr.name));\n                // If no value pattern, return true if any attribute matches the name pattern\n                if (!valuePattern) {\n                    return matchingAttrs.length > 0;\n                }\n                // Check if any of the matching attributes have the specified value\n                return matchingAttrs.some((attr) => valueRegex ? valueRegex.test(attr.value) : attr.value === valuePattern);\n            }\n            else {\n                // matching attribute name by string\n                const value = element.getAttribute(namePattern);\n                // null means the attribute is not present\n                if (value === null) {\n                    return false;\n                }\n                // early exit if no value pattern is provided\n                if (!valuePattern) {\n                    return true;\n                }\n                return valueRegex ? valueRegex.test(value) : value === valuePattern;\n            }\n        }\n        else if (selector.name === 'matches-css') {\n            return selector.argument !== undefined && matchCSSProperty(element, selector.argument);\n        }\n        else if (selector.name === 'matches-css-after') {\n            return (selector.argument !== undefined && matchCSSProperty(element, selector.argument, '::after'));\n        }\n        else if (selector.name === 'matches-css-before') {\n            return (selector.argument !== undefined && matchCSSProperty(element, selector.argument, '::before'));\n        }\n    }\n    return false;\n}\n/**\n * Describes CSS combinator behaviors from the given element.\n * @param element The current subjective element.\n * @param selector A complex selector.\n */\nfunction handleComplexSelector(element, selector) {\n    // The *left* part of the given selector is not queried by the previous step.\n    // If there's no *left* part, we fallback to the current element.\n    const leftElements = selector.left === undefined ? [element] : querySelectorAll(element, selector.left);\n    // The *right* part of the given selector is always *singular*.\n    // The understanding of `compound` selector behavior differs by `match` and `querySelectorAll`.\n    // The `compound` handler in `querySelectorAll` assume the subjective to be queried.\n    // However, our *actual* subjective elements are coming from *left* part of the selector.\n    // Therefore, we unmarshal the `compound` selector and directly use `traversal` which will involve `compound` handling in `match`.\n    const selectors = selector.right.type === 'compound' ? selector.right.compound : [selector.right];\n    const results = new Set();\n    switch (selector.combinator) {\n        case ' ':\n            // Look for all children *in any depth* of the all `leftElements` and filter them by `traversal`.\n            for (const leftElement of leftElements) {\n                for (const child of leftElement.querySelectorAll('*')) {\n                    for (const result of traverse(child, selectors)) {\n                        results.add(result);\n                    }\n                }\n            }\n            break;\n        case '>':\n            // Look for all children of the all `leftElements` and filter them by `traversal`.\n            for (const leftElement of leftElements) {\n                for (const child of leftElement.children) {\n                    for (const result of traverse(child, selectors)) {\n                        results.add(result);\n                    }\n                }\n            }\n            break;\n        case '~':\n            // Look for all siblings of the all `leftElements` and filter them by `traversal`.\n            for (const leftElement of leftElements) {\n                let sibling = leftElement;\n                while ((sibling = sibling.nextElementSibling) !== null) {\n                    for (const result of traverse(sibling, selectors)) {\n                        results.add(result);\n                    }\n                }\n            }\n            break;\n        case '+':\n            // Look for a next sibiling of the all `leftElements` and filter them by `traversal`.\n            for (const leftElement of leftElements) {\n                if (leftElement.nextElementSibling === null) {\n                    continue;\n                }\n                for (const result of traverse(leftElement.nextElementSibling, selectors)) {\n                    results.add(result);\n                }\n            }\n            break;\n    }\n    return Array.from(results);\n}\n/**\n * Transposes the given element with a selector.\n * @param element The subjective element\n * @param selector A selector\n * @returns An array of elements or null if not a transpose operator.\n */\nfunction transpose(element, selector) {\n    if (selector.type === 'pseudo-class') {\n        if (selector.name === 'upward') {\n            if (selector.argument === undefined) {\n                return [];\n            }\n            const argument = stripsWrappingQuotes(selector.argument);\n            let parentElement = element;\n            let number = Number(argument);\n            if (Number.isInteger(number)) {\n                if (number <= 0 || number >= 256) {\n                    return [];\n                }\n                while ((parentElement = parentElement.parentElement) !== null) {\n                    if (--number === 0) {\n                        return [parentElement];\n                    }\n                }\n            }\n            else {\n                while ((parentElement = parentElement.parentElement) !== null) {\n                    if (parentElement.matches(argument)) {\n                        return [parentElement];\n                    }\n                }\n            }\n            return [];\n        }\n        else if (selector.name === 'xpath') {\n            if (selector.argument === undefined) {\n                return [];\n            }\n            return handleXPathSelector(element, selector.argument);\n        }\n    }\n    return null;\n}\n/**\n * Checks elements by traversing from the given element.\n * You need to decide the subjective element candidates manually.\n * It doesn't look for the children of the given element.\n * @param root The subjective element.\n * @param selectors The selector list to validate with.\n * @returns If the given element and all followed candidate fails, it returns an empty array.\n */\nfunction traverse(root, selectors) {\n    if (selectors.length === 0) {\n        return [];\n    }\n    const traversals = [{ element: root, index: 0 }];\n    const results = [];\n    while (traversals.length) {\n        const traversal = traversals.pop();\n        const { element } = traversal;\n        let { index } = traversal;\n        for (; index < selectors.length; index++) {\n            const candidates = transpose(element, selectors[index]);\n            const isTransposeOperator = candidates !== null;\n            if (isTransposeOperator) {\n                traversals.push(...candidates.map((element) => ({ element, index: index + 1 })));\n                break;\n            }\n            else if (matches(element, selectors[index]) === false) {\n                // no maches found - stop processing the branch\n                break;\n            }\n        }\n        // Check if the loop was completed\n        if (index === selectors.length && !results.includes(element)) {\n            results.push(element);\n        }\n    }\n    return results;\n}\nfunction querySelectorAll(element, selector) {\n    // Type of `attribute`, `class`, `id`, and `type` are to express simple selectors.\n    // e.g. `[attr]` is `attribute` type, `.cls` is `class` type, `#lure` is `id` type, and `div` is `type` type.\n    if (selector.type === 'id' ||\n        selector.type === 'class' ||\n        selector.type === 'type' ||\n        selector.type === 'attribute') {\n        return Array.from(element.querySelectorAll(selector.content));\n    }\n    // Type of `list` is sets of selector trees.\n    // We just join all the results.\n    // e.g. `p, span`\n    if (selector.type === 'list') {\n        const results = [];\n        for (const item of selector.list) {\n            for (const result of querySelectorAll(element, item)) {\n                if (!results.includes(result)) {\n                    results.push(result);\n                }\n            }\n        }\n        return results;\n    }\n    // Type of `compound` is a set of consecutive selectors.\n    // They're in chained form like `p:has(span)` and works as logical AND.\n    if (selector.type === 'compound') {\n        const results = [];\n        const [first, ...rest] = selector.compound;\n        for (const subjective of querySelectorAll(element, first)) {\n            for (const result of traverse(subjective, rest)) {\n                if (!results.includes(result)) {\n                    results.push(result);\n                }\n            }\n        }\n        return results;\n    }\n    // Type of `complex` is used to express CSS combinators: ` `, `>`, `+`, `~`.\n    // The `branch` function describes the behavior per combinator.\n    if (selector.type === 'complex') {\n        return handleComplexSelector(element, selector);\n    }\n    if (selector.type === 'pseudo-class') {\n        const results = [];\n        // This code is intended to be matched with `document.documentElement.querySelectorAll`.\n        // Since `document` is at the higher position rather `document.documentElement`,\n        // it can't select `html` for an instance.\n        for (const subjective of element.querySelectorAll('*')) {\n            for (const result of traverse(subjective, [selector])) {\n                if (!results.includes(result)) {\n                    results.push(result);\n                }\n            }\n        }\n        return results;\n    }\n    return [];\n}\n//# sourceMappingURL=eval.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci1leHRlbmRlZC1zZWxlY3RvcnMvZGlzdC9lc20vZXZhbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGNBQWMsUUFBUTtBQUN0QixlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsMkJBQTJCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci1leHRlbmRlZC1zZWxlY3RvcnMvZGlzdC9lc20vZXZhbC5qcz9hYTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQgR2hvc3RlcnkgR21iSC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuLyoqXG4gKiBFdmFsdWF0ZXMgYW4gWFBhdGggZXhwcmVzc2lvbiBhbmQgcmV0dXJucyBtYXRjaGluZyBFbGVtZW50IG5vZGVzLlxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgY29udGV4dCBlbGVtZW50IGZvciBYUGF0aCBldmFsdWF0aW9uXG4gKiBAcGFyYW0geHBhdGhFeHByZXNzaW9uIC0gVGhlIFhQYXRoIGV4cHJlc3Npb24gdG8gZXZhbHVhdGVcbiAqIEByZXR1cm5zIEFycmF5IG9mIEVsZW1lbnQgbm9kZXMgdGhhdCBtYXRjaCB0aGUgWFBhdGggZXhwcmVzc2lvblxuICovXG5mdW5jdGlvbiBoYW5kbGVYUGF0aFNlbGVjdG9yKGVsZW1lbnQsIHhwYXRoRXhwcmVzc2lvbikge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgTm9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIFhQYXRoUmVzdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyB1bnN1cHBvcnRlZCAobm90IHJ1bm5pbmcgaW4gdGhlIGJyb3dzZXIpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmV2YWx1YXRlKHhwYXRoRXhwcmVzc2lvbiwgZWxlbWVudCwgbnVsbCwgWFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUsIG51bGwpO1xuICAgICAgICBpZiAocmVzdWx0LnJlc3VsdFR5cGUgIT09IFhQYXRoUmVzdWx0Lk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQuc25hcHNob3RMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHJlc3VsdC5zbmFwc2hvdEl0ZW0oaSk7XG4gICAgICAgICAgICBpZiAoKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5ub2RlVHlwZSkgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUNTU1ZhbHVlKGNzc1ZhbHVlKSB7XG4gICAgY29uc3QgZmlyc3RDb2xvbkluZGV4ID0gY3NzVmFsdWUuaW5kZXhPZignOicpO1xuICAgIGlmIChmaXJzdENvbG9uSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBDU1MgdmFsdWUgZm9ybWF0OiBubyBjb2xvbiBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBwcm9wZXJ0eSA9IGNzc1ZhbHVlLnNsaWNlKDAsIGZpcnN0Q29sb25JbmRleCkudHJpbSgpO1xuICAgIGNvbnN0IHZhbHVlID0gY3NzVmFsdWUuc2xpY2UoZmlyc3RDb2xvbkluZGV4ICsgMSkudHJpbSgpO1xuICAgIGNvbnN0IGlzUmVnZXggPSB2YWx1ZS5zdGFydHNXaXRoKCcvJykgJiYgdmFsdWUubGFzdEluZGV4T2YoJy8nKSA+IDA7XG4gICAgcmV0dXJuIHsgcHJvcGVydHksIHZhbHVlLCBpc1JlZ2V4IH07XG59XG5mdW5jdGlvbiBtYXRjaENTU1Byb3BlcnR5KGVsZW1lbnQsIGNzc1ZhbHVlLCBwc2V1ZG9FbGVtZW50KSB7XG4gICAgY29uc3QgeyBwcm9wZXJ0eSwgdmFsdWUsIGlzUmVnZXggfSA9IHBhcnNlQ1NTVmFsdWUoY3NzVmFsdWUpO1xuICAgIGNvbnN0IHdpbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCAmJiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgaWYgKCF3aW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gd2luZG93IGNvbnRleHQgZm9yIGVsZW1lbnQnKTtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgcHNldWRvRWxlbWVudCk7XG4gICAgY29uc3QgYWN0dWFsVmFsdWUgPSBjb21wdXRlZFN0eWxlW3Byb3BlcnR5XTtcbiAgICBpZiAoaXNSZWdleCkge1xuICAgICAgICBjb25zdCByZWdleCA9IHBhcnNlUmVnZXgodmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVnZXgudGVzdChhY3R1YWxWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBhY3R1YWxWYWx1ZSA9PT0gdmFsdWU7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2V4KHN0cikge1xuICAgIGlmIChzdHIuc3RhcnRzV2l0aCgnLycpICYmIHN0ci5sYXN0SW5kZXhPZignLycpID4gMCkge1xuICAgICAgICBjb25zdCBsYXN0U2xhc2hJbmRleCA9IHN0ci5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gc3RyLnNsaWNlKDEsIGxhc3RTbGFzaEluZGV4KTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBzdHIuc2xpY2UobGFzdFNsYXNoSW5kZXggKyAxKTtcbiAgICAgICAgaWYgKCEvXltnaW1zdXlkXSokLy50ZXN0KGZsYWdzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlZ2V4IGZsYWdzOiAke2ZsYWdzfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHN0cik7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyaXBzV3JhcHBpbmdRdW90ZXMoc3RyKSB7XG4gICAgaWYgKChzdHIuc3RhcnRzV2l0aCgnXCInKSAmJiBzdHIuZW5kc1dpdGgoJ1wiJykpIHx8IChzdHIuc3RhcnRzV2l0aChcIidcIikgJiYgc3RyLmVuZHNXaXRoKFwiJ1wiKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5zbGljZSgxLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hQYXR0ZXJuKHBhdHRlcm4sIHRleHQpIHtcbiAgICBwYXR0ZXJuID0gc3RyaXBzV3JhcHBpbmdRdW90ZXMocGF0dGVybik7XG4gICAgLy8gVE9ETyAtIHN1cHBvcnQgJ20nIFJlZ0V4cCBhcmd1bWVudFxuICAgIGlmIChwYXR0ZXJuLnN0YXJ0c1dpdGgoJy8nKSAmJiAocGF0dGVybi5lbmRzV2l0aCgnLycpIHx8IHBhdHRlcm4uZW5kc1dpdGgoJy9pJykpKSB7XG4gICAgICAgIGxldCBjYXNlU2Vuc2l0aXZlID0gdHJ1ZTtcbiAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSk7XG4gICAgICAgIGlmIChwYXR0ZXJuLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKDAsIC0yKTtcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBjYXNlU2Vuc2l0aXZlID09PSBmYWxzZSA/ICdpJyA6IHVuZGVmaW5lZCkudGVzdCh0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQuaW5jbHVkZXMocGF0dGVybik7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBjb21wbGllcyB3aXRoIHRoZSBnaXZlbiBzZWxlY3Rvci5cbiAqIEBwYXJhbSBlbGVtZW50IFRoZSBzdWJqZWN0aXZlIGVsZW1lbnQuXG4gKiBAcGFyYW0gc2VsZWN0b3IgVGhlIHNlbGVjdG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hlcyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIHZhciBfYTtcbiAgICBpZiAoc2VsZWN0b3IudHlwZSA9PT0gJ2lkJyB8fFxuICAgICAgICBzZWxlY3Rvci50eXBlID09PSAnY2xhc3MnIHx8XG4gICAgICAgIHNlbGVjdG9yLnR5cGUgPT09ICd0eXBlJyB8fFxuICAgICAgICBzZWxlY3Rvci50eXBlID09PSAnYXR0cmlidXRlJykge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yLmNvbnRlbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWxlY3Rvci50eXBlID09PSAnbGlzdCcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLmxpc3Quc29tZSgocykgPT4gbWF0Y2hlcyhlbGVtZW50LCBzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbGVjdG9yLnR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgICAgLy8gQ29tcG91bmQgc2VsZWN0b3JzIGNvbnRhaW4gb25seSBzaW1wbGUgc2VsZWN0b3JzIChpZCwgY2xhc3MsIHR5cGUsIGF0dHJpYnV0ZSwgcHNldWRvLWNsYXNzKVxuICAgICAgICAvLyB0aGF0IG11c3QgYWxsIG1hdGNoIHRoZSBzYW1lIGVsZW1lbnQuIENvbXBsZXggc2VsZWN0b3JzICh3aXRoIGNvbWJpbmF0b3JzIGxpa2UgPiwgKywgfilcbiAgICAgICAgLy8gYXJlIHByb2Nlc3NlZCBhdCBhIGhpZ2hlciBsZXZlbCBieSB0aGUgcGFyc2VyLCBzbyB0aGV5IGNhbiBuZXZlciBiZSBjaGlsZHJlbiBvZiBjb21wb3VuZCBzZWxlY3RvcnMuXG4gICAgICAgIHJldHVybiBzZWxlY3Rvci5jb21wb3VuZC5ldmVyeSgocykgPT4gbWF0Y2hlcyhlbGVtZW50LCBzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbGVjdG9yLnR5cGUgPT09ICdwc2V1ZG8tY2xhc3MnKSB7XG4gICAgICAgIGlmIChzZWxlY3Rvci5uYW1lID09PSAnaGFzJykge1xuICAgICAgICAgICAgLy8gVGhlIHN1YmplY3RpdmUgZWxlbWVudCBvZiBgOmhhc2AgY2hlY2sgbWF5IGJlIHRoZSBnaXZlbiBlbGVtZW50IG9yIGl0cyBjaGlsZHJlbjpcbiAgICAgICAgICAgIC8vIC0gZS5nLiBgaHRtbDpoYXMoYm9keSlgLCBgYm9keWAgaXMgdGhlIGV4cGVjdGVkIHN1YmplY3RpdmUgdG8gYmUgZmlsdGVyZWQgYnkgYHRyYXZlcnNlYC5cbiAgICAgICAgICAgIC8vIC0gZS5nLiBgaHRtbDpoYXMoPmJvZHkpYCwgYGh0bWxgIGlzIHRoZSBzdWJqZWN0aXZlIGVsZW1lbnQgdG8gYmUgZmlsdGVyZWQgYnkgYGJyYW5jaGAgdGhlbiBgdHJhdmVyc2VgLlxuICAgICAgICAgICAgLy8gYHF1ZXJ5U2VsZWN0b3JBbGxgIGFscmVhZHkgZGVzY3JpYmVzIHRoZSBhbGwuXG4gICAgICAgICAgICByZXR1cm4gKHNlbGVjdG9yLnN1YnRyZWUgIT09IHVuZGVmaW5lZCAmJiBxdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnQsIHNlbGVjdG9yLnN1YnRyZWUpLmxlbmd0aCAhPT0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0b3IubmFtZSA9PT0gJ25vdCcpIHtcbiAgICAgICAgICAgIC8vIFVubGlrZSBgOmhhc2AsIGA6bm90YCBhc3N1bWVzIHRoZSBzdWJ0cmVlIHRvIGJlIHRoZSBjb25kaXRpb24gZm9yIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnN1YnRyZWUgIT09IHVuZGVmaW5lZCAmJiB0cmF2ZXJzZShlbGVtZW50LCBbc2VsZWN0b3Iuc3VidHJlZV0pLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWxlY3Rvci5uYW1lID09PSAnaGFzLXRleHQnKSB7XG4gICAgICAgICAgICBjb25zdCB7IGFyZ3VtZW50IH0gPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICBpZiAodGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaFBhdHRlcm4oYXJndW1lbnQsIHRleHQudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWxlY3Rvci5uYW1lID09PSAnbWluLXRleHQtbGVuZ3RoJykge1xuICAgICAgICAgICAgY29uc3QgbWluTGVuZ3RoID0gTnVtYmVyKHNlbGVjdG9yLmFyZ3VtZW50KTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4obWluTGVuZ3RoKSB8fCBtaW5MZW5ndGggPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICBpZiAodGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aCA+PSBtaW5MZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0b3IubmFtZSA9PT0gJ21hdGNoZXMtcGF0aCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXJndW1lbnQgfSA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3aW5kb3cgPSAoX2EgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0VmlldztcbiAgICAgICAgICAgIGlmICghd2luZG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IGJvdGggcGF0aG5hbWUgYW5kIHNlYXJjaCAocXVlcnkgcGFyYW1ldGVycylcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICAgICAgICBjb25zdCBzZWFyY2ggPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xuICAgICAgICAgICAgY29uc3QgZnVsbFVybCA9IHBhdGggKyBzZWFyY2g7XG4gICAgICAgICAgICBjb25zdCByZWdleCA9IHBhcnNlUmVnZXgoYXJndW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QoZnVsbFVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0b3IubmFtZSA9PT0gJ21hdGNoZXMtYXR0cicpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXJndW1lbnQgfSA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmRleE9mRXF1YWwgPSBhcmd1bWVudC5pbmRleE9mKCc9Jyk7XG4gICAgICAgICAgICBsZXQgbmFtZVBhdHRlcm47XG4gICAgICAgICAgICBsZXQgdmFsdWVQYXR0ZXJuO1xuICAgICAgICAgICAgaWYgKGluZGV4T2ZFcXVhbCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuYW1lUGF0dGVybiA9IGFyZ3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmFtZVBhdHRlcm4gPSBhcmd1bWVudC5zbGljZSgwLCBpbmRleE9mRXF1YWwpO1xuICAgICAgICAgICAgICAgIHZhbHVlUGF0dGVybiA9IGFyZ3VtZW50LnNsaWNlKGluZGV4T2ZFcXVhbCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZVBhdHRlcm4gPSBzdHJpcHNXcmFwcGluZ1F1b3RlcyhuYW1lUGF0dGVybik7XG4gICAgICAgICAgICB2YWx1ZVBhdHRlcm4gPSB2YWx1ZVBhdHRlcm4gPyBzdHJpcHNXcmFwcGluZ1F1b3Rlcyh2YWx1ZVBhdHRlcm4pIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IHZhbHVlUmVnZXggPSBudWxsO1xuICAgICAgICAgICAgaWYgKCh2YWx1ZVBhdHRlcm4gPT09IG51bGwgfHwgdmFsdWVQYXR0ZXJuID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZVBhdHRlcm4uc3RhcnRzV2l0aCgnLycpKSAmJiB2YWx1ZVBhdHRlcm4ubGFzdEluZGV4T2YoJy8nKSA+IDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVJlZ2V4ID0gcGFyc2VSZWdleCh2YWx1ZVBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWVQYXR0ZXJuLnN0YXJ0c1dpdGgoJy8nKSAmJiBuYW1lUGF0dGVybi5sYXN0SW5kZXhPZignLycpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIG1hdGNoaW5nIGF0dHJpYnV0ZSBuYW1lIGJ5IHJlZ2V4XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBwYXJzZVJlZ2V4KG5hbWVQYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZ0F0dHJzID0gWy4uLmVsZW1lbnQuYXR0cmlidXRlc10uZmlsdGVyKChhdHRyKSA9PiByZWdleC50ZXN0KGF0dHIubmFtZSkpO1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIHZhbHVlIHBhdHRlcm4sIHJldHVybiB0cnVlIGlmIGFueSBhdHRyaWJ1dGUgbWF0Y2hlcyB0aGUgbmFtZSBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZVBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nQXR0cnMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW55IG9mIHRoZSBtYXRjaGluZyBhdHRyaWJ1dGVzIGhhdmUgdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ0F0dHJzLnNvbWUoKGF0dHIpID0+IHZhbHVlUmVnZXggPyB2YWx1ZVJlZ2V4LnRlc3QoYXR0ci52YWx1ZSkgOiBhdHRyLnZhbHVlID09PSB2YWx1ZVBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYXR0cmlidXRlIG5hbWUgYnkgc3RyaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lUGF0dGVybik7XG4gICAgICAgICAgICAgICAgLy8gbnVsbCBtZWFucyB0aGUgYXR0cmlidXRlIGlzIG5vdCBwcmVzZW50XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZWFybHkgZXhpdCBpZiBubyB2YWx1ZSBwYXR0ZXJuIGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZVBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVJlZ2V4ID8gdmFsdWVSZWdleC50ZXN0KHZhbHVlKSA6IHZhbHVlID09PSB2YWx1ZVBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0b3IubmFtZSA9PT0gJ21hdGNoZXMtY3NzJykge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yLmFyZ3VtZW50ICE9PSB1bmRlZmluZWQgJiYgbWF0Y2hDU1NQcm9wZXJ0eShlbGVtZW50LCBzZWxlY3Rvci5hcmd1bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0b3IubmFtZSA9PT0gJ21hdGNoZXMtY3NzLWFmdGVyJykge1xuICAgICAgICAgICAgcmV0dXJuIChzZWxlY3Rvci5hcmd1bWVudCAhPT0gdW5kZWZpbmVkICYmIG1hdGNoQ1NTUHJvcGVydHkoZWxlbWVudCwgc2VsZWN0b3IuYXJndW1lbnQsICc6OmFmdGVyJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdG9yLm5hbWUgPT09ICdtYXRjaGVzLWNzcy1iZWZvcmUnKSB7XG4gICAgICAgICAgICByZXR1cm4gKHNlbGVjdG9yLmFyZ3VtZW50ICE9PSB1bmRlZmluZWQgJiYgbWF0Y2hDU1NQcm9wZXJ0eShlbGVtZW50LCBzZWxlY3Rvci5hcmd1bWVudCwgJzo6YmVmb3JlJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogRGVzY3JpYmVzIENTUyBjb21iaW5hdG9yIGJlaGF2aW9ycyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICogQHBhcmFtIGVsZW1lbnQgVGhlIGN1cnJlbnQgc3ViamVjdGl2ZSBlbGVtZW50LlxuICogQHBhcmFtIHNlbGVjdG9yIEEgY29tcGxleCBzZWxlY3Rvci5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlQ29tcGxleFNlbGVjdG9yKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgLy8gVGhlICpsZWZ0KiBwYXJ0IG9mIHRoZSBnaXZlbiBzZWxlY3RvciBpcyBub3QgcXVlcmllZCBieSB0aGUgcHJldmlvdXMgc3RlcC5cbiAgICAvLyBJZiB0aGVyZSdzIG5vICpsZWZ0KiBwYXJ0LCB3ZSBmYWxsYmFjayB0byB0aGUgY3VycmVudCBlbGVtZW50LlxuICAgIGNvbnN0IGxlZnRFbGVtZW50cyA9IHNlbGVjdG9yLmxlZnQgPT09IHVuZGVmaW5lZCA/IFtlbGVtZW50XSA6IHF1ZXJ5U2VsZWN0b3JBbGwoZWxlbWVudCwgc2VsZWN0b3IubGVmdCk7XG4gICAgLy8gVGhlICpyaWdodCogcGFydCBvZiB0aGUgZ2l2ZW4gc2VsZWN0b3IgaXMgYWx3YXlzICpzaW5ndWxhciouXG4gICAgLy8gVGhlIHVuZGVyc3RhbmRpbmcgb2YgYGNvbXBvdW5kYCBzZWxlY3RvciBiZWhhdmlvciBkaWZmZXJzIGJ5IGBtYXRjaGAgYW5kIGBxdWVyeVNlbGVjdG9yQWxsYC5cbiAgICAvLyBUaGUgYGNvbXBvdW5kYCBoYW5kbGVyIGluIGBxdWVyeVNlbGVjdG9yQWxsYCBhc3N1bWUgdGhlIHN1YmplY3RpdmUgdG8gYmUgcXVlcmllZC5cbiAgICAvLyBIb3dldmVyLCBvdXIgKmFjdHVhbCogc3ViamVjdGl2ZSBlbGVtZW50cyBhcmUgY29taW5nIGZyb20gKmxlZnQqIHBhcnQgb2YgdGhlIHNlbGVjdG9yLlxuICAgIC8vIFRoZXJlZm9yZSwgd2UgdW5tYXJzaGFsIHRoZSBgY29tcG91bmRgIHNlbGVjdG9yIGFuZCBkaXJlY3RseSB1c2UgYHRyYXZlcnNhbGAgd2hpY2ggd2lsbCBpbnZvbHZlIGBjb21wb3VuZGAgaGFuZGxpbmcgaW4gYG1hdGNoYC5cbiAgICBjb25zdCBzZWxlY3RvcnMgPSBzZWxlY3Rvci5yaWdodC50eXBlID09PSAnY29tcG91bmQnID8gc2VsZWN0b3IucmlnaHQuY29tcG91bmQgOiBbc2VsZWN0b3IucmlnaHRdO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgU2V0KCk7XG4gICAgc3dpdGNoIChzZWxlY3Rvci5jb21iaW5hdG9yKSB7XG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgLy8gTG9vayBmb3IgYWxsIGNoaWxkcmVuICppbiBhbnkgZGVwdGgqIG9mIHRoZSBhbGwgYGxlZnRFbGVtZW50c2AgYW5kIGZpbHRlciB0aGVtIGJ5IGB0cmF2ZXJzYWxgLlxuICAgICAgICAgICAgZm9yIChjb25zdCBsZWZ0RWxlbWVudCBvZiBsZWZ0RWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGxlZnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiB0cmF2ZXJzZShjaGlsZCwgc2VsZWN0b3JzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5hZGQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIGFsbCBjaGlsZHJlbiBvZiB0aGUgYWxsIGBsZWZ0RWxlbWVudHNgIGFuZCBmaWx0ZXIgdGhlbSBieSBgdHJhdmVyc2FsYC5cbiAgICAgICAgICAgIGZvciAoY29uc3QgbGVmdEVsZW1lbnQgb2YgbGVmdEVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBsZWZ0RWxlbWVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiB0cmF2ZXJzZShjaGlsZCwgc2VsZWN0b3JzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5hZGQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd+JzpcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIGFsbCBzaWJsaW5ncyBvZiB0aGUgYWxsIGBsZWZ0RWxlbWVudHNgIGFuZCBmaWx0ZXIgdGhlbSBieSBgdHJhdmVyc2FsYC5cbiAgICAgICAgICAgIGZvciAoY29uc3QgbGVmdEVsZW1lbnQgb2YgbGVmdEVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNpYmxpbmcgPSBsZWZ0RWxlbWVudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHNpYmxpbmcgPSBzaWJsaW5nLm5leHRFbGVtZW50U2libGluZykgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgdHJhdmVyc2Uoc2libGluZywgc2VsZWN0b3JzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5hZGQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIGEgbmV4dCBzaWJpbGluZyBvZiB0aGUgYWxsIGBsZWZ0RWxlbWVudHNgIGFuZCBmaWx0ZXIgdGhlbSBieSBgdHJhdmVyc2FsYC5cbiAgICAgICAgICAgIGZvciAoY29uc3QgbGVmdEVsZW1lbnQgb2YgbGVmdEVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRFbGVtZW50Lm5leHRFbGVtZW50U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgdHJhdmVyc2UobGVmdEVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nLCBzZWxlY3RvcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuYWRkKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKHJlc3VsdHMpO1xufVxuLyoqXG4gKiBUcmFuc3Bvc2VzIHRoZSBnaXZlbiBlbGVtZW50IHdpdGggYSBzZWxlY3Rvci5cbiAqIEBwYXJhbSBlbGVtZW50IFRoZSBzdWJqZWN0aXZlIGVsZW1lbnRcbiAqIEBwYXJhbSBzZWxlY3RvciBBIHNlbGVjdG9yXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBlbGVtZW50cyBvciBudWxsIGlmIG5vdCBhIHRyYW5zcG9zZSBvcGVyYXRvci5cbiAqL1xuZnVuY3Rpb24gdHJhbnNwb3NlKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09ICdwc2V1ZG8tY2xhc3MnKSB7XG4gICAgICAgIGlmIChzZWxlY3Rvci5uYW1lID09PSAndXB3YXJkJykge1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yLmFyZ3VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudCA9IHN0cmlwc1dyYXBwaW5nUXVvdGVzKHNlbGVjdG9yLmFyZ3VtZW50KTtcbiAgICAgICAgICAgIGxldCBwYXJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgIGxldCBudW1iZXIgPSBOdW1iZXIoYXJndW1lbnQpO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIGlmIChudW1iZXIgPD0gMCB8fCBudW1iZXIgPj0gMjU2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKChwYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50KSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoLS1udW1iZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbcGFyZW50RWxlbWVudF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHBhcmVudEVsZW1lbnQgPSBwYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRFbGVtZW50Lm1hdGNoZXMoYXJndW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3BhcmVudEVsZW1lbnRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdG9yLm5hbWUgPT09ICd4cGF0aCcpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rvci5hcmd1bWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVhQYXRoU2VsZWN0b3IoZWxlbWVudCwgc2VsZWN0b3IuYXJndW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBDaGVja3MgZWxlbWVudHMgYnkgdHJhdmVyc2luZyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICogWW91IG5lZWQgdG8gZGVjaWRlIHRoZSBzdWJqZWN0aXZlIGVsZW1lbnQgY2FuZGlkYXRlcyBtYW51YWxseS5cbiAqIEl0IGRvZXNuJ3QgbG9vayBmb3IgdGhlIGNoaWxkcmVuIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICogQHBhcmFtIHJvb3QgVGhlIHN1YmplY3RpdmUgZWxlbWVudC5cbiAqIEBwYXJhbSBzZWxlY3RvcnMgVGhlIHNlbGVjdG9yIGxpc3QgdG8gdmFsaWRhdGUgd2l0aC5cbiAqIEByZXR1cm5zIElmIHRoZSBnaXZlbiBlbGVtZW50IGFuZCBhbGwgZm9sbG93ZWQgY2FuZGlkYXRlIGZhaWxzLCBpdCByZXR1cm5zIGFuIGVtcHR5IGFycmF5LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZShyb290LCBzZWxlY3RvcnMpIHtcbiAgICBpZiAoc2VsZWN0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHRyYXZlcnNhbHMgPSBbeyBlbGVtZW50OiByb290LCBpbmRleDogMCB9XTtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgd2hpbGUgKHRyYXZlcnNhbHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHRyYXZlcnNhbCA9IHRyYXZlcnNhbHMucG9wKCk7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gdHJhdmVyc2FsO1xuICAgICAgICBsZXQgeyBpbmRleCB9ID0gdHJhdmVyc2FsO1xuICAgICAgICBmb3IgKDsgaW5kZXggPCBzZWxlY3RvcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gdHJhbnNwb3NlKGVsZW1lbnQsIHNlbGVjdG9yc1tpbmRleF0pO1xuICAgICAgICAgICAgY29uc3QgaXNUcmFuc3Bvc2VPcGVyYXRvciA9IGNhbmRpZGF0ZXMgIT09IG51bGw7XG4gICAgICAgICAgICBpZiAoaXNUcmFuc3Bvc2VPcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIHRyYXZlcnNhbHMucHVzaCguLi5jYW5kaWRhdGVzLm1hcCgoZWxlbWVudCkgPT4gKHsgZWxlbWVudCwgaW5kZXg6IGluZGV4ICsgMSB9KSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcnNbaW5kZXhdKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBubyBtYWNoZXMgZm91bmQgLSBzdG9wIHByb2Nlc3NpbmcgdGhlIGJyYW5jaFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBsb29wIHdhcyBjb21wbGV0ZWRcbiAgICAgICAgaWYgKGluZGV4ID09PSBzZWxlY3RvcnMubGVuZ3RoICYmICFyZXN1bHRzLmluY2x1ZGVzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5leHBvcnQgZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIC8vIFR5cGUgb2YgYGF0dHJpYnV0ZWAsIGBjbGFzc2AsIGBpZGAsIGFuZCBgdHlwZWAgYXJlIHRvIGV4cHJlc3Mgc2ltcGxlIHNlbGVjdG9ycy5cbiAgICAvLyBlLmcuIGBbYXR0cl1gIGlzIGBhdHRyaWJ1dGVgIHR5cGUsIGAuY2xzYCBpcyBgY2xhc3NgIHR5cGUsIGAjbHVyZWAgaXMgYGlkYCB0eXBlLCBhbmQgYGRpdmAgaXMgYHR5cGVgIHR5cGUuXG4gICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09ICdpZCcgfHxcbiAgICAgICAgc2VsZWN0b3IudHlwZSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICBzZWxlY3Rvci50eXBlID09PSAndHlwZScgfHxcbiAgICAgICAgc2VsZWN0b3IudHlwZSA9PT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLmNvbnRlbnQpKTtcbiAgICB9XG4gICAgLy8gVHlwZSBvZiBgbGlzdGAgaXMgc2V0cyBvZiBzZWxlY3RvciB0cmVlcy5cbiAgICAvLyBXZSBqdXN0IGpvaW4gYWxsIHRoZSByZXN1bHRzLlxuICAgIC8vIGUuZy4gYHAsIHNwYW5gXG4gICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBzZWxlY3Rvci5saXN0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiBxdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnQsIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRzLmluY2x1ZGVzKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICAvLyBUeXBlIG9mIGBjb21wb3VuZGAgaXMgYSBzZXQgb2YgY29uc2VjdXRpdmUgc2VsZWN0b3JzLlxuICAgIC8vIFRoZXkncmUgaW4gY2hhaW5lZCBmb3JtIGxpa2UgYHA6aGFzKHNwYW4pYCBhbmQgd29ya3MgYXMgbG9naWNhbCBBTkQuXG4gICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBjb25zdCBbZmlyc3QsIC4uLnJlc3RdID0gc2VsZWN0b3IuY29tcG91bmQ7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViamVjdGl2ZSBvZiBxdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnQsIGZpcnN0KSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgdHJhdmVyc2Uoc3ViamVjdGl2ZSwgcmVzdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdHMuaW5jbHVkZXMocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIC8vIFR5cGUgb2YgYGNvbXBsZXhgIGlzIHVzZWQgdG8gZXhwcmVzcyBDU1MgY29tYmluYXRvcnM6IGAgYCwgYD5gLCBgK2AsIGB+YC5cbiAgICAvLyBUaGUgYGJyYW5jaGAgZnVuY3Rpb24gZGVzY3JpYmVzIHRoZSBiZWhhdmlvciBwZXIgY29tYmluYXRvci5cbiAgICBpZiAoc2VsZWN0b3IudHlwZSA9PT0gJ2NvbXBsZXgnKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVDb21wbGV4U2VsZWN0b3IoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH1cbiAgICBpZiAoc2VsZWN0b3IudHlwZSA9PT0gJ3BzZXVkby1jbGFzcycpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICAvLyBUaGlzIGNvZGUgaXMgaW50ZW5kZWQgdG8gYmUgbWF0Y2hlZCB3aXRoIGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbGAuXG4gICAgICAgIC8vIFNpbmNlIGBkb2N1bWVudGAgaXMgYXQgdGhlIGhpZ2hlciBwb3NpdGlvbiByYXRoZXIgYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudGAsXG4gICAgICAgIC8vIGl0IGNhbid0IHNlbGVjdCBgaHRtbGAgZm9yIGFuIGluc3RhbmNlLlxuICAgICAgICBmb3IgKGNvbnN0IHN1YmplY3RpdmUgb2YgZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHRyYXZlcnNlKHN1YmplY3RpdmUsIFtzZWxlY3Rvcl0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRzLmluY2x1ZGVzKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmFsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/eval.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/extended.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/extended.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXTENDED_PSEUDO_CLASSES: () => (/* binding */ EXTENDED_PSEUDO_CLASSES),\n/* harmony export */   PSEUDO_CLASSES: () => (/* binding */ PSEUDO_CLASSES),\n/* harmony export */   PSEUDO_ELEMENTS: () => (/* binding */ PSEUDO_ELEMENTS),\n/* harmony export */   SelectorType: () => (/* binding */ SelectorType),\n/* harmony export */   classifySelector: () => (/* binding */ classifySelector)\n/* harmony export */ });\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/parse.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\nconst EXTENDED_PSEUDO_CLASSES = new Set([\n    // '-abp-contains',\n    // '-abp-has',\n    // '-abp-properties',\n    'has-text',\n    'matches-path',\n    'matches-attr',\n    'matches-css',\n    'matches-css-after',\n    'matches-css-before',\n    'upward',\n    'xpath',\n    // 'if',\n    // 'if-not',\n    // 'min-text-length',\n    // 'nth-ancestor',\n    // 'watch-attr',\n    // 'watch-attrs',\n]);\nconst PSEUDO_CLASSES = new Set([\n    'active',\n    'any',\n    'any-link',\n    'blank',\n    'checked',\n    'default',\n    'defined',\n    'dir',\n    'disabled',\n    'empty',\n    'enabled',\n    'first',\n    'first-child',\n    'first-of-type',\n    'focus',\n    'focus-visible',\n    'focus-within',\n    'fullscreen',\n    'has',\n    'host',\n    'host-context',\n    'hover',\n    'in-range',\n    'indeterminate',\n    'invalid',\n    'is',\n    'lang',\n    'last-child',\n    'last-of-type',\n    'left',\n    'link',\n    'matches',\n    // NOTE: by default we consider `:not(...)` to be a normal CSS selector since,\n    // we are only interested in cases where the argument is an extended selector.\n    // If that is the case, it will still be detected as such.\n    'not',\n    'nth-child',\n    'nth-last-child',\n    'nth-last-of-type',\n    'nth-of-type',\n    'only-child',\n    'only-of-type',\n    'optional',\n    'out-of-range',\n    'placeholder-shown',\n    'read-only',\n    'read-write',\n    'required',\n    'right',\n    'root',\n    'scope',\n    'target',\n    'valid',\n    'visited',\n    'where',\n]);\n// NOTE: here we only need to list the pseudo-elements which can appear with a\n// single colon (e.g. :after or ::after are valid for backward compatibility\n// reasons). They can be misinterpreted as pseudo-classes by the tokenizer for\n// this reason.\nconst PSEUDO_ELEMENTS = new Set(['after', 'before', 'first-letter', 'first-line']);\nvar SelectorType;\n(function (SelectorType) {\n    SelectorType[SelectorType[\"Normal\"] = 0] = \"Normal\";\n    SelectorType[SelectorType[\"Extended\"] = 1] = \"Extended\";\n    SelectorType[SelectorType[\"Invalid\"] = 2] = \"Invalid\";\n})(SelectorType || (SelectorType = {}));\nfunction classifySelector(selector) {\n    // In most cases there is no pseudo-anything so we can quickly exit.\n    if (selector.indexOf(':') === -1) {\n        return SelectorType.Normal;\n    }\n    const tokens = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__.tokenize)(selector);\n    // Detect pseudo-classes\n    let foundSupportedExtendedSelector = false;\n    for (const token of tokens) {\n        if (token.type === 'pseudo-class') {\n            const { name } = token;\n            if (EXTENDED_PSEUDO_CLASSES.has(name) === true) {\n                foundSupportedExtendedSelector = true;\n            }\n            else if (PSEUDO_CLASSES.has(name) === false && PSEUDO_ELEMENTS.has(name) === false) {\n                return SelectorType.Invalid;\n            }\n            // Check for nested :has selectors (which are not supported by standard CSS)\n            if (name === 'has' &&\n                token.argument !== undefined &&\n                token.argument.indexOf(':has(') !== -1) {\n                foundSupportedExtendedSelector = true;\n            }\n            // Recursively\n            if (foundSupportedExtendedSelector === false &&\n                token.argument !== undefined &&\n                _parse_js__WEBPACK_IMPORTED_MODULE_0__.RECURSIVE_PSEUDO_CLASSES.has(name) === true) {\n                const argumentType = classifySelector(token.argument);\n                if (argumentType === SelectorType.Invalid) {\n                    return argumentType;\n                }\n                else if (argumentType === SelectorType.Extended) {\n                    foundSupportedExtendedSelector = true;\n                }\n            }\n        }\n    }\n    if (foundSupportedExtendedSelector === true) {\n        return SelectorType.Extended;\n    }\n    return SelectorType.Normal;\n}\n//# sourceMappingURL=extended.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci1leHRlbmRlZC1zZWxlY3RvcnMvZGlzdC9lc20vZXh0ZW5kZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZ0U7QUFDekQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQzlCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbURBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci1leHRlbmRlZC1zZWxlY3RvcnMvZGlzdC9lc20vZXh0ZW5kZWQuanM/ZDRjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50IEdob3N0ZXJ5IEdtYkguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmltcG9ydCB7IHRva2VuaXplLCBSRUNVUlNJVkVfUFNFVURPX0NMQVNTRVMgfSBmcm9tICcuL3BhcnNlLmpzJztcbmV4cG9ydCBjb25zdCBFWFRFTkRFRF9QU0VVRE9fQ0xBU1NFUyA9IG5ldyBTZXQoW1xuICAgIC8vICctYWJwLWNvbnRhaW5zJyxcbiAgICAvLyAnLWFicC1oYXMnLFxuICAgIC8vICctYWJwLXByb3BlcnRpZXMnLFxuICAgICdoYXMtdGV4dCcsXG4gICAgJ21hdGNoZXMtcGF0aCcsXG4gICAgJ21hdGNoZXMtYXR0cicsXG4gICAgJ21hdGNoZXMtY3NzJyxcbiAgICAnbWF0Y2hlcy1jc3MtYWZ0ZXInLFxuICAgICdtYXRjaGVzLWNzcy1iZWZvcmUnLFxuICAgICd1cHdhcmQnLFxuICAgICd4cGF0aCcsXG4gICAgLy8gJ2lmJyxcbiAgICAvLyAnaWYtbm90JyxcbiAgICAvLyAnbWluLXRleHQtbGVuZ3RoJyxcbiAgICAvLyAnbnRoLWFuY2VzdG9yJyxcbiAgICAvLyAnd2F0Y2gtYXR0cicsXG4gICAgLy8gJ3dhdGNoLWF0dHJzJyxcbl0pO1xuZXhwb3J0IGNvbnN0IFBTRVVET19DTEFTU0VTID0gbmV3IFNldChbXG4gICAgJ2FjdGl2ZScsXG4gICAgJ2FueScsXG4gICAgJ2FueS1saW5rJyxcbiAgICAnYmxhbmsnLFxuICAgICdjaGVja2VkJyxcbiAgICAnZGVmYXVsdCcsXG4gICAgJ2RlZmluZWQnLFxuICAgICdkaXInLFxuICAgICdkaXNhYmxlZCcsXG4gICAgJ2VtcHR5JyxcbiAgICAnZW5hYmxlZCcsXG4gICAgJ2ZpcnN0JyxcbiAgICAnZmlyc3QtY2hpbGQnLFxuICAgICdmaXJzdC1vZi10eXBlJyxcbiAgICAnZm9jdXMnLFxuICAgICdmb2N1cy12aXNpYmxlJyxcbiAgICAnZm9jdXMtd2l0aGluJyxcbiAgICAnZnVsbHNjcmVlbicsXG4gICAgJ2hhcycsXG4gICAgJ2hvc3QnLFxuICAgICdob3N0LWNvbnRleHQnLFxuICAgICdob3ZlcicsXG4gICAgJ2luLXJhbmdlJyxcbiAgICAnaW5kZXRlcm1pbmF0ZScsXG4gICAgJ2ludmFsaWQnLFxuICAgICdpcycsXG4gICAgJ2xhbmcnLFxuICAgICdsYXN0LWNoaWxkJyxcbiAgICAnbGFzdC1vZi10eXBlJyxcbiAgICAnbGVmdCcsXG4gICAgJ2xpbmsnLFxuICAgICdtYXRjaGVzJyxcbiAgICAvLyBOT1RFOiBieSBkZWZhdWx0IHdlIGNvbnNpZGVyIGA6bm90KC4uLilgIHRvIGJlIGEgbm9ybWFsIENTUyBzZWxlY3RvciBzaW5jZSxcbiAgICAvLyB3ZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIGNhc2VzIHdoZXJlIHRoZSBhcmd1bWVudCBpcyBhbiBleHRlbmRlZCBzZWxlY3Rvci5cbiAgICAvLyBJZiB0aGF0IGlzIHRoZSBjYXNlLCBpdCB3aWxsIHN0aWxsIGJlIGRldGVjdGVkIGFzIHN1Y2guXG4gICAgJ25vdCcsXG4gICAgJ250aC1jaGlsZCcsXG4gICAgJ250aC1sYXN0LWNoaWxkJyxcbiAgICAnbnRoLWxhc3Qtb2YtdHlwZScsXG4gICAgJ250aC1vZi10eXBlJyxcbiAgICAnb25seS1jaGlsZCcsXG4gICAgJ29ubHktb2YtdHlwZScsXG4gICAgJ29wdGlvbmFsJyxcbiAgICAnb3V0LW9mLXJhbmdlJyxcbiAgICAncGxhY2Vob2xkZXItc2hvd24nLFxuICAgICdyZWFkLW9ubHknLFxuICAgICdyZWFkLXdyaXRlJyxcbiAgICAncmVxdWlyZWQnLFxuICAgICdyaWdodCcsXG4gICAgJ3Jvb3QnLFxuICAgICdzY29wZScsXG4gICAgJ3RhcmdldCcsXG4gICAgJ3ZhbGlkJyxcbiAgICAndmlzaXRlZCcsXG4gICAgJ3doZXJlJyxcbl0pO1xuLy8gTk9URTogaGVyZSB3ZSBvbmx5IG5lZWQgdG8gbGlzdCB0aGUgcHNldWRvLWVsZW1lbnRzIHdoaWNoIGNhbiBhcHBlYXIgd2l0aCBhXG4vLyBzaW5nbGUgY29sb24gKGUuZy4gOmFmdGVyIG9yIDo6YWZ0ZXIgYXJlIHZhbGlkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4vLyByZWFzb25zKS4gVGhleSBjYW4gYmUgbWlzaW50ZXJwcmV0ZWQgYXMgcHNldWRvLWNsYXNzZXMgYnkgdGhlIHRva2VuaXplciBmb3Jcbi8vIHRoaXMgcmVhc29uLlxuZXhwb3J0IGNvbnN0IFBTRVVET19FTEVNRU5UUyA9IG5ldyBTZXQoWydhZnRlcicsICdiZWZvcmUnLCAnZmlyc3QtbGV0dGVyJywgJ2ZpcnN0LWxpbmUnXSk7XG5leHBvcnQgdmFyIFNlbGVjdG9yVHlwZTtcbihmdW5jdGlvbiAoU2VsZWN0b3JUeXBlKSB7XG4gICAgU2VsZWN0b3JUeXBlW1NlbGVjdG9yVHlwZVtcIk5vcm1hbFwiXSA9IDBdID0gXCJOb3JtYWxcIjtcbiAgICBTZWxlY3RvclR5cGVbU2VsZWN0b3JUeXBlW1wiRXh0ZW5kZWRcIl0gPSAxXSA9IFwiRXh0ZW5kZWRcIjtcbiAgICBTZWxlY3RvclR5cGVbU2VsZWN0b3JUeXBlW1wiSW52YWxpZFwiXSA9IDJdID0gXCJJbnZhbGlkXCI7XG59KShTZWxlY3RvclR5cGUgfHwgKFNlbGVjdG9yVHlwZSA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gY2xhc3NpZnlTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIC8vIEluIG1vc3QgY2FzZXMgdGhlcmUgaXMgbm8gcHNldWRvLWFueXRoaW5nIHNvIHdlIGNhbiBxdWlja2x5IGV4aXQuXG4gICAgaWYgKHNlbGVjdG9yLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFNlbGVjdG9yVHlwZS5Ob3JtYWw7XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IHRva2VuaXplKHNlbGVjdG9yKTtcbiAgICAvLyBEZXRlY3QgcHNldWRvLWNsYXNzZXNcbiAgICBsZXQgZm91bmRTdXBwb3J0ZWRFeHRlbmRlZFNlbGVjdG9yID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdwc2V1ZG8tY2xhc3MnKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUgfSA9IHRva2VuO1xuICAgICAgICAgICAgaWYgKEVYVEVOREVEX1BTRVVET19DTEFTU0VTLmhhcyhuYW1lKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGZvdW5kU3VwcG9ydGVkRXh0ZW5kZWRTZWxlY3RvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChQU0VVRE9fQ0xBU1NFUy5oYXMobmFtZSkgPT09IGZhbHNlICYmIFBTRVVET19FTEVNRU5UUy5oYXMobmFtZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNlbGVjdG9yVHlwZS5JbnZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG5lc3RlZCA6aGFzIHNlbGVjdG9ycyAod2hpY2ggYXJlIG5vdCBzdXBwb3J0ZWQgYnkgc3RhbmRhcmQgQ1NTKVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdoYXMnICYmXG4gICAgICAgICAgICAgICAgdG9rZW4uYXJndW1lbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRva2VuLmFyZ3VtZW50LmluZGV4T2YoJzpoYXMoJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZm91bmRTdXBwb3J0ZWRFeHRlbmRlZFNlbGVjdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICBpZiAoZm91bmRTdXBwb3J0ZWRFeHRlbmRlZFNlbGVjdG9yID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgIHRva2VuLmFyZ3VtZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBSRUNVUlNJVkVfUFNFVURPX0NMQVNTRVMuaGFzKG5hbWUpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJndW1lbnRUeXBlID0gY2xhc3NpZnlTZWxlY3Rvcih0b2tlbi5hcmd1bWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50VHlwZSA9PT0gU2VsZWN0b3JUeXBlLkludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50VHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRUeXBlID09PSBTZWxlY3RvclR5cGUuRXh0ZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRTdXBwb3J0ZWRFeHRlbmRlZFNlbGVjdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvdW5kU3VwcG9ydGVkRXh0ZW5kZWRTZWxlY3RvciA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gU2VsZWN0b3JUeXBlLkV4dGVuZGVkO1xuICAgIH1cbiAgICByZXR1cm4gU2VsZWN0b3JUeXBlLk5vcm1hbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dGVuZGVkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/extended.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXTENDED_PSEUDO_CLASSES: () => (/* reexport safe */ _extended_js__WEBPACK_IMPORTED_MODULE_3__.EXTENDED_PSEUDO_CLASSES),\n/* harmony export */   PSEUDO_CLASSES: () => (/* reexport safe */ _extended_js__WEBPACK_IMPORTED_MODULE_3__.PSEUDO_CLASSES),\n/* harmony export */   PSEUDO_ELEMENTS: () => (/* reexport safe */ _extended_js__WEBPACK_IMPORTED_MODULE_3__.PSEUDO_ELEMENTS),\n/* harmony export */   SelectorType: () => (/* reexport safe */ _extended_js__WEBPACK_IMPORTED_MODULE_3__.SelectorType),\n/* harmony export */   classifySelector: () => (/* reexport safe */ _extended_js__WEBPACK_IMPORTED_MODULE_3__.classifySelector),\n/* harmony export */   isAST: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_2__.isAST),\n/* harmony export */   isAtoms: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_2__.isAtoms),\n/* harmony export */   matches: () => (/* reexport safe */ _eval_js__WEBPACK_IMPORTED_MODULE_1__.matches),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_0__.parse),\n/* harmony export */   querySelectorAll: () => (/* reexport safe */ _eval_js__WEBPACK_IMPORTED_MODULE_1__.querySelectorAll),\n/* harmony export */   tokenize: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_0__.tokenize)\n/* harmony export */ });\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/parse.js\");\n/* harmony import */ var _eval_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./eval.js */ \"(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/eval.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.js */ \"(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/types.js\");\n/* harmony import */ var _extended_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extended.js */ \"(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/extended.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci1leHRlbmRlZC1zZWxlY3RvcnMvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkM7QUFDUztBQUMzQjtBQUMrRjtBQUMxSCIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXItZXh0ZW5kZWQtc2VsZWN0b3JzL2Rpc3QvZXNtL2luZGV4LmpzPzFkNTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCBHaG9zdGVyeSBHbWJILiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5leHBvcnQgeyBwYXJzZSwgdG9rZW5pemUgfSBmcm9tICcuL3BhcnNlLmpzJztcbmV4cG9ydCB7IHF1ZXJ5U2VsZWN0b3JBbGwsIG1hdGNoZXMgfSBmcm9tICcuL2V2YWwuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcy5qcyc7XG5leHBvcnQgeyBFWFRFTkRFRF9QU0VVRE9fQ0xBU1NFUywgUFNFVURPX0NMQVNTRVMsIFBTRVVET19FTEVNRU5UUywgU2VsZWN0b3JUeXBlLCBjbGFzc2lmeVNlbGVjdG9yLCB9IGZyb20gJy4vZXh0ZW5kZWQuanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/parse.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/parse.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RECURSIVE_PSEUDO_CLASSES: () => (/* binding */ RECURSIVE_PSEUDO_CLASSES),\n/* harmony export */   gobbleParens: () => (/* binding */ gobbleParens),\n/* harmony export */   gobbleQuotes: () => (/* binding */ gobbleQuotes),\n/* harmony export */   isEscaped: () => (/* binding */ isEscaped),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   replace: () => (/* binding */ replace),\n/* harmony export */   tokenize: () => (/* binding */ tokenize)\n/* harmony export */ });\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ \"(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/types.js\");\n/*!\n * Based on parsel. Extended by Rmi Berson for Ghostery (2021).\n * https://github.com/LeaVerou/parsel\n *\n * MIT License\n *\n * Copyright (c) 2020 Lea Verou\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nconst RECURSIVE_PSEUDO_CLASSES = new Set([\n    'any',\n    'dir',\n    'has',\n    'host-context',\n    'is',\n    'matches',\n    'not',\n    'where',\n]);\nconst TOKENS = {\n    attribute: /\\[\\s*(?:(?<namespace>\\*|[-\\w]*)\\|)?(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)\\s*(?:(?<operator>\\W?=)\\s*(?<value>.+?)\\s*(?<caseSensitive>[iIsS])?\\s*)?\\]/gu,\n    id: /#(?<name>(?:[-\\w\\u{0080}-\\u{FFFF}]|\\\\.)+)/gu,\n    class: /\\.(?<name>(?:[-\\w\\u{0080}-\\u{FFFF}]|\\\\.)+)/gu,\n    comma: /\\s*,\\s*/g, // must be before combinator\n    combinator: /\\s*[\\s>+~]\\s*/g, // this must be after attribute\n    'pseudo-element': /::(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)(?:\\((?:*)\\))?/gu, // this must be before pseudo-class\n    'pseudo-class': /:(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)(?:\\((?<argument>*)\\))?/gu,\n    type: /(?:(?<namespace>\\*|[-\\w]*)\\|)?(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)|\\*/gu, // this must be last\n};\nconst TOKENS_WITH_PARENS = new Set(['pseudo-class', 'pseudo-element']);\nconst TOKENS_WITH_STRINGS = new Set([...TOKENS_WITH_PARENS, 'attribute']);\nconst TRIM_TOKENS = new Set(['combinator', 'comma']);\nconst TOKENS_FOR_RESTORE = Object.assign({}, TOKENS);\nTOKENS_FOR_RESTORE['pseudo-element'] = RegExp(TOKENS['pseudo-element'].source.replace('(?<argument>*)', '(?<argument>.*?)'), 'gu');\nTOKENS_FOR_RESTORE['pseudo-class'] = RegExp(TOKENS['pseudo-class'].source.replace('(?<argument>*)', '(?<argument>.*)'), 'gu');\n// TODO - it feels like with some more typing shenanigans we could replace groups validation by generic logic in this function.\nfunction splitOnMatch(pattern, str) {\n    pattern.lastIndex = 0;\n    const match = pattern.exec(str);\n    if (match === null) {\n        return undefined;\n    }\n    const from = match.index - 1;\n    const content = match[0];\n    const before = str.slice(0, from + 1);\n    const after = str.slice(from + content.length + 1);\n    return [before, [content, match.groups || {}], after];\n}\nconst GRAMMAR = [\n    // attribute\n    (str) => {\n        const match = splitOnMatch(TOKENS.attribute, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name, operator, value, namespace, caseSensitive }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'attribute',\n                content,\n                length: content.length,\n                namespace,\n                caseSensitive,\n                pos: [],\n                name,\n                operator,\n                value,\n            },\n            after,\n        ];\n    },\n    // #id\n    (str) => {\n        const match = splitOnMatch(TOKENS.id, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'id',\n                content,\n                length: content.length,\n                pos: [],\n                name,\n            },\n            after,\n        ];\n    },\n    // .class\n    (str) => {\n        const match = splitOnMatch(TOKENS.class, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'class',\n                content,\n                length: content.length,\n                pos: [],\n                name,\n            },\n            after,\n        ];\n    },\n    // comma ,\n    (str) => {\n        const match = splitOnMatch(TOKENS.comma, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content], after] = match;\n        return [\n            before,\n            {\n                type: 'comma',\n                content,\n                length: content.length,\n                pos: [],\n            },\n            after,\n        ];\n    },\n    // combinator\n    (str) => {\n        const match = splitOnMatch(TOKENS.combinator, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content], after] = match;\n        return [\n            before,\n            {\n                type: 'combinator',\n                content,\n                length: content.length,\n                pos: [],\n            },\n            after,\n        ];\n    },\n    // pseudo-element\n    (str) => {\n        const match = splitOnMatch(TOKENS['pseudo-element'], str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'pseudo-element',\n                content,\n                length: content.length,\n                pos: [],\n                name,\n            },\n            after,\n        ];\n    },\n    // pseudo-class\n    (str) => {\n        const match = splitOnMatch(TOKENS['pseudo-class'], str);\n        if (match === undefined) {\n            return undefined;\n        }\n        // TODO - here `argument` can be undefined and should be rejected?\n        const [before, [content, { name, argument }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'pseudo-class',\n                content,\n                length: content.length,\n                pos: [],\n                name,\n                argument,\n                subtree: undefined,\n            },\n            after,\n        ];\n    },\n    // type\n    (str) => {\n        const match = splitOnMatch(TOKENS.type, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name, namespace }], after] = match;\n        return [\n            before,\n            {\n                type: 'type',\n                content,\n                length: content.length,\n                namespace,\n                pos: [],\n                name,\n            },\n            after,\n        ];\n    },\n];\nfunction tokenizeBy(text) {\n    if (!text) {\n        return [];\n    }\n    const strarr = [text];\n    for (const tokenizer of GRAMMAR) {\n        for (let i = 0; i < strarr.length; i++) {\n            const str = strarr[i];\n            if (typeof str === 'string') {\n                const match = tokenizer(str);\n                if (match !== undefined) {\n                    strarr.splice(i, 1, ...match.filter((a) => a.length !== 0));\n                }\n            }\n        }\n    }\n    let offset = 0;\n    for (const token of strarr) {\n        if (typeof token !== 'string') {\n            token.pos = [offset, offset + token.length];\n            if (TRIM_TOKENS.has(token.type)) {\n                token.content = token.content.trim() || ' ';\n            }\n        }\n        offset += token.length;\n    }\n    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isAtoms)(strarr)) {\n        return strarr;\n    }\n    // NOTE: here this means that parsing failed.\n    return [];\n}\nfunction restoreNested(tokens, strings, regex, types) {\n    // TODO - here from offsets in strings and tokens we should be able to find the exact spot without RegExp?\n    for (const str of strings) {\n        for (const token of tokens) {\n            if (types.has(token.type) && token.pos[0] < str.start && str.start < token.pos[1]) {\n                const content = token.content;\n                token.content = token.content.replace(regex, str.str);\n                if (token.content !== content) {\n                    // actually changed?\n                    // Re-evaluate groups\n                    TOKENS_FOR_RESTORE[token.type].lastIndex = 0;\n                    const match = TOKENS_FOR_RESTORE[token.type].exec(token.content);\n                    if (match !== null) {\n                        Object.assign(token, match.groups);\n                    }\n                }\n            }\n        }\n    }\n}\nfunction isEscaped(str, index) {\n    let backslashes = 0;\n    index -= 1;\n    while (index >= 0 && str[index] === '\\\\') {\n        backslashes += 1;\n        index -= 1;\n    }\n    return backslashes % 2 !== 0;\n}\nfunction gobbleQuotes(text, quote, start) {\n    // Find end of quote, taking care of ignoring escaped quotes\n    let end = start + 1;\n    while ((end = text.indexOf(quote, end)) !== -1 && isEscaped(text, end) === true) {\n        end += 1;\n    }\n    if (end === -1) {\n        // Opening quote without closing quote\n        return undefined;\n    }\n    return text.slice(start, end + 1);\n}\nfunction gobbleParens(text, start) {\n    let stack = 0;\n    for (let i = start; i < text.length; i++) {\n        const char = text[i];\n        if (char === '(') {\n            stack += 1;\n        }\n        else if (char === ')') {\n            if (stack > 0) {\n                stack -= 1;\n            }\n            else {\n                // Closing paren without opening paren\n                return undefined;\n            }\n        }\n        if (stack === 0) {\n            return text.slice(start, i + 1);\n        }\n    }\n    // Opening paren without closing paren\n    return undefined;\n}\nfunction replace(selector, replacement, opening, gobble) {\n    const strings = [];\n    let offset = 0;\n    while ((offset = selector.indexOf(opening, offset)) !== -1) {\n        const str = gobble(selector, offset);\n        if (str === undefined) {\n            break;\n        }\n        strings.push({ str, start: offset });\n        selector = `${selector.slice(0, offset + 1)}${replacement.repeat(str.length - 2)}${selector.slice(offset + str.length - 1)}`;\n        offset += str.length;\n    }\n    return [strings, selector];\n}\nfunction tokenize(selector) {\n    if (typeof selector !== 'string') {\n        return [];\n    }\n    // Prevent leading/trailing whitespace be interpreted as combinators\n    selector = selector.trim();\n    if (selector.length === 0) {\n        return [];\n    }\n    // Replace strings with whitespace strings (to preserve offsets)\n    const [doubleQuotes, selectorWithoutDoubleQuotes] = replace(selector, '', '\"', (text, start) => gobbleQuotes(text, '\"', start));\n    const [singleQuotes, selectorWithoutQuotes] = replace(selectorWithoutDoubleQuotes, '', \"'\", (text, start) => gobbleQuotes(text, \"'\", start));\n    // Now that strings are out of the way, extract parens and replace them with parens with whitespace (to preserve offsets)\n    const [parens, selectorWithoutParens] = replace(selectorWithoutQuotes, '', '(', gobbleParens);\n    // Now we have no nested structures and we can parse with regexes\n    const tokens = tokenizeBy(selectorWithoutParens);\n    // Now restore parens and strings in reverse order\n    restoreNested(tokens, parens, /\\(*\\)/, TOKENS_WITH_PARENS);\n    restoreNested(tokens, doubleQuotes, /\"*\"/, TOKENS_WITH_STRINGS);\n    restoreNested(tokens, singleQuotes, /'*'/, TOKENS_WITH_STRINGS);\n    return tokens;\n}\n// Convert a flat list of tokens into a tree of complex & compound selectors\nfunction nestTokens(tokens, { list = true } = {}) {\n    if (list === true && tokens.some((t) => t.type === 'comma')) {\n        const selectors = [];\n        const temp = [];\n        for (let i = 0; i < tokens.length; i += 1) {\n            const token = tokens[i];\n            if (token.type === 'comma') {\n                if (temp.length === 0) {\n                    throw new Error('Incorrect comma at ' + i);\n                }\n                const sub = nestTokens(temp, { list: false });\n                if (sub !== undefined) {\n                    selectors.push(sub);\n                }\n                temp.length = 0;\n            }\n            else {\n                temp.push(token);\n            }\n        }\n        if (temp.length === 0) {\n            throw new Error('Trailing comma');\n        }\n        else {\n            const sub = nestTokens(temp, { list: false });\n            if (sub !== undefined) {\n                selectors.push(sub);\n            }\n        }\n        return { type: 'list', list: selectors };\n    }\n    for (let i = tokens.length - 1; i >= 0; i--) {\n        const token = tokens[i];\n        if (token.type === 'combinator') {\n            const left = nestTokens(tokens.slice(0, i));\n            const right = nestTokens(tokens.slice(i + 1));\n            if (right === undefined) {\n                return undefined;\n            }\n            if (token.content !== ' ' &&\n                token.content !== '~' &&\n                token.content !== '+' &&\n                token.content !== '>') {\n                return undefined;\n            }\n            return {\n                type: 'complex',\n                combinator: token.content,\n                left,\n                right,\n            };\n        }\n    }\n    if (tokens.length === 0) {\n        return undefined;\n    }\n    if ((0,_types_js__WEBPACK_IMPORTED_MODULE_0__.isAST)(tokens)) {\n        if (tokens.length === 1) {\n            return tokens[0];\n        }\n        // If we're here, there are no combinators, so it's just a list\n        return {\n            type: 'compound',\n            compound: [...tokens], // clone to avoid pointers messing up the AST\n        };\n    }\n    return undefined;\n}\n// Traverse an AST (or part thereof), in depth-first order\nfunction walk(node, callback, o, parent) {\n    if (node === undefined) {\n        return;\n    }\n    if (node.type === 'complex') {\n        walk(node.left, callback, o, node);\n        walk(node.right, callback, o, node);\n    }\n    else if (node.type === 'compound') {\n        for (const n of node.compound) {\n            walk(n, callback, o, node);\n        }\n    }\n    else if (node.type === 'pseudo-class' &&\n        node.subtree !== undefined &&\n        o !== undefined &&\n        o.type === 'pseudo-class' &&\n        o.subtree !== undefined) {\n        walk(node.subtree, callback, o, node);\n    }\n    callback(node, parent);\n}\n/**\n * Parse a CSS selector\n * @param selector {String} The selector to parse\n * @param options.recursive {Boolean} Whether to parse the arguments of pseudo-classes like :is(), :has() etc. Defaults to true.\n * @param options.list {Boolean} Whether this can be a selector list (A, B, C etc). Defaults to true.\n */\nfunction parse(selector, { recursive = true, list = true } = {}) {\n    const tokens = tokenize(selector);\n    if (tokens.length === 0) {\n        return undefined;\n    }\n    const ast = nestTokens(tokens, { list });\n    if (recursive === true) {\n        walk(ast, (node) => {\n            if (node.type === 'pseudo-class' &&\n                node.argument &&\n                node.name !== undefined &&\n                RECURSIVE_PSEUDO_CLASSES.has(node.name)) {\n                node.subtree = parse(node.argument, { recursive: true, list: true });\n            }\n        });\n    }\n    return ast;\n}\n//# sourceMappingURL=parse.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci1leHRlbmRlZC1zZWxlY3RvcnMvZGlzdC9lc20vcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRDO0FBQ3JDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsS0FBSyxJQUFJLEtBQUs7QUFDaEYsNEJBQTRCLEtBQUssSUFBSSxLQUFLO0FBQzFDLGdDQUFnQyxLQUFLLElBQUksS0FBSztBQUM5QztBQUNBO0FBQ0Esd0NBQXdDLEtBQUssSUFBSSxLQUFLO0FBQ3RELHFDQUFxQyxLQUFLLElBQUksS0FBSztBQUNuRCx3REFBd0QsS0FBSyxJQUFJLEtBQUs7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpREFBaUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQyxzQkFBc0IsOEJBQThCLEVBQUUsbUNBQW1DLEVBQUUsd0NBQXdDO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjLElBQUk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1Qiw2QkFBNkIsU0FBUztBQUN0Qyx3QkFBd0IsU0FBUztBQUNqQztBQUNPLDJCQUEyQixnQ0FBZ0MsSUFBSTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw2QkFBNkI7QUFDbkY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvYWRibG9ja2VyLWV4dGVuZGVkLXNlbGVjdG9ycy9kaXN0L2VzbS9wYXJzZS5qcz8zY2JiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQmFzZWQgb24gcGFyc2VsLiBFeHRlbmRlZCBieSBSw6ltaSBCZXJzb24gZm9yIEdob3N0ZXJ5ICgyMDIxKS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFWZXJvdS9wYXJzZWxcbiAqXG4gKiBNSVQgTGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAyMCBMZWEgVmVyb3VcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5pbXBvcnQgeyBpc0FTVCwgaXNBdG9tcyB9IGZyb20gJy4vdHlwZXMuanMnO1xuZXhwb3J0IGNvbnN0IFJFQ1VSU0lWRV9QU0VVRE9fQ0xBU1NFUyA9IG5ldyBTZXQoW1xuICAgICdhbnknLFxuICAgICdkaXInLFxuICAgICdoYXMnLFxuICAgICdob3N0LWNvbnRleHQnLFxuICAgICdpcycsXG4gICAgJ21hdGNoZXMnLFxuICAgICdub3QnLFxuICAgICd3aGVyZScsXG5dKTtcbmNvbnN0IFRPS0VOUyA9IHtcbiAgICBhdHRyaWJ1dGU6IC9cXFtcXHMqKD86KD88bmFtZXNwYWNlPlxcKnxbLVxcd10qKVxcfCk/KD88bmFtZT5bLVxcd1xcdXswMDgwfS1cXHV7RkZGRn1dKylcXHMqKD86KD88b3BlcmF0b3I+XFxXPz0pXFxzKig/PHZhbHVlPi4rPylcXHMqKD88Y2FzZVNlbnNpdGl2ZT5baUlzU10pP1xccyopP1xcXS9ndSxcbiAgICBpZDogLyMoPzxuYW1lPig/OlstXFx3XFx1ezAwODB9LVxcdXtGRkZGfV18XFxcXC4pKykvZ3UsXG4gICAgY2xhc3M6IC9cXC4oPzxuYW1lPig/OlstXFx3XFx1ezAwODB9LVxcdXtGRkZGfV18XFxcXC4pKykvZ3UsXG4gICAgY29tbWE6IC9cXHMqLFxccyovZywgLy8gbXVzdCBiZSBiZWZvcmUgY29tYmluYXRvclxuICAgIGNvbWJpbmF0b3I6IC9cXHMqW1xccz4rfl1cXHMqL2csIC8vIHRoaXMgbXVzdCBiZSBhZnRlciBhdHRyaWJ1dGVcbiAgICAncHNldWRvLWVsZW1lbnQnOiAvOjooPzxuYW1lPlstXFx3XFx1ezAwODB9LVxcdXtGRkZGfV0rKSg/OlxcKCg/OsK2KilcXCkpPy9ndSwgLy8gdGhpcyBtdXN0IGJlIGJlZm9yZSBwc2V1ZG8tY2xhc3NcbiAgICAncHNldWRvLWNsYXNzJzogLzooPzxuYW1lPlstXFx3XFx1ezAwODB9LVxcdXtGRkZGfV0rKSg/OlxcKCg/PGFyZ3VtZW50PsK2KilcXCkpPy9ndSxcbiAgICB0eXBlOiAvKD86KD88bmFtZXNwYWNlPlxcKnxbLVxcd10qKVxcfCk/KD88bmFtZT5bLVxcd1xcdXswMDgwfS1cXHV7RkZGRn1dKyl8XFwqL2d1LCAvLyB0aGlzIG11c3QgYmUgbGFzdFxufTtcbmNvbnN0IFRPS0VOU19XSVRIX1BBUkVOUyA9IG5ldyBTZXQoWydwc2V1ZG8tY2xhc3MnLCAncHNldWRvLWVsZW1lbnQnXSk7XG5jb25zdCBUT0tFTlNfV0lUSF9TVFJJTkdTID0gbmV3IFNldChbLi4uVE9LRU5TX1dJVEhfUEFSRU5TLCAnYXR0cmlidXRlJ10pO1xuY29uc3QgVFJJTV9UT0tFTlMgPSBuZXcgU2V0KFsnY29tYmluYXRvcicsICdjb21tYSddKTtcbmNvbnN0IFRPS0VOU19GT1JfUkVTVE9SRSA9IE9iamVjdC5hc3NpZ24oe30sIFRPS0VOUyk7XG5UT0tFTlNfRk9SX1JFU1RPUkVbJ3BzZXVkby1lbGVtZW50J10gPSBSZWdFeHAoVE9LRU5TWydwc2V1ZG8tZWxlbWVudCddLnNvdXJjZS5yZXBsYWNlKCcoPzxhcmd1bWVudD7CtiopJywgJyg/PGFyZ3VtZW50Pi4qPyknKSwgJ2d1Jyk7XG5UT0tFTlNfRk9SX1JFU1RPUkVbJ3BzZXVkby1jbGFzcyddID0gUmVnRXhwKFRPS0VOU1sncHNldWRvLWNsYXNzJ10uc291cmNlLnJlcGxhY2UoJyg/PGFyZ3VtZW50PsK2KiknLCAnKD88YXJndW1lbnQ+LiopJyksICdndScpO1xuLy8gVE9ETyAtIGl0IGZlZWxzIGxpa2Ugd2l0aCBzb21lIG1vcmUgdHlwaW5nIHNoZW5hbmlnYW5zIHdlIGNvdWxkIHJlcGxhY2UgZ3JvdXBzIHZhbGlkYXRpb24gYnkgZ2VuZXJpYyBsb2dpYyBpbiB0aGlzIGZ1bmN0aW9uLlxuZnVuY3Rpb24gc3BsaXRPbk1hdGNoKHBhdHRlcm4sIHN0cikge1xuICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICBjb25zdCBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzdHIpO1xuICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBmcm9tID0gbWF0Y2guaW5kZXggLSAxO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBtYXRjaFswXTtcbiAgICBjb25zdCBiZWZvcmUgPSBzdHIuc2xpY2UoMCwgZnJvbSArIDEpO1xuICAgIGNvbnN0IGFmdGVyID0gc3RyLnNsaWNlKGZyb20gKyBjb250ZW50Lmxlbmd0aCArIDEpO1xuICAgIHJldHVybiBbYmVmb3JlLCBbY29udGVudCwgbWF0Y2guZ3JvdXBzIHx8IHt9XSwgYWZ0ZXJdO1xufVxuY29uc3QgR1JBTU1BUiA9IFtcbiAgICAvLyBhdHRyaWJ1dGVcbiAgICAoc3RyKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc3BsaXRPbk1hdGNoKFRPS0VOUy5hdHRyaWJ1dGUsIHN0cik7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtiZWZvcmUsIFtjb250ZW50LCB7IG5hbWUsIG9wZXJhdG9yLCB2YWx1ZSwgbmFtZXNwYWNlLCBjYXNlU2Vuc2l0aXZlIH1dLCBhZnRlcl0gPSBtYXRjaDtcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYmVmb3JlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhdHRyaWJ1dGUnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBjb250ZW50Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgICAgICAgICBwb3M6IFtdLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWZ0ZXIsXG4gICAgICAgIF07XG4gICAgfSxcbiAgICAvLyAjaWRcbiAgICAoc3RyKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc3BsaXRPbk1hdGNoKFRPS0VOUy5pZCwgc3RyKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2JlZm9yZSwgW2NvbnRlbnQsIHsgbmFtZSB9XSwgYWZ0ZXJdID0gbWF0Y2g7XG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGJlZm9yZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaWQnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBjb250ZW50Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBwb3M6IFtdLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWZ0ZXIsXG4gICAgICAgIF07XG4gICAgfSxcbiAgICAvLyAuY2xhc3NcbiAgICAoc3RyKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc3BsaXRPbk1hdGNoKFRPS0VOUy5jbGFzcywgc3RyKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2JlZm9yZSwgW2NvbnRlbnQsIHsgbmFtZSB9XSwgYWZ0ZXJdID0gbWF0Y2g7XG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGJlZm9yZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2xhc3MnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBjb250ZW50Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBwb3M6IFtdLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWZ0ZXIsXG4gICAgICAgIF07XG4gICAgfSxcbiAgICAvLyBjb21tYSAsXG4gICAgKHN0cikgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNwbGl0T25NYXRjaChUT0tFTlMuY29tbWEsIHN0cik7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtiZWZvcmUsIFtjb250ZW50XSwgYWZ0ZXJdID0gbWF0Y2g7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBiZWZvcmUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbW1hJyxcbiAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgIGxlbmd0aDogY29udGVudC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcG9zOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZnRlcixcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIC8vIGNvbWJpbmF0b3JcbiAgICAoc3RyKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc3BsaXRPbk1hdGNoKFRPS0VOUy5jb21iaW5hdG9yLCBzdHIpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYmVmb3JlLCBbY29udGVudF0sIGFmdGVyXSA9IG1hdGNoO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYmVmb3JlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21iaW5hdG9yJyxcbiAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgIGxlbmd0aDogY29udGVudC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcG9zOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZnRlcixcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIC8vIHBzZXVkby1lbGVtZW50XG4gICAgKHN0cikgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNwbGl0T25NYXRjaChUT0tFTlNbJ3BzZXVkby1lbGVtZW50J10sIHN0cik7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtiZWZvcmUsIFtjb250ZW50LCB7IG5hbWUgfV0sIGFmdGVyXSA9IG1hdGNoO1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBiZWZvcmUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BzZXVkby1lbGVtZW50JyxcbiAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgIGxlbmd0aDogY29udGVudC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcG9zOiBbXSxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFmdGVyLFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgLy8gcHNldWRvLWNsYXNzXG4gICAgKHN0cikgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNwbGl0T25NYXRjaChUT0tFTlNbJ3BzZXVkby1jbGFzcyddLCBzdHIpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIC0gaGVyZSBgYXJndW1lbnRgIGNhbiBiZSB1bmRlZmluZWQgYW5kIHNob3VsZCBiZSByZWplY3RlZD9cbiAgICAgICAgY29uc3QgW2JlZm9yZSwgW2NvbnRlbnQsIHsgbmFtZSwgYXJndW1lbnQgfV0sIGFmdGVyXSA9IG1hdGNoO1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBiZWZvcmUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BzZXVkby1jbGFzcycsXG4gICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGNvbnRlbnQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHBvczogW10sXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudCxcbiAgICAgICAgICAgICAgICBzdWJ0cmVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWZ0ZXIsXG4gICAgICAgIF07XG4gICAgfSxcbiAgICAvLyB0eXBlXG4gICAgKHN0cikgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNwbGl0T25NYXRjaChUT0tFTlMudHlwZSwgc3RyKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2JlZm9yZSwgW2NvbnRlbnQsIHsgbmFtZSwgbmFtZXNwYWNlIH1dLCBhZnRlcl0gPSBtYXRjaDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGJlZm9yZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndHlwZScsXG4gICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGNvbnRlbnQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBwb3M6IFtdLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWZ0ZXIsXG4gICAgICAgIF07XG4gICAgfSxcbl07XG5mdW5jdGlvbiB0b2tlbml6ZUJ5KHRleHQpIHtcbiAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBzdHJhcnIgPSBbdGV4dF07XG4gICAgZm9yIChjb25zdCB0b2tlbml6ZXIgb2YgR1JBTU1BUikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3RyID0gc3RyYXJyW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB0b2tlbml6ZXIoc3RyKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJhcnIuc3BsaWNlKGksIDEsIC4uLm1hdGNoLmZpbHRlcigoYSkgPT4gYS5sZW5ndGggIT09IDApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiBzdHJhcnIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRva2VuLnBvcyA9IFtvZmZzZXQsIG9mZnNldCArIHRva2VuLmxlbmd0aF07XG4gICAgICAgICAgICBpZiAoVFJJTV9UT0tFTlMuaGFzKHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLmNvbnRlbnQudHJpbSgpIHx8ICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gdG9rZW4ubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoaXNBdG9tcyhzdHJhcnIpKSB7XG4gICAgICAgIHJldHVybiBzdHJhcnI7XG4gICAgfVxuICAgIC8vIE5PVEU6IGhlcmUgdGhpcyBtZWFucyB0aGF0IHBhcnNpbmcgZmFpbGVkLlxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVOZXN0ZWQodG9rZW5zLCBzdHJpbmdzLCByZWdleCwgdHlwZXMpIHtcbiAgICAvLyBUT0RPIC0gaGVyZSBmcm9tIG9mZnNldHMgaW4gc3RyaW5ncyBhbmQgdG9rZW5zIHdlIHNob3VsZCBiZSBhYmxlIHRvIGZpbmQgdGhlIGV4YWN0IHNwb3Qgd2l0aG91dCBSZWdFeHA/XG4gICAgZm9yIChjb25zdCBzdHIgb2Ygc3RyaW5ncykge1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgaWYgKHR5cGVzLmhhcyh0b2tlbi50eXBlKSAmJiB0b2tlbi5wb3NbMF0gPCBzdHIuc3RhcnQgJiYgc3RyLnN0YXJ0IDwgdG9rZW4ucG9zWzFdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHRva2VuLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLmNvbnRlbnQucmVwbGFjZShyZWdleCwgc3RyLnN0cik7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmNvbnRlbnQgIT09IGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgY2hhbmdlZD9cbiAgICAgICAgICAgICAgICAgICAgLy8gUmUtZXZhbHVhdGUgZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgIFRPS0VOU19GT1JfUkVTVE9SRVt0b2tlbi50eXBlXS5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IFRPS0VOU19GT1JfUkVTVE9SRVt0b2tlbi50eXBlXS5leGVjKHRva2VuLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odG9rZW4sIG1hdGNoLmdyb3Vwcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNFc2NhcGVkKHN0ciwgaW5kZXgpIHtcbiAgICBsZXQgYmFja3NsYXNoZXMgPSAwO1xuICAgIGluZGV4IC09IDE7XG4gICAgd2hpbGUgKGluZGV4ID49IDAgJiYgc3RyW2luZGV4XSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGJhY2tzbGFzaGVzICs9IDE7XG4gICAgICAgIGluZGV4IC09IDE7XG4gICAgfVxuICAgIHJldHVybiBiYWNrc2xhc2hlcyAlIDIgIT09IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gZ29iYmxlUXVvdGVzKHRleHQsIHF1b3RlLCBzdGFydCkge1xuICAgIC8vIEZpbmQgZW5kIG9mIHF1b3RlLCB0YWtpbmcgY2FyZSBvZiBpZ25vcmluZyBlc2NhcGVkIHF1b3Rlc1xuICAgIGxldCBlbmQgPSBzdGFydCArIDE7XG4gICAgd2hpbGUgKChlbmQgPSB0ZXh0LmluZGV4T2YocXVvdGUsIGVuZCkpICE9PSAtMSAmJiBpc0VzY2FwZWQodGV4dCwgZW5kKSA9PT0gdHJ1ZSkge1xuICAgICAgICBlbmQgKz0gMTtcbiAgICB9XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgLy8gT3BlbmluZyBxdW90ZSB3aXRob3V0IGNsb3NpbmcgcXVvdGVcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQuc2xpY2Uoc3RhcnQsIGVuZCArIDEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdvYmJsZVBhcmVucyh0ZXh0LCBzdGFydCkge1xuICAgIGxldCBzdGFjayA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gdGV4dFtpXTtcbiAgICAgICAgaWYgKGNoYXIgPT09ICcoJykge1xuICAgICAgICAgICAgc3RhY2sgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnKScpIHtcbiAgICAgICAgICAgIGlmIChzdGFjayA+IDApIHtcbiAgICAgICAgICAgICAgICBzdGFjayAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xvc2luZyBwYXJlbiB3aXRob3V0IG9wZW5pbmcgcGFyZW5cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjayA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQuc2xpY2Uoc3RhcnQsIGkgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBPcGVuaW5nIHBhcmVuIHdpdGhvdXQgY2xvc2luZyBwYXJlblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZShzZWxlY3RvciwgcmVwbGFjZW1lbnQsIG9wZW5pbmcsIGdvYmJsZSkge1xuICAgIGNvbnN0IHN0cmluZ3MgPSBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICB3aGlsZSAoKG9mZnNldCA9IHNlbGVjdG9yLmluZGV4T2Yob3BlbmluZywgb2Zmc2V0KSkgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IHN0ciA9IGdvYmJsZShzZWxlY3Rvciwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmdzLnB1c2goeyBzdHIsIHN0YXJ0OiBvZmZzZXQgfSk7XG4gICAgICAgIHNlbGVjdG9yID0gYCR7c2VsZWN0b3Iuc2xpY2UoMCwgb2Zmc2V0ICsgMSl9JHtyZXBsYWNlbWVudC5yZXBlYXQoc3RyLmxlbmd0aCAtIDIpfSR7c2VsZWN0b3Iuc2xpY2Uob2Zmc2V0ICsgc3RyLmxlbmd0aCAtIDEpfWA7XG4gICAgICAgIG9mZnNldCArPSBzdHIubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gW3N0cmluZ3MsIHNlbGVjdG9yXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b2tlbml6ZShzZWxlY3Rvcikge1xuICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLy8gUHJldmVudCBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2UgYmUgaW50ZXJwcmV0ZWQgYXMgY29tYmluYXRvcnNcbiAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnRyaW0oKTtcbiAgICBpZiAoc2VsZWN0b3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLy8gUmVwbGFjZSBzdHJpbmdzIHdpdGggd2hpdGVzcGFjZSBzdHJpbmdzICh0byBwcmVzZXJ2ZSBvZmZzZXRzKVxuICAgIGNvbnN0IFtkb3VibGVRdW90ZXMsIHNlbGVjdG9yV2l0aG91dERvdWJsZVF1b3Rlc10gPSByZXBsYWNlKHNlbGVjdG9yLCAnwqcnLCAnXCInLCAodGV4dCwgc3RhcnQpID0+IGdvYmJsZVF1b3Rlcyh0ZXh0LCAnXCInLCBzdGFydCkpO1xuICAgIGNvbnN0IFtzaW5nbGVRdW90ZXMsIHNlbGVjdG9yV2l0aG91dFF1b3Rlc10gPSByZXBsYWNlKHNlbGVjdG9yV2l0aG91dERvdWJsZVF1b3RlcywgJ8KnJywgXCInXCIsICh0ZXh0LCBzdGFydCkgPT4gZ29iYmxlUXVvdGVzKHRleHQsIFwiJ1wiLCBzdGFydCkpO1xuICAgIC8vIE5vdyB0aGF0IHN0cmluZ3MgYXJlIG91dCBvZiB0aGUgd2F5LCBleHRyYWN0IHBhcmVucyBhbmQgcmVwbGFjZSB0aGVtIHdpdGggcGFyZW5zIHdpdGggd2hpdGVzcGFjZSAodG8gcHJlc2VydmUgb2Zmc2V0cylcbiAgICBjb25zdCBbcGFyZW5zLCBzZWxlY3RvcldpdGhvdXRQYXJlbnNdID0gcmVwbGFjZShzZWxlY3RvcldpdGhvdXRRdW90ZXMsICfCticsICcoJywgZ29iYmxlUGFyZW5zKTtcbiAgICAvLyBOb3cgd2UgaGF2ZSBubyBuZXN0ZWQgc3RydWN0dXJlcyBhbmQgd2UgY2FuIHBhcnNlIHdpdGggcmVnZXhlc1xuICAgIGNvbnN0IHRva2VucyA9IHRva2VuaXplQnkoc2VsZWN0b3JXaXRob3V0UGFyZW5zKTtcbiAgICAvLyBOb3cgcmVzdG9yZSBwYXJlbnMgYW5kIHN0cmluZ3MgaW4gcmV2ZXJzZSBvcmRlclxuICAgIHJlc3RvcmVOZXN0ZWQodG9rZW5zLCBwYXJlbnMsIC9cXCjCtipcXCkvLCBUT0tFTlNfV0lUSF9QQVJFTlMpO1xuICAgIHJlc3RvcmVOZXN0ZWQodG9rZW5zLCBkb3VibGVRdW90ZXMsIC9cIsKnKlwiLywgVE9LRU5TX1dJVEhfU1RSSU5HUyk7XG4gICAgcmVzdG9yZU5lc3RlZCh0b2tlbnMsIHNpbmdsZVF1b3RlcywgLyfCpyonLywgVE9LRU5TX1dJVEhfU1RSSU5HUyk7XG4gICAgcmV0dXJuIHRva2Vucztcbn1cbi8vIENvbnZlcnQgYSBmbGF0IGxpc3Qgb2YgdG9rZW5zIGludG8gYSB0cmVlIG9mIGNvbXBsZXggJiBjb21wb3VuZCBzZWxlY3RvcnNcbmZ1bmN0aW9uIG5lc3RUb2tlbnModG9rZW5zLCB7IGxpc3QgPSB0cnVlIH0gPSB7fSkge1xuICAgIGlmIChsaXN0ID09PSB0cnVlICYmIHRva2Vucy5zb21lKCh0KSA9PiB0LnR5cGUgPT09ICdjb21tYScpKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IFtdO1xuICAgICAgICBjb25zdCB0ZW1wID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnY29tbWEnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGNvbW1hIGF0ICcgKyBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViID0gbmVzdFRva2Vucyh0ZW1wLCB7IGxpc3Q6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzdWIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnMucHVzaChzdWIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZW1wLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZW1wLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFpbGluZyBjb21tYScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gbmVzdFRva2Vucyh0ZW1wLCB7IGxpc3Q6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKHN1YiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzLnB1c2goc3ViKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiAnbGlzdCcsIGxpc3Q6IHNlbGVjdG9ycyB9O1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2NvbWJpbmF0b3InKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gbmVzdFRva2Vucyh0b2tlbnMuc2xpY2UoMCwgaSkpO1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBuZXN0VG9rZW5zKHRva2Vucy5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLmNvbnRlbnQgIT09ICcgJyAmJlxuICAgICAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgIT09ICd+JyAmJlxuICAgICAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgIT09ICcrJyAmJlxuICAgICAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgIT09ICc+Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb21wbGV4JyxcbiAgICAgICAgICAgICAgICBjb21iaW5hdG9yOiB0b2tlbi5jb250ZW50LFxuICAgICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpc0FTVCh0b2tlbnMpKSB7XG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIGhlcmUsIHRoZXJlIGFyZSBubyBjb21iaW5hdG9ycywgc28gaXQncyBqdXN0IGEgbGlzdFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2NvbXBvdW5kJyxcbiAgICAgICAgICAgIGNvbXBvdW5kOiBbLi4udG9rZW5zXSwgLy8gY2xvbmUgdG8gYXZvaWQgcG9pbnRlcnMgbWVzc2luZyB1cCB0aGUgQVNUXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyBUcmF2ZXJzZSBhbiBBU1QgKG9yIHBhcnQgdGhlcmVvZiksIGluIGRlcHRoLWZpcnN0IG9yZGVyXG5mdW5jdGlvbiB3YWxrKG5vZGUsIGNhbGxiYWNrLCBvLCBwYXJlbnQpIHtcbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2NvbXBsZXgnKSB7XG4gICAgICAgIHdhbGsobm9kZS5sZWZ0LCBjYWxsYmFjaywgbywgbm9kZSk7XG4gICAgICAgIHdhbGsobm9kZS5yaWdodCwgY2FsbGJhY2ssIG8sIG5vZGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBuIG9mIG5vZGUuY29tcG91bmQpIHtcbiAgICAgICAgICAgIHdhbGsobiwgY2FsbGJhY2ssIG8sIG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ3BzZXVkby1jbGFzcycgJiZcbiAgICAgICAgbm9kZS5zdWJ0cmVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgbyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG8udHlwZSA9PT0gJ3BzZXVkby1jbGFzcycgJiZcbiAgICAgICAgby5zdWJ0cmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2Fsayhub2RlLnN1YnRyZWUsIGNhbGxiYWNrLCBvLCBub2RlKTtcbiAgICB9XG4gICAgY2FsbGJhY2sobm9kZSwgcGFyZW50KTtcbn1cbi8qKlxuICogUGFyc2UgYSBDU1Mgc2VsZWN0b3JcbiAqIEBwYXJhbSBzZWxlY3RvciB7U3RyaW5nfSBUaGUgc2VsZWN0b3IgdG8gcGFyc2VcbiAqIEBwYXJhbSBvcHRpb25zLnJlY3Vyc2l2ZSB7Qm9vbGVhbn0gV2hldGhlciB0byBwYXJzZSB0aGUgYXJndW1lbnRzIG9mIHBzZXVkby1jbGFzc2VzIGxpa2UgOmlzKCksIDpoYXMoKSBldGMuIERlZmF1bHRzIHRvIHRydWUuXG4gKiBAcGFyYW0gb3B0aW9ucy5saXN0IHtCb29sZWFufSBXaGV0aGVyIHRoaXMgY2FuIGJlIGEgc2VsZWN0b3IgbGlzdCAoQSwgQiwgQyBldGMpLiBEZWZhdWx0cyB0byB0cnVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Uoc2VsZWN0b3IsIHsgcmVjdXJzaXZlID0gdHJ1ZSwgbGlzdCA9IHRydWUgfSA9IHt9KSB7XG4gICAgY29uc3QgdG9rZW5zID0gdG9rZW5pemUoc2VsZWN0b3IpO1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGFzdCA9IG5lc3RUb2tlbnModG9rZW5zLCB7IGxpc3QgfSk7XG4gICAgaWYgKHJlY3Vyc2l2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICB3YWxrKGFzdCwgKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdwc2V1ZG8tY2xhc3MnICYmXG4gICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudCAmJlxuICAgICAgICAgICAgICAgIG5vZGUubmFtZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgUkVDVVJTSVZFX1BTRVVET19DTEFTU0VTLmhhcyhub2RlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zdWJ0cmVlID0gcGFyc2Uobm9kZS5hcmd1bWVudCwgeyByZWN1cnNpdmU6IHRydWUsIGxpc3Q6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXN0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/types.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/types.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAST: () => (/* binding */ isAST),\n/* harmony export */   isAtoms: () => (/* binding */ isAtoms)\n/* harmony export */ });\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nconst tokenTypes = [\n    'attribute',\n    'id',\n    'class',\n    'comma',\n    'combinator',\n    'pseudo-element',\n    'pseudo-class',\n    'type',\n];\nfunction isAtoms(tokens) {\n    return tokens.every((token) => typeof token !== 'string');\n}\nfunction isAST(tokens) {\n    return tokens.every((token) => token.type !== 'comma' && token.type !== 'combinator');\n}\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci1leHRlbmRlZC1zZWxlY3RvcnMvZGlzdC9lc20vdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvYWRibG9ja2VyLWV4dGVuZGVkLXNlbGVjdG9ycy9kaXN0L2VzbS90eXBlcy5qcz85YTc4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQgR2hvc3RlcnkgR21iSC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuY29uc3QgdG9rZW5UeXBlcyA9IFtcbiAgICAnYXR0cmlidXRlJyxcbiAgICAnaWQnLFxuICAgICdjbGFzcycsXG4gICAgJ2NvbW1hJyxcbiAgICAnY29tYmluYXRvcicsXG4gICAgJ3BzZXVkby1lbGVtZW50JyxcbiAgICAncHNldWRvLWNsYXNzJyxcbiAgICAndHlwZScsXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXRvbXModG9rZW5zKSB7XG4gICAgcmV0dXJuIHRva2Vucy5ldmVyeSgodG9rZW4pID0+IHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQVNUKHRva2Vucykge1xuICAgIHJldHVybiB0b2tlbnMuZXZlcnkoKHRva2VuKSA9PiB0b2tlbi50eXBlICE9PSAnY29tbWEnICYmIHRva2VuLnR5cGUgIT09ICdjb21iaW5hdG9yJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker-playwright/dist/esm/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker-playwright/dist/esm/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockingContext: () => (/* binding */ BlockingContext),\n/* harmony export */   Config: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.Config),\n/* harmony export */   CosmeticFilter: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.CosmeticFilter),\n/* harmony export */   ENGINE_VERSION: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.ENGINE_VERSION),\n/* harmony export */   FilterType: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.FilterType),\n/* harmony export */   FiltersEngine: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.FiltersEngine),\n/* harmony export */   NetworkFilter: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.NetworkFilter),\n/* harmony export */   PlaywrightBlocker: () => (/* binding */ PlaywrightBlocker),\n/* harmony export */   Preprocessor: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.Preprocessor),\n/* harmony export */   Request: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.Request),\n/* harmony export */   Resources: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.Resources),\n/* harmony export */   ReverseIndex: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.ReverseIndex),\n/* harmony export */   StreamingHtmlFilter: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.StreamingHtmlFilter),\n/* harmony export */   adsAndTrackingLists: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.adsAndTrackingLists),\n/* harmony export */   adsLists: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.adsLists),\n/* harmony export */   detectFilterType: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.detectFilterType),\n/* harmony export */   f: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.f),\n/* harmony export */   fetchLists: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.fetchLists),\n/* harmony export */   fetchResources: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.fetchResources),\n/* harmony export */   fetchWithRetry: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.fetchWithRetry),\n/* harmony export */   fromPlaywrightDetails: () => (/* binding */ fromPlaywrightDetails),\n/* harmony export */   fullLists: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.fullLists),\n/* harmony export */   generateDiff: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.generateDiff),\n/* harmony export */   getHostnameHashesFromLabelsBackward: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.getHostnameHashesFromLabelsBackward),\n/* harmony export */   getLinesWithFilters: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.getLinesWithFilters),\n/* harmony export */   hasUnicode: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.hasUnicode),\n/* harmony export */   isUTF8: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.isUTF8),\n/* harmony export */   makeRequest: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.makeRequest),\n/* harmony export */   mergeDiffs: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.mergeDiffs),\n/* harmony export */   parseFilter: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.parseFilter),\n/* harmony export */   parseFilters: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.parseFilters),\n/* harmony export */   tokenize: () => (/* reexport safe */ _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.tokenize)\n/* harmony export */ });\n/* harmony import */ var tldts_experimental__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tldts-experimental */ \"(rsc)/./node_modules/tldts-experimental/dist/es6/index.js\");\n/* harmony import */ var _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ghostery/adblocker */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/index.js\");\n/* harmony import */ var _ghostery_adblocker_content__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ghostery/adblocker-content */ \"(rsc)/./node_modules/@ghostery/adblocker-content/dist/esm/index.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\nfunction sleep(milliseconds) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, milliseconds);\n    });\n}\nfunction getTopLevelUrl(frame) {\n    let sourceUrl = '';\n    while (frame !== null) {\n        sourceUrl = frame.url();\n        if (sourceUrl.length !== 0) {\n            break;\n        }\n        frame = frame.parentFrame();\n    }\n    return sourceUrl;\n}\n/**\n * Create an instance of `Request` from `pw.Request`.\n */\nfunction fromPlaywrightDetails(details) {\n    const sourceUrl = getTopLevelUrl(details.frame());\n    const url = details.url();\n    const type = details.resourceType();\n    return _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.Request.fromRawDetails({\n        _originalRequestDetails: details,\n        requestId: `${type}-${url}-${sourceUrl}`,\n        sourceUrl,\n        type,\n        url,\n    });\n}\n/**\n * Wrap `FiltersEngine` into a Playwright-friendly helper class.\n */\nclass BlockingContext {\n    constructor(page, blocker) {\n        this.page = page;\n        this.blocker = blocker;\n        this.onFrameNavigated = (frame) => blocker.onFrameNavigated(frame);\n        this.onRequest = (route) => blocker.onRequest(route);\n    }\n    async enable() {\n        if (this.blocker.config.loadCosmeticFilters === true) {\n            // Register callback to cosmetics injection (CSS + scriptlets)\n            this.page.on('framenavigated', this.onFrameNavigated);\n            this.page.once('domcontentloaded', () => {\n                this.onFrameNavigated(this.page.mainFrame());\n            });\n        }\n        if (this.blocker.config.loadNetworkFilters === true) {\n            // NOTES:\n            //  - page.setBypassCSP(enabled) might be needed to perform\n            //  injections on some pages.\n            //  - we currently do not perform CSP headers injection as there is\n            //  currently no way to modify responses in Playwright. This feature could\n            //  easily be added if Playwright implements the required capability.\n            //\n            // Register callback for network requests filtering.\n            await this.page.route('**/*', this.onRequest);\n        }\n    }\n    async disable() {\n        if (this.blocker.config.loadNetworkFilters === true) {\n            await this.page.unroute('**/*', this.onRequest);\n        }\n        if (this.blocker.config.loadCosmeticFilters === true) {\n            this.page.off('framenavigated', this.onFrameNavigated);\n        }\n    }\n}\n/**\n * Wrap `FiltersEngine` into a Playwright-friendly helper class. It exposes\n * methods to interface with Playwright APIs needed to block ads.\n */\nclass PlaywrightBlocker extends _ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.FiltersEngine {\n    constructor() {\n        super(...arguments);\n        this.contexts = new WeakMap();\n        // ----------------------------------------------------------------------- //\n        // PlaywrightBlocker-specific additions to FiltersEngine\n        // ----------------------------------------------------------------------- //\n        this.onFrameNavigated = async (frame) => {\n            try {\n                await this.onFrame(frame);\n            }\n            catch (ex) {\n                // Ignore\n            }\n        };\n        this.onFrame = async (frame) => {\n            const url = frame.url();\n            if (url === 'chrome-error://chromewebdata/') {\n                return;\n            }\n            // Look for all iframes in this context and check if they should be removed\n            // from the DOM completely. For this we check if their `src` or `href`\n            // attribute would be blocked by any network filter.\n            this.removeBlockedFrames(frame).catch(() => {\n                /* ignore */\n            });\n            const parsed = (0,tldts_experimental__WEBPACK_IMPORTED_MODULE_0__.parse)(url);\n            const hostname = parsed.hostname || '';\n            const domain = parsed.domain || '';\n            // We first query for stylesheets and scriptlets which are either generic or\n            // based on the hostname of this frame. We need to get these as fast as\n            // possible to reduce blinking when page loads.\n            {\n                const { active, styles, scripts } = this.getCosmeticsFilters({\n                    domain,\n                    hostname,\n                    url,\n                    // Done once per frame.\n                    getBaseRules: true,\n                    getInjectionRules: true,\n                    getExtendedRules: true,\n                    getRulesFromHostname: true,\n                    // Will handle DOM features (see below).\n                    getRulesFromDOM: false,\n                });\n                if (active === false) {\n                    return;\n                }\n                Promise.all([\n                    this.injectScriptletsIntoFrame(frame, scripts),\n                    this.injectStylesIntoFrame(frame, styles),\n                ]).catch(() => {\n                    /* ignore */\n                });\n            }\n            // Seconde step is to start monitoring the DOM of the page in order to\n            // inject more specific selectors based on `id`, `class`, or `href` found on\n            // nodes. We first query all of them, then monitor the DOM for a few\n            // seconds (or until one of the stopping conditions is met, see below).\n            const observer = new _ghostery_adblocker_content__WEBPACK_IMPORTED_MODULE_2__.DOMMonitor((update) => {\n                if (update.type === 'features') {\n                    const { active, styles } = this.getCosmeticsFilters({\n                        domain,\n                        hostname,\n                        url,\n                        // DOM information\n                        ...update,\n                        // Only done once per frame (see above).\n                        getBaseRules: false,\n                        getInjectionRules: false,\n                        getExtendedRules: false,\n                        getRulesFromHostname: false,\n                        // Allows to get styles for updated DOM.\n                        getRulesFromDOM: true,\n                    });\n                    // Abort if cosmetics are disabled\n                    if (active === false) {\n                        return;\n                    }\n                    this.injectStylesIntoFrame(frame, styles).catch(() => {\n                        /* ignore */\n                    });\n                }\n            });\n            // This loop will periodically check if any new custom styles should be\n            // injected in the page (using values of attributes `id`, `class`, or `href`).\n            //\n            // We stop looking in the following cases:\n            // * Frame was detached.\n            // * No new attribute was found.\n            // * Number of iterations exceeded 10 (i.e. 5 seconds).\n            // * Exception was raised.\n            //\n            // Additionally, we might stop after the first lookup if\n            // `enableMutationObserver` is disabled in config, which means that we\n            // should not actively monitor the DOM for changes.\n            let numberOfIterations = 0;\n            do {\n                if (frame.isDetached()) {\n                    break;\n                }\n                try {\n                    const foundNewFeatures = observer.handleNewFeatures(await frame.$$eval(':root', _ghostery_adblocker_content__WEBPACK_IMPORTED_MODULE_2__.extractFeaturesFromDOM));\n                    numberOfIterations += 1;\n                    if (numberOfIterations === 10) {\n                        break;\n                    }\n                    if (foundNewFeatures === false) {\n                        break;\n                    }\n                }\n                catch (ex) {\n                    break;\n                }\n                if (this.config.enableMutationObserver === false) {\n                    break;\n                }\n                await sleep(500);\n                // eslint-disable-next-line no-constant-condition\n            } while (true);\n        };\n        this.onRequest = async (route) => {\n            const details = route.request();\n            const request = fromPlaywrightDetails(details);\n            if (this.config.guessRequestTypeFromUrl === true && request.type === 'other') {\n                request.guessTypeOfRequest();\n            }\n            const frame = details.frame();\n            if (request.isMainFrame() ||\n                (request.type === 'document' && frame !== null && frame.parentFrame() === null)) {\n                route.continue();\n                return;\n            }\n            const { redirect, match } = this.match(request);\n            if (redirect !== undefined) {\n                if (redirect.contentType.endsWith(';base64')) {\n                    route.fulfill({\n                        body: Buffer.from(redirect.body, 'base64'),\n                        contentType: redirect.contentType.slice(0, -7),\n                    });\n                }\n                else {\n                    route.fulfill({\n                        body: redirect.body,\n                        contentType: redirect.contentType,\n                    });\n                }\n            }\n            else if (match === true) {\n                route.abort('blockedbyclient');\n            }\n            else {\n                route.continue();\n            }\n        };\n    }\n    // ----------------------------------------------------------------------- //\n    // Helpers to enable and disable blocking for 'browser'\n    // ----------------------------------------------------------------------- //\n    async enableBlockingInPage(page) {\n        let context = this.contexts.get(page);\n        if (context !== undefined) {\n            return context;\n        }\n        context = new BlockingContext(page, this);\n        this.contexts.set(page, context);\n        await context.enable();\n        return context;\n    }\n    async disableBlockingInPage(page) {\n        const context = this.contexts.get(page);\n        if (context === undefined) {\n            throw new Error('Trying to disable blocking which was not enabled');\n        }\n        this.contexts.delete(page);\n        await context.disable();\n    }\n    isBlockingEnabled(page) {\n        return this.contexts.has(page);\n    }\n    async injectStylesIntoFrame(frame, styles) {\n        if (styles.length !== 0) {\n            await frame.addStyleTag({\n                content: styles,\n            });\n        }\n    }\n    async injectScriptletsIntoFrame(frame, scripts) {\n        const promises = [];\n        if (scripts.length !== 0) {\n            for (const script of scripts) {\n                promises.push(frame.addScriptTag({\n                    content: (0,_ghostery_adblocker_content__WEBPACK_IMPORTED_MODULE_2__.autoRemoveScript)(script),\n                }));\n            }\n        }\n        await Promise.all(promises);\n    }\n    /**\n     * Look for sub-frames in `frame`, check if their `src` or `href` would be\n     * blocked, and then proceed to removing them from the DOM completely.\n     */\n    async removeBlockedFrames(frame) {\n        const promises = [];\n        const sourceUrl = getTopLevelUrl(frame);\n        for (const url of await frame.$$eval('iframe[src],iframe[href]', (elements) => elements.map(({ src, href }) => src || href))) {\n            const { match } = this.match(_ghostery_adblocker__WEBPACK_IMPORTED_MODULE_1__.Request.fromRawDetails({\n                url,\n                sourceUrl,\n                type: 'sub_frame',\n            }));\n            if (match) {\n                promises.push(frame\n                    .$$eval(`iframe[src=\"${url}\"],iframe[href=\"${url}\"]`, (iframes) => {\n                    var _a;\n                    for (const iframe of iframes) {\n                        (_a = iframe === null || iframe === void 0 ? void 0 : iframe.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(iframe);\n                    }\n                })\n                    .catch(() => {\n                    /* ignore */\n                }));\n            }\n        }\n        await Promise.all(promises);\n    }\n}\n// Re-export symboles from @ghostery/adblocker for convenience\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci1wbGF5d3JpZ2h0L2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkM7QUFDa0I7QUFDc0M7QUFDbkc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3REFBTztBQUNsQjtBQUNBLHNCQUFzQixLQUFLLEdBQUcsSUFBSSxHQUFHLFVBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQyw4REFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsMkJBQTJCLHlEQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1FQUFVO0FBQzNDO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRywrRUFBc0I7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkVBQWdCO0FBQzdDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLFdBQVc7QUFDbEgsb0JBQW9CLFFBQVEsYUFBYSx3REFBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDJDQUEyQyxJQUFJLGtCQUFrQixJQUFJO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29DO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci1wbGF5d3JpZ2h0L2Rpc3QvZXNtL2luZGV4LmpzPzU3MjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCBHaG9zdGVyeSBHbWJILiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJ3RsZHRzLWV4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBGaWx0ZXJzRW5naW5lLCBSZXF1ZXN0IH0gZnJvbSAnQGdob3N0ZXJ5L2FkYmxvY2tlcic7XG5pbXBvcnQgeyBhdXRvUmVtb3ZlU2NyaXB0LCBleHRyYWN0RmVhdHVyZXNGcm9tRE9NLCBET01Nb25pdG9yIH0gZnJvbSAnQGdob3N0ZXJ5L2FkYmxvY2tlci1jb250ZW50JztcbmZ1bmN0aW9uIHNsZWVwKG1pbGxpc2Vjb25kcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1pbGxpc2Vjb25kcyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRUb3BMZXZlbFVybChmcmFtZSkge1xuICAgIGxldCBzb3VyY2VVcmwgPSAnJztcbiAgICB3aGlsZSAoZnJhbWUgIT09IG51bGwpIHtcbiAgICAgICAgc291cmNlVXJsID0gZnJhbWUudXJsKCk7XG4gICAgICAgIGlmIChzb3VyY2VVcmwubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmcmFtZSA9IGZyYW1lLnBhcmVudEZyYW1lKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VVcmw7XG59XG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBgUmVxdWVzdGAgZnJvbSBgcHcuUmVxdWVzdGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUGxheXdyaWdodERldGFpbHMoZGV0YWlscykge1xuICAgIGNvbnN0IHNvdXJjZVVybCA9IGdldFRvcExldmVsVXJsKGRldGFpbHMuZnJhbWUoKSk7XG4gICAgY29uc3QgdXJsID0gZGV0YWlscy51cmwoKTtcbiAgICBjb25zdCB0eXBlID0gZGV0YWlscy5yZXNvdXJjZVR5cGUoKTtcbiAgICByZXR1cm4gUmVxdWVzdC5mcm9tUmF3RGV0YWlscyh7XG4gICAgICAgIF9vcmlnaW5hbFJlcXVlc3REZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICByZXF1ZXN0SWQ6IGAke3R5cGV9LSR7dXJsfS0ke3NvdXJjZVVybH1gLFxuICAgICAgICBzb3VyY2VVcmwsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHVybCxcbiAgICB9KTtcbn1cbi8qKlxuICogV3JhcCBgRmlsdGVyc0VuZ2luZWAgaW50byBhIFBsYXl3cmlnaHQtZnJpZW5kbHkgaGVscGVyIGNsYXNzLlxuICovXG5leHBvcnQgY2xhc3MgQmxvY2tpbmdDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihwYWdlLCBibG9ja2VyKSB7XG4gICAgICAgIHRoaXMucGFnZSA9IHBhZ2U7XG4gICAgICAgIHRoaXMuYmxvY2tlciA9IGJsb2NrZXI7XG4gICAgICAgIHRoaXMub25GcmFtZU5hdmlnYXRlZCA9IChmcmFtZSkgPT4gYmxvY2tlci5vbkZyYW1lTmF2aWdhdGVkKGZyYW1lKTtcbiAgICAgICAgdGhpcy5vblJlcXVlc3QgPSAocm91dGUpID0+IGJsb2NrZXIub25SZXF1ZXN0KHJvdXRlKTtcbiAgICB9XG4gICAgYXN5bmMgZW5hYmxlKCkge1xuICAgICAgICBpZiAodGhpcy5ibG9ja2VyLmNvbmZpZy5sb2FkQ29zbWV0aWNGaWx0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBSZWdpc3RlciBjYWxsYmFjayB0byBjb3NtZXRpY3MgaW5qZWN0aW9uIChDU1MgKyBzY3JpcHRsZXRzKVxuICAgICAgICAgICAgdGhpcy5wYWdlLm9uKCdmcmFtZW5hdmlnYXRlZCcsIHRoaXMub25GcmFtZU5hdmlnYXRlZCk7XG4gICAgICAgICAgICB0aGlzLnBhZ2Uub25jZSgnZG9tY29udGVudGxvYWRlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRnJhbWVOYXZpZ2F0ZWQodGhpcy5wYWdlLm1haW5GcmFtZSgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJsb2NrZXIuY29uZmlnLmxvYWROZXR3b3JrRmlsdGVycyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gTk9URVM6XG4gICAgICAgICAgICAvLyAgLSBwYWdlLnNldEJ5cGFzc0NTUChlbmFibGVkKSBtaWdodCBiZSBuZWVkZWQgdG8gcGVyZm9ybVxuICAgICAgICAgICAgLy8gIGluamVjdGlvbnMgb24gc29tZSBwYWdlcy5cbiAgICAgICAgICAgIC8vICAtIHdlIGN1cnJlbnRseSBkbyBub3QgcGVyZm9ybSBDU1AgaGVhZGVycyBpbmplY3Rpb24gYXMgdGhlcmUgaXNcbiAgICAgICAgICAgIC8vICBjdXJyZW50bHkgbm8gd2F5IHRvIG1vZGlmeSByZXNwb25zZXMgaW4gUGxheXdyaWdodC4gVGhpcyBmZWF0dXJlIGNvdWxkXG4gICAgICAgICAgICAvLyAgZWFzaWx5IGJlIGFkZGVkIGlmIFBsYXl3cmlnaHQgaW1wbGVtZW50cyB0aGUgcmVxdWlyZWQgY2FwYWJpbGl0eS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBSZWdpc3RlciBjYWxsYmFjayBmb3IgbmV0d29yayByZXF1ZXN0cyBmaWx0ZXJpbmcuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBhZ2Uucm91dGUoJyoqLyonLCB0aGlzLm9uUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGlzYWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tlci5jb25maWcubG9hZE5ldHdvcmtGaWx0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBhZ2UudW5yb3V0ZSgnKiovKicsIHRoaXMub25SZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ibG9ja2VyLmNvbmZpZy5sb2FkQ29zbWV0aWNGaWx0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2Uub2ZmKCdmcmFtZW5hdmlnYXRlZCcsIHRoaXMub25GcmFtZU5hdmlnYXRlZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFdyYXAgYEZpbHRlcnNFbmdpbmVgIGludG8gYSBQbGF5d3JpZ2h0LWZyaWVuZGx5IGhlbHBlciBjbGFzcy4gSXQgZXhwb3Nlc1xuICogbWV0aG9kcyB0byBpbnRlcmZhY2Ugd2l0aCBQbGF5d3JpZ2h0IEFQSXMgbmVlZGVkIHRvIGJsb2NrIGFkcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFBsYXl3cmlnaHRCbG9ja2VyIGV4dGVuZHMgRmlsdGVyc0VuZ2luZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICAgICAgICAvLyBQbGF5d3JpZ2h0QmxvY2tlci1zcGVjaWZpYyBhZGRpdGlvbnMgdG8gRmlsdGVyc0VuZ2luZVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICAgICAgICB0aGlzLm9uRnJhbWVOYXZpZ2F0ZWQgPSBhc3luYyAoZnJhbWUpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vbkZyYW1lKGZyYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRnJhbWUgPSBhc3luYyAoZnJhbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGZyYW1lLnVybCgpO1xuICAgICAgICAgICAgaWYgKHVybCA9PT0gJ2Nocm9tZS1lcnJvcjovL2Nocm9tZXdlYmRhdGEvJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExvb2sgZm9yIGFsbCBpZnJhbWVzIGluIHRoaXMgY29udGV4dCBhbmQgY2hlY2sgaWYgdGhleSBzaG91bGQgYmUgcmVtb3ZlZFxuICAgICAgICAgICAgLy8gZnJvbSB0aGUgRE9NIGNvbXBsZXRlbHkuIEZvciB0aGlzIHdlIGNoZWNrIGlmIHRoZWlyIGBzcmNgIG9yIGBocmVmYFxuICAgICAgICAgICAgLy8gYXR0cmlidXRlIHdvdWxkIGJlIGJsb2NrZWQgYnkgYW55IG5ldHdvcmsgZmlsdGVyLlxuICAgICAgICAgICAgdGhpcy5yZW1vdmVCbG9ja2VkRnJhbWVzKGZyYW1lKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLyogaWdub3JlICovXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHVybCk7XG4gICAgICAgICAgICBjb25zdCBob3N0bmFtZSA9IHBhcnNlZC5ob3N0bmFtZSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IHBhcnNlZC5kb21haW4gfHwgJyc7XG4gICAgICAgICAgICAvLyBXZSBmaXJzdCBxdWVyeSBmb3Igc3R5bGVzaGVldHMgYW5kIHNjcmlwdGxldHMgd2hpY2ggYXJlIGVpdGhlciBnZW5lcmljIG9yXG4gICAgICAgICAgICAvLyBiYXNlZCBvbiB0aGUgaG9zdG5hbWUgb2YgdGhpcyBmcmFtZS4gV2UgbmVlZCB0byBnZXQgdGhlc2UgYXMgZmFzdCBhc1xuICAgICAgICAgICAgLy8gcG9zc2libGUgdG8gcmVkdWNlIGJsaW5raW5nIHdoZW4gcGFnZSBsb2Fkcy5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFjdGl2ZSwgc3R5bGVzLCBzY3JpcHRzIH0gPSB0aGlzLmdldENvc21ldGljc0ZpbHRlcnMoe1xuICAgICAgICAgICAgICAgICAgICBkb21haW4sXG4gICAgICAgICAgICAgICAgICAgIGhvc3RuYW1lLFxuICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIC8vIERvbmUgb25jZSBwZXIgZnJhbWUuXG4gICAgICAgICAgICAgICAgICAgIGdldEJhc2VSdWxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0SW5qZWN0aW9uUnVsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldEV4dGVuZGVkUnVsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldFJ1bGVzRnJvbUhvc3RuYW1lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAvLyBXaWxsIGhhbmRsZSBET00gZmVhdHVyZXMgKHNlZSBiZWxvdykuXG4gICAgICAgICAgICAgICAgICAgIGdldFJ1bGVzRnJvbURPTTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5qZWN0U2NyaXB0bGV0c0ludG9GcmFtZShmcmFtZSwgc2NyaXB0cyksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5qZWN0U3R5bGVzSW50b0ZyYW1lKGZyYW1lLCBzdHlsZXMpLFxuICAgICAgICAgICAgICAgIF0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogaWdub3JlICovXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZWNvbmRlIHN0ZXAgaXMgdG8gc3RhcnQgbW9uaXRvcmluZyB0aGUgRE9NIG9mIHRoZSBwYWdlIGluIG9yZGVyIHRvXG4gICAgICAgICAgICAvLyBpbmplY3QgbW9yZSBzcGVjaWZpYyBzZWxlY3RvcnMgYmFzZWQgb24gYGlkYCwgYGNsYXNzYCwgb3IgYGhyZWZgIGZvdW5kIG9uXG4gICAgICAgICAgICAvLyBub2Rlcy4gV2UgZmlyc3QgcXVlcnkgYWxsIG9mIHRoZW0sIHRoZW4gbW9uaXRvciB0aGUgRE9NIGZvciBhIGZld1xuICAgICAgICAgICAgLy8gc2Vjb25kcyAob3IgdW50aWwgb25lIG9mIHRoZSBzdG9wcGluZyBjb25kaXRpb25zIGlzIG1ldCwgc2VlIGJlbG93KS5cbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IERPTU1vbml0b3IoKHVwZGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGUudHlwZSA9PT0gJ2ZlYXR1cmVzJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGFjdGl2ZSwgc3R5bGVzIH0gPSB0aGlzLmdldENvc21ldGljc0ZpbHRlcnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBET00gaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnVwZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgZG9uZSBvbmNlIHBlciBmcmFtZSAoc2VlIGFib3ZlKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEJhc2VSdWxlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRJbmplY3Rpb25SdWxlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRFeHRlbmRlZFJ1bGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFJ1bGVzRnJvbUhvc3RuYW1lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93cyB0byBnZXQgc3R5bGVzIGZvciB1cGRhdGVkIERPTS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFJ1bGVzRnJvbURPTTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFib3J0IGlmIGNvc21ldGljcyBhcmUgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluamVjdFN0eWxlc0ludG9GcmFtZShmcmFtZSwgc3R5bGVzKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBpZ25vcmUgKi9cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBUaGlzIGxvb3Agd2lsbCBwZXJpb2RpY2FsbHkgY2hlY2sgaWYgYW55IG5ldyBjdXN0b20gc3R5bGVzIHNob3VsZCBiZVxuICAgICAgICAgICAgLy8gaW5qZWN0ZWQgaW4gdGhlIHBhZ2UgKHVzaW5nIHZhbHVlcyBvZiBhdHRyaWJ1dGVzIGBpZGAsIGBjbGFzc2AsIG9yIGBocmVmYCkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gV2Ugc3RvcCBsb29raW5nIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgICAgICAgICAvLyAqIEZyYW1lIHdhcyBkZXRhY2hlZC5cbiAgICAgICAgICAgIC8vICogTm8gbmV3IGF0dHJpYnV0ZSB3YXMgZm91bmQuXG4gICAgICAgICAgICAvLyAqIE51bWJlciBvZiBpdGVyYXRpb25zIGV4Y2VlZGVkIDEwIChpLmUuIDUgc2Vjb25kcykuXG4gICAgICAgICAgICAvLyAqIEV4Y2VwdGlvbiB3YXMgcmFpc2VkLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEFkZGl0aW9uYWxseSwgd2UgbWlnaHQgc3RvcCBhZnRlciB0aGUgZmlyc3QgbG9va3VwIGlmXG4gICAgICAgICAgICAvLyBgZW5hYmxlTXV0YXRpb25PYnNlcnZlcmAgaXMgZGlzYWJsZWQgaW4gY29uZmlnLCB3aGljaCBtZWFucyB0aGF0IHdlXG4gICAgICAgICAgICAvLyBzaG91bGQgbm90IGFjdGl2ZWx5IG1vbml0b3IgdGhlIERPTSBmb3IgY2hhbmdlcy5cbiAgICAgICAgICAgIGxldCBudW1iZXJPZkl0ZXJhdGlvbnMgPSAwO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZS5pc0RldGFjaGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kTmV3RmVhdHVyZXMgPSBvYnNlcnZlci5oYW5kbGVOZXdGZWF0dXJlcyhhd2FpdCBmcmFtZS4kJGV2YWwoJzpyb290JywgZXh0cmFjdEZlYXR1cmVzRnJvbURPTSkpO1xuICAgICAgICAgICAgICAgICAgICBudW1iZXJPZkl0ZXJhdGlvbnMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bWJlck9mSXRlcmF0aW9ucyA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZE5ld0ZlYXR1cmVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlTXV0YXRpb25PYnNlcnZlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKDUwMCk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25SZXF1ZXN0ID0gYXN5bmMgKHJvdXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXRhaWxzID0gcm91dGUucmVxdWVzdCgpO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGZyb21QbGF5d3JpZ2h0RGV0YWlscyhkZXRhaWxzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5ndWVzc1JlcXVlc3RUeXBlRnJvbVVybCA9PT0gdHJ1ZSAmJiByZXF1ZXN0LnR5cGUgPT09ICdvdGhlcicpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lmd1ZXNzVHlwZU9mUmVxdWVzdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnJhbWUgPSBkZXRhaWxzLmZyYW1lKCk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5pc01haW5GcmFtZSgpIHx8XG4gICAgICAgICAgICAgICAgKHJlcXVlc3QudHlwZSA9PT0gJ2RvY3VtZW50JyAmJiBmcmFtZSAhPT0gbnVsbCAmJiBmcmFtZS5wYXJlbnRGcmFtZSgpID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIHJvdXRlLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyByZWRpcmVjdCwgbWF0Y2ggfSA9IHRoaXMubWF0Y2gocmVxdWVzdCk7XG4gICAgICAgICAgICBpZiAocmVkaXJlY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdC5jb250ZW50VHlwZS5lbmRzV2l0aCgnO2Jhc2U2NCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlLmZ1bGZpbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogQnVmZmVyLmZyb20ocmVkaXJlY3QuYm9keSwgJ2Jhc2U2NCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IHJlZGlyZWN0LmNvbnRlbnRUeXBlLnNsaWNlKDAsIC03KSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZS5mdWxmaWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHJlZGlyZWN0LmJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogcmVkaXJlY3QuY29udGVudFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcm91dGUuYWJvcnQoJ2Jsb2NrZWRieWNsaWVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm91dGUuY29udGludWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbiAgICAvLyBIZWxwZXJzIHRvIGVuYWJsZSBhbmQgZGlzYWJsZSBibG9ja2luZyBmb3IgJ2Jyb3dzZXInXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbiAgICBhc3luYyBlbmFibGVCbG9ja2luZ0luUGFnZShwYWdlKSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5jb250ZXh0cy5nZXQocGFnZSk7XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQgPSBuZXcgQmxvY2tpbmdDb250ZXh0KHBhZ2UsIHRoaXMpO1xuICAgICAgICB0aGlzLmNvbnRleHRzLnNldChwYWdlLCBjb250ZXh0KTtcbiAgICAgICAgYXdhaXQgY29udGV4dC5lbmFibGUoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIGFzeW5jIGRpc2FibGVCbG9ja2luZ0luUGFnZShwYWdlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRzLmdldChwYWdlKTtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gZGlzYWJsZSBibG9ja2luZyB3aGljaCB3YXMgbm90IGVuYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRleHRzLmRlbGV0ZShwYWdlKTtcbiAgICAgICAgYXdhaXQgY29udGV4dC5kaXNhYmxlKCk7XG4gICAgfVxuICAgIGlzQmxvY2tpbmdFbmFibGVkKHBhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dHMuaGFzKHBhZ2UpO1xuICAgIH1cbiAgICBhc3luYyBpbmplY3RTdHlsZXNJbnRvRnJhbWUoZnJhbWUsIHN0eWxlcykge1xuICAgICAgICBpZiAoc3R5bGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgYXdhaXQgZnJhbWUuYWRkU3R5bGVUYWcoe1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHN0eWxlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGluamVjdFNjcmlwdGxldHNJbnRvRnJhbWUoZnJhbWUsIHNjcmlwdHMpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgaWYgKHNjcmlwdHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjcmlwdCBvZiBzY3JpcHRzKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChmcmFtZS5hZGRTY3JpcHRUYWcoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBhdXRvUmVtb3ZlU2NyaXB0KHNjcmlwdCksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9vayBmb3Igc3ViLWZyYW1lcyBpbiBgZnJhbWVgLCBjaGVjayBpZiB0aGVpciBgc3JjYCBvciBgaHJlZmAgd291bGQgYmVcbiAgICAgKiBibG9ja2VkLCBhbmQgdGhlbiBwcm9jZWVkIHRvIHJlbW92aW5nIHRoZW0gZnJvbSB0aGUgRE9NIGNvbXBsZXRlbHkuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlQmxvY2tlZEZyYW1lcyhmcmFtZSkge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBjb25zdCBzb3VyY2VVcmwgPSBnZXRUb3BMZXZlbFVybChmcmFtZSk7XG4gICAgICAgIGZvciAoY29uc3QgdXJsIG9mIGF3YWl0IGZyYW1lLiQkZXZhbCgnaWZyYW1lW3NyY10saWZyYW1lW2hyZWZdJywgKGVsZW1lbnRzKSA9PiBlbGVtZW50cy5tYXAoKHsgc3JjLCBocmVmIH0pID0+IHNyYyB8fCBocmVmKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbWF0Y2ggfSA9IHRoaXMubWF0Y2goUmVxdWVzdC5mcm9tUmF3RGV0YWlscyh7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIHNvdXJjZVVybCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3ViX2ZyYW1lJyxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgLiQkZXZhbChgaWZyYW1lW3NyYz1cIiR7dXJsfVwiXSxpZnJhbWVbaHJlZj1cIiR7dXJsfVwiXWAsIChpZnJhbWVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpZnJhbWUgb2YgaWZyYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gaWZyYW1lID09PSBudWxsIHx8IGlmcmFtZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaWZyYW1lLnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogaWdub3JlICovXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG59XG4vLyBSZS1leHBvcnQgc3ltYm9sZXMgZnJvbSBAZ2hvc3RlcnkvYWRibG9ja2VyIGZvciBjb252ZW5pZW5jZVxuZXhwb3J0ICogZnJvbSAnQGdob3N0ZXJ5L2FkYmxvY2tlcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker-playwright/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/cosmetic-selector.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/codebooks/cosmetic-selector.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/* eslint-disable prettier/prettier */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([\n    \", document.addEventListene\",\n    \", document.createElement, \",\n    \", document.getElementById,\",\n    \"%5Bhref%5E%3D%22https%3A%2\",\n    \"aopr, app_vars.force_disab\",\n    \"%22%3A%22denied%22%2C%22\",\n    \"aeld, DOMContentLoaded, \",\n    \"nosiif, visibility, 1000\",\n    \"set-local-storage-item, \",\n    \"acs, addEventListener, \",\n    \"trusted-click-element, \",\n    \"-if, googlesyndication\",\n    \"_ENSIGHTEN_PRIVACY_\",\n    \"set, blurred, false\",\n    \"[target=\\\"_blank\\\"]\",\n    \"%22%3Afalse%2C%22\",\n    \"[href^=\\\"https://\",\n    \"%22%3Atrue%2C%22\",\n    \"[href^=\\\"http://\",\n    \"[data-testid=\\\"\",\n    \"%22%3Afalse%7D\",\n    \"rmnt, script, \",\n    \", , reload, 1\",\n    \"BlockDetected\",\n    \"onselectstart\",\n    \"div[class^=\\\"\",\n    \"trusted-set-\",\n    \", document.\",\n    \".prototype.\",\n    \"contextmenu\",\n    \"leaderboard\",\n    \"otification\",\n    \":has-text(\",\n    \"background\",\n    \"analytics\",\n    \"container\",\n    \"Container\",\n    \"decodeURI\",\n    \"div[id^=\\\"\",\n    \"div[style\",\n    \"no-xhr-if\",\n    \"placehold\",\n    \"[href*=\\\"\",\n    \"AAAAAAAA\",\n    \"backdrop\",\n    \"disclaim\",\n    \"https://\",\n    \"no-fetch\",\n    \"noopFunc\",\n    \".com/\\\"]\",\n    \"article\",\n    \"consent\",\n    \"Consent\",\n    \"content\",\n    \"display\",\n    \"keydown\",\n    \"message\",\n    \"overlay\",\n    \"privacy\",\n    \"product\",\n    \"sidebar\",\n    \"sponsor\",\n    \"wrapper\",\n    \"-child\",\n    \"[class\",\n    \"[data-\",\n    \"accept\",\n    \"banner\",\n    \"bottom\",\n    \"button\",\n    \"cookie\",\n    \"Cookie\",\n    \"COOKIE\",\n    \"google\",\n    \"necess\",\n    \"nostif\",\n    \"notice\",\n    \"nowoif\",\n    \"policy\",\n    \"Policy\",\n    \"script\",\n    \"widget\",\n    \":has(\",\n    \":not(\",\n    \"Accep\",\n    \"block\",\n    \"Block\",\n    \"click\",\n    \"disab\",\n    \"false\",\n    \"fixed\",\n    \"frame\",\n    \"modal\",\n    \"popup\",\n    \"taboo\",\n    \".com\",\n    \"0px;\",\n    \"2%3A\",\n    \"2%5D\",\n    \"aeld\",\n    \"aopr\",\n    \"body\",\n    \"foot\",\n    \"gdpr\",\n    \"html\",\n    \"icky\",\n    \"ight\",\n    \"Info\",\n    \"set-\",\n    \"show\",\n    \"tion\",\n    \"true\",\n    \"www.\",\n    \" > \",\n    \"%3A\",\n    \"%3D\",\n    \"%5B\",\n    \"%5C\",\n    \"522\",\n    \"52C\",\n    \"53A\",\n    \"age\",\n    \"app\",\n    \"box\",\n    \"div\",\n    \"dow\",\n    \"ent\",\n    \"out\",\n    \"rap\",\n    \"top\",\n    \"__\",\n    \", \",\n    \": \",\n    \".m\",\n    \"\\\"]\",\n    \"%2\",\n    \"%7\",\n    \"=\\\"\",\n    \"00\",\n    \"ac\",\n    \"ad\",\n    \"Ad\",\n    \"al\",\n    \"an\",\n    \"ar\",\n    \"at\",\n    \"de\",\n    \"e-\",\n    \"ed\",\n    \"el\",\n    \"en\",\n    \"er\",\n    \"es\",\n    \"et\",\n    \"g-\",\n    \"he\",\n    \"id\",\n    \"im\",\n    \"in\",\n    \"is\",\n    \"it\",\n    \"la\",\n    \"le\",\n    \"li\",\n    \"lo\",\n    \"o-\",\n    \"ol\",\n    \"om\",\n    \"on\",\n    \"op\",\n    \"or\",\n    \"ra\",\n    \"re\",\n    \"ro\",\n    \"s_\",\n    \"s-\",\n    \"se\",\n    \"si\",\n    \"sp\",\n    \"st\",\n    \"t-\",\n    \"te\",\n    \"ti\",\n    \"tr\",\n    \"un\",\n    \" \",\n    \"_\",\n    \"-\",\n    \";\",\n    \":\",\n    \".\",\n    \"(\",\n    \")\",\n    \"[\",\n    \"]\",\n    \"*\",\n    \"/\",\n    \"#\",\n    \"^\",\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"a\",\n    \"b\",\n    \"B\",\n    \"c\",\n    \"C\",\n    \"d\",\n    \"D\",\n    \"e\",\n    \"E\",\n    \"f\",\n    \"F\",\n    \"g\",\n    \"G\",\n    \"h\",\n    \"H\",\n    \"i\",\n    \"I\",\n    \"j\",\n    \"k\",\n    \"l\",\n    \"L\",\n    \"m\",\n    \"M\",\n    \"n\",\n    \"N\",\n    \"o\",\n    \"O\",\n    \"p\",\n    \"P\",\n    \"q\",\n    \"r\",\n    \"R\",\n    \"s\",\n    \"S\",\n    \"t\",\n    \"T\",\n    \"u\",\n    \"U\",\n    \"v\",\n    \"V\",\n    \"w\",\n    \"W\",\n    \"x\",\n    \"y\",\n    \"z\"\n]);\n//# sourceMappingURL=cosmetic-selector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9jb2RlYm9va3MvY29zbWV0aWMtc2VsZWN0b3IuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvYWRibG9ja2VyL2Rpc3QvZXNtL2NvZGVib29rcy9jb3NtZXRpYy1zZWxlY3Rvci5qcz85OWFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQgR2hvc3RlcnkgR21iSC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgcHJldHRpZXIvcHJldHRpZXIgKi9cbmV4cG9ydCBkZWZhdWx0IFtcbiAgICBcIiwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lXCIsXG4gICAgXCIsIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQsIFwiLFxuICAgIFwiLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCxcIixcbiAgICBcIiU1QmhyZWYlNUUlM0QlMjJodHRwcyUzQSUyXCIsXG4gICAgXCJhb3ByLCBhcHBfdmFycy5mb3JjZV9kaXNhYlwiLFxuICAgIFwiJTIyJTNBJTIyZGVuaWVkJTIyJTJDJTIyXCIsXG4gICAgXCJhZWxkLCBET01Db250ZW50TG9hZGVkLCBcIixcbiAgICBcIm5vc2lpZiwgdmlzaWJpbGl0eSwgMTAwMFwiLFxuICAgIFwic2V0LWxvY2FsLXN0b3JhZ2UtaXRlbSwgXCIsXG4gICAgXCJhY3MsIGFkZEV2ZW50TGlzdGVuZXIsIFwiLFxuICAgIFwidHJ1c3RlZC1jbGljay1lbGVtZW50LCBcIixcbiAgICBcIi1pZiwgZ29vZ2xlc3luZGljYXRpb25cIixcbiAgICBcIl9FTlNJR0hURU5fUFJJVkFDWV9cIixcbiAgICBcInNldCwgYmx1cnJlZCwgZmFsc2VcIixcbiAgICBcIlt0YXJnZXQ9XFxcIl9ibGFua1xcXCJdXCIsXG4gICAgXCIlMjIlM0FmYWxzZSUyQyUyMlwiLFxuICAgIFwiW2hyZWZePVxcXCJodHRwczovL1wiLFxuICAgIFwiJTIyJTNBdHJ1ZSUyQyUyMlwiLFxuICAgIFwiW2hyZWZePVxcXCJodHRwOi8vXCIsXG4gICAgXCJbZGF0YS10ZXN0aWQ9XFxcIlwiLFxuICAgIFwiJTIyJTNBZmFsc2UlN0RcIixcbiAgICBcInJtbnQsIHNjcmlwdCwgXCIsXG4gICAgXCIsICwgcmVsb2FkLCAxXCIsXG4gICAgXCJCbG9ja0RldGVjdGVkXCIsXG4gICAgXCJvbnNlbGVjdHN0YXJ0XCIsXG4gICAgXCJkaXZbY2xhc3NePVxcXCJcIixcbiAgICBcInRydXN0ZWQtc2V0LVwiLFxuICAgIFwiLCBkb2N1bWVudC5cIixcbiAgICBcIi5wcm90b3R5cGUuXCIsXG4gICAgXCJjb250ZXh0bWVudVwiLFxuICAgIFwibGVhZGVyYm9hcmRcIixcbiAgICBcIm90aWZpY2F0aW9uXCIsXG4gICAgXCI6aGFzLXRleHQoXCIsXG4gICAgXCJiYWNrZ3JvdW5kXCIsXG4gICAgXCJhbmFseXRpY3NcIixcbiAgICBcImNvbnRhaW5lclwiLFxuICAgIFwiQ29udGFpbmVyXCIsXG4gICAgXCJkZWNvZGVVUklcIixcbiAgICBcImRpdltpZF49XFxcIlwiLFxuICAgIFwiZGl2W3N0eWxlXCIsXG4gICAgXCJuby14aHItaWZcIixcbiAgICBcInBsYWNlaG9sZFwiLFxuICAgIFwiW2hyZWYqPVxcXCJcIixcbiAgICBcIkFBQUFBQUFBXCIsXG4gICAgXCJiYWNrZHJvcFwiLFxuICAgIFwiZGlzY2xhaW1cIixcbiAgICBcImh0dHBzOi8vXCIsXG4gICAgXCJuby1mZXRjaFwiLFxuICAgIFwibm9vcEZ1bmNcIixcbiAgICBcIi5jb20vXFxcIl1cIixcbiAgICBcImFydGljbGVcIixcbiAgICBcImNvbnNlbnRcIixcbiAgICBcIkNvbnNlbnRcIixcbiAgICBcImNvbnRlbnRcIixcbiAgICBcImRpc3BsYXlcIixcbiAgICBcImtleWRvd25cIixcbiAgICBcIm1lc3NhZ2VcIixcbiAgICBcIm92ZXJsYXlcIixcbiAgICBcInByaXZhY3lcIixcbiAgICBcInByb2R1Y3RcIixcbiAgICBcInNpZGViYXJcIixcbiAgICBcInNwb25zb3JcIixcbiAgICBcIndyYXBwZXJcIixcbiAgICBcIi1jaGlsZFwiLFxuICAgIFwiW2NsYXNzXCIsXG4gICAgXCJbZGF0YS1cIixcbiAgICBcImFjY2VwdFwiLFxuICAgIFwiYmFubmVyXCIsXG4gICAgXCJib3R0b21cIixcbiAgICBcImJ1dHRvblwiLFxuICAgIFwiY29va2llXCIsXG4gICAgXCJDb29raWVcIixcbiAgICBcIkNPT0tJRVwiLFxuICAgIFwiZ29vZ2xlXCIsXG4gICAgXCJuZWNlc3NcIixcbiAgICBcIm5vc3RpZlwiLFxuICAgIFwibm90aWNlXCIsXG4gICAgXCJub3dvaWZcIixcbiAgICBcInBvbGljeVwiLFxuICAgIFwiUG9saWN5XCIsXG4gICAgXCJzY3JpcHRcIixcbiAgICBcIndpZGdldFwiLFxuICAgIFwiOmhhcyhcIixcbiAgICBcIjpub3QoXCIsXG4gICAgXCJBY2NlcFwiLFxuICAgIFwiYmxvY2tcIixcbiAgICBcIkJsb2NrXCIsXG4gICAgXCJjbGlja1wiLFxuICAgIFwiZGlzYWJcIixcbiAgICBcImZhbHNlXCIsXG4gICAgXCJmaXhlZFwiLFxuICAgIFwiZnJhbWVcIixcbiAgICBcIm1vZGFsXCIsXG4gICAgXCJwb3B1cFwiLFxuICAgIFwidGFib29cIixcbiAgICBcIi5jb21cIixcbiAgICBcIjBweDtcIixcbiAgICBcIjIlM0FcIixcbiAgICBcIjIlNURcIixcbiAgICBcImFlbGRcIixcbiAgICBcImFvcHJcIixcbiAgICBcImJvZHlcIixcbiAgICBcImZvb3RcIixcbiAgICBcImdkcHJcIixcbiAgICBcImh0bWxcIixcbiAgICBcImlja3lcIixcbiAgICBcImlnaHRcIixcbiAgICBcIkluZm9cIixcbiAgICBcInNldC1cIixcbiAgICBcInNob3dcIixcbiAgICBcInRpb25cIixcbiAgICBcInRydWVcIixcbiAgICBcInd3dy5cIixcbiAgICBcIiA+IFwiLFxuICAgIFwiJTNBXCIsXG4gICAgXCIlM0RcIixcbiAgICBcIiU1QlwiLFxuICAgIFwiJTVDXCIsXG4gICAgXCI1MjJcIixcbiAgICBcIjUyQ1wiLFxuICAgIFwiNTNBXCIsXG4gICAgXCJhZ2VcIixcbiAgICBcImFwcFwiLFxuICAgIFwiYm94XCIsXG4gICAgXCJkaXZcIixcbiAgICBcImRvd1wiLFxuICAgIFwiZW50XCIsXG4gICAgXCJvdXRcIixcbiAgICBcInJhcFwiLFxuICAgIFwidG9wXCIsXG4gICAgXCJfX1wiLFxuICAgIFwiLCBcIixcbiAgICBcIjogXCIsXG4gICAgXCIubVwiLFxuICAgIFwiXFxcIl1cIixcbiAgICBcIiUyXCIsXG4gICAgXCIlN1wiLFxuICAgIFwiPVxcXCJcIixcbiAgICBcIjAwXCIsXG4gICAgXCJhY1wiLFxuICAgIFwiYWRcIixcbiAgICBcIkFkXCIsXG4gICAgXCJhbFwiLFxuICAgIFwiYW5cIixcbiAgICBcImFyXCIsXG4gICAgXCJhdFwiLFxuICAgIFwiZGVcIixcbiAgICBcImUtXCIsXG4gICAgXCJlZFwiLFxuICAgIFwiZWxcIixcbiAgICBcImVuXCIsXG4gICAgXCJlclwiLFxuICAgIFwiZXNcIixcbiAgICBcImV0XCIsXG4gICAgXCJnLVwiLFxuICAgIFwiaGVcIixcbiAgICBcImlkXCIsXG4gICAgXCJpbVwiLFxuICAgIFwiaW5cIixcbiAgICBcImlzXCIsXG4gICAgXCJpdFwiLFxuICAgIFwibGFcIixcbiAgICBcImxlXCIsXG4gICAgXCJsaVwiLFxuICAgIFwibG9cIixcbiAgICBcIm8tXCIsXG4gICAgXCJvbFwiLFxuICAgIFwib21cIixcbiAgICBcIm9uXCIsXG4gICAgXCJvcFwiLFxuICAgIFwib3JcIixcbiAgICBcInJhXCIsXG4gICAgXCJyZVwiLFxuICAgIFwicm9cIixcbiAgICBcInNfXCIsXG4gICAgXCJzLVwiLFxuICAgIFwic2VcIixcbiAgICBcInNpXCIsXG4gICAgXCJzcFwiLFxuICAgIFwic3RcIixcbiAgICBcInQtXCIsXG4gICAgXCJ0ZVwiLFxuICAgIFwidGlcIixcbiAgICBcInRyXCIsXG4gICAgXCJ1blwiLFxuICAgIFwiIFwiLFxuICAgIFwiX1wiLFxuICAgIFwiLVwiLFxuICAgIFwiO1wiLFxuICAgIFwiOlwiLFxuICAgIFwiLlwiLFxuICAgIFwiKFwiLFxuICAgIFwiKVwiLFxuICAgIFwiW1wiLFxuICAgIFwiXVwiLFxuICAgIFwiKlwiLFxuICAgIFwiL1wiLFxuICAgIFwiI1wiLFxuICAgIFwiXlwiLFxuICAgIFwiMFwiLFxuICAgIFwiMVwiLFxuICAgIFwiMlwiLFxuICAgIFwiM1wiLFxuICAgIFwiNFwiLFxuICAgIFwiNVwiLFxuICAgIFwiNlwiLFxuICAgIFwiN1wiLFxuICAgIFwiOFwiLFxuICAgIFwiOVwiLFxuICAgIFwiYVwiLFxuICAgIFwiYlwiLFxuICAgIFwiQlwiLFxuICAgIFwiY1wiLFxuICAgIFwiQ1wiLFxuICAgIFwiZFwiLFxuICAgIFwiRFwiLFxuICAgIFwiZVwiLFxuICAgIFwiRVwiLFxuICAgIFwiZlwiLFxuICAgIFwiRlwiLFxuICAgIFwiZ1wiLFxuICAgIFwiR1wiLFxuICAgIFwiaFwiLFxuICAgIFwiSFwiLFxuICAgIFwiaVwiLFxuICAgIFwiSVwiLFxuICAgIFwialwiLFxuICAgIFwia1wiLFxuICAgIFwibFwiLFxuICAgIFwiTFwiLFxuICAgIFwibVwiLFxuICAgIFwiTVwiLFxuICAgIFwiblwiLFxuICAgIFwiTlwiLFxuICAgIFwib1wiLFxuICAgIFwiT1wiLFxuICAgIFwicFwiLFxuICAgIFwiUFwiLFxuICAgIFwicVwiLFxuICAgIFwiclwiLFxuICAgIFwiUlwiLFxuICAgIFwic1wiLFxuICAgIFwiU1wiLFxuICAgIFwidFwiLFxuICAgIFwiVFwiLFxuICAgIFwidVwiLFxuICAgIFwiVVwiLFxuICAgIFwidlwiLFxuICAgIFwiVlwiLFxuICAgIFwid1wiLFxuICAgIFwiV1wiLFxuICAgIFwieFwiLFxuICAgIFwieVwiLFxuICAgIFwielwiXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29zbWV0aWMtc2VsZWN0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/cosmetic-selector.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/network-csp.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/codebooks/network-csp.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/* eslint-disable prettier/prettier */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([\n    \"sandbox allow-forms allow-same-origin allow-scripts allow-modals allow-orientation-lock allow-pointer-lock allow-presentation allow-top-navigation\",\n    \"script-src 'self' 'unsafe-inline' 'unsafe-eval' \",\n    \" data: blob: mediastream: filesystem:\",\n    \"default-src 'unsafe-inline' 'self' \",\n    \" allow-same-origin allow-scripts\",\n    \"script-src 'self' 'unsafe-eval' \",\n    \" *.google.com *.gstatic.com *.\",\n    \"gle.com *.googletagmanager.com\",\n    \"script-src * 'unsafe-inline'\",\n    \"default-src 'self'\",\n    \"child-src 'none';\",\n    \"worker-src 'none'\",\n    \"*.gstatic.com *.\",\n    \"'unsafe-inline'\",\n    \"e-src 'self' *\",\n    \"googleapis.com\",\n    \" allow-modals\",\n    \"unsafe-eval'\",\n    \"child-src *\",\n    \"gstatic.com\",\n    \"script-src \",\n    \"style-src *\",\n    \" https://\",\n    \"facebook.\",\n    \"frame-src\",\n    \" allow-\",\n    \" https:\",\n    \".com *.\",\n    \"'self' \",\n    \"sandbox\",\n    \"data: \",\n    \"disqus\",\n    \"google\",\n    \"ation\",\n    \"http:\",\n    \"-src\",\n    \".com\",\n    \"n.cc\",\n    \" *.\",\n    \"avi\",\n    \"ent\",\n    \"net\",\n    \"ram\",\n    \"yti\",\n    \" '\",\n    \" f\",\n    \"*.\",\n    \"ad\",\n    \"as\",\n    \"cd\",\n    \"ck\",\n    \"co\",\n    \"er\",\n    \"go\",\n    \"he\",\n    \"ic\",\n    \"im\",\n    \"in\",\n    \"lo\",\n    \"on\",\n    \"or\",\n    \"re\",\n    \"ta\",\n    \"tu\",\n    \" \",\n    \"-\",\n    \";\",\n    \":\",\n    \".\",\n    \"'\",\n    \"*\",\n    \"/\",\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"g\",\n    \"h\",\n    \"i\",\n    \"j\",\n    \"k\",\n    \"l\",\n    \"m\",\n    \"n\",\n    \"o\",\n    \"p\",\n    \"q\",\n    \"r\",\n    \"s\",\n    \"t\",\n    \"u\",\n    \"v\",\n    \"w\",\n    \"x\",\n    \"y\"\n]);\n//# sourceMappingURL=network-csp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9jb2RlYm9va3MvbmV0d29yay1jc3AuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9jb2RlYm9va3MvbmV0d29yay1jc3AuanM/ODhmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50IEdob3N0ZXJ5IEdtYkguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIHByZXR0aWVyL3ByZXR0aWVyICovXG5leHBvcnQgZGVmYXVsdCBbXG4gICAgXCJzYW5kYm94IGFsbG93LWZvcm1zIGFsbG93LXNhbWUtb3JpZ2luIGFsbG93LXNjcmlwdHMgYWxsb3ctbW9kYWxzIGFsbG93LW9yaWVudGF0aW9uLWxvY2sgYWxsb3ctcG9pbnRlci1sb2NrIGFsbG93LXByZXNlbnRhdGlvbiBhbGxvdy10b3AtbmF2aWdhdGlvblwiLFxuICAgIFwic2NyaXB0LXNyYyAnc2VsZicgJ3Vuc2FmZS1pbmxpbmUnICd1bnNhZmUtZXZhbCcgXCIsXG4gICAgXCIgZGF0YTogYmxvYjogbWVkaWFzdHJlYW06IGZpbGVzeXN0ZW06XCIsXG4gICAgXCJkZWZhdWx0LXNyYyAndW5zYWZlLWlubGluZScgJ3NlbGYnIFwiLFxuICAgIFwiIGFsbG93LXNhbWUtb3JpZ2luIGFsbG93LXNjcmlwdHNcIixcbiAgICBcInNjcmlwdC1zcmMgJ3NlbGYnICd1bnNhZmUtZXZhbCcgXCIsXG4gICAgXCIgKi5nb29nbGUuY29tICouZ3N0YXRpYy5jb20gKi5cIixcbiAgICBcImdsZS5jb20gKi5nb29nbGV0YWdtYW5hZ2VyLmNvbVwiLFxuICAgIFwic2NyaXB0LXNyYyAqICd1bnNhZmUtaW5saW5lJ1wiLFxuICAgIFwiZGVmYXVsdC1zcmMgJ3NlbGYnXCIsXG4gICAgXCJjaGlsZC1zcmMgJ25vbmUnO1wiLFxuICAgIFwid29ya2VyLXNyYyAnbm9uZSdcIixcbiAgICBcIiouZ3N0YXRpYy5jb20gKi5cIixcbiAgICBcIid1bnNhZmUtaW5saW5lJ1wiLFxuICAgIFwiZS1zcmMgJ3NlbGYnICpcIixcbiAgICBcImdvb2dsZWFwaXMuY29tXCIsXG4gICAgXCIgYWxsb3ctbW9kYWxzXCIsXG4gICAgXCJ1bnNhZmUtZXZhbCdcIixcbiAgICBcImNoaWxkLXNyYyAqXCIsXG4gICAgXCJnc3RhdGljLmNvbVwiLFxuICAgIFwic2NyaXB0LXNyYyBcIixcbiAgICBcInN0eWxlLXNyYyAqXCIsXG4gICAgXCIgaHR0cHM6Ly9cIixcbiAgICBcImZhY2Vib29rLlwiLFxuICAgIFwiZnJhbWUtc3JjXCIsXG4gICAgXCIgYWxsb3ctXCIsXG4gICAgXCIgaHR0cHM6XCIsXG4gICAgXCIuY29tICouXCIsXG4gICAgXCInc2VsZicgXCIsXG4gICAgXCJzYW5kYm94XCIsXG4gICAgXCJkYXRhOiBcIixcbiAgICBcImRpc3F1c1wiLFxuICAgIFwiZ29vZ2xlXCIsXG4gICAgXCJhdGlvblwiLFxuICAgIFwiaHR0cDpcIixcbiAgICBcIi1zcmNcIixcbiAgICBcIi5jb21cIixcbiAgICBcIm4uY2NcIixcbiAgICBcIiAqLlwiLFxuICAgIFwiYXZpXCIsXG4gICAgXCJlbnRcIixcbiAgICBcIm5ldFwiLFxuICAgIFwicmFtXCIsXG4gICAgXCJ5dGlcIixcbiAgICBcIiAnXCIsXG4gICAgXCIgZlwiLFxuICAgIFwiKi5cIixcbiAgICBcImFkXCIsXG4gICAgXCJhc1wiLFxuICAgIFwiY2RcIixcbiAgICBcImNrXCIsXG4gICAgXCJjb1wiLFxuICAgIFwiZXJcIixcbiAgICBcImdvXCIsXG4gICAgXCJoZVwiLFxuICAgIFwiaWNcIixcbiAgICBcImltXCIsXG4gICAgXCJpblwiLFxuICAgIFwibG9cIixcbiAgICBcIm9uXCIsXG4gICAgXCJvclwiLFxuICAgIFwicmVcIixcbiAgICBcInRhXCIsXG4gICAgXCJ0dVwiLFxuICAgIFwiIFwiLFxuICAgIFwiLVwiLFxuICAgIFwiO1wiLFxuICAgIFwiOlwiLFxuICAgIFwiLlwiLFxuICAgIFwiJ1wiLFxuICAgIFwiKlwiLFxuICAgIFwiL1wiLFxuICAgIFwiYVwiLFxuICAgIFwiYlwiLFxuICAgIFwiY1wiLFxuICAgIFwiZFwiLFxuICAgIFwiZVwiLFxuICAgIFwiZlwiLFxuICAgIFwiZ1wiLFxuICAgIFwiaFwiLFxuICAgIFwiaVwiLFxuICAgIFwialwiLFxuICAgIFwia1wiLFxuICAgIFwibFwiLFxuICAgIFwibVwiLFxuICAgIFwiblwiLFxuICAgIFwib1wiLFxuICAgIFwicFwiLFxuICAgIFwicVwiLFxuICAgIFwiclwiLFxuICAgIFwic1wiLFxuICAgIFwidFwiLFxuICAgIFwidVwiLFxuICAgIFwidlwiLFxuICAgIFwid1wiLFxuICAgIFwieFwiLFxuICAgIFwieVwiXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29yay1jc3AuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/network-csp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/network-filter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/codebooks/network-filter.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/* eslint-disable prettier/prettier */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([\n    \",ipaddress=/^(1(72\\\\.67\\\\.\\\\d{3}|04\\\\.21\\\\.\\\\d+)\\\\.\\\\d+|188\\\\.114\\\\.9[67]\\\\.[08]|64:ff9b::[a-f0-9]{4}:[a-f0-9]{1,4})$/,replace='/^/<script>(()=>{window.open=new proxy(window.open,{apply:(n,o,w)=>{}});let e=document.queryselector(\\\"script\\\");e.innerhtml.includes(\\\"window.open\\\")&&e.parentelement.removechild(e)})();<\\\\/script>/i'\",\n    \")?[_0-9a-z]{6,16}\\\\/?[_0-9a-z]{5,120}(?:[-.](?:app|bundle|ma?in|module|prod|index|v\\\\d|vendor))?(?:\\\\.js)?$/$script,3p,match-case,to=com|~aswpsdkus.com|~chimpstatic.com|~mojirater.com|~polldaddy.com|~squareoffs.com|~succeedscene.com|~tallysight.com|~veraviews.com,\",\n    \"/^https:\\\\/\\\\/(?:www\\\\d\\\\.)?[-a-z]{6,}\\\\.(?:club|com|info|net|org)\\\\/(?=[-_a-zA-Z]{0,42}\\\\d)(?=[-_0-9a-z]{0,42}[A-Z])[-_0-9a-zA-Z]{43}\\\\/\\\\?\",\n    \"/^https:\\\\/\\\\/[0-9a-z]{7,25}\\\\.com\\\\/(?:assets|build|bundles|chunks|dist|files|j|public|scripts|static)?\\\\/?(?:js\\\\/\",\n    \"/^https:\\\\/\\\\/s[cfntz]y?[ace][acemnu][a-z]{1,4}or?[mn][a-z]{4,8}[iy][a-z]?\\\\.\",\n    \"/videojs-vast-vpaid@2.0.2/bin/videojs_5.vast.vpaid.min\",\n    \"*&iu=%2f18190176%2c22509719621%2fadthrive_video_\",\n    \"/(\\\\d{0,1})?tamilprint(\\\\d{1,2})?\\\\.[a-z]{3,7}/##\",\n    \"\\\\/[a-zA-Z0-9]{30,}\\\\?[a-zA-Z0-9]{25,}$/\",\n    \"/pagead/managed/js/gpt/*/pubads_impl\",\n    \"[-.][-a-z0-9][-a-z0-9]+\\\\.[a-z]+\\\\//\",\n    \"/extensions/*/appmeasurement\",\n    \"\\\\.pussyspace\\\\.(?:com|net)\\\\/\",\n    \"/pagead/js/adsbygoogle.js\",\n    \"/js/sdkloader/ima3.js\",\n    \"/js/sdkloader/ima3_d\",\n    \"/videojs-contrib-ads\",\n    \"/wp-content/plugins/\",\n    \"/wp-content/uploads/\",\n    \"/public/widget/data\",\n    \"/wp-content/themes/\",\n    \"/detroitchicago/\",\n    \"/appmeasurement\",\n    \"/cdn-cgi/trace\",\n    \"/^https?:\\\\/\\\\/\",\n    \"/^https:\\\\/\\\\/\",\n    \"fingerprint\",\n    \"/413gkwmt/\",\n    \"impression\",\n    \"[a-z0-9]{\",\n    \"/plugins/\",\n    \"affiliate\",\n    \"analytics\",\n    \"telemetry\",\n    \"[a-f0-9]\",\n    \"/assets/\",\n    \"/images/\",\n    \"tracking\",\n    \"/public\",\n    \"300x250\",\n    \"captcha\",\n    \"collect\",\n    \"consent\",\n    \"content\",\n    \"counter\",\n    \"metrics\",\n    \"privacy\",\n    \"/media\",\n    \"banner\",\n    \"bundle\",\n    \"client\",\n    \"cookie\",\n    \"dn-cgi\",\n    \"google\",\n    \"module\",\n    \"prebid\",\n    \"script\",\n    \"source\",\n    \"widget\",\n    \".aspx\",\n    \".cgi?\",\n    \".com/\",\n    \".html\",\n    \"[a-z]\",\n    \"/api/\",\n    \"/beac\",\n    \"/java\",\n    \"/stat\",\n    \"0x600\",\n    \"a-z]{\",\n    \"block\",\n    \"click\",\n    \"count\",\n    \"embed\",\n    \"event\",\n    \"fault\",\n    \"frame\",\n    \"image\",\n    \"manag\",\n    \"pixel\",\n    \"popup\",\n    \"theme\",\n    \"track\",\n    \"type=\",\n    \"video\",\n    \"visit\",\n    \".css\",\n    \".gif\",\n    \".jpg\",\n    \".min\",\n    \".php\",\n    \".png\",\n    \"[0-9\",\n    \"/img\",\n    \"/jqu\",\n    \"/js/\",\n    \"/lib\",\n    \"/log\",\n    \"/web\",\n    \"/wp-\",\n    \"468x\",\n    \"gi-b\",\n    \"html\",\n    \"http\",\n    \"mail\",\n    \"page\",\n    \"play\",\n    \"plug\",\n    \"tect\",\n    \"uild\",\n    \"view\",\n    \".js\",\n    \"(?:\",\n    \"/ad\",\n    \"%2f\",\n    \"=*&\",\n    \"com\",\n    \"dpr\",\n    \"id=\",\n    \"jax\",\n    \"key\",\n    \"log\",\n    \"sdk\",\n    \"tag\",\n    \"web\",\n    \":/\",\n    \"*.\",\n    \"*/\",\n    \"/_\",\n    \"/?\",\n    \"/*\",\n    \"/d\",\n    \"/f\",\n    \"/g\",\n    \"/h\",\n    \"/m\",\n    \"/n\",\n    \"/r\",\n    \"/u\",\n    \"/w\",\n    \"\\\\.\",\n    \"\\\\/\",\n    \"a-\",\n    \"ac\",\n    \"ad\",\n    \"ag\",\n    \"al\",\n    \"am\",\n    \"an\",\n    \"ap\",\n    \"ar\",\n    \"as\",\n    \"at\",\n    \"ce\",\n    \"ch\",\n    \"co\",\n    \"de\",\n    \"di\",\n    \"e/\",\n    \"ed\",\n    \"el\",\n    \"en\",\n    \"er\",\n    \"et\",\n    \"ic\",\n    \"id\",\n    \"ig\",\n    \"im\",\n    \"in\",\n    \"it\",\n    \"js\",\n    \"la\",\n    \"le\",\n    \"li\",\n    \"lo\",\n    \"mp\",\n    \"ol\",\n    \"om\",\n    \"on\",\n    \"op\",\n    \"or\",\n    \"ot\",\n    \"re\",\n    \"ro\",\n    \"s_\",\n    \"s-\",\n    \"s?\",\n    \"s/\",\n    \"sh\",\n    \"si\",\n    \"sp\",\n    \"st\",\n    \"t/\",\n    \"te\",\n    \"ti\",\n    \"tm\",\n    \"tr\",\n    \"ub\",\n    \"un\",\n    \"ur\",\n    \"ut\",\n    \"ve\",\n    \"_\",\n    \"-\",\n    \",\",\n    \"?\",\n    \".\",\n    \")\",\n    \"[\",\n    \"{\",\n    \"}\",\n    \"*\",\n    \"/\",\n    \"\\\\\",\n    \"&\",\n    \"^\",\n    \"=\",\n    \"|\",\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"g\",\n    \"h\",\n    \"i\",\n    \"j\",\n    \"k\",\n    \"l\",\n    \"m\",\n    \"n\",\n    \"o\",\n    \"p\",\n    \"q\",\n    \"r\",\n    \"s\",\n    \"t\",\n    \"u\",\n    \"v\",\n    \"w\",\n    \"x\",\n    \"y\",\n    \"z\"\n]);\n//# sourceMappingURL=network-filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9jb2RlYm9va3MvbmV0d29yay1maWx0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZTtBQUNmLG1DQUFtQyxFQUFFLG1FQUFtRSxFQUFFLFVBQVUsSUFBSSw4QkFBOEIsbUNBQW1DLGtCQUFrQixFQUFFLHlDQUF5QyxzRUFBc0UsSUFBSTtBQUNoVSxpQkFBaUIsS0FBSyxjQUFjLE1BQU07QUFDMUMsd0NBQXdDLEdBQUcsNkNBQTZDLEtBQUssa0JBQWtCLEtBQUssb0JBQW9CLEdBQUc7QUFDM0ksNEJBQTRCLEtBQUs7QUFDakMsZ0RBQWdELElBQUksYUFBYSxJQUFJO0FBQ3JFO0FBQ0E7QUFDQSxXQUFXLElBQUksaUJBQWlCLElBQUksV0FBVyxJQUFJO0FBQ25ELG9CQUFvQixJQUFJLGVBQWUsSUFBSTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXIvZGlzdC9lc20vY29kZWJvb2tzL25ldHdvcmstZmlsdGVyLmpzP2UwYmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCBHaG9zdGVyeSBHbWJILiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmV0dGllci9wcmV0dGllciAqL1xuZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwiLGlwYWRkcmVzcz0vXigxKDcyXFxcXC42N1xcXFwuXFxcXGR7M318MDRcXFxcLjIxXFxcXC5cXFxcZCspXFxcXC5cXFxcZCt8MTg4XFxcXC4xMTRcXFxcLjlbNjddXFxcXC5bMDhdfDY0OmZmOWI6OlthLWYwLTldezR9OlthLWYwLTldezEsNH0pJC8scmVwbGFjZT0nL14vPHNjcmlwdD4oKCk9Pnt3aW5kb3cub3Blbj1uZXcgcHJveHkod2luZG93Lm9wZW4se2FwcGx5OihuLG8sdyk9Pnt9fSk7bGV0IGU9ZG9jdW1lbnQucXVlcnlzZWxlY3RvcihcXFwic2NyaXB0XFxcIik7ZS5pbm5lcmh0bWwuaW5jbHVkZXMoXFxcIndpbmRvdy5vcGVuXFxcIikmJmUucGFyZW50ZWxlbWVudC5yZW1vdmVjaGlsZChlKX0pKCk7PFxcXFwvc2NyaXB0Pi9pJ1wiLFxuICAgIFwiKT9bXzAtOWEtel17NiwxNn1cXFxcLz9bXzAtOWEtel17NSwxMjB9KD86Wy0uXSg/OmFwcHxidW5kbGV8bWE/aW58bW9kdWxlfHByb2R8aW5kZXh8dlxcXFxkfHZlbmRvcikpPyg/OlxcXFwuanMpPyQvJHNjcmlwdCwzcCxtYXRjaC1jYXNlLHRvPWNvbXx+YXN3cHNka3VzLmNvbXx+Y2hpbXBzdGF0aWMuY29tfH5tb2ppcmF0ZXIuY29tfH5wb2xsZGFkZHkuY29tfH5zcXVhcmVvZmZzLmNvbXx+c3VjY2VlZHNjZW5lLmNvbXx+dGFsbHlzaWdodC5jb218fnZlcmF2aWV3cy5jb20sXCIsXG4gICAgXCIvXmh0dHBzOlxcXFwvXFxcXC8oPzp3d3dcXFxcZFxcXFwuKT9bLWEtel17Nix9XFxcXC4oPzpjbHVifGNvbXxpbmZvfG5ldHxvcmcpXFxcXC8oPz1bLV9hLXpBLVpdezAsNDJ9XFxcXGQpKD89Wy1fMC05YS16XXswLDQyfVtBLVpdKVstXzAtOWEtekEtWl17NDN9XFxcXC9cXFxcP1wiLFxuICAgIFwiL15odHRwczpcXFxcL1xcXFwvWzAtOWEtel17NywyNX1cXFxcLmNvbVxcXFwvKD86YXNzZXRzfGJ1aWxkfGJ1bmRsZXN8Y2h1bmtzfGRpc3R8ZmlsZXN8anxwdWJsaWN8c2NyaXB0c3xzdGF0aWMpP1xcXFwvPyg/OmpzXFxcXC9cIixcbiAgICBcIi9eaHR0cHM6XFxcXC9cXFxcL3NbY2ZudHpdeT9bYWNlXVthY2VtbnVdW2Etel17MSw0fW9yP1ttbl1bYS16XXs0LDh9W2l5XVthLXpdP1xcXFwuXCIsXG4gICAgXCIvdmlkZW9qcy12YXN0LXZwYWlkQDIuMC4yL2Jpbi92aWRlb2pzXzUudmFzdC52cGFpZC5taW5cIixcbiAgICBcIiomaXU9JTJmMTgxOTAxNzYlMmMyMjUwOTcxOTYyMSUyZmFkdGhyaXZlX3ZpZGVvX1wiLFxuICAgIFwiLyhcXFxcZHswLDF9KT90YW1pbHByaW50KFxcXFxkezEsMn0pP1xcXFwuW2Etel17Myw3fS8jI1wiLFxuICAgIFwiXFxcXC9bYS16QS1aMC05XXszMCx9XFxcXD9bYS16QS1aMC05XXsyNSx9JC9cIixcbiAgICBcIi9wYWdlYWQvbWFuYWdlZC9qcy9ncHQvKi9wdWJhZHNfaW1wbFwiLFxuICAgIFwiWy0uXVstYS16MC05XVstYS16MC05XStcXFxcLlthLXpdK1xcXFwvL1wiLFxuICAgIFwiL2V4dGVuc2lvbnMvKi9hcHBtZWFzdXJlbWVudFwiLFxuICAgIFwiXFxcXC5wdXNzeXNwYWNlXFxcXC4oPzpjb218bmV0KVxcXFwvXCIsXG4gICAgXCIvcGFnZWFkL2pzL2Fkc2J5Z29vZ2xlLmpzXCIsXG4gICAgXCIvanMvc2RrbG9hZGVyL2ltYTMuanNcIixcbiAgICBcIi9qcy9zZGtsb2FkZXIvaW1hM19kXCIsXG4gICAgXCIvdmlkZW9qcy1jb250cmliLWFkc1wiLFxuICAgIFwiL3dwLWNvbnRlbnQvcGx1Z2lucy9cIixcbiAgICBcIi93cC1jb250ZW50L3VwbG9hZHMvXCIsXG4gICAgXCIvcHVibGljL3dpZGdldC9kYXRhXCIsXG4gICAgXCIvd3AtY29udGVudC90aGVtZXMvXCIsXG4gICAgXCIvZGV0cm9pdGNoaWNhZ28vXCIsXG4gICAgXCIvYXBwbWVhc3VyZW1lbnRcIixcbiAgICBcIi9jZG4tY2dpL3RyYWNlXCIsXG4gICAgXCIvXmh0dHBzPzpcXFxcL1xcXFwvXCIsXG4gICAgXCIvXmh0dHBzOlxcXFwvXFxcXC9cIixcbiAgICBcImZpbmdlcnByaW50XCIsXG4gICAgXCIvNDEzZ2t3bXQvXCIsXG4gICAgXCJpbXByZXNzaW9uXCIsXG4gICAgXCJbYS16MC05XXtcIixcbiAgICBcIi9wbHVnaW5zL1wiLFxuICAgIFwiYWZmaWxpYXRlXCIsXG4gICAgXCJhbmFseXRpY3NcIixcbiAgICBcInRlbGVtZXRyeVwiLFxuICAgIFwiW2EtZjAtOV1cIixcbiAgICBcIi9hc3NldHMvXCIsXG4gICAgXCIvaW1hZ2VzL1wiLFxuICAgIFwidHJhY2tpbmdcIixcbiAgICBcIi9wdWJsaWNcIixcbiAgICBcIjMwMHgyNTBcIixcbiAgICBcImNhcHRjaGFcIixcbiAgICBcImNvbGxlY3RcIixcbiAgICBcImNvbnNlbnRcIixcbiAgICBcImNvbnRlbnRcIixcbiAgICBcImNvdW50ZXJcIixcbiAgICBcIm1ldHJpY3NcIixcbiAgICBcInByaXZhY3lcIixcbiAgICBcIi9tZWRpYVwiLFxuICAgIFwiYmFubmVyXCIsXG4gICAgXCJidW5kbGVcIixcbiAgICBcImNsaWVudFwiLFxuICAgIFwiY29va2llXCIsXG4gICAgXCJkbi1jZ2lcIixcbiAgICBcImdvb2dsZVwiLFxuICAgIFwibW9kdWxlXCIsXG4gICAgXCJwcmViaWRcIixcbiAgICBcInNjcmlwdFwiLFxuICAgIFwic291cmNlXCIsXG4gICAgXCJ3aWRnZXRcIixcbiAgICBcIi5hc3B4XCIsXG4gICAgXCIuY2dpP1wiLFxuICAgIFwiLmNvbS9cIixcbiAgICBcIi5odG1sXCIsXG4gICAgXCJbYS16XVwiLFxuICAgIFwiL2FwaS9cIixcbiAgICBcIi9iZWFjXCIsXG4gICAgXCIvamF2YVwiLFxuICAgIFwiL3N0YXRcIixcbiAgICBcIjB4NjAwXCIsXG4gICAgXCJhLXpde1wiLFxuICAgIFwiYmxvY2tcIixcbiAgICBcImNsaWNrXCIsXG4gICAgXCJjb3VudFwiLFxuICAgIFwiZW1iZWRcIixcbiAgICBcImV2ZW50XCIsXG4gICAgXCJmYXVsdFwiLFxuICAgIFwiZnJhbWVcIixcbiAgICBcImltYWdlXCIsXG4gICAgXCJtYW5hZ1wiLFxuICAgIFwicGl4ZWxcIixcbiAgICBcInBvcHVwXCIsXG4gICAgXCJ0aGVtZVwiLFxuICAgIFwidHJhY2tcIixcbiAgICBcInR5cGU9XCIsXG4gICAgXCJ2aWRlb1wiLFxuICAgIFwidmlzaXRcIixcbiAgICBcIi5jc3NcIixcbiAgICBcIi5naWZcIixcbiAgICBcIi5qcGdcIixcbiAgICBcIi5taW5cIixcbiAgICBcIi5waHBcIixcbiAgICBcIi5wbmdcIixcbiAgICBcIlswLTlcIixcbiAgICBcIi9pbWdcIixcbiAgICBcIi9qcXVcIixcbiAgICBcIi9qcy9cIixcbiAgICBcIi9saWJcIixcbiAgICBcIi9sb2dcIixcbiAgICBcIi93ZWJcIixcbiAgICBcIi93cC1cIixcbiAgICBcIjQ2OHhcIixcbiAgICBcImdpLWJcIixcbiAgICBcImh0bWxcIixcbiAgICBcImh0dHBcIixcbiAgICBcIm1haWxcIixcbiAgICBcInBhZ2VcIixcbiAgICBcInBsYXlcIixcbiAgICBcInBsdWdcIixcbiAgICBcInRlY3RcIixcbiAgICBcInVpbGRcIixcbiAgICBcInZpZXdcIixcbiAgICBcIi5qc1wiLFxuICAgIFwiKD86XCIsXG4gICAgXCIvYWRcIixcbiAgICBcIiUyZlwiLFxuICAgIFwiPSomXCIsXG4gICAgXCJjb21cIixcbiAgICBcImRwclwiLFxuICAgIFwiaWQ9XCIsXG4gICAgXCJqYXhcIixcbiAgICBcImtleVwiLFxuICAgIFwibG9nXCIsXG4gICAgXCJzZGtcIixcbiAgICBcInRhZ1wiLFxuICAgIFwid2ViXCIsXG4gICAgXCI6L1wiLFxuICAgIFwiKi5cIixcbiAgICBcIiovXCIsXG4gICAgXCIvX1wiLFxuICAgIFwiLz9cIixcbiAgICBcIi8qXCIsXG4gICAgXCIvZFwiLFxuICAgIFwiL2ZcIixcbiAgICBcIi9nXCIsXG4gICAgXCIvaFwiLFxuICAgIFwiL21cIixcbiAgICBcIi9uXCIsXG4gICAgXCIvclwiLFxuICAgIFwiL3VcIixcbiAgICBcIi93XCIsXG4gICAgXCJcXFxcLlwiLFxuICAgIFwiXFxcXC9cIixcbiAgICBcImEtXCIsXG4gICAgXCJhY1wiLFxuICAgIFwiYWRcIixcbiAgICBcImFnXCIsXG4gICAgXCJhbFwiLFxuICAgIFwiYW1cIixcbiAgICBcImFuXCIsXG4gICAgXCJhcFwiLFxuICAgIFwiYXJcIixcbiAgICBcImFzXCIsXG4gICAgXCJhdFwiLFxuICAgIFwiY2VcIixcbiAgICBcImNoXCIsXG4gICAgXCJjb1wiLFxuICAgIFwiZGVcIixcbiAgICBcImRpXCIsXG4gICAgXCJlL1wiLFxuICAgIFwiZWRcIixcbiAgICBcImVsXCIsXG4gICAgXCJlblwiLFxuICAgIFwiZXJcIixcbiAgICBcImV0XCIsXG4gICAgXCJpY1wiLFxuICAgIFwiaWRcIixcbiAgICBcImlnXCIsXG4gICAgXCJpbVwiLFxuICAgIFwiaW5cIixcbiAgICBcIml0XCIsXG4gICAgXCJqc1wiLFxuICAgIFwibGFcIixcbiAgICBcImxlXCIsXG4gICAgXCJsaVwiLFxuICAgIFwibG9cIixcbiAgICBcIm1wXCIsXG4gICAgXCJvbFwiLFxuICAgIFwib21cIixcbiAgICBcIm9uXCIsXG4gICAgXCJvcFwiLFxuICAgIFwib3JcIixcbiAgICBcIm90XCIsXG4gICAgXCJyZVwiLFxuICAgIFwicm9cIixcbiAgICBcInNfXCIsXG4gICAgXCJzLVwiLFxuICAgIFwicz9cIixcbiAgICBcInMvXCIsXG4gICAgXCJzaFwiLFxuICAgIFwic2lcIixcbiAgICBcInNwXCIsXG4gICAgXCJzdFwiLFxuICAgIFwidC9cIixcbiAgICBcInRlXCIsXG4gICAgXCJ0aVwiLFxuICAgIFwidG1cIixcbiAgICBcInRyXCIsXG4gICAgXCJ1YlwiLFxuICAgIFwidW5cIixcbiAgICBcInVyXCIsXG4gICAgXCJ1dFwiLFxuICAgIFwidmVcIixcbiAgICBcIl9cIixcbiAgICBcIi1cIixcbiAgICBcIixcIixcbiAgICBcIj9cIixcbiAgICBcIi5cIixcbiAgICBcIilcIixcbiAgICBcIltcIixcbiAgICBcIntcIixcbiAgICBcIn1cIixcbiAgICBcIipcIixcbiAgICBcIi9cIixcbiAgICBcIlxcXFxcIixcbiAgICBcIiZcIixcbiAgICBcIl5cIixcbiAgICBcIj1cIixcbiAgICBcInxcIixcbiAgICBcIjBcIixcbiAgICBcIjFcIixcbiAgICBcIjJcIixcbiAgICBcIjNcIixcbiAgICBcIjRcIixcbiAgICBcIjVcIixcbiAgICBcIjZcIixcbiAgICBcIjdcIixcbiAgICBcIjhcIixcbiAgICBcIjlcIixcbiAgICBcImFcIixcbiAgICBcImJcIixcbiAgICBcImNcIixcbiAgICBcImRcIixcbiAgICBcImVcIixcbiAgICBcImZcIixcbiAgICBcImdcIixcbiAgICBcImhcIixcbiAgICBcImlcIixcbiAgICBcImpcIixcbiAgICBcImtcIixcbiAgICBcImxcIixcbiAgICBcIm1cIixcbiAgICBcIm5cIixcbiAgICBcIm9cIixcbiAgICBcInBcIixcbiAgICBcInFcIixcbiAgICBcInJcIixcbiAgICBcInNcIixcbiAgICBcInRcIixcbiAgICBcInVcIixcbiAgICBcInZcIixcbiAgICBcIndcIixcbiAgICBcInhcIixcbiAgICBcInlcIixcbiAgICBcInpcIlxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmstZmlsdGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/network-filter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/network-hostname.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/codebooks/network-hostname.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/* eslint-disable prettier/prettier */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([\n    \".actonservice.com\",\n    \"googlesyndication\",\n    \"imasdk.googleapis\",\n    \".cloudfront.net\",\n    \"analytics.\",\n    \"marketing.\",\n    \"tracking.\",\n    \".website\",\n    \"metrics.\",\n    \".online\",\n    \"digital\",\n    \".co.uk\",\n    \".space\",\n    \"a8clk.\",\n    \"stats.\",\n    \".shop\",\n    \".site\",\n    \"a8cv.\",\n    \"click\",\n    \"image\",\n    \"media\",\n    \"track\",\n    \".com\",\n    \".net\",\n    \".top\",\n    \".xyz\",\n    \"www.\",\n    \".io\",\n    \".jp\",\n    \"app\",\n    \"cdn\",\n    \"ght\",\n    \"new\",\n    \"pro\",\n    \"web\",\n    \".b\",\n    \".c\",\n    \".f\",\n    \".h\",\n    \".m\",\n    \".n\",\n    \".p\",\n    \".s\",\n    \".w\",\n    \"a1\",\n    \"a2\",\n    \"a4\",\n    \"ab\",\n    \"ac\",\n    \"ad\",\n    \"af\",\n    \"ag\",\n    \"ah\",\n    \"ai\",\n    \"ak\",\n    \"al\",\n    \"am\",\n    \"an\",\n    \"ap\",\n    \"ar\",\n    \"as\",\n    \"at\",\n    \"au\",\n    \"av\",\n    \"aw\",\n    \"ax\",\n    \"ay\",\n    \"az\",\n    \"be\",\n    \"bl\",\n    \"bo\",\n    \"br\",\n    \"bu\",\n    \"ca\",\n    \"ce\",\n    \"ch\",\n    \"ci\",\n    \"ck\",\n    \"cl\",\n    \"cr\",\n    \"ct\",\n    \"cu\",\n    \"de\",\n    \"di\",\n    \"do\",\n    \"dr\",\n    \"ds\",\n    \"du\",\n    \"dy\",\n    \"e-\",\n    \"eb\",\n    \"ec\",\n    \"ed\",\n    \"ef\",\n    \"el\",\n    \"em\",\n    \"en\",\n    \"ep\",\n    \"er\",\n    \"es\",\n    \"et\",\n    \"eu\",\n    \"ev\",\n    \"ew\",\n    \"ex\",\n    \"fd\",\n    \"fe\",\n    \"ff\",\n    \"fi\",\n    \"fo\",\n    \"fr\",\n    \"ge\",\n    \"gl\",\n    \"gn\",\n    \"go\",\n    \"gr\",\n    \"gu\",\n    \"gy\",\n    \"he\",\n    \"ho\",\n    \"ia\",\n    \"ib\",\n    \"ic\",\n    \"id\",\n    \"ie\",\n    \"if\",\n    \"ig\",\n    \"ik\",\n    \"il\",\n    \"im\",\n    \"in\",\n    \"io\",\n    \"ip\",\n    \"ir\",\n    \"is\",\n    \"it\",\n    \"iv\",\n    \"ix\",\n    \"iz\",\n    \"jo\",\n    \"ke\",\n    \"kr\",\n    \"ks\",\n    \"la\",\n    \"ld\",\n    \"le\",\n    \"li\",\n    \"lo\",\n    \"lu\",\n    \"ly\",\n    \"ma\",\n    \"me\",\n    \"mo\",\n    \"mp\",\n    \"my\",\n    \"nd\",\n    \"ne\",\n    \"no\",\n    \"nt\",\n    \"ob\",\n    \"ol\",\n    \"om\",\n    \"on\",\n    \"oo\",\n    \"op\",\n    \"or\",\n    \"ot\",\n    \"ou\",\n    \"ow\",\n    \"ph\",\n    \"pl\",\n    \"po\",\n    \"pr\",\n    \"pt\",\n    \"pu\",\n    \"qp\",\n    \"qu\",\n    \"re\",\n    \"ri\",\n    \"ro\",\n    \"ru\",\n    \"s-\",\n    \"sc\",\n    \"se\",\n    \"sh\",\n    \"si\",\n    \"sk\",\n    \"so\",\n    \"sp\",\n    \"ss\",\n    \"st\",\n    \"su\",\n    \"sw\",\n    \"sy\",\n    \"te\",\n    \"th\",\n    \"ti\",\n    \"to\",\n    \"tr\",\n    \"ts\",\n    \"tu\",\n    \"tv\",\n    \"tw\",\n    \"ty\",\n    \"ub\",\n    \"ul\",\n    \"um\",\n    \"un\",\n    \"up\",\n    \"ur\",\n    \"us\",\n    \"ut\",\n    \"ve\",\n    \"vi\",\n    \"vo\",\n    \"we\",\n    \"-\",\n    \".\",\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"g\",\n    \"h\",\n    \"i\",\n    \"j\",\n    \"k\",\n    \"l\",\n    \"m\",\n    \"n\",\n    \"o\",\n    \"p\",\n    \"q\",\n    \"r\",\n    \"s\",\n    \"t\",\n    \"u\",\n    \"v\",\n    \"w\",\n    \"x\",\n    \"y\",\n    \"z\"\n]);\n//# sourceMappingURL=network-hostname.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9jb2RlYm9va3MvbmV0d29yay1ob3N0bmFtZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9jb2RlYm9va3MvbmV0d29yay1ob3N0bmFtZS5qcz82OTc2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQgR2hvc3RlcnkgR21iSC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgcHJldHRpZXIvcHJldHRpZXIgKi9cbmV4cG9ydCBkZWZhdWx0IFtcbiAgICBcIi5hY3RvbnNlcnZpY2UuY29tXCIsXG4gICAgXCJnb29nbGVzeW5kaWNhdGlvblwiLFxuICAgIFwiaW1hc2RrLmdvb2dsZWFwaXNcIixcbiAgICBcIi5jbG91ZGZyb250Lm5ldFwiLFxuICAgIFwiYW5hbHl0aWNzLlwiLFxuICAgIFwibWFya2V0aW5nLlwiLFxuICAgIFwidHJhY2tpbmcuXCIsXG4gICAgXCIud2Vic2l0ZVwiLFxuICAgIFwibWV0cmljcy5cIixcbiAgICBcIi5vbmxpbmVcIixcbiAgICBcImRpZ2l0YWxcIixcbiAgICBcIi5jby51a1wiLFxuICAgIFwiLnNwYWNlXCIsXG4gICAgXCJhOGNsay5cIixcbiAgICBcInN0YXRzLlwiLFxuICAgIFwiLnNob3BcIixcbiAgICBcIi5zaXRlXCIsXG4gICAgXCJhOGN2LlwiLFxuICAgIFwiY2xpY2tcIixcbiAgICBcImltYWdlXCIsXG4gICAgXCJtZWRpYVwiLFxuICAgIFwidHJhY2tcIixcbiAgICBcIi5jb21cIixcbiAgICBcIi5uZXRcIixcbiAgICBcIi50b3BcIixcbiAgICBcIi54eXpcIixcbiAgICBcInd3dy5cIixcbiAgICBcIi5pb1wiLFxuICAgIFwiLmpwXCIsXG4gICAgXCJhcHBcIixcbiAgICBcImNkblwiLFxuICAgIFwiZ2h0XCIsXG4gICAgXCJuZXdcIixcbiAgICBcInByb1wiLFxuICAgIFwid2ViXCIsXG4gICAgXCIuYlwiLFxuICAgIFwiLmNcIixcbiAgICBcIi5mXCIsXG4gICAgXCIuaFwiLFxuICAgIFwiLm1cIixcbiAgICBcIi5uXCIsXG4gICAgXCIucFwiLFxuICAgIFwiLnNcIixcbiAgICBcIi53XCIsXG4gICAgXCJhMVwiLFxuICAgIFwiYTJcIixcbiAgICBcImE0XCIsXG4gICAgXCJhYlwiLFxuICAgIFwiYWNcIixcbiAgICBcImFkXCIsXG4gICAgXCJhZlwiLFxuICAgIFwiYWdcIixcbiAgICBcImFoXCIsXG4gICAgXCJhaVwiLFxuICAgIFwiYWtcIixcbiAgICBcImFsXCIsXG4gICAgXCJhbVwiLFxuICAgIFwiYW5cIixcbiAgICBcImFwXCIsXG4gICAgXCJhclwiLFxuICAgIFwiYXNcIixcbiAgICBcImF0XCIsXG4gICAgXCJhdVwiLFxuICAgIFwiYXZcIixcbiAgICBcImF3XCIsXG4gICAgXCJheFwiLFxuICAgIFwiYXlcIixcbiAgICBcImF6XCIsXG4gICAgXCJiZVwiLFxuICAgIFwiYmxcIixcbiAgICBcImJvXCIsXG4gICAgXCJiclwiLFxuICAgIFwiYnVcIixcbiAgICBcImNhXCIsXG4gICAgXCJjZVwiLFxuICAgIFwiY2hcIixcbiAgICBcImNpXCIsXG4gICAgXCJja1wiLFxuICAgIFwiY2xcIixcbiAgICBcImNyXCIsXG4gICAgXCJjdFwiLFxuICAgIFwiY3VcIixcbiAgICBcImRlXCIsXG4gICAgXCJkaVwiLFxuICAgIFwiZG9cIixcbiAgICBcImRyXCIsXG4gICAgXCJkc1wiLFxuICAgIFwiZHVcIixcbiAgICBcImR5XCIsXG4gICAgXCJlLVwiLFxuICAgIFwiZWJcIixcbiAgICBcImVjXCIsXG4gICAgXCJlZFwiLFxuICAgIFwiZWZcIixcbiAgICBcImVsXCIsXG4gICAgXCJlbVwiLFxuICAgIFwiZW5cIixcbiAgICBcImVwXCIsXG4gICAgXCJlclwiLFxuICAgIFwiZXNcIixcbiAgICBcImV0XCIsXG4gICAgXCJldVwiLFxuICAgIFwiZXZcIixcbiAgICBcImV3XCIsXG4gICAgXCJleFwiLFxuICAgIFwiZmRcIixcbiAgICBcImZlXCIsXG4gICAgXCJmZlwiLFxuICAgIFwiZmlcIixcbiAgICBcImZvXCIsXG4gICAgXCJmclwiLFxuICAgIFwiZ2VcIixcbiAgICBcImdsXCIsXG4gICAgXCJnblwiLFxuICAgIFwiZ29cIixcbiAgICBcImdyXCIsXG4gICAgXCJndVwiLFxuICAgIFwiZ3lcIixcbiAgICBcImhlXCIsXG4gICAgXCJob1wiLFxuICAgIFwiaWFcIixcbiAgICBcImliXCIsXG4gICAgXCJpY1wiLFxuICAgIFwiaWRcIixcbiAgICBcImllXCIsXG4gICAgXCJpZlwiLFxuICAgIFwiaWdcIixcbiAgICBcImlrXCIsXG4gICAgXCJpbFwiLFxuICAgIFwiaW1cIixcbiAgICBcImluXCIsXG4gICAgXCJpb1wiLFxuICAgIFwiaXBcIixcbiAgICBcImlyXCIsXG4gICAgXCJpc1wiLFxuICAgIFwiaXRcIixcbiAgICBcIml2XCIsXG4gICAgXCJpeFwiLFxuICAgIFwiaXpcIixcbiAgICBcImpvXCIsXG4gICAgXCJrZVwiLFxuICAgIFwia3JcIixcbiAgICBcImtzXCIsXG4gICAgXCJsYVwiLFxuICAgIFwibGRcIixcbiAgICBcImxlXCIsXG4gICAgXCJsaVwiLFxuICAgIFwibG9cIixcbiAgICBcImx1XCIsXG4gICAgXCJseVwiLFxuICAgIFwibWFcIixcbiAgICBcIm1lXCIsXG4gICAgXCJtb1wiLFxuICAgIFwibXBcIixcbiAgICBcIm15XCIsXG4gICAgXCJuZFwiLFxuICAgIFwibmVcIixcbiAgICBcIm5vXCIsXG4gICAgXCJudFwiLFxuICAgIFwib2JcIixcbiAgICBcIm9sXCIsXG4gICAgXCJvbVwiLFxuICAgIFwib25cIixcbiAgICBcIm9vXCIsXG4gICAgXCJvcFwiLFxuICAgIFwib3JcIixcbiAgICBcIm90XCIsXG4gICAgXCJvdVwiLFxuICAgIFwib3dcIixcbiAgICBcInBoXCIsXG4gICAgXCJwbFwiLFxuICAgIFwicG9cIixcbiAgICBcInByXCIsXG4gICAgXCJwdFwiLFxuICAgIFwicHVcIixcbiAgICBcInFwXCIsXG4gICAgXCJxdVwiLFxuICAgIFwicmVcIixcbiAgICBcInJpXCIsXG4gICAgXCJyb1wiLFxuICAgIFwicnVcIixcbiAgICBcInMtXCIsXG4gICAgXCJzY1wiLFxuICAgIFwic2VcIixcbiAgICBcInNoXCIsXG4gICAgXCJzaVwiLFxuICAgIFwic2tcIixcbiAgICBcInNvXCIsXG4gICAgXCJzcFwiLFxuICAgIFwic3NcIixcbiAgICBcInN0XCIsXG4gICAgXCJzdVwiLFxuICAgIFwic3dcIixcbiAgICBcInN5XCIsXG4gICAgXCJ0ZVwiLFxuICAgIFwidGhcIixcbiAgICBcInRpXCIsXG4gICAgXCJ0b1wiLFxuICAgIFwidHJcIixcbiAgICBcInRzXCIsXG4gICAgXCJ0dVwiLFxuICAgIFwidHZcIixcbiAgICBcInR3XCIsXG4gICAgXCJ0eVwiLFxuICAgIFwidWJcIixcbiAgICBcInVsXCIsXG4gICAgXCJ1bVwiLFxuICAgIFwidW5cIixcbiAgICBcInVwXCIsXG4gICAgXCJ1clwiLFxuICAgIFwidXNcIixcbiAgICBcInV0XCIsXG4gICAgXCJ2ZVwiLFxuICAgIFwidmlcIixcbiAgICBcInZvXCIsXG4gICAgXCJ3ZVwiLFxuICAgIFwiLVwiLFxuICAgIFwiLlwiLFxuICAgIFwiMFwiLFxuICAgIFwiMVwiLFxuICAgIFwiMlwiLFxuICAgIFwiM1wiLFxuICAgIFwiNFwiLFxuICAgIFwiNVwiLFxuICAgIFwiNlwiLFxuICAgIFwiN1wiLFxuICAgIFwiOFwiLFxuICAgIFwiOVwiLFxuICAgIFwiYVwiLFxuICAgIFwiYlwiLFxuICAgIFwiY1wiLFxuICAgIFwiZFwiLFxuICAgIFwiZVwiLFxuICAgIFwiZlwiLFxuICAgIFwiZ1wiLFxuICAgIFwiaFwiLFxuICAgIFwiaVwiLFxuICAgIFwialwiLFxuICAgIFwia1wiLFxuICAgIFwibFwiLFxuICAgIFwibVwiLFxuICAgIFwiblwiLFxuICAgIFwib1wiLFxuICAgIFwicFwiLFxuICAgIFwicVwiLFxuICAgIFwiclwiLFxuICAgIFwic1wiLFxuICAgIFwidFwiLFxuICAgIFwidVwiLFxuICAgIFwidlwiLFxuICAgIFwid1wiLFxuICAgIFwieFwiLFxuICAgIFwieVwiLFxuICAgIFwielwiXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29yay1ob3N0bmFtZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/network-hostname.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/network-redirect.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/codebooks/network-redirect.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/* eslint-disable prettier/prettier */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([\n    \"google-analytics.com/analytics.js\",\n    \"googlesyndication_adsbygoogle.js\",\n    \"googletagmanager.com/gtm.js\",\n    \"googletagservices_gpt.js\",\n    \"googletagmanager_gtm.js\",\n    \"fuckadblock.js-3.2.0:5\",\n    \"amazon_apstag.js\",\n    \"google-analytics\",\n    \"fingerprint2.js\",\n    \"noop-1s.mp4:10\",\n    \"google-ima.js\",\n    \"noop-0.1s.mp3\",\n    \"prebid-ads.js\",\n    \"nobab2.js:10\",\n    \"noopmp3-0.1s\",\n    \"noop-1s.mp4\",\n    \"noopmp4-1s\",\n    \"32x32.png\",\n    \"noop.html\",\n    \"noopframe\",\n    \"noop.txt\",\n    \"nooptext\",\n    \"1x1.gif\",\n    \"2x2.png\",\n    \"noop.js\",\n    \"noopjs\",\n    \".com/\",\n    \".js:5\",\n    \"none\",\n    \"noop\",\n    \":10\",\n    \".js\",\n    \"ads\",\n    \"bea\",\n    \"_a\",\n    \":5\",\n    \".0\",\n    \"ar\",\n    \"ch\",\n    \"ic\",\n    \"in\",\n    \"le\",\n    \"ma\",\n    \"re\",\n    \"st\",\n    \"_\",\n    \"-\",\n    \":\",\n    \".\",\n    \"/\",\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"g\",\n    \"h\",\n    \"i\",\n    \"j\",\n    \"k\",\n    \"l\",\n    \"m\",\n    \"n\",\n    \"o\",\n    \"p\",\n    \"r\",\n    \"s\",\n    \"t\",\n    \"u\",\n    \"v\",\n    \"w\",\n    \"x\",\n    \"y\",\n    \"z\"\n]);\n//# sourceMappingURL=network-redirect.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9jb2RlYm9va3MvbmV0d29yay1yZWRpcmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvYWRibG9ja2VyL2Rpc3QvZXNtL2NvZGVib29rcy9uZXR3b3JrLXJlZGlyZWN0LmpzPzdiZTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCBHaG9zdGVyeSBHbWJILiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmV0dGllci9wcmV0dGllciAqL1xuZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwiZ29vZ2xlLWFuYWx5dGljcy5jb20vYW5hbHl0aWNzLmpzXCIsXG4gICAgXCJnb29nbGVzeW5kaWNhdGlvbl9hZHNieWdvb2dsZS5qc1wiLFxuICAgIFwiZ29vZ2xldGFnbWFuYWdlci5jb20vZ3RtLmpzXCIsXG4gICAgXCJnb29nbGV0YWdzZXJ2aWNlc19ncHQuanNcIixcbiAgICBcImdvb2dsZXRhZ21hbmFnZXJfZ3RtLmpzXCIsXG4gICAgXCJmdWNrYWRibG9jay5qcy0zLjIuMDo1XCIsXG4gICAgXCJhbWF6b25fYXBzdGFnLmpzXCIsXG4gICAgXCJnb29nbGUtYW5hbHl0aWNzXCIsXG4gICAgXCJmaW5nZXJwcmludDIuanNcIixcbiAgICBcIm5vb3AtMXMubXA0OjEwXCIsXG4gICAgXCJnb29nbGUtaW1hLmpzXCIsXG4gICAgXCJub29wLTAuMXMubXAzXCIsXG4gICAgXCJwcmViaWQtYWRzLmpzXCIsXG4gICAgXCJub2JhYjIuanM6MTBcIixcbiAgICBcIm5vb3BtcDMtMC4xc1wiLFxuICAgIFwibm9vcC0xcy5tcDRcIixcbiAgICBcIm5vb3BtcDQtMXNcIixcbiAgICBcIjMyeDMyLnBuZ1wiLFxuICAgIFwibm9vcC5odG1sXCIsXG4gICAgXCJub29wZnJhbWVcIixcbiAgICBcIm5vb3AudHh0XCIsXG4gICAgXCJub29wdGV4dFwiLFxuICAgIFwiMXgxLmdpZlwiLFxuICAgIFwiMngyLnBuZ1wiLFxuICAgIFwibm9vcC5qc1wiLFxuICAgIFwibm9vcGpzXCIsXG4gICAgXCIuY29tL1wiLFxuICAgIFwiLmpzOjVcIixcbiAgICBcIm5vbmVcIixcbiAgICBcIm5vb3BcIixcbiAgICBcIjoxMFwiLFxuICAgIFwiLmpzXCIsXG4gICAgXCJhZHNcIixcbiAgICBcImJlYVwiLFxuICAgIFwiX2FcIixcbiAgICBcIjo1XCIsXG4gICAgXCIuMFwiLFxuICAgIFwiYXJcIixcbiAgICBcImNoXCIsXG4gICAgXCJpY1wiLFxuICAgIFwiaW5cIixcbiAgICBcImxlXCIsXG4gICAgXCJtYVwiLFxuICAgIFwicmVcIixcbiAgICBcInN0XCIsXG4gICAgXCJfXCIsXG4gICAgXCItXCIsXG4gICAgXCI6XCIsXG4gICAgXCIuXCIsXG4gICAgXCIvXCIsXG4gICAgXCIwXCIsXG4gICAgXCIxXCIsXG4gICAgXCIyXCIsXG4gICAgXCIzXCIsXG4gICAgXCI0XCIsXG4gICAgXCI1XCIsXG4gICAgXCJhXCIsXG4gICAgXCJiXCIsXG4gICAgXCJjXCIsXG4gICAgXCJkXCIsXG4gICAgXCJlXCIsXG4gICAgXCJmXCIsXG4gICAgXCJnXCIsXG4gICAgXCJoXCIsXG4gICAgXCJpXCIsXG4gICAgXCJqXCIsXG4gICAgXCJrXCIsXG4gICAgXCJsXCIsXG4gICAgXCJtXCIsXG4gICAgXCJuXCIsXG4gICAgXCJvXCIsXG4gICAgXCJwXCIsXG4gICAgXCJyXCIsXG4gICAgXCJzXCIsXG4gICAgXCJ0XCIsXG4gICAgXCJ1XCIsXG4gICAgXCJ2XCIsXG4gICAgXCJ3XCIsXG4gICAgXCJ4XCIsXG4gICAgXCJ5XCIsXG4gICAgXCJ6XCJcbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXR3b3JrLXJlZGlyZWN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/network-redirect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/raw-cosmetic.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/codebooks/raw-cosmetic.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/* eslint-disable prettier/prettier */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([\n    \" !important;\",\n    \"-storage-ite\",\n    \"-touch-callo\",\n    \"[href^=\\\"http\",\n    \"%22%3Afalse%\",\n    \"div[class^=\\\"\",\n    \"nt, script, \",\n    \"trusted-clic\",\n    \"trusted-set-\",\n    \"user-select:\",\n    \", document.\",\n    \"contextmenu\",\n    \"k-element, \",\n    \"ut: default\",\n    \":has-text(\",\n    \".com##+js(\",\n    \"background\",\n    \"flow: auto\",\n    \".*,xhamst\",\n    \"container\",\n    \"-webkit\",\n    \":style(\",\n    \"AAAAAAA\",\n    \"consent\",\n    \"content\",\n    \"nowoif)\",\n    \"privacy\",\n    \"-wrapp\",\n    \".co.uk\",\n    \"[class\",\n    \"[data-\",\n    \"[id^=\\\"\",\n    \"##+js(\",\n    \"accept\",\n    \"banner\",\n    \"bottom\",\n    \"cookie\",\n    \"Cookie\",\n    \"google\",\n    \"policy\",\n    \"script\",\n    \" text\",\n    \":has(\",\n    \".com,\",\n    \"1000)\",\n    \"block\",\n    \"true)\",\n    \".com\",\n    \".cz,\",\n    \".de,\",\n    \".fr,\",\n    \".pl,\",\n    \"#@#.\",\n    \"aeld\",\n    \"butt\",\n    \"gdpr\",\n    \"html\",\n    \"ight\",\n    \"news\",\n    \"s://\",\n    \"www.\",\n    \" > \",\n    \"##.\",\n    \"###\",\n    \"%3A\",\n    \"%3D\",\n    \"%5B\",\n    \"%5C\",\n    \"%5D\",\n    \"522\",\n    \"52C\",\n    \"53A\",\n    \"acs\",\n    \"age\",\n    \"web\",\n    \"__\",\n    \"-s\",\n    \", \",\n    \": \",\n    \".*\",\n    \".b\",\n    \".n\",\n    \".p\",\n    \".t\",\n    \"\\\"]\",\n    \"##\",\n    \"%2\",\n    \"%7\",\n    \"=\\\"\",\n    \"00\",\n    \"ab\",\n    \"ac\",\n    \"ad\",\n    \"Ad\",\n    \"al\",\n    \"am\",\n    \"an\",\n    \"ap\",\n    \"ar\",\n    \"as\",\n    \"at\",\n    \"au\",\n    \"bi\",\n    \"bo\",\n    \"ce\",\n    \"ch\",\n    \"ck\",\n    \"co\",\n    \"ct\",\n    \"d-\",\n    \"da\",\n    \"de\",\n    \"di\",\n    \"do\",\n    \"ed\",\n    \"el\",\n    \"en\",\n    \"er\",\n    \"es\",\n    \"et\",\n    \"fi\",\n    \"fo\",\n    \"g-\",\n    \"ga\",\n    \"ge\",\n    \"go\",\n    \"he\",\n    \"ho\",\n    \"ic\",\n    \"id\",\n    \"ie\",\n    \"if\",\n    \"il\",\n    \"im\",\n    \"in\",\n    \"is\",\n    \"it\",\n    \"ke\",\n    \"la\",\n    \"ld\",\n    \"le\",\n    \"li\",\n    \"lo\",\n    \"ma\",\n    \"me\",\n    \"mi\",\n    \"mo\",\n    \"mp\",\n    \"na\",\n    \"ne\",\n    \"no\",\n    \"ol\",\n    \"on\",\n    \"op\",\n    \"or\",\n    \"ot\",\n    \"ov\",\n    \"po\",\n    \"pp\",\n    \"ra\",\n    \"re\",\n    \"ro\",\n    \"ru\",\n    \"s_\",\n    \"s-\",\n    \"sc\",\n    \"se\",\n    \"sh\",\n    \"si\",\n    \"sk\",\n    \"so\",\n    \"sp\",\n    \"ss\",\n    \"st\",\n    \"t-\",\n    \"ta\",\n    \"te\",\n    \"th\",\n    \"ti\",\n    \"to\",\n    \"ub\",\n    \"ul\",\n    \"um\",\n    \"un\",\n    \"up\",\n    \"ur\",\n    \"us\",\n    \"ut\",\n    \"ve\",\n    \"vi\",\n    \"xh\",\n    \"y-\",\n    \" \",\n    \"_\",\n    \"-\",\n    \",\",\n    \";\",\n    \":\",\n    \".\",\n    \"(\",\n    \")\",\n    \"[\",\n    \"*\",\n    \"/\",\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"a\",\n    \"b\",\n    \"B\",\n    \"c\",\n    \"C\",\n    \"d\",\n    \"D\",\n    \"e\",\n    \"E\",\n    \"f\",\n    \"F\",\n    \"g\",\n    \"h\",\n    \"i\",\n    \"I\",\n    \"j\",\n    \"k\",\n    \"l\",\n    \"L\",\n    \"m\",\n    \"M\",\n    \"n\",\n    \"N\",\n    \"o\",\n    \"O\",\n    \"p\",\n    \"P\",\n    \"q\",\n    \"r\",\n    \"R\",\n    \"s\",\n    \"S\",\n    \"t\",\n    \"T\",\n    \"u\",\n    \"v\",\n    \"w\",\n    \"x\",\n    \"y\",\n    \"z\"\n]);\n//# sourceMappingURL=raw-cosmetic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9jb2RlYm9va3MvcmF3LWNvc21ldGljLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWU7QUFDZixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9jb2RlYm9va3MvcmF3LWNvc21ldGljLmpzP2IwNDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCBHaG9zdGVyeSBHbWJILiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmV0dGllci9wcmV0dGllciAqL1xuZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwiICFpbXBvcnRhbnQ7XCIsXG4gICAgXCItc3RvcmFnZS1pdGVcIixcbiAgICBcIi10b3VjaC1jYWxsb1wiLFxuICAgIFwiW2hyZWZePVxcXCJodHRwXCIsXG4gICAgXCIlMjIlM0FmYWxzZSVcIixcbiAgICBcImRpdltjbGFzc149XFxcIlwiLFxuICAgIFwibnQsIHNjcmlwdCwgXCIsXG4gICAgXCJ0cnVzdGVkLWNsaWNcIixcbiAgICBcInRydXN0ZWQtc2V0LVwiLFxuICAgIFwidXNlci1zZWxlY3Q6XCIsXG4gICAgXCIsIGRvY3VtZW50LlwiLFxuICAgIFwiY29udGV4dG1lbnVcIixcbiAgICBcImstZWxlbWVudCwgXCIsXG4gICAgXCJ1dDogZGVmYXVsdFwiLFxuICAgIFwiOmhhcy10ZXh0KFwiLFxuICAgIFwiLmNvbSMjK2pzKFwiLFxuICAgIFwiYmFja2dyb3VuZFwiLFxuICAgIFwiZmxvdzogYXV0b1wiLFxuICAgIFwiLioseGhhbXN0XCIsXG4gICAgXCJjb250YWluZXJcIixcbiAgICBcIi13ZWJraXRcIixcbiAgICBcIjpzdHlsZShcIixcbiAgICBcIkFBQUFBQUFcIixcbiAgICBcImNvbnNlbnRcIixcbiAgICBcImNvbnRlbnRcIixcbiAgICBcIm5vd29pZilcIixcbiAgICBcInByaXZhY3lcIixcbiAgICBcIi13cmFwcFwiLFxuICAgIFwiLmNvLnVrXCIsXG4gICAgXCJbY2xhc3NcIixcbiAgICBcIltkYXRhLVwiLFxuICAgIFwiW2lkXj1cXFwiXCIsXG4gICAgXCIjIytqcyhcIixcbiAgICBcImFjY2VwdFwiLFxuICAgIFwiYmFubmVyXCIsXG4gICAgXCJib3R0b21cIixcbiAgICBcImNvb2tpZVwiLFxuICAgIFwiQ29va2llXCIsXG4gICAgXCJnb29nbGVcIixcbiAgICBcInBvbGljeVwiLFxuICAgIFwic2NyaXB0XCIsXG4gICAgXCIgdGV4dFwiLFxuICAgIFwiOmhhcyhcIixcbiAgICBcIi5jb20sXCIsXG4gICAgXCIxMDAwKVwiLFxuICAgIFwiYmxvY2tcIixcbiAgICBcInRydWUpXCIsXG4gICAgXCIuY29tXCIsXG4gICAgXCIuY3osXCIsXG4gICAgXCIuZGUsXCIsXG4gICAgXCIuZnIsXCIsXG4gICAgXCIucGwsXCIsXG4gICAgXCIjQCMuXCIsXG4gICAgXCJhZWxkXCIsXG4gICAgXCJidXR0XCIsXG4gICAgXCJnZHByXCIsXG4gICAgXCJodG1sXCIsXG4gICAgXCJpZ2h0XCIsXG4gICAgXCJuZXdzXCIsXG4gICAgXCJzOi8vXCIsXG4gICAgXCJ3d3cuXCIsXG4gICAgXCIgPiBcIixcbiAgICBcIiMjLlwiLFxuICAgIFwiIyMjXCIsXG4gICAgXCIlM0FcIixcbiAgICBcIiUzRFwiLFxuICAgIFwiJTVCXCIsXG4gICAgXCIlNUNcIixcbiAgICBcIiU1RFwiLFxuICAgIFwiNTIyXCIsXG4gICAgXCI1MkNcIixcbiAgICBcIjUzQVwiLFxuICAgIFwiYWNzXCIsXG4gICAgXCJhZ2VcIixcbiAgICBcIndlYlwiLFxuICAgIFwiX19cIixcbiAgICBcIi1zXCIsXG4gICAgXCIsIFwiLFxuICAgIFwiOiBcIixcbiAgICBcIi4qXCIsXG4gICAgXCIuYlwiLFxuICAgIFwiLm5cIixcbiAgICBcIi5wXCIsXG4gICAgXCIudFwiLFxuICAgIFwiXFxcIl1cIixcbiAgICBcIiMjXCIsXG4gICAgXCIlMlwiLFxuICAgIFwiJTdcIixcbiAgICBcIj1cXFwiXCIsXG4gICAgXCIwMFwiLFxuICAgIFwiYWJcIixcbiAgICBcImFjXCIsXG4gICAgXCJhZFwiLFxuICAgIFwiQWRcIixcbiAgICBcImFsXCIsXG4gICAgXCJhbVwiLFxuICAgIFwiYW5cIixcbiAgICBcImFwXCIsXG4gICAgXCJhclwiLFxuICAgIFwiYXNcIixcbiAgICBcImF0XCIsXG4gICAgXCJhdVwiLFxuICAgIFwiYmlcIixcbiAgICBcImJvXCIsXG4gICAgXCJjZVwiLFxuICAgIFwiY2hcIixcbiAgICBcImNrXCIsXG4gICAgXCJjb1wiLFxuICAgIFwiY3RcIixcbiAgICBcImQtXCIsXG4gICAgXCJkYVwiLFxuICAgIFwiZGVcIixcbiAgICBcImRpXCIsXG4gICAgXCJkb1wiLFxuICAgIFwiZWRcIixcbiAgICBcImVsXCIsXG4gICAgXCJlblwiLFxuICAgIFwiZXJcIixcbiAgICBcImVzXCIsXG4gICAgXCJldFwiLFxuICAgIFwiZmlcIixcbiAgICBcImZvXCIsXG4gICAgXCJnLVwiLFxuICAgIFwiZ2FcIixcbiAgICBcImdlXCIsXG4gICAgXCJnb1wiLFxuICAgIFwiaGVcIixcbiAgICBcImhvXCIsXG4gICAgXCJpY1wiLFxuICAgIFwiaWRcIixcbiAgICBcImllXCIsXG4gICAgXCJpZlwiLFxuICAgIFwiaWxcIixcbiAgICBcImltXCIsXG4gICAgXCJpblwiLFxuICAgIFwiaXNcIixcbiAgICBcIml0XCIsXG4gICAgXCJrZVwiLFxuICAgIFwibGFcIixcbiAgICBcImxkXCIsXG4gICAgXCJsZVwiLFxuICAgIFwibGlcIixcbiAgICBcImxvXCIsXG4gICAgXCJtYVwiLFxuICAgIFwibWVcIixcbiAgICBcIm1pXCIsXG4gICAgXCJtb1wiLFxuICAgIFwibXBcIixcbiAgICBcIm5hXCIsXG4gICAgXCJuZVwiLFxuICAgIFwibm9cIixcbiAgICBcIm9sXCIsXG4gICAgXCJvblwiLFxuICAgIFwib3BcIixcbiAgICBcIm9yXCIsXG4gICAgXCJvdFwiLFxuICAgIFwib3ZcIixcbiAgICBcInBvXCIsXG4gICAgXCJwcFwiLFxuICAgIFwicmFcIixcbiAgICBcInJlXCIsXG4gICAgXCJyb1wiLFxuICAgIFwicnVcIixcbiAgICBcInNfXCIsXG4gICAgXCJzLVwiLFxuICAgIFwic2NcIixcbiAgICBcInNlXCIsXG4gICAgXCJzaFwiLFxuICAgIFwic2lcIixcbiAgICBcInNrXCIsXG4gICAgXCJzb1wiLFxuICAgIFwic3BcIixcbiAgICBcInNzXCIsXG4gICAgXCJzdFwiLFxuICAgIFwidC1cIixcbiAgICBcInRhXCIsXG4gICAgXCJ0ZVwiLFxuICAgIFwidGhcIixcbiAgICBcInRpXCIsXG4gICAgXCJ0b1wiLFxuICAgIFwidWJcIixcbiAgICBcInVsXCIsXG4gICAgXCJ1bVwiLFxuICAgIFwidW5cIixcbiAgICBcInVwXCIsXG4gICAgXCJ1clwiLFxuICAgIFwidXNcIixcbiAgICBcInV0XCIsXG4gICAgXCJ2ZVwiLFxuICAgIFwidmlcIixcbiAgICBcInhoXCIsXG4gICAgXCJ5LVwiLFxuICAgIFwiIFwiLFxuICAgIFwiX1wiLFxuICAgIFwiLVwiLFxuICAgIFwiLFwiLFxuICAgIFwiO1wiLFxuICAgIFwiOlwiLFxuICAgIFwiLlwiLFxuICAgIFwiKFwiLFxuICAgIFwiKVwiLFxuICAgIFwiW1wiLFxuICAgIFwiKlwiLFxuICAgIFwiL1wiLFxuICAgIFwiMFwiLFxuICAgIFwiMVwiLFxuICAgIFwiMlwiLFxuICAgIFwiM1wiLFxuICAgIFwiNFwiLFxuICAgIFwiNVwiLFxuICAgIFwiNlwiLFxuICAgIFwiN1wiLFxuICAgIFwiOFwiLFxuICAgIFwiOVwiLFxuICAgIFwiYVwiLFxuICAgIFwiYlwiLFxuICAgIFwiQlwiLFxuICAgIFwiY1wiLFxuICAgIFwiQ1wiLFxuICAgIFwiZFwiLFxuICAgIFwiRFwiLFxuICAgIFwiZVwiLFxuICAgIFwiRVwiLFxuICAgIFwiZlwiLFxuICAgIFwiRlwiLFxuICAgIFwiZ1wiLFxuICAgIFwiaFwiLFxuICAgIFwiaVwiLFxuICAgIFwiSVwiLFxuICAgIFwialwiLFxuICAgIFwia1wiLFxuICAgIFwibFwiLFxuICAgIFwiTFwiLFxuICAgIFwibVwiLFxuICAgIFwiTVwiLFxuICAgIFwiblwiLFxuICAgIFwiTlwiLFxuICAgIFwib1wiLFxuICAgIFwiT1wiLFxuICAgIFwicFwiLFxuICAgIFwiUFwiLFxuICAgIFwicVwiLFxuICAgIFwiclwiLFxuICAgIFwiUlwiLFxuICAgIFwic1wiLFxuICAgIFwiU1wiLFxuICAgIFwidFwiLFxuICAgIFwiVFwiLFxuICAgIFwidVwiLFxuICAgIFwidlwiLFxuICAgIFwid1wiLFxuICAgIFwieFwiLFxuICAgIFwieVwiLFxuICAgIFwielwiXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmF3LWNvc21ldGljLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/raw-cosmetic.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/raw-network.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/codebooks/raw-network.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/* eslint-disable prettier/prettier */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([\n    \".actonservi\",\n    \"/^https:\\\\/\\\\\",\n    \"/js/sdkload\",\n    \"/wp-content\",\n    \"||smetrics.\",\n    \"third-party\",\n    \"xmlhttprequ\",\n    \"-rule=noop\",\n    \"marketing.\",\n    \",redirect\",\n    \".digital^\",\n    \".website^\",\n    \"$document\",\n    \"analytics\",\n    \",domain=\",\n    \".online^\",\n    \"metrics.\",\n    \"tracking\",\n    \".space^\",\n    \"$script\",\n    \"imasdk.\",\n    \".co.uk\",\n    \".cyou^\",\n    \".help^\",\n    \".shop^\",\n    \".site^\",\n    \"$ghide\",\n    \"a8clk.\",\n    \"cookie\",\n    \"google\",\n    \"script\",\n    \".com^\",\n    \".net^\",\n    \".top^\",\n    \".xyz^\",\n    \"$doma\",\n    \"a8cv.\",\n    \"click\",\n    \"image\",\n    \"media\",\n    \"track\",\n    \".com\",\n    \".fr^\",\n    \".gif\",\n    \".io^\",\n    \".jp^\",\n    \"/js/\",\n    \"$doc\",\n    \"$xhr\",\n    \"a-z]\",\n    \"www.\",\n    \",1p\",\n    \",3p\",\n    \".js\",\n    \"cdn\",\n    \"fd^\",\n    \"ld^\",\n    \"web\",\n    \".b\",\n    \".c\",\n    \".f\",\n    \".m\",\n    \".n\",\n    \".p\",\n    \".s\",\n    \".w\",\n    \"@@\",\n    \"/*\",\n    \"/p\",\n    \"||\",\n    \"ab\",\n    \"ac\",\n    \"ad\",\n    \"af\",\n    \"ag\",\n    \"ai\",\n    \"ak\",\n    \"al\",\n    \"am\",\n    \"an\",\n    \"ap\",\n    \"ar\",\n    \"as\",\n    \"at\",\n    \"au\",\n    \"av\",\n    \"aw\",\n    \"ax\",\n    \"ay\",\n    \"az\",\n    \"be\",\n    \"bi\",\n    \"bo\",\n    \"br\",\n    \"ca\",\n    \"ce\",\n    \"ch\",\n    \"ck\",\n    \"ct\",\n    \"cu\",\n    \"de\",\n    \"di\",\n    \"do\",\n    \"e-\",\n    \"eb\",\n    \"ec\",\n    \"ed\",\n    \"el\",\n    \"em\",\n    \"en\",\n    \"ep\",\n    \"er\",\n    \"es\",\n    \"et\",\n    \"ev\",\n    \"ew\",\n    \"ex\",\n    \"fe\",\n    \"ff\",\n    \"fi\",\n    \"fo\",\n    \"fr\",\n    \"g^\",\n    \"ge\",\n    \"gi\",\n    \"go\",\n    \"gr\",\n    \"he\",\n    \"hi\",\n    \"ho\",\n    \"hp\",\n    \"ht\",\n    \"ic\",\n    \"id\",\n    \"ig\",\n    \"il\",\n    \"im\",\n    \"in\",\n    \"io\",\n    \"ip\",\n    \"ir\",\n    \"is\",\n    \"it\",\n    \"ix\",\n    \"jo\",\n    \"js\",\n    \"ke\",\n    \"l^\",\n    \"la\",\n    \"le\",\n    \"li\",\n    \"lo\",\n    \"lu\",\n    \"ly\",\n    \"ma\",\n    \"me\",\n    \"mo\",\n    \"mp\",\n    \"my\",\n    \"no\",\n    \"ol\",\n    \"om\",\n    \"on\",\n    \"oo\",\n    \"op\",\n    \"or\",\n    \"ot\",\n    \"pl\",\n    \"po\",\n    \"pr\",\n    \"qu\",\n    \"re\",\n    \"ri\",\n    \"ro\",\n    \"ru\",\n    \"s/\",\n    \"sc\",\n    \"se\",\n    \"sh\",\n    \"si\",\n    \"so\",\n    \"sp\",\n    \"ss\",\n    \"st\",\n    \"sw\",\n    \"t-\",\n    \"te\",\n    \"th\",\n    \"ti\",\n    \"to\",\n    \"tr\",\n    \"ts\",\n    \"tv\",\n    \"ty\",\n    \"ub\",\n    \"ud\",\n    \"ul\",\n    \"um\",\n    \"un\",\n    \"up\",\n    \"ur\",\n    \"us\",\n    \"ut\",\n    \"ve\",\n    \"vi\",\n    \"_\",\n    \"-\",\n    \",\",\n    \"?\",\n    \".\",\n    \"*\",\n    \"/\",\n    \"\\\\\",\n    \"^\",\n    \"=\",\n    \"|\",\n    \"~\",\n    \"$\",\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"a\",\n    \"b\",\n    \"c\",\n    \"d\",\n    \"e\",\n    \"f\",\n    \"g\",\n    \"h\",\n    \"i\",\n    \"j\",\n    \"k\",\n    \"l\",\n    \"m\",\n    \"n\",\n    \"o\",\n    \"p\",\n    \"q\",\n    \"r\",\n    \"s\",\n    \"t\",\n    \"u\",\n    \"v\",\n    \"w\",\n    \"x\",\n    \"y\",\n    \"z\"\n]);\n//# sourceMappingURL=raw-network.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9jb2RlYm9va3MvcmF3LW5ldHdvcmsuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXIvZGlzdC9lc20vY29kZWJvb2tzL3Jhdy1uZXR3b3JrLmpzP2Y3N2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCBHaG9zdGVyeSBHbWJILiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmV0dGllci9wcmV0dGllciAqL1xuZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwiLmFjdG9uc2VydmlcIixcbiAgICBcIi9eaHR0cHM6XFxcXC9cXFxcXCIsXG4gICAgXCIvanMvc2RrbG9hZFwiLFxuICAgIFwiL3dwLWNvbnRlbnRcIixcbiAgICBcInx8c21ldHJpY3MuXCIsXG4gICAgXCJ0aGlyZC1wYXJ0eVwiLFxuICAgIFwieG1saHR0cHJlcXVcIixcbiAgICBcIi1ydWxlPW5vb3BcIixcbiAgICBcIm1hcmtldGluZy5cIixcbiAgICBcIixyZWRpcmVjdFwiLFxuICAgIFwiLmRpZ2l0YWxeXCIsXG4gICAgXCIud2Vic2l0ZV5cIixcbiAgICBcIiRkb2N1bWVudFwiLFxuICAgIFwiYW5hbHl0aWNzXCIsXG4gICAgXCIsZG9tYWluPVwiLFxuICAgIFwiLm9ubGluZV5cIixcbiAgICBcIm1ldHJpY3MuXCIsXG4gICAgXCJ0cmFja2luZ1wiLFxuICAgIFwiLnNwYWNlXlwiLFxuICAgIFwiJHNjcmlwdFwiLFxuICAgIFwiaW1hc2RrLlwiLFxuICAgIFwiLmNvLnVrXCIsXG4gICAgXCIuY3lvdV5cIixcbiAgICBcIi5oZWxwXlwiLFxuICAgIFwiLnNob3BeXCIsXG4gICAgXCIuc2l0ZV5cIixcbiAgICBcIiRnaGlkZVwiLFxuICAgIFwiYThjbGsuXCIsXG4gICAgXCJjb29raWVcIixcbiAgICBcImdvb2dsZVwiLFxuICAgIFwic2NyaXB0XCIsXG4gICAgXCIuY29tXlwiLFxuICAgIFwiLm5ldF5cIixcbiAgICBcIi50b3BeXCIsXG4gICAgXCIueHl6XlwiLFxuICAgIFwiJGRvbWFcIixcbiAgICBcImE4Y3YuXCIsXG4gICAgXCJjbGlja1wiLFxuICAgIFwiaW1hZ2VcIixcbiAgICBcIm1lZGlhXCIsXG4gICAgXCJ0cmFja1wiLFxuICAgIFwiLmNvbVwiLFxuICAgIFwiLmZyXlwiLFxuICAgIFwiLmdpZlwiLFxuICAgIFwiLmlvXlwiLFxuICAgIFwiLmpwXlwiLFxuICAgIFwiL2pzL1wiLFxuICAgIFwiJGRvY1wiLFxuICAgIFwiJHhoclwiLFxuICAgIFwiYS16XVwiLFxuICAgIFwid3d3LlwiLFxuICAgIFwiLDFwXCIsXG4gICAgXCIsM3BcIixcbiAgICBcIi5qc1wiLFxuICAgIFwiY2RuXCIsXG4gICAgXCJmZF5cIixcbiAgICBcImxkXlwiLFxuICAgIFwid2ViXCIsXG4gICAgXCIuYlwiLFxuICAgIFwiLmNcIixcbiAgICBcIi5mXCIsXG4gICAgXCIubVwiLFxuICAgIFwiLm5cIixcbiAgICBcIi5wXCIsXG4gICAgXCIuc1wiLFxuICAgIFwiLndcIixcbiAgICBcIkBAXCIsXG4gICAgXCIvKlwiLFxuICAgIFwiL3BcIixcbiAgICBcInx8XCIsXG4gICAgXCJhYlwiLFxuICAgIFwiYWNcIixcbiAgICBcImFkXCIsXG4gICAgXCJhZlwiLFxuICAgIFwiYWdcIixcbiAgICBcImFpXCIsXG4gICAgXCJha1wiLFxuICAgIFwiYWxcIixcbiAgICBcImFtXCIsXG4gICAgXCJhblwiLFxuICAgIFwiYXBcIixcbiAgICBcImFyXCIsXG4gICAgXCJhc1wiLFxuICAgIFwiYXRcIixcbiAgICBcImF1XCIsXG4gICAgXCJhdlwiLFxuICAgIFwiYXdcIixcbiAgICBcImF4XCIsXG4gICAgXCJheVwiLFxuICAgIFwiYXpcIixcbiAgICBcImJlXCIsXG4gICAgXCJiaVwiLFxuICAgIFwiYm9cIixcbiAgICBcImJyXCIsXG4gICAgXCJjYVwiLFxuICAgIFwiY2VcIixcbiAgICBcImNoXCIsXG4gICAgXCJja1wiLFxuICAgIFwiY3RcIixcbiAgICBcImN1XCIsXG4gICAgXCJkZVwiLFxuICAgIFwiZGlcIixcbiAgICBcImRvXCIsXG4gICAgXCJlLVwiLFxuICAgIFwiZWJcIixcbiAgICBcImVjXCIsXG4gICAgXCJlZFwiLFxuICAgIFwiZWxcIixcbiAgICBcImVtXCIsXG4gICAgXCJlblwiLFxuICAgIFwiZXBcIixcbiAgICBcImVyXCIsXG4gICAgXCJlc1wiLFxuICAgIFwiZXRcIixcbiAgICBcImV2XCIsXG4gICAgXCJld1wiLFxuICAgIFwiZXhcIixcbiAgICBcImZlXCIsXG4gICAgXCJmZlwiLFxuICAgIFwiZmlcIixcbiAgICBcImZvXCIsXG4gICAgXCJmclwiLFxuICAgIFwiZ15cIixcbiAgICBcImdlXCIsXG4gICAgXCJnaVwiLFxuICAgIFwiZ29cIixcbiAgICBcImdyXCIsXG4gICAgXCJoZVwiLFxuICAgIFwiaGlcIixcbiAgICBcImhvXCIsXG4gICAgXCJocFwiLFxuICAgIFwiaHRcIixcbiAgICBcImljXCIsXG4gICAgXCJpZFwiLFxuICAgIFwiaWdcIixcbiAgICBcImlsXCIsXG4gICAgXCJpbVwiLFxuICAgIFwiaW5cIixcbiAgICBcImlvXCIsXG4gICAgXCJpcFwiLFxuICAgIFwiaXJcIixcbiAgICBcImlzXCIsXG4gICAgXCJpdFwiLFxuICAgIFwiaXhcIixcbiAgICBcImpvXCIsXG4gICAgXCJqc1wiLFxuICAgIFwia2VcIixcbiAgICBcImxeXCIsXG4gICAgXCJsYVwiLFxuICAgIFwibGVcIixcbiAgICBcImxpXCIsXG4gICAgXCJsb1wiLFxuICAgIFwibHVcIixcbiAgICBcImx5XCIsXG4gICAgXCJtYVwiLFxuICAgIFwibWVcIixcbiAgICBcIm1vXCIsXG4gICAgXCJtcFwiLFxuICAgIFwibXlcIixcbiAgICBcIm5vXCIsXG4gICAgXCJvbFwiLFxuICAgIFwib21cIixcbiAgICBcIm9uXCIsXG4gICAgXCJvb1wiLFxuICAgIFwib3BcIixcbiAgICBcIm9yXCIsXG4gICAgXCJvdFwiLFxuICAgIFwicGxcIixcbiAgICBcInBvXCIsXG4gICAgXCJwclwiLFxuICAgIFwicXVcIixcbiAgICBcInJlXCIsXG4gICAgXCJyaVwiLFxuICAgIFwicm9cIixcbiAgICBcInJ1XCIsXG4gICAgXCJzL1wiLFxuICAgIFwic2NcIixcbiAgICBcInNlXCIsXG4gICAgXCJzaFwiLFxuICAgIFwic2lcIixcbiAgICBcInNvXCIsXG4gICAgXCJzcFwiLFxuICAgIFwic3NcIixcbiAgICBcInN0XCIsXG4gICAgXCJzd1wiLFxuICAgIFwidC1cIixcbiAgICBcInRlXCIsXG4gICAgXCJ0aFwiLFxuICAgIFwidGlcIixcbiAgICBcInRvXCIsXG4gICAgXCJ0clwiLFxuICAgIFwidHNcIixcbiAgICBcInR2XCIsXG4gICAgXCJ0eVwiLFxuICAgIFwidWJcIixcbiAgICBcInVkXCIsXG4gICAgXCJ1bFwiLFxuICAgIFwidW1cIixcbiAgICBcInVuXCIsXG4gICAgXCJ1cFwiLFxuICAgIFwidXJcIixcbiAgICBcInVzXCIsXG4gICAgXCJ1dFwiLFxuICAgIFwidmVcIixcbiAgICBcInZpXCIsXG4gICAgXCJfXCIsXG4gICAgXCItXCIsXG4gICAgXCIsXCIsXG4gICAgXCI/XCIsXG4gICAgXCIuXCIsXG4gICAgXCIqXCIsXG4gICAgXCIvXCIsXG4gICAgXCJcXFxcXCIsXG4gICAgXCJeXCIsXG4gICAgXCI9XCIsXG4gICAgXCJ8XCIsXG4gICAgXCJ+XCIsXG4gICAgXCIkXCIsXG4gICAgXCIwXCIsXG4gICAgXCIxXCIsXG4gICAgXCIyXCIsXG4gICAgXCIzXCIsXG4gICAgXCI0XCIsXG4gICAgXCI1XCIsXG4gICAgXCI2XCIsXG4gICAgXCI3XCIsXG4gICAgXCI4XCIsXG4gICAgXCI5XCIsXG4gICAgXCJhXCIsXG4gICAgXCJiXCIsXG4gICAgXCJjXCIsXG4gICAgXCJkXCIsXG4gICAgXCJlXCIsXG4gICAgXCJmXCIsXG4gICAgXCJnXCIsXG4gICAgXCJoXCIsXG4gICAgXCJpXCIsXG4gICAgXCJqXCIsXG4gICAgXCJrXCIsXG4gICAgXCJsXCIsXG4gICAgXCJtXCIsXG4gICAgXCJuXCIsXG4gICAgXCJvXCIsXG4gICAgXCJwXCIsXG4gICAgXCJxXCIsXG4gICAgXCJyXCIsXG4gICAgXCJzXCIsXG4gICAgXCJ0XCIsXG4gICAgXCJ1XCIsXG4gICAgXCJ2XCIsXG4gICAgXCJ3XCIsXG4gICAgXCJ4XCIsXG4gICAgXCJ5XCIsXG4gICAgXCJ6XCJcbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYXctbmV0d29yay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/raw-network.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/compact-set.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/compact-set.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compactTokens: () => (/* binding */ compactTokens),\n/* harmony export */   concatTypedArrays: () => (/* binding */ concatTypedArrays),\n/* harmony export */   hasEmptyIntersection: () => (/* binding */ hasEmptyIntersection),\n/* harmony export */   mergeCompactSets: () => (/* binding */ mergeCompactSets)\n/* harmony export */ });\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nfunction compactTokens(tokens) {\n    const sorted = tokens.sort();\n    let lastIndex = 1;\n    for (let i = 1; i < sorted.length; i += 1) {\n        if (sorted[lastIndex - 1] !== sorted[i]) {\n            sorted[lastIndex++] = sorted[i];\n        }\n    }\n    return sorted.subarray(0, lastIndex);\n}\nfunction hasEmptyIntersection(s1, s2) {\n    let i = 0;\n    let j = 0;\n    while (i < s1.length && j < s2.length && s1[i] !== s2[j]) {\n        if (s1[i] < s2[j]) {\n            i += 1;\n        }\n        else {\n            j += 1;\n        }\n    }\n    return i === s1.length || j === s2.length;\n}\nconst EMPTY_UINT32_ARRAY = new Uint32Array(0);\nfunction concatTypedArrays(arrays) {\n    if (arrays.length === 0) {\n        return EMPTY_UINT32_ARRAY;\n    }\n    if (arrays.length === 1) {\n        return arrays[0];\n    }\n    let totalSize = 0;\n    for (let i = 0; i < arrays.length; i += 1) {\n        totalSize += arrays[i].length;\n    }\n    const result = new Uint32Array(totalSize);\n    let index = 0;\n    for (let i = 0; i < arrays.length; i += 1) {\n        const array = arrays[i];\n        for (let j = 0; j < array.length; j += 1) {\n            result[index++] = array[j];\n        }\n    }\n    return result;\n}\nfunction mergeCompactSets(arrays) {\n    return compactTokens(concatTypedArrays(arrays));\n}\n//# sourceMappingURL=compact-set.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9jb21wYWN0LXNldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXIvZGlzdC9lc20vY29tcGFjdC1zZXQuanM/OTJjYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50IEdob3N0ZXJ5IEdtYkguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wYWN0VG9rZW5zKHRva2Vucykge1xuICAgIGNvbnN0IHNvcnRlZCA9IHRva2Vucy5zb3J0KCk7XG4gICAgbGV0IGxhc3RJbmRleCA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzb3J0ZWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHNvcnRlZFtsYXN0SW5kZXggLSAxXSAhPT0gc29ydGVkW2ldKSB7XG4gICAgICAgICAgICBzb3J0ZWRbbGFzdEluZGV4KytdID0gc29ydGVkW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3J0ZWQuc3ViYXJyYXkoMCwgbGFzdEluZGV4KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNFbXB0eUludGVyc2VjdGlvbihzMSwgczIpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIHdoaWxlIChpIDwgczEubGVuZ3RoICYmIGogPCBzMi5sZW5ndGggJiYgczFbaV0gIT09IHMyW2pdKSB7XG4gICAgICAgIGlmIChzMVtpXSA8IHMyW2pdKSB7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGkgPT09IHMxLmxlbmd0aCB8fCBqID09PSBzMi5sZW5ndGg7XG59XG5jb25zdCBFTVBUWV9VSU5UMzJfQVJSQVkgPSBuZXcgVWludDMyQXJyYXkoMCk7XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0VHlwZWRBcnJheXMoYXJyYXlzKSB7XG4gICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEVNUFRZX1VJTlQzMl9BUlJBWTtcbiAgICB9XG4gICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5c1swXTtcbiAgICB9XG4gICAgbGV0IHRvdGFsU2l6ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdG90YWxTaXplICs9IGFycmF5c1tpXS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50MzJBcnJheSh0b3RhbFNpemUpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBhcnJheXNbaV07XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXJyYXkubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleCsrXSA9IGFycmF5W2pdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VDb21wYWN0U2V0cyhhcnJheXMpIHtcbiAgICByZXR1cm4gY29tcGFjdFRva2Vucyhjb25jYXRUeXBlZEFycmF5cyhhcnJheXMpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBhY3Qtc2V0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/compact-set.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/compression.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/compression.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Compression)\n/* harmony export */ });\n/* harmony import */ var _remusao_smaz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @remusao/smaz */ \"(rsc)/./node_modules/@remusao/smaz/dist/esm/index.js\");\n/* harmony import */ var _codebooks_cosmetic_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./codebooks/cosmetic-selector.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/cosmetic-selector.js\");\n/* harmony import */ var _codebooks_network_csp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./codebooks/network-csp.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/network-csp.js\");\n/* harmony import */ var _codebooks_network_filter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./codebooks/network-filter.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/network-filter.js\");\n/* harmony import */ var _codebooks_network_hostname_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./codebooks/network-hostname.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/network-hostname.js\");\n/* harmony import */ var _codebooks_network_redirect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./codebooks/network-redirect.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/network-redirect.js\");\n/* harmony import */ var _codebooks_raw_network_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./codebooks/raw-network.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/raw-network.js\");\n/* harmony import */ var _codebooks_raw_cosmetic_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./codebooks/raw-cosmetic.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/codebooks/raw-cosmetic.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n\n\n\nclass Compression {\n    constructor() {\n        this.cosmeticSelector = new _remusao_smaz__WEBPACK_IMPORTED_MODULE_0__.Smaz(_codebooks_cosmetic_selector_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n        this.networkCSP = new _remusao_smaz__WEBPACK_IMPORTED_MODULE_0__.Smaz(_codebooks_network_csp_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n        this.networkRedirect = new _remusao_smaz__WEBPACK_IMPORTED_MODULE_0__.Smaz(_codebooks_network_redirect_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n        this.networkHostname = new _remusao_smaz__WEBPACK_IMPORTED_MODULE_0__.Smaz(_codebooks_network_hostname_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n        this.networkFilter = new _remusao_smaz__WEBPACK_IMPORTED_MODULE_0__.Smaz(_codebooks_network_filter_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n        this.networkRaw = new _remusao_smaz__WEBPACK_IMPORTED_MODULE_0__.Smaz(_codebooks_raw_network_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n        this.cosmeticRaw = new _remusao_smaz__WEBPACK_IMPORTED_MODULE_0__.Smaz(_codebooks_raw_cosmetic_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"], 800000);\n    }\n}\n//# sourceMappingURL=compression.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9jb21wcmVzc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxQztBQUNtQztBQUNaO0FBQ007QUFDSTtBQUNBO0FBQ1Y7QUFDRTtBQUMvQztBQUNmO0FBQ0Esb0NBQW9DLCtDQUFJLENBQUMsdUVBQXdCO0FBQ2pFLDhCQUE4QiwrQ0FBSSxDQUFDLGlFQUFrQjtBQUNyRCxtQ0FBbUMsK0NBQUksQ0FBQyxzRUFBdUI7QUFDL0QsbUNBQW1DLCtDQUFJLENBQUMsc0VBQXVCO0FBQy9ELGlDQUFpQywrQ0FBSSxDQUFDLG9FQUFxQjtBQUMzRCw4QkFBOEIsK0NBQUksQ0FBQyxpRUFBa0I7QUFDckQsK0JBQStCLCtDQUFJLENBQUMsa0VBQW1CO0FBQ3ZEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXIvZGlzdC9lc20vY29tcHJlc3Npb24uanM/M2IwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50IEdob3N0ZXJ5IEdtYkguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmltcG9ydCB7IFNtYXogfSBmcm9tICdAcmVtdXNhby9zbWF6JztcbmltcG9ydCBjb3NtZXRpY1NlbGVjdG9yQ29kZWJvb2sgZnJvbSAnLi9jb2RlYm9va3MvY29zbWV0aWMtc2VsZWN0b3IuanMnO1xuaW1wb3J0IG5ldHdvcmtDU1BDb2RlYm9vayBmcm9tICcuL2NvZGVib29rcy9uZXR3b3JrLWNzcC5qcyc7XG5pbXBvcnQgbmV0d29ya0ZpbHRlckNvZGVib29rIGZyb20gJy4vY29kZWJvb2tzL25ldHdvcmstZmlsdGVyLmpzJztcbmltcG9ydCBuZXR3b3JrSG9zdG5hbWVDb2RlYm9vayBmcm9tICcuL2NvZGVib29rcy9uZXR3b3JrLWhvc3RuYW1lLmpzJztcbmltcG9ydCBuZXR3b3JrUmVkaXJlY3RDb2RlYm9vayBmcm9tICcuL2NvZGVib29rcy9uZXR3b3JrLXJlZGlyZWN0LmpzJztcbmltcG9ydCBuZXR3b3JrUmF3Q29kZWJvb2sgZnJvbSAnLi9jb2RlYm9va3MvcmF3LW5ldHdvcmsuanMnO1xuaW1wb3J0IGNvc21ldGljUmF3Q29kZWJvb2sgZnJvbSAnLi9jb2RlYm9va3MvcmF3LWNvc21ldGljLmpzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb3NtZXRpY1NlbGVjdG9yID0gbmV3IFNtYXooY29zbWV0aWNTZWxlY3RvckNvZGVib29rKTtcbiAgICAgICAgdGhpcy5uZXR3b3JrQ1NQID0gbmV3IFNtYXoobmV0d29ya0NTUENvZGVib29rKTtcbiAgICAgICAgdGhpcy5uZXR3b3JrUmVkaXJlY3QgPSBuZXcgU21heihuZXR3b3JrUmVkaXJlY3RDb2RlYm9vayk7XG4gICAgICAgIHRoaXMubmV0d29ya0hvc3RuYW1lID0gbmV3IFNtYXoobmV0d29ya0hvc3RuYW1lQ29kZWJvb2spO1xuICAgICAgICB0aGlzLm5ldHdvcmtGaWx0ZXIgPSBuZXcgU21heihuZXR3b3JrRmlsdGVyQ29kZWJvb2spO1xuICAgICAgICB0aGlzLm5ldHdvcmtSYXcgPSBuZXcgU21heihuZXR3b3JrUmF3Q29kZWJvb2spO1xuICAgICAgICB0aGlzLmNvc21ldGljUmF3ID0gbmV3IFNtYXooY29zbWV0aWNSYXdDb2RlYm9vaywgODAwMDAwKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wcmVzc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/compression.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/config.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/config.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Config)\n/* harmony export */ });\n/* harmony import */ var _data_view_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data-view.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/data-view.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\nclass Config {\n    static deserialize(buffer) {\n        return new Config({\n            debug: buffer.getBool(),\n            enableCompression: buffer.getBool(),\n            enableHtmlFiltering: buffer.getBool(),\n            enableInMemoryCache: buffer.getBool(),\n            enableMutationObserver: buffer.getBool(),\n            enableOptimizations: buffer.getBool(),\n            enablePushInjectionsOnNavigationEvents: buffer.getBool(),\n            guessRequestTypeFromUrl: buffer.getBool(),\n            integrityCheck: buffer.getBool(),\n            loadCSPFilters: buffer.getBool(),\n            loadCosmeticFilters: buffer.getBool(),\n            loadExceptionFilters: buffer.getBool(),\n            loadExtendedSelectors: buffer.getBool(),\n            loadGenericCosmeticsFilters: buffer.getBool(),\n            loadNetworkFilters: buffer.getBool(),\n            loadPreprocessors: buffer.getBool(),\n        });\n    }\n    constructor({ debug = false, enableCompression = false, enableHtmlFiltering = false, enableInMemoryCache = true, enableMutationObserver = true, enableOptimizations = true, enablePushInjectionsOnNavigationEvents = true, guessRequestTypeFromUrl = false, integrityCheck = true, loadCSPFilters = true, loadCosmeticFilters = true, loadExceptionFilters = true, loadExtendedSelectors = false, loadGenericCosmeticsFilters = true, loadNetworkFilters = true, loadPreprocessors = false, } = {}) {\n        this.debug = debug;\n        this.enableCompression = enableCompression;\n        this.enableHtmlFiltering = enableHtmlFiltering;\n        this.enableInMemoryCache = enableInMemoryCache;\n        this.enableMutationObserver = enableMutationObserver;\n        this.enableOptimizations = enableOptimizations;\n        this.enablePushInjectionsOnNavigationEvents = enablePushInjectionsOnNavigationEvents;\n        this.guessRequestTypeFromUrl = guessRequestTypeFromUrl;\n        this.integrityCheck = integrityCheck;\n        this.loadCSPFilters = loadCSPFilters;\n        this.loadCosmeticFilters = loadCosmeticFilters;\n        this.loadExceptionFilters = loadExceptionFilters;\n        this.loadExtendedSelectors = loadExtendedSelectors;\n        this.loadGenericCosmeticsFilters = loadGenericCosmeticsFilters;\n        this.loadNetworkFilters = loadNetworkFilters;\n        this.loadPreprocessors = loadPreprocessors;\n    }\n    getSerializedSize() {\n        // NOTE: this should always be the number of attributes and needs to be\n        // updated when `Config` changes.\n        return 16 * (0,_data_view_js__WEBPACK_IMPORTED_MODULE_0__.sizeOfBool)();\n    }\n    serialize(buffer) {\n        buffer.pushBool(this.debug);\n        buffer.pushBool(this.enableCompression);\n        buffer.pushBool(this.enableHtmlFiltering);\n        buffer.pushBool(this.enableInMemoryCache);\n        buffer.pushBool(this.enableMutationObserver);\n        buffer.pushBool(this.enableOptimizations);\n        buffer.pushBool(this.enablePushInjectionsOnNavigationEvents);\n        buffer.pushBool(this.guessRequestTypeFromUrl);\n        buffer.pushBool(this.integrityCheck);\n        buffer.pushBool(this.loadCSPFilters);\n        buffer.pushBool(this.loadCosmeticFilters);\n        buffer.pushBool(this.loadExceptionFilters);\n        buffer.pushBool(this.loadExtendedSelectors);\n        buffer.pushBool(this.loadGenericCosmeticsFilters);\n        buffer.pushBool(this.loadNetworkFilters);\n        buffer.pushBool(this.loadPreprocessors);\n    }\n}\n//# sourceMappingURL=config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUM3QjtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQixnZEFBZ2QsSUFBSTtBQUN0ZTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlEQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXIvZGlzdC9lc20vY29uZmlnLmpzPzNjNWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCBHaG9zdGVyeSBHbWJILiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgeyBzaXplT2ZCb29sIH0gZnJvbSAnLi9kYXRhLXZpZXcuanMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29uZmlnIHtcbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uZmlnKHtcbiAgICAgICAgICAgIGRlYnVnOiBidWZmZXIuZ2V0Qm9vbCgpLFxuICAgICAgICAgICAgZW5hYmxlQ29tcHJlc3Npb246IGJ1ZmZlci5nZXRCb29sKCksXG4gICAgICAgICAgICBlbmFibGVIdG1sRmlsdGVyaW5nOiBidWZmZXIuZ2V0Qm9vbCgpLFxuICAgICAgICAgICAgZW5hYmxlSW5NZW1vcnlDYWNoZTogYnVmZmVyLmdldEJvb2woKSxcbiAgICAgICAgICAgIGVuYWJsZU11dGF0aW9uT2JzZXJ2ZXI6IGJ1ZmZlci5nZXRCb29sKCksXG4gICAgICAgICAgICBlbmFibGVPcHRpbWl6YXRpb25zOiBidWZmZXIuZ2V0Qm9vbCgpLFxuICAgICAgICAgICAgZW5hYmxlUHVzaEluamVjdGlvbnNPbk5hdmlnYXRpb25FdmVudHM6IGJ1ZmZlci5nZXRCb29sKCksXG4gICAgICAgICAgICBndWVzc1JlcXVlc3RUeXBlRnJvbVVybDogYnVmZmVyLmdldEJvb2woKSxcbiAgICAgICAgICAgIGludGVncml0eUNoZWNrOiBidWZmZXIuZ2V0Qm9vbCgpLFxuICAgICAgICAgICAgbG9hZENTUEZpbHRlcnM6IGJ1ZmZlci5nZXRCb29sKCksXG4gICAgICAgICAgICBsb2FkQ29zbWV0aWNGaWx0ZXJzOiBidWZmZXIuZ2V0Qm9vbCgpLFxuICAgICAgICAgICAgbG9hZEV4Y2VwdGlvbkZpbHRlcnM6IGJ1ZmZlci5nZXRCb29sKCksXG4gICAgICAgICAgICBsb2FkRXh0ZW5kZWRTZWxlY3RvcnM6IGJ1ZmZlci5nZXRCb29sKCksXG4gICAgICAgICAgICBsb2FkR2VuZXJpY0Nvc21ldGljc0ZpbHRlcnM6IGJ1ZmZlci5nZXRCb29sKCksXG4gICAgICAgICAgICBsb2FkTmV0d29ya0ZpbHRlcnM6IGJ1ZmZlci5nZXRCb29sKCksXG4gICAgICAgICAgICBsb2FkUHJlcHJvY2Vzc29yczogYnVmZmVyLmdldEJvb2woKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsgZGVidWcgPSBmYWxzZSwgZW5hYmxlQ29tcHJlc3Npb24gPSBmYWxzZSwgZW5hYmxlSHRtbEZpbHRlcmluZyA9IGZhbHNlLCBlbmFibGVJbk1lbW9yeUNhY2hlID0gdHJ1ZSwgZW5hYmxlTXV0YXRpb25PYnNlcnZlciA9IHRydWUsIGVuYWJsZU9wdGltaXphdGlvbnMgPSB0cnVlLCBlbmFibGVQdXNoSW5qZWN0aW9uc09uTmF2aWdhdGlvbkV2ZW50cyA9IHRydWUsIGd1ZXNzUmVxdWVzdFR5cGVGcm9tVXJsID0gZmFsc2UsIGludGVncml0eUNoZWNrID0gdHJ1ZSwgbG9hZENTUEZpbHRlcnMgPSB0cnVlLCBsb2FkQ29zbWV0aWNGaWx0ZXJzID0gdHJ1ZSwgbG9hZEV4Y2VwdGlvbkZpbHRlcnMgPSB0cnVlLCBsb2FkRXh0ZW5kZWRTZWxlY3RvcnMgPSBmYWxzZSwgbG9hZEdlbmVyaWNDb3NtZXRpY3NGaWx0ZXJzID0gdHJ1ZSwgbG9hZE5ldHdvcmtGaWx0ZXJzID0gdHJ1ZSwgbG9hZFByZXByb2Nlc3NvcnMgPSBmYWxzZSwgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuZGVidWcgPSBkZWJ1ZztcbiAgICAgICAgdGhpcy5lbmFibGVDb21wcmVzc2lvbiA9IGVuYWJsZUNvbXByZXNzaW9uO1xuICAgICAgICB0aGlzLmVuYWJsZUh0bWxGaWx0ZXJpbmcgPSBlbmFibGVIdG1sRmlsdGVyaW5nO1xuICAgICAgICB0aGlzLmVuYWJsZUluTWVtb3J5Q2FjaGUgPSBlbmFibGVJbk1lbW9yeUNhY2hlO1xuICAgICAgICB0aGlzLmVuYWJsZU11dGF0aW9uT2JzZXJ2ZXIgPSBlbmFibGVNdXRhdGlvbk9ic2VydmVyO1xuICAgICAgICB0aGlzLmVuYWJsZU9wdGltaXphdGlvbnMgPSBlbmFibGVPcHRpbWl6YXRpb25zO1xuICAgICAgICB0aGlzLmVuYWJsZVB1c2hJbmplY3Rpb25zT25OYXZpZ2F0aW9uRXZlbnRzID0gZW5hYmxlUHVzaEluamVjdGlvbnNPbk5hdmlnYXRpb25FdmVudHM7XG4gICAgICAgIHRoaXMuZ3Vlc3NSZXF1ZXN0VHlwZUZyb21VcmwgPSBndWVzc1JlcXVlc3RUeXBlRnJvbVVybDtcbiAgICAgICAgdGhpcy5pbnRlZ3JpdHlDaGVjayA9IGludGVncml0eUNoZWNrO1xuICAgICAgICB0aGlzLmxvYWRDU1BGaWx0ZXJzID0gbG9hZENTUEZpbHRlcnM7XG4gICAgICAgIHRoaXMubG9hZENvc21ldGljRmlsdGVycyA9IGxvYWRDb3NtZXRpY0ZpbHRlcnM7XG4gICAgICAgIHRoaXMubG9hZEV4Y2VwdGlvbkZpbHRlcnMgPSBsb2FkRXhjZXB0aW9uRmlsdGVycztcbiAgICAgICAgdGhpcy5sb2FkRXh0ZW5kZWRTZWxlY3RvcnMgPSBsb2FkRXh0ZW5kZWRTZWxlY3RvcnM7XG4gICAgICAgIHRoaXMubG9hZEdlbmVyaWNDb3NtZXRpY3NGaWx0ZXJzID0gbG9hZEdlbmVyaWNDb3NtZXRpY3NGaWx0ZXJzO1xuICAgICAgICB0aGlzLmxvYWROZXR3b3JrRmlsdGVycyA9IGxvYWROZXR3b3JrRmlsdGVycztcbiAgICAgICAgdGhpcy5sb2FkUHJlcHJvY2Vzc29ycyA9IGxvYWRQcmVwcm9jZXNzb3JzO1xuICAgIH1cbiAgICBnZXRTZXJpYWxpemVkU2l6ZSgpIHtcbiAgICAgICAgLy8gTk9URTogdGhpcyBzaG91bGQgYWx3YXlzIGJlIHRoZSBudW1iZXIgb2YgYXR0cmlidXRlcyBhbmQgbmVlZHMgdG8gYmVcbiAgICAgICAgLy8gdXBkYXRlZCB3aGVuIGBDb25maWdgIGNoYW5nZXMuXG4gICAgICAgIHJldHVybiAxNiAqIHNpemVPZkJvb2woKTtcbiAgICB9XG4gICAgc2VyaWFsaXplKGJ1ZmZlcikge1xuICAgICAgICBidWZmZXIucHVzaEJvb2wodGhpcy5kZWJ1Zyk7XG4gICAgICAgIGJ1ZmZlci5wdXNoQm9vbCh0aGlzLmVuYWJsZUNvbXByZXNzaW9uKTtcbiAgICAgICAgYnVmZmVyLnB1c2hCb29sKHRoaXMuZW5hYmxlSHRtbEZpbHRlcmluZyk7XG4gICAgICAgIGJ1ZmZlci5wdXNoQm9vbCh0aGlzLmVuYWJsZUluTWVtb3J5Q2FjaGUpO1xuICAgICAgICBidWZmZXIucHVzaEJvb2wodGhpcy5lbmFibGVNdXRhdGlvbk9ic2VydmVyKTtcbiAgICAgICAgYnVmZmVyLnB1c2hCb29sKHRoaXMuZW5hYmxlT3B0aW1pemF0aW9ucyk7XG4gICAgICAgIGJ1ZmZlci5wdXNoQm9vbCh0aGlzLmVuYWJsZVB1c2hJbmplY3Rpb25zT25OYXZpZ2F0aW9uRXZlbnRzKTtcbiAgICAgICAgYnVmZmVyLnB1c2hCb29sKHRoaXMuZ3Vlc3NSZXF1ZXN0VHlwZUZyb21VcmwpO1xuICAgICAgICBidWZmZXIucHVzaEJvb2wodGhpcy5pbnRlZ3JpdHlDaGVjayk7XG4gICAgICAgIGJ1ZmZlci5wdXNoQm9vbCh0aGlzLmxvYWRDU1BGaWx0ZXJzKTtcbiAgICAgICAgYnVmZmVyLnB1c2hCb29sKHRoaXMubG9hZENvc21ldGljRmlsdGVycyk7XG4gICAgICAgIGJ1ZmZlci5wdXNoQm9vbCh0aGlzLmxvYWRFeGNlcHRpb25GaWx0ZXJzKTtcbiAgICAgICAgYnVmZmVyLnB1c2hCb29sKHRoaXMubG9hZEV4dGVuZGVkU2VsZWN0b3JzKTtcbiAgICAgICAgYnVmZmVyLnB1c2hCb29sKHRoaXMubG9hZEdlbmVyaWNDb3NtZXRpY3NGaWx0ZXJzKTtcbiAgICAgICAgYnVmZmVyLnB1c2hCb29sKHRoaXMubG9hZE5ldHdvcmtGaWx0ZXJzKTtcbiAgICAgICAgYnVmZmVyLnB1c2hCb29sKHRoaXMubG9hZFByZXByb2Nlc3NvcnMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmZpZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/crc32.js":
/*!************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/crc32.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ crc32)\n/* harmony export */ });\n/* crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */\n/* From: https://github.com/SheetJS/js-crc32/ */\nconst T = (() => {\n    let c = 0;\n    const table = new Int32Array(256);\n    for (let n = 0; n !== 256; n += 1) {\n        c = n;\n        c = c & 1 ? -306674912 ^ (c >>> 1) : c >>> 1;\n        c = c & 1 ? -306674912 ^ (c >>> 1) : c >>> 1;\n        c = c & 1 ? -306674912 ^ (c >>> 1) : c >>> 1;\n        c = c & 1 ? -306674912 ^ (c >>> 1) : c >>> 1;\n        c = c & 1 ? -306674912 ^ (c >>> 1) : c >>> 1;\n        c = c & 1 ? -306674912 ^ (c >>> 1) : c >>> 1;\n        c = c & 1 ? -306674912 ^ (c >>> 1) : c >>> 1;\n        c = c & 1 ? -306674912 ^ (c >>> 1) : c >>> 1;\n        table[n] = c;\n    }\n    return table;\n})();\nfunction crc32(buf, start, end) {\n    let C = 0 ^ -1;\n    const L = end - 7;\n    let i = start;\n    while (i < L) {\n        C = (C >>> 8) ^ T[(C ^ buf[i++]) & 0xff];\n        C = (C >>> 8) ^ T[(C ^ buf[i++]) & 0xff];\n        C = (C >>> 8) ^ T[(C ^ buf[i++]) & 0xff];\n        C = (C >>> 8) ^ T[(C ^ buf[i++]) & 0xff];\n        C = (C >>> 8) ^ T[(C ^ buf[i++]) & 0xff];\n        C = (C >>> 8) ^ T[(C ^ buf[i++]) & 0xff];\n        C = (C >>> 8) ^ T[(C ^ buf[i++]) & 0xff];\n        C = (C >>> 8) ^ T[(C ^ buf[i++]) & 0xff];\n    }\n    while (i < L + 7) {\n        C = (C >>> 8) ^ T[(C ^ buf[i++]) & 0xff];\n    }\n    return (C ^ -1) >>> 0;\n}\n//# sourceMappingURL=crc32.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9jcmMzMi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDYztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9jcmMzMi5qcz8zNmUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGNyYzMyLmpzIChDKSAyMDE0LXByZXNlbnQgU2hlZXRKUyAtLSBodHRwOi8vc2hlZXRqcy5jb20gKi9cbi8qIEZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9TaGVldEpTL2pzLWNyYzMyLyAqL1xuY29uc3QgVCA9ICgoKSA9PiB7XG4gICAgbGV0IGMgPSAwO1xuICAgIGNvbnN0IHRhYmxlID0gbmV3IEludDMyQXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiAhPT0gMjU2OyBuICs9IDEpIHtcbiAgICAgICAgYyA9IG47XG4gICAgICAgIGMgPSBjICYgMSA/IC0zMDY2NzQ5MTIgXiAoYyA+Pj4gMSkgOiBjID4+PiAxO1xuICAgICAgICBjID0gYyAmIDEgPyAtMzA2Njc0OTEyIF4gKGMgPj4+IDEpIDogYyA+Pj4gMTtcbiAgICAgICAgYyA9IGMgJiAxID8gLTMwNjY3NDkxMiBeIChjID4+PiAxKSA6IGMgPj4+IDE7XG4gICAgICAgIGMgPSBjICYgMSA/IC0zMDY2NzQ5MTIgXiAoYyA+Pj4gMSkgOiBjID4+PiAxO1xuICAgICAgICBjID0gYyAmIDEgPyAtMzA2Njc0OTEyIF4gKGMgPj4+IDEpIDogYyA+Pj4gMTtcbiAgICAgICAgYyA9IGMgJiAxID8gLTMwNjY3NDkxMiBeIChjID4+PiAxKSA6IGMgPj4+IDE7XG4gICAgICAgIGMgPSBjICYgMSA/IC0zMDY2NzQ5MTIgXiAoYyA+Pj4gMSkgOiBjID4+PiAxO1xuICAgICAgICBjID0gYyAmIDEgPyAtMzA2Njc0OTEyIF4gKGMgPj4+IDEpIDogYyA+Pj4gMTtcbiAgICAgICAgdGFibGVbbl0gPSBjO1xuICAgIH1cbiAgICByZXR1cm4gdGFibGU7XG59KSgpO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JjMzIoYnVmLCBzdGFydCwgZW5kKSB7XG4gICAgbGV0IEMgPSAwIF4gLTE7XG4gICAgY29uc3QgTCA9IGVuZCAtIDc7XG4gICAgbGV0IGkgPSBzdGFydDtcbiAgICB3aGlsZSAoaSA8IEwpIHtcbiAgICAgICAgQyA9IChDID4+PiA4KSBeIFRbKEMgXiBidWZbaSsrXSkgJiAweGZmXTtcbiAgICAgICAgQyA9IChDID4+PiA4KSBeIFRbKEMgXiBidWZbaSsrXSkgJiAweGZmXTtcbiAgICAgICAgQyA9IChDID4+PiA4KSBeIFRbKEMgXiBidWZbaSsrXSkgJiAweGZmXTtcbiAgICAgICAgQyA9IChDID4+PiA4KSBeIFRbKEMgXiBidWZbaSsrXSkgJiAweGZmXTtcbiAgICAgICAgQyA9IChDID4+PiA4KSBeIFRbKEMgXiBidWZbaSsrXSkgJiAweGZmXTtcbiAgICAgICAgQyA9IChDID4+PiA4KSBeIFRbKEMgXiBidWZbaSsrXSkgJiAweGZmXTtcbiAgICAgICAgQyA9IChDID4+PiA4KSBeIFRbKEMgXiBidWZbaSsrXSkgJiAweGZmXTtcbiAgICAgICAgQyA9IChDID4+PiA4KSBeIFRbKEMgXiBidWZbaSsrXSkgJiAweGZmXTtcbiAgICB9XG4gICAgd2hpbGUgKGkgPCBMICsgNykge1xuICAgICAgICBDID0gKEMgPj4+IDgpIF4gVFsoQyBeIGJ1ZltpKytdKSAmIDB4ZmZdO1xuICAgIH1cbiAgICByZXR1cm4gKEMgXiAtMSkgPj4+IDA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmMzMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/crc32.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/data-view.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/data-view.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EMPTY_UINT32_ARRAY: () => (/* binding */ EMPTY_UINT32_ARRAY),\n/* harmony export */   EMPTY_UINT8_ARRAY: () => (/* binding */ EMPTY_UINT8_ARRAY),\n/* harmony export */   StaticDataView: () => (/* binding */ StaticDataView),\n/* harmony export */   sizeOfASCII: () => (/* binding */ sizeOfASCII),\n/* harmony export */   sizeOfBool: () => (/* binding */ sizeOfBool),\n/* harmony export */   sizeOfByte: () => (/* binding */ sizeOfByte),\n/* harmony export */   sizeOfBytes: () => (/* binding */ sizeOfBytes),\n/* harmony export */   sizeOfBytesWithLength: () => (/* binding */ sizeOfBytesWithLength),\n/* harmony export */   sizeOfCosmeticSelector: () => (/* binding */ sizeOfCosmeticSelector),\n/* harmony export */   sizeOfLength: () => (/* binding */ sizeOfLength),\n/* harmony export */   sizeOfNetworkCSP: () => (/* binding */ sizeOfNetworkCSP),\n/* harmony export */   sizeOfNetworkFilter: () => (/* binding */ sizeOfNetworkFilter),\n/* harmony export */   sizeOfNetworkHostname: () => (/* binding */ sizeOfNetworkHostname),\n/* harmony export */   sizeOfNetworkRedirect: () => (/* binding */ sizeOfNetworkRedirect),\n/* harmony export */   sizeOfRawCosmetic: () => (/* binding */ sizeOfRawCosmetic),\n/* harmony export */   sizeOfRawNetwork: () => (/* binding */ sizeOfRawNetwork),\n/* harmony export */   sizeOfUTF8: () => (/* binding */ sizeOfUTF8),\n/* harmony export */   sizeOfUint32Array: () => (/* binding */ sizeOfUint32Array)\n/* harmony export */ });\n/* harmony import */ var _compression_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compression.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/compression.js\");\n/* harmony import */ var _crc32_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crc32.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/crc32.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\nconst EMPTY_UINT8_ARRAY = new Uint8Array(0);\nconst EMPTY_UINT32_ARRAY = new Uint32Array(0);\n// Check if current architecture is little endian\nconst LITTLE_ENDIAN = new Int8Array(new Int16Array([1]).buffer)[0] === 1;\n// TextEncoder doesn't need to be recreated every time unlike TextDecoder\nconst TEXT_ENCODER = new TextEncoder();\n// Store compression in a lazy, global singleton\nlet getCompressionSingleton = () => {\n    const COMPRESSION = new _compression_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    getCompressionSingleton = () => COMPRESSION;\n    return COMPRESSION;\n};\nfunction align4(pos) {\n    // From: https://stackoverflow.com/a/2022194\n    return (pos + 3) & ~0x03;\n}\n/**\n * Return size of of a serialized byte value.\n */\nfunction sizeOfByte() {\n    return 1;\n}\n/**\n * Return size of of a serialized boolean value.\n */\nfunction sizeOfBool() {\n    return 1;\n}\n/**\n * Return number of bytes needed to serialize `length`.\n */\nfunction sizeOfLength(length) {\n    return length <= 127 ? 1 : 5;\n}\n/**\n * Return number of bytes needed to serialize `array` Uint8Array typed array.\n *\n * WARNING: this only returns the correct size if `align` is `false`.\n */\nfunction sizeOfBytes(array, align) {\n    return sizeOfBytesWithLength(array.length, align);\n}\n/**\n * Return number of bytes needed to serialize `array` Uint8Array typed array.\n *\n * WARNING: this only returns the correct size if `align` is `false`.\n */\nfunction sizeOfBytesWithLength(length, align) {\n    // Alignment is a tricky thing because it depends on the current offset in\n    // the buffer at the time of serialization; which we cannot anticipate\n    // before actually starting serialization. This means that we need to\n    // potentially over-estimate the size (at most by 3 bytes) to make sure the\n    // final size is at least equal or a bit bigger than necessary.\n    return (align ? 3 : 0) + length + sizeOfLength(length);\n}\n/**\n * Return number of bytes needed to serialize `str` ASCII string.\n */\nfunction sizeOfASCII(str) {\n    return str.length + sizeOfLength(str.length);\n}\n/**\n * Return number of bytes needed to serialize `str` UTF8 string.\n */\nfunction sizeOfUTF8(str) {\n    const encodedLength = TEXT_ENCODER.encode(str).length;\n    return encodedLength + sizeOfLength(encodedLength);\n}\n/**\n * Return number of bytes needed to serialize `array`.\n */\nfunction sizeOfUint32Array(array) {\n    return array.byteLength + sizeOfLength(array.length);\n}\nfunction sizeOfNetworkRedirect(str, compression) {\n    return compression === true\n        ? sizeOfBytesWithLength(getCompressionSingleton().networkRedirect.getCompressedSize(str), false)\n        : sizeOfASCII(str);\n}\nfunction sizeOfNetworkHostname(str, compression) {\n    return compression === true\n        ? sizeOfBytesWithLength(getCompressionSingleton().networkHostname.getCompressedSize(str), false)\n        : sizeOfASCII(str);\n}\nfunction sizeOfNetworkCSP(str, compression) {\n    return compression === true\n        ? sizeOfBytesWithLength(getCompressionSingleton().networkCSP.getCompressedSize(str), false)\n        : sizeOfASCII(str);\n}\nfunction sizeOfNetworkFilter(str, compression) {\n    return compression === true\n        ? sizeOfBytesWithLength(getCompressionSingleton().networkFilter.getCompressedSize(str), false)\n        : sizeOfASCII(str);\n}\nfunction sizeOfCosmeticSelector(str, compression) {\n    return compression === true\n        ? sizeOfBytesWithLength(getCompressionSingleton().cosmeticSelector.getCompressedSize(str), false)\n        : sizeOfASCII(str);\n}\nfunction sizeOfRawNetwork(str, compression) {\n    return compression === true\n        ? sizeOfBytesWithLength(getCompressionSingleton().networkRaw.getCompressedSize(TEXT_ENCODER.encode(str)), false)\n        : sizeOfUTF8(str);\n}\nfunction sizeOfRawCosmetic(str, compression) {\n    return compression === true\n        ? sizeOfBytesWithLength(getCompressionSingleton().cosmeticRaw.getCompressedSize(TEXT_ENCODER.encode(str)), false)\n        : sizeOfUTF8(str);\n}\n/**\n * This abstraction allows to serialize efficiently low-level values of types:\n * string, uint8, uint16, uint32, etc. while hiding the complexity of managing\n * the current offset and growing. It should always be instantiated with a\n * big-enough length because this will not allow for resizing. To allow\n * deciding the required total size, function estimating the size needed to\n * store different primitive values are exposes as static methods.\n *\n * This class is also more efficient than the built-in `DataView`.\n *\n * The way this is used in practice is that you write pairs of function to\n * serialize and deserialize a given structure/class (with code being pretty\n * symetrical). In the serializer you `pushX` values, and in the deserializer\n * you use `getX` functions to get back the values.\n */\nclass StaticDataView {\n    /**\n     * Create an empty (i.e.: size = 0) StaticDataView.\n     */\n    static empty(options) {\n        return StaticDataView.fromUint8Array(EMPTY_UINT8_ARRAY, options);\n    }\n    /**\n     * Instantiate a StaticDataView instance from `array` of type Uint8Array.\n     */\n    static fromUint8Array(array, options) {\n        return new StaticDataView(array, options);\n    }\n    /**\n     * Instantiate a StaticDataView with given `capacity` number of bytes.\n     */\n    static allocate(capacity, options) {\n        return new StaticDataView(new Uint8Array(capacity), options);\n    }\n    constructor(buffer, { enableCompression }) {\n        if (LITTLE_ENDIAN === false) {\n            // This check makes sure that we will not load the adblocker on a\n            // big-endian system. This would not work since byte ordering is important\n            // at the moment (mainly for performance reasons).\n            throw new Error('Adblocker currently does not support Big-endian systems');\n        }\n        if (enableCompression === true) {\n            this.enableCompression();\n        }\n        this.buffer = buffer;\n        this.pos = 0;\n    }\n    enableCompression() {\n        this.compression = getCompressionSingleton();\n    }\n    checksum() {\n        return (0,_crc32_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.buffer, 0, this.pos);\n    }\n    dataAvailable() {\n        return this.pos < this.buffer.byteLength;\n    }\n    setPos(pos) {\n        this.pos = pos;\n    }\n    getPos() {\n        return this.pos;\n    }\n    seekZero() {\n        this.pos = 0;\n    }\n    slice() {\n        this.checkSize();\n        return this.buffer.slice(0, this.pos);\n    }\n    subarray() {\n        if (this.pos === this.buffer.byteLength) {\n            return this.buffer;\n        }\n        this.checkSize();\n        return this.buffer.subarray(0, this.pos);\n    }\n    /**\n     * Make sure that `this.pos` is aligned on a multiple of 4.\n     */\n    align4() {\n        this.pos = align4(this.pos);\n    }\n    set(buffer) {\n        this.buffer = new Uint8Array(buffer);\n        this.seekZero();\n    }\n    pushBool(bool) {\n        this.pushByte(Number(bool));\n    }\n    getBool() {\n        return Boolean(this.getByte());\n    }\n    setByte(pos, byte) {\n        this.buffer[pos] = byte;\n    }\n    pushByte(octet) {\n        this.pushUint8(octet);\n    }\n    getByte() {\n        return this.getUint8();\n    }\n    pushBytes(bytes, align = false) {\n        this.pushLength(bytes.length);\n        if (align === true) {\n            this.align4();\n        }\n        this.buffer.set(bytes, this.pos);\n        this.pos += bytes.byteLength;\n    }\n    getBytes(align = false) {\n        const numberOfBytes = this.getLength();\n        if (align === true) {\n            this.align4();\n        }\n        const bytes = this.buffer.subarray(this.pos, this.pos + numberOfBytes);\n        this.pos += numberOfBytes;\n        return bytes;\n    }\n    /**\n     * Allows row access to the internal buffer through a Uint32Array acting like\n     * a view. This is used for super fast writing/reading of large chunks of\n     * Uint32 numbers in the byte array.\n     */\n    getUint32ArrayView(desiredSize) {\n        // Round this.pos to next multiple of 4 for alignement\n        this.align4();\n        // Short-cut when empty array\n        if (desiredSize === 0) {\n            return EMPTY_UINT32_ARRAY;\n        }\n        // Create non-empty view\n        const view = new Uint32Array(this.buffer.buffer, this.pos + this.buffer.byteOffset, desiredSize);\n        this.pos += desiredSize * 4;\n        return view;\n    }\n    pushUint8(uint8) {\n        this.buffer[this.pos++] = uint8;\n    }\n    getUint8() {\n        return this.buffer[this.pos++];\n    }\n    pushUint16(uint16) {\n        this.buffer[this.pos++] = uint16 >>> 8;\n        this.buffer[this.pos++] = uint16;\n    }\n    getUint16() {\n        return ((this.buffer[this.pos++] << 8) | this.buffer[this.pos++]) >>> 0;\n    }\n    pushUint32(uint32) {\n        this.buffer[this.pos++] = uint32 >>> 24;\n        this.buffer[this.pos++] = uint32 >>> 16;\n        this.buffer[this.pos++] = uint32 >>> 8;\n        this.buffer[this.pos++] = uint32;\n    }\n    getUint32() {\n        return ((((this.buffer[this.pos++] << 24) >>> 0) +\n            ((this.buffer[this.pos++] << 16) |\n                (this.buffer[this.pos++] << 8) |\n                this.buffer[this.pos++])) >>>\n            0);\n    }\n    pushUint32Array(arr) {\n        this.pushLength(arr.length);\n        // TODO - use `set` to push the full buffer at once?\n        for (const n of arr) {\n            this.pushUint32(n);\n        }\n    }\n    getUint32Array() {\n        const length = this.getLength();\n        const arr = new Uint32Array(length);\n        // TODO - use `subarray`?\n        for (let i = 0; i < length; i += 1) {\n            arr[i] = this.getUint32();\n        }\n        return arr;\n    }\n    pushUTF8(raw) {\n        const pos = this.getPos();\n        // Assume the size of output length is 1 (which means output is less than 128)\n        // based on the possible minimal length to avoid memory relocation.\n        // The minimal length is always 1 byte per character.\n        const start = pos + sizeOfLength(raw.length);\n        const { written } = TEXT_ENCODER.encodeInto(raw, this.buffer.subarray(start));\n        // If we failed to predict, that means the required bytes for length is 5.\n        if (pos + sizeOfLength(written) !== start) {\n            // Push 4 bytes back, `start + 4` or `pos + 5`\n            this.buffer.copyWithin(pos + 5, start, start + written);\n        }\n        // Restore pos to push length\n        this.setPos(pos);\n        this.pushLength(written);\n        // Reflect written bytes to pos\n        this.setPos(this.pos + written);\n    }\n    getUTF8() {\n        const byteLength = this.getLength();\n        this.pos += byteLength;\n        return new TextDecoder('utf8', { ignoreBOM: true }).decode(this.buffer.subarray(this.pos - byteLength, this.pos));\n    }\n    pushASCII(str) {\n        this.pushLength(str.length);\n        for (let i = 0; i < str.length; i += 1) {\n            this.buffer[this.pos++] = str.charCodeAt(i);\n        }\n    }\n    getASCII() {\n        const byteLength = this.getLength();\n        this.pos += byteLength;\n        // @ts-expect-error `Uint8Array<ArrayBufferLike>` is indexable with `number`\n        return String.fromCharCode.apply(null, this.buffer.subarray(this.pos - byteLength, this.pos));\n    }\n    pushNetworkRedirect(str) {\n        if (this.compression !== undefined) {\n            this.pushBytes(this.compression.networkRedirect.compress(str));\n        }\n        else {\n            this.pushASCII(str);\n        }\n    }\n    getNetworkRedirect() {\n        if (this.compression !== undefined) {\n            return this.compression.networkRedirect.decompress(this.getBytes());\n        }\n        return this.getASCII();\n    }\n    pushNetworkHostname(str) {\n        if (this.compression !== undefined) {\n            this.pushBytes(this.compression.networkHostname.compress(str));\n        }\n        else {\n            this.pushASCII(str);\n        }\n    }\n    getNetworkHostname() {\n        if (this.compression !== undefined) {\n            return this.compression.networkHostname.decompress(this.getBytes());\n        }\n        return this.getASCII();\n    }\n    pushNetworkCSP(str) {\n        if (this.compression !== undefined) {\n            this.pushBytes(this.compression.networkCSP.compress(str));\n        }\n        else {\n            this.pushASCII(str);\n        }\n    }\n    getNetworkCSP() {\n        if (this.compression !== undefined) {\n            return this.compression.networkCSP.decompress(this.getBytes());\n        }\n        return this.getASCII();\n    }\n    pushNetworkFilter(str) {\n        if (this.compression !== undefined) {\n            this.pushBytes(this.compression.networkFilter.compress(str));\n        }\n        else {\n            this.pushASCII(str);\n        }\n    }\n    getNetworkFilter() {\n        if (this.compression !== undefined) {\n            return this.compression.networkFilter.decompress(this.getBytes());\n        }\n        return this.getASCII();\n    }\n    pushCosmeticSelector(str) {\n        if (this.compression !== undefined) {\n            this.pushBytes(this.compression.cosmeticSelector.compress(str));\n        }\n        else {\n            this.pushASCII(str);\n        }\n    }\n    getCosmeticSelector() {\n        if (this.compression !== undefined) {\n            return this.compression.cosmeticSelector.decompress(this.getBytes());\n        }\n        return this.getASCII();\n    }\n    pushRawCosmetic(str) {\n        if (this.compression !== undefined) {\n            this.pushBytes(this.compression.cosmeticRaw.compress(TEXT_ENCODER.encode(str)));\n        }\n        else {\n            this.pushUTF8(str);\n        }\n    }\n    getRawCosmetic() {\n        if (this.compression !== undefined) {\n            return new TextDecoder('utf8', { ignoreBOM: true }).decode(this.compression.cosmeticRaw.decompressRaw(this.getBytes()));\n        }\n        return this.getUTF8();\n    }\n    pushRawNetwork(str) {\n        if (this.compression !== undefined) {\n            this.pushBytes(this.compression.networkRaw.compress(TEXT_ENCODER.encode(str)));\n        }\n        else {\n            this.pushUTF8(str);\n        }\n    }\n    getRawNetwork() {\n        if (this.compression !== undefined) {\n            return new TextDecoder('utf8', { ignoreBOM: true }).decode(this.compression.networkRaw.decompressRaw(this.getBytes()));\n        }\n        return this.getUTF8();\n    }\n    checkSize() {\n        if (this.pos !== 0 && this.pos > this.buffer.byteLength) {\n            throw new Error(`StaticDataView too small: ${this.buffer.byteLength}, but required ${this.pos} bytes`);\n        }\n    }\n    // Serialiez `length` with variable encoding to save space\n    pushLength(length) {\n        if (length <= 127) {\n            this.pushUint8(length);\n        }\n        else {\n            this.pushUint8(128);\n            this.pushUint32(length);\n        }\n    }\n    getLength() {\n        const lengthShort = this.getUint8();\n        return lengthShort === 128 ? this.getUint32() : lengthShort;\n    }\n}\n//# sourceMappingURL=data-view.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9kYXRhLXZpZXcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyQztBQUNaO0FBQ3hCO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdURBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlCQUFpQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlCQUFpQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHVCQUF1QixpQkFBaUIsVUFBVTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvYWRibG9ja2VyL2Rpc3QvZXNtL2RhdGEtdmlldy5qcz82NDk5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQgR2hvc3RlcnkgR21iSC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IENvbXByZXNzaW9uIGZyb20gJy4vY29tcHJlc3Npb24uanMnO1xuaW1wb3J0IGNyYzMyIGZyb20gJy4vY3JjMzIuanMnO1xuZXhwb3J0IGNvbnN0IEVNUFRZX1VJTlQ4X0FSUkFZID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG5leHBvcnQgY29uc3QgRU1QVFlfVUlOVDMyX0FSUkFZID0gbmV3IFVpbnQzMkFycmF5KDApO1xuLy8gQ2hlY2sgaWYgY3VycmVudCBhcmNoaXRlY3R1cmUgaXMgbGl0dGxlIGVuZGlhblxuY29uc3QgTElUVExFX0VORElBTiA9IG5ldyBJbnQ4QXJyYXkobmV3IEludDE2QXJyYXkoWzFdKS5idWZmZXIpWzBdID09PSAxO1xuLy8gVGV4dEVuY29kZXIgZG9lc24ndCBuZWVkIHRvIGJlIHJlY3JlYXRlZCBldmVyeSB0aW1lIHVubGlrZSBUZXh0RGVjb2RlclxuY29uc3QgVEVYVF9FTkNPREVSID0gbmV3IFRleHRFbmNvZGVyKCk7XG4vLyBTdG9yZSBjb21wcmVzc2lvbiBpbiBhIGxhenksIGdsb2JhbCBzaW5nbGV0b25cbmxldCBnZXRDb21wcmVzc2lvblNpbmdsZXRvbiA9ICgpID0+IHtcbiAgICBjb25zdCBDT01QUkVTU0lPTiA9IG5ldyBDb21wcmVzc2lvbigpO1xuICAgIGdldENvbXByZXNzaW9uU2luZ2xldG9uID0gKCkgPT4gQ09NUFJFU1NJT047XG4gICAgcmV0dXJuIENPTVBSRVNTSU9OO1xufTtcbmZ1bmN0aW9uIGFsaWduNChwb3MpIHtcbiAgICAvLyBGcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjAyMjE5NFxuICAgIHJldHVybiAocG9zICsgMykgJiB+MHgwMztcbn1cbi8qKlxuICogUmV0dXJuIHNpemUgb2Ygb2YgYSBzZXJpYWxpemVkIGJ5dGUgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaXplT2ZCeXRlKCkge1xuICAgIHJldHVybiAxO1xufVxuLyoqXG4gKiBSZXR1cm4gc2l6ZSBvZiBvZiBhIHNlcmlhbGl6ZWQgYm9vbGVhbiB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpemVPZkJvb2woKSB7XG4gICAgcmV0dXJuIDE7XG59XG4vKipcbiAqIFJldHVybiBudW1iZXIgb2YgYnl0ZXMgbmVlZGVkIHRvIHNlcmlhbGl6ZSBgbGVuZ3RoYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpemVPZkxlbmd0aChsZW5ndGgpIHtcbiAgICByZXR1cm4gbGVuZ3RoIDw9IDEyNyA/IDEgOiA1O1xufVxuLyoqXG4gKiBSZXR1cm4gbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCB0byBzZXJpYWxpemUgYGFycmF5YCBVaW50OEFycmF5IHR5cGVkIGFycmF5LlxuICpcbiAqIFdBUk5JTkc6IHRoaXMgb25seSByZXR1cm5zIHRoZSBjb3JyZWN0IHNpemUgaWYgYGFsaWduYCBpcyBgZmFsc2VgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2l6ZU9mQnl0ZXMoYXJyYXksIGFsaWduKSB7XG4gICAgcmV0dXJuIHNpemVPZkJ5dGVzV2l0aExlbmd0aChhcnJheS5sZW5ndGgsIGFsaWduKTtcbn1cbi8qKlxuICogUmV0dXJuIG51bWJlciBvZiBieXRlcyBuZWVkZWQgdG8gc2VyaWFsaXplIGBhcnJheWAgVWludDhBcnJheSB0eXBlZCBhcnJheS5cbiAqXG4gKiBXQVJOSU5HOiB0aGlzIG9ubHkgcmV0dXJucyB0aGUgY29ycmVjdCBzaXplIGlmIGBhbGlnbmAgaXMgYGZhbHNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpemVPZkJ5dGVzV2l0aExlbmd0aChsZW5ndGgsIGFsaWduKSB7XG4gICAgLy8gQWxpZ25tZW50IGlzIGEgdHJpY2t5IHRoaW5nIGJlY2F1c2UgaXQgZGVwZW5kcyBvbiB0aGUgY3VycmVudCBvZmZzZXQgaW5cbiAgICAvLyB0aGUgYnVmZmVyIGF0IHRoZSB0aW1lIG9mIHNlcmlhbGl6YXRpb247IHdoaWNoIHdlIGNhbm5vdCBhbnRpY2lwYXRlXG4gICAgLy8gYmVmb3JlIGFjdHVhbGx5IHN0YXJ0aW5nIHNlcmlhbGl6YXRpb24uIFRoaXMgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvXG4gICAgLy8gcG90ZW50aWFsbHkgb3Zlci1lc3RpbWF0ZSB0aGUgc2l6ZSAoYXQgbW9zdCBieSAzIGJ5dGVzKSB0byBtYWtlIHN1cmUgdGhlXG4gICAgLy8gZmluYWwgc2l6ZSBpcyBhdCBsZWFzdCBlcXVhbCBvciBhIGJpdCBiaWdnZXIgdGhhbiBuZWNlc3NhcnkuXG4gICAgcmV0dXJuIChhbGlnbiA/IDMgOiAwKSArIGxlbmd0aCArIHNpemVPZkxlbmd0aChsZW5ndGgpO1xufVxuLyoqXG4gKiBSZXR1cm4gbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCB0byBzZXJpYWxpemUgYHN0cmAgQVNDSUkgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2l6ZU9mQVNDSUkoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5sZW5ndGggKyBzaXplT2ZMZW5ndGgoc3RyLmxlbmd0aCk7XG59XG4vKipcbiAqIFJldHVybiBudW1iZXIgb2YgYnl0ZXMgbmVlZGVkIHRvIHNlcmlhbGl6ZSBgc3RyYCBVVEY4IHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpemVPZlVURjgoc3RyKSB7XG4gICAgY29uc3QgZW5jb2RlZExlbmd0aCA9IFRFWFRfRU5DT0RFUi5lbmNvZGUoc3RyKS5sZW5ndGg7XG4gICAgcmV0dXJuIGVuY29kZWRMZW5ndGggKyBzaXplT2ZMZW5ndGgoZW5jb2RlZExlbmd0aCk7XG59XG4vKipcbiAqIFJldHVybiBudW1iZXIgb2YgYnl0ZXMgbmVlZGVkIHRvIHNlcmlhbGl6ZSBgYXJyYXlgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2l6ZU9mVWludDMyQXJyYXkoYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXkuYnl0ZUxlbmd0aCArIHNpemVPZkxlbmd0aChhcnJheS5sZW5ndGgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpemVPZk5ldHdvcmtSZWRpcmVjdChzdHIsIGNvbXByZXNzaW9uKSB7XG4gICAgcmV0dXJuIGNvbXByZXNzaW9uID09PSB0cnVlXG4gICAgICAgID8gc2l6ZU9mQnl0ZXNXaXRoTGVuZ3RoKGdldENvbXByZXNzaW9uU2luZ2xldG9uKCkubmV0d29ya1JlZGlyZWN0LmdldENvbXByZXNzZWRTaXplKHN0ciksIGZhbHNlKVxuICAgICAgICA6IHNpemVPZkFTQ0lJKHN0cik7XG59XG5leHBvcnQgZnVuY3Rpb24gc2l6ZU9mTmV0d29ya0hvc3RuYW1lKHN0ciwgY29tcHJlc3Npb24pIHtcbiAgICByZXR1cm4gY29tcHJlc3Npb24gPT09IHRydWVcbiAgICAgICAgPyBzaXplT2ZCeXRlc1dpdGhMZW5ndGgoZ2V0Q29tcHJlc3Npb25TaW5nbGV0b24oKS5uZXR3b3JrSG9zdG5hbWUuZ2V0Q29tcHJlc3NlZFNpemUoc3RyKSwgZmFsc2UpXG4gICAgICAgIDogc2l6ZU9mQVNDSUkoc3RyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaXplT2ZOZXR3b3JrQ1NQKHN0ciwgY29tcHJlc3Npb24pIHtcbiAgICByZXR1cm4gY29tcHJlc3Npb24gPT09IHRydWVcbiAgICAgICAgPyBzaXplT2ZCeXRlc1dpdGhMZW5ndGgoZ2V0Q29tcHJlc3Npb25TaW5nbGV0b24oKS5uZXR3b3JrQ1NQLmdldENvbXByZXNzZWRTaXplKHN0ciksIGZhbHNlKVxuICAgICAgICA6IHNpemVPZkFTQ0lJKHN0cik7XG59XG5leHBvcnQgZnVuY3Rpb24gc2l6ZU9mTmV0d29ya0ZpbHRlcihzdHIsIGNvbXByZXNzaW9uKSB7XG4gICAgcmV0dXJuIGNvbXByZXNzaW9uID09PSB0cnVlXG4gICAgICAgID8gc2l6ZU9mQnl0ZXNXaXRoTGVuZ3RoKGdldENvbXByZXNzaW9uU2luZ2xldG9uKCkubmV0d29ya0ZpbHRlci5nZXRDb21wcmVzc2VkU2l6ZShzdHIpLCBmYWxzZSlcbiAgICAgICAgOiBzaXplT2ZBU0NJSShzdHIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpemVPZkNvc21ldGljU2VsZWN0b3Ioc3RyLCBjb21wcmVzc2lvbikge1xuICAgIHJldHVybiBjb21wcmVzc2lvbiA9PT0gdHJ1ZVxuICAgICAgICA/IHNpemVPZkJ5dGVzV2l0aExlbmd0aChnZXRDb21wcmVzc2lvblNpbmdsZXRvbigpLmNvc21ldGljU2VsZWN0b3IuZ2V0Q29tcHJlc3NlZFNpemUoc3RyKSwgZmFsc2UpXG4gICAgICAgIDogc2l6ZU9mQVNDSUkoc3RyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaXplT2ZSYXdOZXR3b3JrKHN0ciwgY29tcHJlc3Npb24pIHtcbiAgICByZXR1cm4gY29tcHJlc3Npb24gPT09IHRydWVcbiAgICAgICAgPyBzaXplT2ZCeXRlc1dpdGhMZW5ndGgoZ2V0Q29tcHJlc3Npb25TaW5nbGV0b24oKS5uZXR3b3JrUmF3LmdldENvbXByZXNzZWRTaXplKFRFWFRfRU5DT0RFUi5lbmNvZGUoc3RyKSksIGZhbHNlKVxuICAgICAgICA6IHNpemVPZlVURjgoc3RyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaXplT2ZSYXdDb3NtZXRpYyhzdHIsIGNvbXByZXNzaW9uKSB7XG4gICAgcmV0dXJuIGNvbXByZXNzaW9uID09PSB0cnVlXG4gICAgICAgID8gc2l6ZU9mQnl0ZXNXaXRoTGVuZ3RoKGdldENvbXByZXNzaW9uU2luZ2xldG9uKCkuY29zbWV0aWNSYXcuZ2V0Q29tcHJlc3NlZFNpemUoVEVYVF9FTkNPREVSLmVuY29kZShzdHIpKSwgZmFsc2UpXG4gICAgICAgIDogc2l6ZU9mVVRGOChzdHIpO1xufVxuLyoqXG4gKiBUaGlzIGFic3RyYWN0aW9uIGFsbG93cyB0byBzZXJpYWxpemUgZWZmaWNpZW50bHkgbG93LWxldmVsIHZhbHVlcyBvZiB0eXBlczpcbiAqIHN0cmluZywgdWludDgsIHVpbnQxNiwgdWludDMyLCBldGMuIHdoaWxlIGhpZGluZyB0aGUgY29tcGxleGl0eSBvZiBtYW5hZ2luZ1xuICogdGhlIGN1cnJlbnQgb2Zmc2V0IGFuZCBncm93aW5nLiBJdCBzaG91bGQgYWx3YXlzIGJlIGluc3RhbnRpYXRlZCB3aXRoIGFcbiAqIGJpZy1lbm91Z2ggbGVuZ3RoIGJlY2F1c2UgdGhpcyB3aWxsIG5vdCBhbGxvdyBmb3IgcmVzaXppbmcuIFRvIGFsbG93XG4gKiBkZWNpZGluZyB0aGUgcmVxdWlyZWQgdG90YWwgc2l6ZSwgZnVuY3Rpb24gZXN0aW1hdGluZyB0aGUgc2l6ZSBuZWVkZWQgdG9cbiAqIHN0b3JlIGRpZmZlcmVudCBwcmltaXRpdmUgdmFsdWVzIGFyZSBleHBvc2VzIGFzIHN0YXRpYyBtZXRob2RzLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgYWxzbyBtb3JlIGVmZmljaWVudCB0aGFuIHRoZSBidWlsdC1pbiBgRGF0YVZpZXdgLlxuICpcbiAqIFRoZSB3YXkgdGhpcyBpcyB1c2VkIGluIHByYWN0aWNlIGlzIHRoYXQgeW91IHdyaXRlIHBhaXJzIG9mIGZ1bmN0aW9uIHRvXG4gKiBzZXJpYWxpemUgYW5kIGRlc2VyaWFsaXplIGEgZ2l2ZW4gc3RydWN0dXJlL2NsYXNzICh3aXRoIGNvZGUgYmVpbmcgcHJldHR5XG4gKiBzeW1ldHJpY2FsKS4gSW4gdGhlIHNlcmlhbGl6ZXIgeW91IGBwdXNoWGAgdmFsdWVzLCBhbmQgaW4gdGhlIGRlc2VyaWFsaXplclxuICogeW91IHVzZSBgZ2V0WGAgZnVuY3Rpb25zIHRvIGdldCBiYWNrIHRoZSB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGF0aWNEYXRhVmlldyB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGVtcHR5IChpLmUuOiBzaXplID0gMCkgU3RhdGljRGF0YVZpZXcuXG4gICAgICovXG4gICAgc3RhdGljIGVtcHR5KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFN0YXRpY0RhdGFWaWV3LmZyb21VaW50OEFycmF5KEVNUFRZX1VJTlQ4X0FSUkFZLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSBTdGF0aWNEYXRhVmlldyBpbnN0YW5jZSBmcm9tIGBhcnJheWAgb2YgdHlwZSBVaW50OEFycmF5LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVWludDhBcnJheShhcnJheSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRpY0RhdGFWaWV3KGFycmF5LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSBTdGF0aWNEYXRhVmlldyB3aXRoIGdpdmVuIGBjYXBhY2l0eWAgbnVtYmVyIG9mIGJ5dGVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhbGxvY2F0ZShjYXBhY2l0eSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRpY0RhdGFWaWV3KG5ldyBVaW50OEFycmF5KGNhcGFjaXR5KSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgeyBlbmFibGVDb21wcmVzc2lvbiB9KSB7XG4gICAgICAgIGlmIChMSVRUTEVfRU5ESUFOID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBjaGVjayBtYWtlcyBzdXJlIHRoYXQgd2Ugd2lsbCBub3QgbG9hZCB0aGUgYWRibG9ja2VyIG9uIGFcbiAgICAgICAgICAgIC8vIGJpZy1lbmRpYW4gc3lzdGVtLiBUaGlzIHdvdWxkIG5vdCB3b3JrIHNpbmNlIGJ5dGUgb3JkZXJpbmcgaXMgaW1wb3J0YW50XG4gICAgICAgICAgICAvLyBhdCB0aGUgbW9tZW50IChtYWlubHkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGJsb2NrZXIgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgQmlnLWVuZGlhbiBzeXN0ZW1zJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYWJsZUNvbXByZXNzaW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZUNvbXByZXNzaW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgZW5hYmxlQ29tcHJlc3Npb24oKSB7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSBnZXRDb21wcmVzc2lvblNpbmdsZXRvbigpO1xuICAgIH1cbiAgICBjaGVja3N1bSgpIHtcbiAgICAgICAgcmV0dXJuIGNyYzMyKHRoaXMuYnVmZmVyLCAwLCB0aGlzLnBvcyk7XG4gICAgfVxuICAgIGRhdGFBdmFpbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA8IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHNldFBvcyhwb3MpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgfVxuICAgIGdldFBvcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zO1xuICAgIH1cbiAgICBzZWVrWmVybygpIHtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICBzbGljZSgpIHtcbiAgICAgICAgdGhpcy5jaGVja1NpemUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNsaWNlKDAsIHRoaXMucG9zKTtcbiAgICB9XG4gICAgc3ViYXJyYXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA9PT0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tTaXplKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VyZSB0aGF0IGB0aGlzLnBvc2AgaXMgYWxpZ25lZCBvbiBhIG11bHRpcGxlIG9mIDQuXG4gICAgICovXG4gICAgYWxpZ240KCkge1xuICAgICAgICB0aGlzLnBvcyA9IGFsaWduNCh0aGlzLnBvcyk7XG4gICAgfVxuICAgIHNldChidWZmZXIpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICB0aGlzLnNlZWtaZXJvKCk7XG4gICAgfVxuICAgIHB1c2hCb29sKGJvb2wpIHtcbiAgICAgICAgdGhpcy5wdXNoQnl0ZShOdW1iZXIoYm9vbCkpO1xuICAgIH1cbiAgICBnZXRCb29sKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmdldEJ5dGUoKSk7XG4gICAgfVxuICAgIHNldEJ5dGUocG9zLCBieXRlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyW3Bvc10gPSBieXRlO1xuICAgIH1cbiAgICBwdXNoQnl0ZShvY3RldCkge1xuICAgICAgICB0aGlzLnB1c2hVaW50OChvY3RldCk7XG4gICAgfVxuICAgIGdldEJ5dGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVpbnQ4KCk7XG4gICAgfVxuICAgIHB1c2hCeXRlcyhieXRlcywgYWxpZ24gPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnB1c2hMZW5ndGgoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKGFsaWduID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmFsaWduNCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyLnNldChieXRlcywgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBnZXRCeXRlcyhhbGlnbiA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IG51bWJlck9mQnl0ZXMgPSB0aGlzLmdldExlbmd0aCgpO1xuICAgICAgICBpZiAoYWxpZ24gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWxpZ240KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheSh0aGlzLnBvcywgdGhpcy5wb3MgKyBudW1iZXJPZkJ5dGVzKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gbnVtYmVyT2ZCeXRlcztcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3Mgcm93IGFjY2VzcyB0byB0aGUgaW50ZXJuYWwgYnVmZmVyIHRocm91Z2ggYSBVaW50MzJBcnJheSBhY3RpbmcgbGlrZVxuICAgICAqIGEgdmlldy4gVGhpcyBpcyB1c2VkIGZvciBzdXBlciBmYXN0IHdyaXRpbmcvcmVhZGluZyBvZiBsYXJnZSBjaHVua3Mgb2ZcbiAgICAgKiBVaW50MzIgbnVtYmVycyBpbiB0aGUgYnl0ZSBhcnJheS5cbiAgICAgKi9cbiAgICBnZXRVaW50MzJBcnJheVZpZXcoZGVzaXJlZFNpemUpIHtcbiAgICAgICAgLy8gUm91bmQgdGhpcy5wb3MgdG8gbmV4dCBtdWx0aXBsZSBvZiA0IGZvciBhbGlnbmVtZW50XG4gICAgICAgIHRoaXMuYWxpZ240KCk7XG4gICAgICAgIC8vIFNob3J0LWN1dCB3aGVuIGVtcHR5IGFycmF5XG4gICAgICAgIGlmIChkZXNpcmVkU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX1VJTlQzMl9BUlJBWTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgbm9uLWVtcHR5IHZpZXdcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBVaW50MzJBcnJheSh0aGlzLmJ1ZmZlci5idWZmZXIsIHRoaXMucG9zICsgdGhpcy5idWZmZXIuYnl0ZU9mZnNldCwgZGVzaXJlZFNpemUpO1xuICAgICAgICB0aGlzLnBvcyArPSBkZXNpcmVkU2l6ZSAqIDQ7XG4gICAgICAgIHJldHVybiB2aWV3O1xuICAgIH1cbiAgICBwdXNoVWludDgodWludDgpIHtcbiAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3MrK10gPSB1aW50ODtcbiAgICB9XG4gICAgZ2V0VWludDgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLnBvcysrXTtcbiAgICB9XG4gICAgcHVzaFVpbnQxNih1aW50MTYpIHtcbiAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3MrK10gPSB1aW50MTYgPj4+IDg7XG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zKytdID0gdWludDE2O1xuICAgIH1cbiAgICBnZXRVaW50MTYoKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMuYnVmZmVyW3RoaXMucG9zKytdIDw8IDgpIHwgdGhpcy5idWZmZXJbdGhpcy5wb3MrK10pID4+PiAwO1xuICAgIH1cbiAgICBwdXNoVWludDMyKHVpbnQzMikge1xuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvcysrXSA9IHVpbnQzMiA+Pj4gMjQ7XG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zKytdID0gdWludDMyID4+PiAxNjtcbiAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3MrK10gPSB1aW50MzIgPj4+IDg7XG4gICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zKytdID0gdWludDMyO1xuICAgIH1cbiAgICBnZXRVaW50MzIoKSB7XG4gICAgICAgIHJldHVybiAoKCgodGhpcy5idWZmZXJbdGhpcy5wb3MrK10gPDwgMjQpID4+PiAwKSArXG4gICAgICAgICAgICAoKHRoaXMuYnVmZmVyW3RoaXMucG9zKytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKHRoaXMuYnVmZmVyW3RoaXMucG9zKytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvcysrXSkpID4+PlxuICAgICAgICAgICAgMCk7XG4gICAgfVxuICAgIHB1c2hVaW50MzJBcnJheShhcnIpIHtcbiAgICAgICAgdGhpcy5wdXNoTGVuZ3RoKGFyci5sZW5ndGgpO1xuICAgICAgICAvLyBUT0RPIC0gdXNlIGBzZXRgIHRvIHB1c2ggdGhlIGZ1bGwgYnVmZmVyIGF0IG9uY2U/XG4gICAgICAgIGZvciAoY29uc3QgbiBvZiBhcnIpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFVpbnQzMihuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRVaW50MzJBcnJheSgpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5nZXRMZW5ndGgoKTtcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQzMkFycmF5KGxlbmd0aCk7XG4gICAgICAgIC8vIFRPRE8gLSB1c2UgYHN1YmFycmF5YD9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgYXJyW2ldID0gdGhpcy5nZXRVaW50MzIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICBwdXNoVVRGOChyYXcpIHtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5nZXRQb3MoKTtcbiAgICAgICAgLy8gQXNzdW1lIHRoZSBzaXplIG9mIG91dHB1dCBsZW5ndGggaXMgMSAod2hpY2ggbWVhbnMgb3V0cHV0IGlzIGxlc3MgdGhhbiAxMjgpXG4gICAgICAgIC8vIGJhc2VkIG9uIHRoZSBwb3NzaWJsZSBtaW5pbWFsIGxlbmd0aCB0byBhdm9pZCBtZW1vcnkgcmVsb2NhdGlvbi5cbiAgICAgICAgLy8gVGhlIG1pbmltYWwgbGVuZ3RoIGlzIGFsd2F5cyAxIGJ5dGUgcGVyIGNoYXJhY3Rlci5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBwb3MgKyBzaXplT2ZMZW5ndGgocmF3Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHsgd3JpdHRlbiB9ID0gVEVYVF9FTkNPREVSLmVuY29kZUludG8ocmF3LCB0aGlzLmJ1ZmZlci5zdWJhcnJheShzdGFydCkpO1xuICAgICAgICAvLyBJZiB3ZSBmYWlsZWQgdG8gcHJlZGljdCwgdGhhdCBtZWFucyB0aGUgcmVxdWlyZWQgYnl0ZXMgZm9yIGxlbmd0aCBpcyA1LlxuICAgICAgICBpZiAocG9zICsgc2l6ZU9mTGVuZ3RoKHdyaXR0ZW4pICE9PSBzdGFydCkge1xuICAgICAgICAgICAgLy8gUHVzaCA0IGJ5dGVzIGJhY2ssIGBzdGFydCArIDRgIG9yIGBwb3MgKyA1YFxuICAgICAgICAgICAgdGhpcy5idWZmZXIuY29weVdpdGhpbihwb3MgKyA1LCBzdGFydCwgc3RhcnQgKyB3cml0dGVuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXN0b3JlIHBvcyB0byBwdXNoIGxlbmd0aFxuICAgICAgICB0aGlzLnNldFBvcyhwb3MpO1xuICAgICAgICB0aGlzLnB1c2hMZW5ndGgod3JpdHRlbik7XG4gICAgICAgIC8vIFJlZmxlY3Qgd3JpdHRlbiBieXRlcyB0byBwb3NcbiAgICAgICAgdGhpcy5zZXRQb3ModGhpcy5wb3MgKyB3cml0dGVuKTtcbiAgICB9XG4gICAgZ2V0VVRGOCgpIHtcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG4gICAgICAgIHRoaXMucG9zICs9IGJ5dGVMZW5ndGg7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnLCB7IGlnbm9yZUJPTTogdHJ1ZSB9KS5kZWNvZGUodGhpcy5idWZmZXIuc3ViYXJyYXkodGhpcy5wb3MgLSBieXRlTGVuZ3RoLCB0aGlzLnBvcykpO1xuICAgIH1cbiAgICBwdXNoQVNDSUkoc3RyKSB7XG4gICAgICAgIHRoaXMucHVzaExlbmd0aChzdHIubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zKytdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0QVNDSUkoKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSB0aGlzLmdldExlbmd0aCgpO1xuICAgICAgICB0aGlzLnBvcyArPSBieXRlTGVuZ3RoO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBVaW50OEFycmF5PEFycmF5QnVmZmVyTGlrZT5gIGlzIGluZGV4YWJsZSB3aXRoIGBudW1iZXJgXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMucG9zIC0gYnl0ZUxlbmd0aCwgdGhpcy5wb3MpKTtcbiAgICB9XG4gICAgcHVzaE5ldHdvcmtSZWRpcmVjdChzdHIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3Npb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoQnl0ZXModGhpcy5jb21wcmVzc2lvbi5uZXR3b3JrUmVkaXJlY3QuY29tcHJlc3Moc3RyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hBU0NJSShzdHIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE5ldHdvcmtSZWRpcmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3Npb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHJlc3Npb24ubmV0d29ya1JlZGlyZWN0LmRlY29tcHJlc3ModGhpcy5nZXRCeXRlcygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBU0NJSSgpO1xuICAgIH1cbiAgICBwdXNoTmV0d29ya0hvc3RuYW1lKHN0cikge1xuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hCeXRlcyh0aGlzLmNvbXByZXNzaW9uLm5ldHdvcmtIb3N0bmFtZS5jb21wcmVzcyhzdHIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHVzaEFTQ0lJKHN0cik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TmV0d29ya0hvc3RuYW1lKCkge1xuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wcmVzc2lvbi5uZXR3b3JrSG9zdG5hbWUuZGVjb21wcmVzcyh0aGlzLmdldEJ5dGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFTQ0lJKCk7XG4gICAgfVxuICAgIHB1c2hOZXR3b3JrQ1NQKHN0cikge1xuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hCeXRlcyh0aGlzLmNvbXByZXNzaW9uLm5ldHdvcmtDU1AuY29tcHJlc3Moc3RyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hBU0NJSShzdHIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE5ldHdvcmtDU1AoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXByZXNzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXByZXNzaW9uLm5ldHdvcmtDU1AuZGVjb21wcmVzcyh0aGlzLmdldEJ5dGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFTQ0lJKCk7XG4gICAgfVxuICAgIHB1c2hOZXR3b3JrRmlsdGVyKHN0cikge1xuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hCeXRlcyh0aGlzLmNvbXByZXNzaW9uLm5ldHdvcmtGaWx0ZXIuY29tcHJlc3Moc3RyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hBU0NJSShzdHIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE5ldHdvcmtGaWx0ZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXByZXNzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXByZXNzaW9uLm5ldHdvcmtGaWx0ZXIuZGVjb21wcmVzcyh0aGlzLmdldEJ5dGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFTQ0lJKCk7XG4gICAgfVxuICAgIHB1c2hDb3NtZXRpY1NlbGVjdG9yKHN0cikge1xuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hCeXRlcyh0aGlzLmNvbXByZXNzaW9uLmNvc21ldGljU2VsZWN0b3IuY29tcHJlc3Moc3RyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hBU0NJSShzdHIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENvc21ldGljU2VsZWN0b3IoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXByZXNzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXByZXNzaW9uLmNvc21ldGljU2VsZWN0b3IuZGVjb21wcmVzcyh0aGlzLmdldEJ5dGVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFTQ0lJKCk7XG4gICAgfVxuICAgIHB1c2hSYXdDb3NtZXRpYyhzdHIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3Npb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoQnl0ZXModGhpcy5jb21wcmVzc2lvbi5jb3NtZXRpY1Jhdy5jb21wcmVzcyhURVhUX0VOQ09ERVIuZW5jb2RlKHN0cikpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFVURjgoc3RyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSYXdDb3NtZXRpYygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3Npb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigndXRmOCcsIHsgaWdub3JlQk9NOiB0cnVlIH0pLmRlY29kZSh0aGlzLmNvbXByZXNzaW9uLmNvc21ldGljUmF3LmRlY29tcHJlc3NSYXcodGhpcy5nZXRCeXRlcygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VVRGOCgpO1xuICAgIH1cbiAgICBwdXNoUmF3TmV0d29yayhzdHIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3Npb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoQnl0ZXModGhpcy5jb21wcmVzc2lvbi5uZXR3b3JrUmF3LmNvbXByZXNzKFRFWFRfRU5DT0RFUi5lbmNvZGUoc3RyKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wdXNoVVRGOChzdHIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJhd05ldHdvcmsoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXByZXNzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnLCB7IGlnbm9yZUJPTTogdHJ1ZSB9KS5kZWNvZGUodGhpcy5jb21wcmVzc2lvbi5uZXR3b3JrUmF3LmRlY29tcHJlc3NSYXcodGhpcy5nZXRCeXRlcygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VVRGOCgpO1xuICAgIH1cbiAgICBjaGVja1NpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyAhPT0gMCAmJiB0aGlzLnBvcyA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RhdGljRGF0YVZpZXcgdG9vIHNtYWxsOiAke3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGh9LCBidXQgcmVxdWlyZWQgJHt0aGlzLnBvc30gYnl0ZXNgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXJpYWxpZXogYGxlbmd0aGAgd2l0aCB2YXJpYWJsZSBlbmNvZGluZyB0byBzYXZlIHNwYWNlXG4gICAgcHVzaExlbmd0aChsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA8PSAxMjcpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFVpbnQ4KGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hVaW50OCgxMjgpO1xuICAgICAgICAgICAgdGhpcy5wdXNoVWludDMyKGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TGVuZ3RoKCkge1xuICAgICAgICBjb25zdCBsZW5ndGhTaG9ydCA9IHRoaXMuZ2V0VWludDgoKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aFNob3J0ID09PSAxMjggPyB0aGlzLmdldFVpbnQzMigpIDogbGVuZ3RoU2hvcnQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS12aWV3LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/data-view.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/encoding.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/encoding.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isUTF8: () => (/* binding */ isUTF8)\n/* harmony export */ });\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/*!\n * Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n// From http://bjoern.hoehrmann.de/utf-8/decoder/dfa/\nconst utf8d = new Uint8Array([\n    /* eslint-disable prettier/prettier */\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00..1f\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20..3f\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 40..5f\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 60..7f\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, // 80..9f\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, // a0..bf\n    8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // c0..df\n    0xa, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, // e0..ef\n    0xb, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, // f0..ff\n    0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, // s0..s0\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, // s1..s2\n    1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, // s3..s4\n    1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, // s5..s6\n    1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // s7..s8\n    /* eslint-enable prettier/prettier */\n]);\nfunction isAscii(bytes) {\n    if (bytes.length === 0) {\n        return true;\n    }\n    for (let i = 0; i < bytes.length; i += 1) {\n        if (bytes[i] > 127) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isUTF8(bytes) {\n    if (bytes.length === 0) {\n        return true;\n    }\n    if (isAscii(bytes) === true) {\n        return true;\n    }\n    let state = 0;\n    for (let i = 0; i < bytes.length; i += 1) {\n        const type = utf8d[bytes[i]];\n        state = utf8d[256 + state * 16 + type];\n        if (state === 1 || state === undefined) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=encoding.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmNvZGluZy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvYWRibG9ja2VyL2Rpc3QvZXNtL2VuY29kaW5nLmpzPzdiNzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCBHaG9zdGVyeSBHbWJILiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG4vKiFcbiAqIENvcHlyaWdodCAoYykgMjAwOC0yMDA5IEJqb2VybiBIb2Vocm1hbm4gPGJqb2VybkBob2Vocm1hbm4uZGU+XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbiAqIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4gKiByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3JcbiAqIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1NcbiAqIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuLy8gRnJvbSBodHRwOi8vYmpvZXJuLmhvZWhybWFubi5kZS91dGYtOC9kZWNvZGVyL2RmYS9cbmNvbnN0IHV0ZjhkID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIC8qIGVzbGludC1kaXNhYmxlIHByZXR0aWVyL3ByZXR0aWVyICovXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMDAuLjFmXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMjAuLjNmXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gNDAuLjVmXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gNjAuLjdmXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgOSwgLy8gODAuLjlmXG4gICAgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgNywgLy8gYTAuLmJmXG4gICAgOCwgOCwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgMiwgLy8gYzAuLmRmXG4gICAgMHhhLCAweDMsIDB4MywgMHgzLCAweDMsIDB4MywgMHgzLCAweDMsIDB4MywgMHgzLCAweDMsIDB4MywgMHgzLCAweDQsIDB4MywgMHgzLCAvLyBlMC4uZWZcbiAgICAweGIsIDB4NiwgMHg2LCAweDYsIDB4NSwgMHg4LCAweDgsIDB4OCwgMHg4LCAweDgsIDB4OCwgMHg4LCAweDgsIDB4OCwgMHg4LCAweDgsIC8vIGYwLi5mZlxuICAgIDB4MCwgMHgxLCAweDIsIDB4MywgMHg1LCAweDgsIDB4NywgMHgxLCAweDEsIDB4MSwgMHg0LCAweDYsIDB4MSwgMHgxLCAweDEsIDB4MSwgLy8gczAuLnMwXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gczEuLnMyXG4gICAgMSwgMiwgMSwgMSwgMSwgMSwgMSwgMiwgMSwgMiwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMiwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gczMuLnM0XG4gICAgMSwgMiwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMiwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMywgMSwgMywgMSwgMSwgMSwgMSwgMSwgMSwgLy8gczUuLnM2XG4gICAgMSwgMywgMSwgMSwgMSwgMSwgMSwgMywgMSwgMywgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMywgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gczcuLnM4XG4gICAgLyogZXNsaW50LWVuYWJsZSBwcmV0dGllci9wcmV0dGllciAqL1xuXSk7XG5mdW5jdGlvbiBpc0FzY2lpKGJ5dGVzKSB7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoYnl0ZXNbaV0gPiAxMjcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1VURjgoYnl0ZXMpIHtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNBc2NpaShieXRlcykgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBzdGF0ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCB0eXBlID0gdXRmOGRbYnl0ZXNbaV1dO1xuICAgICAgICBzdGF0ZSA9IHV0ZjhkWzI1NiArIHN0YXRlICogMTYgKyB0eXBlXTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAxIHx8IHN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuY29kaW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/encoding.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/cosmetic.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/cosmetic.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createLookupTokens: () => (/* binding */ createLookupTokens),\n/* harmony export */   createStylesheet: () => (/* binding */ createStylesheet),\n/* harmony export */   \"default\": () => (/* binding */ CosmeticFilterBucket)\n/* harmony export */ });\n/* harmony import */ var _compact_set_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../compact-set.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/compact-set.js\");\n/* harmony import */ var _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../filters/cosmetic.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/cosmetic.js\");\n/* harmony import */ var _request_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../request.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/request.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/utils.js\");\n/* harmony import */ var _optimizer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../optimizer.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/optimizer.js\");\n/* harmony import */ var _reverse_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../reverse-index.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/reverse-index.js\");\n/* harmony import */ var _filters_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./filters.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/filters.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n\n\n/**\n * Given a list of CSS selectors, create a valid stylesheet ready to be\n * injected in the page. This also takes care to no create rules with too many\n * selectors for Chrome, see: https://crbug.com/804179\n */\nfunction createStylesheet(rules, style = _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_HIDING_STYLE) {\n    if (rules.length === 0) {\n        return '';\n    }\n    const maximumNumberOfSelectors = 1024;\n    const parts = [];\n    const styleStr = ` { ${style} }`;\n    for (let i = 0; i < rules.length; i += maximumNumberOfSelectors) {\n        // Accumulate up to `maximumNumberOfSelectors` selectors into `selector`.\n        // We use string concatenation here since it's faster than using\n        // `Array.prototype.join`.\n        let selector = rules[i];\n        for (let j = i + 1, end = Math.min(rules.length, i + maximumNumberOfSelectors); j < end; j += 1) {\n            selector += ',\\n' + rules[j];\n        }\n        // Insert CSS after last selector (e.g.: `{ display: none }`)\n        selector += styleStr;\n        // If `rules` has less than the limit, we can short-circuit here\n        if (rules.length < maximumNumberOfSelectors) {\n            return selector;\n        }\n        // Keep track of this chunk and process next ones\n        parts.push(selector);\n    }\n    // Join all chunks together\n    return parts.join('\\n');\n}\n/**\n * If at least one filter from `rules` has a custom style (e.g.: `##.foo\n * :style(...)`) then we fallback to `createStylesheetFromRulesWithCustomStyles`\n * which is slower than `createStylesheetFromRules`.\n */\nfunction createStylesheetFromRulesWithCustomStyles(rules, hidingStyle = _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_HIDING_STYLE) {\n    const selectorsPerStyle = new Map();\n    for (const rule of rules) {\n        const style = rule.getStyle(hidingStyle);\n        const selectors = selectorsPerStyle.get(style);\n        if (selectors === undefined) {\n            selectorsPerStyle.set(style, [rule.getSelector()]);\n        }\n        else {\n            selectors.push(rule.getSelector());\n        }\n    }\n    const stylesheets = [];\n    const selectorsPerStyleArray = Array.from(selectorsPerStyle.entries());\n    for (const [style, selectors] of selectorsPerStyleArray) {\n        stylesheets.push(createStylesheet(selectors, style));\n    }\n    return stylesheets.join('\\n\\n');\n}\n/**\n * Given a list of cosmetic filters, create a stylesheet ready to be injected.\n * This function is optimistic and will assume there is no `:style` filter in\n * `rules`. In case one is found on the way, we fallback to the slower\n * `createStylesheetFromRulesWithCustomStyles` function.\n */\nfunction createStylesheetFromRules(rules, hidingStyle = _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_HIDING_STYLE) {\n    const selectors = [];\n    for (const rule of rules) {\n        if (rule.hasCustomStyle()) {\n            return createStylesheetFromRulesWithCustomStyles(rules, hidingStyle);\n        }\n        selectors.push(rule.selector);\n    }\n    return createStylesheet(selectors, hidingStyle);\n}\nfunction createLookupTokens(hostname, domain) {\n    const hostnamesHashes = (0,_request_js__WEBPACK_IMPORTED_MODULE_2__.getHostnameHashesFromLabelsBackward)(hostname, domain);\n    const entitiesHashes = (0,_request_js__WEBPACK_IMPORTED_MODULE_2__.getEntityHashesFromLabelsBackward)(hostname, domain);\n    const tokens = new Uint32Array(hostnamesHashes.length + entitiesHashes.length);\n    let index = 0;\n    for (const hash of hostnamesHashes) {\n        tokens[index++] = hash;\n    }\n    for (const hash of entitiesHashes) {\n        tokens[index++] = hash;\n    }\n    return tokens;\n}\n/**\n * Efficient container for CosmeticFilter instances. Allows to quickly\n * retrieved scripts and stylesheets to inject in pages for a specific\n * hostname/domain.\n */\nclass CosmeticFilterBucket {\n    static deserialize(buffer, config) {\n        const bucket = new CosmeticFilterBucket({ config });\n        bucket.genericRules = _filters_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].deserialize(buffer, _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize, config);\n        bucket.classesIndex = _reverse_index_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].deserialize(buffer, _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize, _optimizer_js__WEBPACK_IMPORTED_MODULE_4__.noopOptimizeCosmetic, config);\n        bucket.hostnameIndex = _reverse_index_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].deserialize(buffer, _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize, _optimizer_js__WEBPACK_IMPORTED_MODULE_4__.noopOptimizeCosmetic, config);\n        bucket.hrefsIndex = _reverse_index_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].deserialize(buffer, _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize, _optimizer_js__WEBPACK_IMPORTED_MODULE_4__.noopOptimizeCosmetic, config);\n        bucket.idsIndex = _reverse_index_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].deserialize(buffer, _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize, _optimizer_js__WEBPACK_IMPORTED_MODULE_4__.noopOptimizeCosmetic, config);\n        bucket.unhideIndex = _reverse_index_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].deserialize(buffer, _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize, _optimizer_js__WEBPACK_IMPORTED_MODULE_4__.noopOptimizeCosmetic, config);\n        return bucket;\n    }\n    constructor({ filters = [], config }) {\n        this.genericRules = new _filters_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]({\n            config,\n            deserialize: _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize,\n            filters: [],\n        });\n        this.classesIndex = new _reverse_index_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]({\n            config,\n            deserialize: _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize,\n            filters: [],\n            optimize: _optimizer_js__WEBPACK_IMPORTED_MODULE_4__.noopOptimizeCosmetic,\n        });\n        this.hostnameIndex = new _reverse_index_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]({\n            config,\n            deserialize: _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize,\n            filters: [],\n            optimize: _optimizer_js__WEBPACK_IMPORTED_MODULE_4__.noopOptimizeCosmetic,\n        });\n        this.hrefsIndex = new _reverse_index_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]({\n            config,\n            deserialize: _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize,\n            filters: [],\n            optimize: _optimizer_js__WEBPACK_IMPORTED_MODULE_4__.noopOptimizeCosmetic,\n        });\n        this.idsIndex = new _reverse_index_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]({\n            config,\n            deserialize: _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize,\n            filters: [],\n            optimize: _optimizer_js__WEBPACK_IMPORTED_MODULE_4__.noopOptimizeCosmetic,\n        });\n        this.unhideIndex = new _reverse_index_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]({\n            config,\n            deserialize: _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize,\n            filters: [],\n            optimize: _optimizer_js__WEBPACK_IMPORTED_MODULE_4__.noopOptimizeCosmetic,\n        });\n        // In-memory cache, lazily initialized\n        this.baseStylesheet = null;\n        this.extraGenericRules = null;\n        if (filters.length !== 0) {\n            this.update(filters, undefined, config);\n        }\n    }\n    getFilters() {\n        const filters = [];\n        return filters.concat(this.genericRules.getFilters(), this.classesIndex.getFilters(), this.hostnameIndex.getFilters(), this.hrefsIndex.getFilters(), this.idsIndex.getFilters(), this.unhideIndex.getFilters());\n    }\n    update(newFilters, removedFilters, config) {\n        const classSelectors = [];\n        const genericHideRules = [];\n        const hostnameSpecificRules = [];\n        const hrefSelectors = [];\n        const idSelectors = [];\n        const unHideRules = [];\n        for (const rule of newFilters) {\n            if (rule.isUnhide()) {\n                unHideRules.push(rule);\n            }\n            else if (rule.isGenericHide()) {\n                if (rule.isClassSelector()) {\n                    classSelectors.push(rule);\n                }\n                else if (rule.isIdSelector()) {\n                    idSelectors.push(rule);\n                }\n                else if (rule.isHrefSelector()) {\n                    hrefSelectors.push(rule);\n                }\n                else {\n                    genericHideRules.push(rule);\n                }\n            }\n            else if (rule.isExtended() === false || config.loadExtendedSelectors === true) {\n                hostnameSpecificRules.push(rule);\n            }\n        }\n        this.genericRules.update(genericHideRules, removedFilters);\n        this.classesIndex.update(classSelectors, removedFilters);\n        this.hostnameIndex.update(hostnameSpecificRules, removedFilters);\n        this.hrefsIndex.update(hrefSelectors, removedFilters);\n        this.idsIndex.update(idSelectors, removedFilters);\n        this.unhideIndex.update(unHideRules, removedFilters);\n    }\n    getSerializedSize() {\n        return (this.genericRules.getSerializedSize() +\n            this.classesIndex.getSerializedSize() +\n            this.hostnameIndex.getSerializedSize() +\n            this.hrefsIndex.getSerializedSize() +\n            this.idsIndex.getSerializedSize() +\n            this.unhideIndex.getSerializedSize());\n    }\n    serialize(buffer) {\n        this.genericRules.serialize(buffer);\n        this.classesIndex.serialize(buffer);\n        this.hostnameIndex.serialize(buffer);\n        this.hrefsIndex.serialize(buffer);\n        this.idsIndex.serialize(buffer);\n        this.unhideIndex.serialize(buffer);\n    }\n    /**\n     * Request cosmetics and scripts to inject in a page.\n     */\n    getCosmeticsFilters({ domain, hostname, ancestors = [], classes = [], hrefs = [], ids = [], allowGenericHides = true, allowSpecificHides = true, \n    // Allows to specify which rules to return\n    getRulesFromDOM = true, getRulesFromHostname = true, isFilterExcluded, }) {\n        // Tokens from `hostname` and `domain` which will be used to lookup filters\n        // from the reverse index. The same tokens are re-used for multiple indices.\n        const hostnameTokens = createLookupTokens(hostname, domain);\n        const combinedHostnameTokens = Uint32Array.from([\n            ...hostnameTokens,\n            ...ancestors.flatMap((ancestor) => Array.from(createLookupTokens(ancestor.hostname, ancestor.domain))),\n        ]);\n        const filters = [];\n        // =======================================================================\n        // Rules: hostname-specific\n        // =======================================================================\n        // Collect matching rules which specify a hostname constraint.\n        if (getRulesFromHostname === true) {\n            this.hostnameIndex.iterMatchingFilters(combinedHostnameTokens, (filter) => {\n                // A hostname-specific filter is considered if it's a scriptlet (not\n                // impacted by disabling of specific filters) or specific hides are\n                // allowed.\n                if ((allowSpecificHides === true || filter.isScriptInject() === true) &&\n                    filter.match(hostname, domain, ancestors) &&\n                    !(isFilterExcluded === null || isFilterExcluded === void 0 ? void 0 : isFilterExcluded(filter))) {\n                    filters.push(filter);\n                }\n                return true;\n            });\n        }\n        // =======================================================================\n        // Rules: generic hide\n        // =======================================================================\n        // Optionally, collect genericHide rules. We need to make sure the `rule`\n        // matches the hostname and domain since some generic rules can specify\n        // negated hostnames and entities (e.g.: ~foo.*##generic).\n        if (allowGenericHides === true && getRulesFromHostname === true) {\n            const genericRules = this.getGenericRules();\n            for (const filter of genericRules) {\n                if (filter.match(hostname, domain) === true && !(isFilterExcluded === null || isFilterExcluded === void 0 ? void 0 : isFilterExcluded(filter))) {\n                    filters.push(filter);\n                }\n            }\n        }\n        // =======================================================================\n        // Class selector based\n        // =======================================================================\n        if (allowGenericHides === true && getRulesFromDOM === true && classes.length !== 0) {\n            this.classesIndex.iterMatchingFilters((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.hashStrings)(classes), (filter) => {\n                if (filter.match(hostname, domain) && !(isFilterExcluded === null || isFilterExcluded === void 0 ? void 0 : isFilterExcluded(filter))) {\n                    filters.push(filter);\n                }\n                return true;\n            });\n        }\n        // =======================================================================\n        // Id selector based\n        // =======================================================================\n        if (allowGenericHides === true && getRulesFromDOM === true && ids.length !== 0) {\n            this.idsIndex.iterMatchingFilters((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.hashStrings)(ids), (filter) => {\n                if (filter.match(hostname, domain) && !(isFilterExcluded === null || isFilterExcluded === void 0 ? void 0 : isFilterExcluded(filter))) {\n                    filters.push(filter);\n                }\n                return true;\n            });\n        }\n        // =======================================================================\n        // Href selector based\n        // =======================================================================\n        if (allowGenericHides === true && getRulesFromDOM === true && hrefs.length !== 0) {\n            this.hrefsIndex.iterMatchingFilters((0,_compact_set_js__WEBPACK_IMPORTED_MODULE_0__.compactTokens)((0,_compact_set_js__WEBPACK_IMPORTED_MODULE_0__.concatTypedArrays)(hrefs.map((href) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.tokenizeNoSkip)(href)))), (filter) => {\n                if (filter.match(hostname, domain) && !(isFilterExcluded === null || isFilterExcluded === void 0 ? void 0 : isFilterExcluded(filter))) {\n                    filters.push(filter);\n                }\n                return true;\n            });\n        }\n        const unhides = [];\n        // If we found at least one candidate, check if we have unhidden rules,\n        // apply them and dispatch rules into `injections` (i.e.: '+js(...)'),\n        // `extended` (i.e. :not(...)), and `styles` (i.e.: '##rule').\n        if (filters.length !== 0) {\n            // =======================================================================\n            // Rules: unhide\n            // =======================================================================\n            // Collect unhidden selectors. They will be used to filter-out canceled\n            // rules from other indices.\n            this.unhideIndex.iterMatchingFilters(combinedHostnameTokens, (filter) => {\n                if (filter.match(hostname, domain, ancestors) && !(isFilterExcluded === null || isFilterExcluded === void 0 ? void 0 : isFilterExcluded(filter))) {\n                    unhides.push(filter);\n                }\n                return true;\n            });\n        }\n        return {\n            filters,\n            unhides,\n        };\n    }\n    getStylesheetsFromFilters({ filters, extendedFilters, }, { getBaseRules, allowGenericHides, hidingStyle = _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_HIDING_STYLE, }) {\n        let stylesheet = getBaseRules === false || allowGenericHides === false ? '' : this.getBaseStylesheet();\n        if (hidingStyle !== _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_HIDING_STYLE) {\n            stylesheet = stylesheet.replace(_filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_HIDING_STYLE, hidingStyle);\n        }\n        if (filters.length !== 0) {\n            if (stylesheet.length !== 0) {\n                stylesheet += '\\n\\n';\n            }\n            stylesheet += createStylesheetFromRules(filters, hidingStyle);\n        }\n        const extended = [];\n        if (extendedFilters.length !== 0) {\n            const extendedStyles = new Map();\n            for (const filter of extendedFilters) {\n                const ast = filter.getSelectorAST();\n                if (ast !== undefined) {\n                    const attribute = filter.isRemove() ? undefined : filter.getStyleAttributeHash();\n                    if (attribute !== undefined) {\n                        extendedStyles.set(filter.getStyle(hidingStyle), attribute);\n                    }\n                    extended.push({\n                        id: filter.getId(),\n                        ast,\n                        remove: filter.isRemove(),\n                        attribute,\n                    });\n                }\n            }\n            if (extendedStyles.size !== 0) {\n                if (stylesheet.length !== 0) {\n                    stylesheet += '\\n\\n';\n                }\n                stylesheet += [...extendedStyles.entries()]\n                    .map(([style, attribute]) => `[${attribute}] { ${style} }`)\n                    .join('\\n\\n');\n            }\n        }\n        return { stylesheet, extended };\n    }\n    /**\n     * Return the list of filters which can potentially be un-hidden by another\n     * rule currently contained in the cosmetic bucket.\n     */\n    getGenericRules() {\n        if (this.extraGenericRules === null) {\n            return this.lazyPopulateGenericRulesCache().genericRules;\n        }\n        return this.extraGenericRules;\n    }\n    /**\n     * The base stylesheet is made of generic filters (not specific to any\n     * hostname) which cannot be hidden (i.e.: there is currently no rule which\n     * might hide their selector). This means that it will never change and is\n     * the same for all sites. We generate it once and re-use it any-time we want\n     * to inject it.\n     */\n    getBaseStylesheet() {\n        if (this.baseStylesheet === null) {\n            return this.lazyPopulateGenericRulesCache().baseStylesheet;\n        }\n        return this.baseStylesheet;\n    }\n    /**\n     * This is used to lazily generate both the list of generic rules which can\n     * *potentially be un-hidden* (i.e.: there exists at least one unhide rule\n     * for the selector) and a stylesheet containing all selectors which cannot\n     * be un-hidden. Since this list will not change between updates we can\n     * generate once and use many times.\n     */\n    lazyPopulateGenericRulesCache() {\n        if (this.baseStylesheet === null || this.extraGenericRules === null) {\n            // Collect all selectors which can be subjected to an unhide rule\n            const unHideRules = this.unhideIndex.getFilters();\n            const canBeHiddenSelectors = new Set();\n            for (const rule of unHideRules) {\n                canBeHiddenSelectors.add(rule.getSelector());\n            }\n            // Split generic rules into two groups:\n            // 1. Rules which cannot be hidden\n            // 2. Rules which can be hidden on some domains\n            //\n            // This allows to create a base stylesheet which we know will never\n            // change then keep a minority of rules in-memory which can potentially\n            // be hidden.\n            const genericRules = this.genericRules.getFilters();\n            const cannotBeHiddenRules = [];\n            const canBeHiddenRules = [];\n            for (const rule of genericRules) {\n                if (rule.hasCustomStyle() ||\n                    rule.isScriptInject() ||\n                    rule.hasHostnameConstraint() ||\n                    canBeHiddenSelectors.has(rule.getSelector())) {\n                    canBeHiddenRules.push(rule);\n                }\n                else {\n                    cannotBeHiddenRules.push(rule);\n                }\n            }\n            this.baseStylesheet = createStylesheetFromRules(cannotBeHiddenRules);\n            this.extraGenericRules = canBeHiddenRules;\n        }\n        return {\n            baseStylesheet: this.baseStylesheet,\n            genericRules: this.extraGenericRules,\n        };\n    }\n}\n//# sourceMappingURL=cosmetic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvYnVja2V0L2Nvc21ldGljLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN3RTtBQUNTO0FBQzBCO0FBQzlDO0FBQ047QUFDUjtBQUNIO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5Q0FBeUMsc0VBQW9CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRSxRQUFRO0FBQ25DLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsU0FBUztBQUNqRztBQUNBO0FBQ0Esb0RBQW9ELGVBQWU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0Usc0VBQW9CO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxzRUFBb0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw0QkFBNEIsZ0ZBQW1DO0FBQy9ELDJCQUEyQiw4RUFBaUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBLGtEQUFrRCxRQUFRO0FBQzFELDhCQUE4QixtREFBZ0IscUJBQXFCLDREQUFjO0FBQ2pGLDhCQUE4Qix5REFBWSxxQkFBcUIsNERBQWMsY0FBYywrREFBb0I7QUFDL0csK0JBQStCLHlEQUFZLHFCQUFxQiw0REFBYyxjQUFjLCtEQUFvQjtBQUNoSCw0QkFBNEIseURBQVkscUJBQXFCLDREQUFjLGNBQWMsK0RBQW9CO0FBQzdHLDBCQUEwQix5REFBWSxxQkFBcUIsNERBQWMsY0FBYywrREFBb0I7QUFDM0csNkJBQTZCLHlEQUFZLHFCQUFxQiw0REFBYyxjQUFjLCtEQUFvQjtBQUM5RztBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QyxnQ0FBZ0MsbURBQWdCO0FBQ2hEO0FBQ0EseUJBQXlCLDREQUFjO0FBQ3ZDO0FBQ0EsU0FBUztBQUNULGdDQUFnQyx5REFBWTtBQUM1QztBQUNBLHlCQUF5Qiw0REFBYztBQUN2QztBQUNBLHNCQUFzQiwrREFBb0I7QUFDMUMsU0FBUztBQUNULGlDQUFpQyx5REFBWTtBQUM3QztBQUNBLHlCQUF5Qiw0REFBYztBQUN2QztBQUNBLHNCQUFzQiwrREFBb0I7QUFDMUMsU0FBUztBQUNULDhCQUE4Qix5REFBWTtBQUMxQztBQUNBLHlCQUF5Qiw0REFBYztBQUN2QztBQUNBLHNCQUFzQiwrREFBb0I7QUFDMUMsU0FBUztBQUNULDRCQUE0Qix5REFBWTtBQUN4QztBQUNBLHlCQUF5Qiw0REFBYztBQUN2QztBQUNBLHNCQUFzQiwrREFBb0I7QUFDMUMsU0FBUztBQUNULCtCQUErQix5REFBWTtBQUMzQztBQUNBLHlCQUF5Qiw0REFBYztBQUN2QztBQUNBLHNCQUFzQiwrREFBb0I7QUFDMUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHNEQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0RBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw4REFBYSxDQUFDLGtFQUFpQixxQkFBcUIseURBQWM7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQixJQUFJLCtDQUErQyxzRUFBb0IsR0FBRztBQUNySTtBQUNBLDRCQUE0QixzRUFBb0I7QUFDaEQsNENBQTRDLHNFQUFvQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxVQUFVLElBQUksRUFBRSxRQUFRO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXIvZGlzdC9lc20vZW5naW5lL2J1Y2tldC9jb3NtZXRpYy5qcz85NGY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQgR2hvc3RlcnkgR21iSC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgY29tcGFjdFRva2VucywgY29uY2F0VHlwZWRBcnJheXMgfSBmcm9tICcuLi8uLi9jb21wYWN0LXNldC5qcyc7XG5pbXBvcnQgQ29zbWV0aWNGaWx0ZXIsIHsgREVGQVVMVF9ISURJTkdfU1RZTEUgfSBmcm9tICcuLi8uLi9maWx0ZXJzL2Nvc21ldGljLmpzJztcbmltcG9ydCB7IGdldEVudGl0eUhhc2hlc0Zyb21MYWJlbHNCYWNrd2FyZCwgZ2V0SG9zdG5hbWVIYXNoZXNGcm9tTGFiZWxzQmFja3dhcmQsIH0gZnJvbSAnLi4vLi4vcmVxdWVzdC5qcyc7XG5pbXBvcnQgeyBoYXNoU3RyaW5ncywgdG9rZW5pemVOb1NraXAgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgeyBub29wT3B0aW1pemVDb3NtZXRpYyB9IGZyb20gJy4uL29wdGltaXplci5qcyc7XG5pbXBvcnQgUmV2ZXJzZUluZGV4IGZyb20gJy4uL3JldmVyc2UtaW5kZXguanMnO1xuaW1wb3J0IEZpbHRlcnNDb250YWluZXIgZnJvbSAnLi9maWx0ZXJzLmpzJztcbi8qKlxuICogR2l2ZW4gYSBsaXN0IG9mIENTUyBzZWxlY3RvcnMsIGNyZWF0ZSBhIHZhbGlkIHN0eWxlc2hlZXQgcmVhZHkgdG8gYmVcbiAqIGluamVjdGVkIGluIHRoZSBwYWdlLiBUaGlzIGFsc28gdGFrZXMgY2FyZSB0byBubyBjcmVhdGUgcnVsZXMgd2l0aCB0b28gbWFueVxuICogc2VsZWN0b3JzIGZvciBDaHJvbWUsIHNlZTogaHR0cHM6Ly9jcmJ1Zy5jb20vODA0MTc5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHlsZXNoZWV0KHJ1bGVzLCBzdHlsZSA9IERFRkFVTFRfSElESU5HX1NUWUxFKSB7XG4gICAgaWYgKHJ1bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNvbnN0IG1heGltdW1OdW1iZXJPZlNlbGVjdG9ycyA9IDEwMjQ7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBjb25zdCBzdHlsZVN0ciA9IGAgeyAke3N0eWxlfSB9YDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSArPSBtYXhpbXVtTnVtYmVyT2ZTZWxlY3RvcnMpIHtcbiAgICAgICAgLy8gQWNjdW11bGF0ZSB1cCB0byBgbWF4aW11bU51bWJlck9mU2VsZWN0b3JzYCBzZWxlY3RvcnMgaW50byBgc2VsZWN0b3JgLlxuICAgICAgICAvLyBXZSB1c2Ugc3RyaW5nIGNvbmNhdGVuYXRpb24gaGVyZSBzaW5jZSBpdCdzIGZhc3RlciB0aGFuIHVzaW5nXG4gICAgICAgIC8vIGBBcnJheS5wcm90b3R5cGUuam9pbmAuXG4gICAgICAgIGxldCBzZWxlY3RvciA9IHJ1bGVzW2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gaSArIDEsIGVuZCA9IE1hdGgubWluKHJ1bGVzLmxlbmd0aCwgaSArIG1heGltdW1OdW1iZXJPZlNlbGVjdG9ycyk7IGogPCBlbmQ7IGogKz0gMSkge1xuICAgICAgICAgICAgc2VsZWN0b3IgKz0gJyxcXG4nICsgcnVsZXNbal07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5zZXJ0IENTUyBhZnRlciBsYXN0IHNlbGVjdG9yIChlLmcuOiBgeyBkaXNwbGF5OiBub25lIH1gKVxuICAgICAgICBzZWxlY3RvciArPSBzdHlsZVN0cjtcbiAgICAgICAgLy8gSWYgYHJ1bGVzYCBoYXMgbGVzcyB0aGFuIHRoZSBsaW1pdCwgd2UgY2FuIHNob3J0LWNpcmN1aXQgaGVyZVxuICAgICAgICBpZiAocnVsZXMubGVuZ3RoIDwgbWF4aW11bU51bWJlck9mU2VsZWN0b3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGlzIGNodW5rIGFuZCBwcm9jZXNzIG5leHQgb25lc1xuICAgICAgICBwYXJ0cy5wdXNoKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgLy8gSm9pbiBhbGwgY2h1bmtzIHRvZ2V0aGVyXG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJ1xcbicpO1xufVxuLyoqXG4gKiBJZiBhdCBsZWFzdCBvbmUgZmlsdGVyIGZyb20gYHJ1bGVzYCBoYXMgYSBjdXN0b20gc3R5bGUgKGUuZy46IGAjIy5mb29cbiAqIDpzdHlsZSguLi4pYCkgdGhlbiB3ZSBmYWxsYmFjayB0byBgY3JlYXRlU3R5bGVzaGVldEZyb21SdWxlc1dpdGhDdXN0b21TdHlsZXNgXG4gKiB3aGljaCBpcyBzbG93ZXIgdGhhbiBgY3JlYXRlU3R5bGVzaGVldEZyb21SdWxlc2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlc2hlZXRGcm9tUnVsZXNXaXRoQ3VzdG9tU3R5bGVzKHJ1bGVzLCBoaWRpbmdTdHlsZSA9IERFRkFVTFRfSElESU5HX1NUWUxFKSB7XG4gICAgY29uc3Qgc2VsZWN0b3JzUGVyU3R5bGUgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBydWxlIG9mIHJ1bGVzKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gcnVsZS5nZXRTdHlsZShoaWRpbmdTdHlsZSk7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IHNlbGVjdG9yc1BlclN0eWxlLmdldChzdHlsZSk7XG4gICAgICAgIGlmIChzZWxlY3RvcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2VsZWN0b3JzUGVyU3R5bGUuc2V0KHN0eWxlLCBbcnVsZS5nZXRTZWxlY3RvcigpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RvcnMucHVzaChydWxlLmdldFNlbGVjdG9yKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlc2hlZXRzID0gW107XG4gICAgY29uc3Qgc2VsZWN0b3JzUGVyU3R5bGVBcnJheSA9IEFycmF5LmZyb20oc2VsZWN0b3JzUGVyU3R5bGUuZW50cmllcygpKTtcbiAgICBmb3IgKGNvbnN0IFtzdHlsZSwgc2VsZWN0b3JzXSBvZiBzZWxlY3RvcnNQZXJTdHlsZUFycmF5KSB7XG4gICAgICAgIHN0eWxlc2hlZXRzLnB1c2goY3JlYXRlU3R5bGVzaGVldChzZWxlY3RvcnMsIHN0eWxlKSk7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXNoZWV0cy5qb2luKCdcXG5cXG4nKTtcbn1cbi8qKlxuICogR2l2ZW4gYSBsaXN0IG9mIGNvc21ldGljIGZpbHRlcnMsIGNyZWF0ZSBhIHN0eWxlc2hlZXQgcmVhZHkgdG8gYmUgaW5qZWN0ZWQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG9wdGltaXN0aWMgYW5kIHdpbGwgYXNzdW1lIHRoZXJlIGlzIG5vIGA6c3R5bGVgIGZpbHRlciBpblxuICogYHJ1bGVzYC4gSW4gY2FzZSBvbmUgaXMgZm91bmQgb24gdGhlIHdheSwgd2UgZmFsbGJhY2sgdG8gdGhlIHNsb3dlclxuICogYGNyZWF0ZVN0eWxlc2hlZXRGcm9tUnVsZXNXaXRoQ3VzdG9tU3R5bGVzYCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3R5bGVzaGVldEZyb21SdWxlcyhydWxlcywgaGlkaW5nU3R5bGUgPSBERUZBVUxUX0hJRElOR19TVFlMRSkge1xuICAgIGNvbnN0IHNlbGVjdG9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgcnVsZSBvZiBydWxlcykge1xuICAgICAgICBpZiAocnVsZS5oYXNDdXN0b21TdHlsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlU3R5bGVzaGVldEZyb21SdWxlc1dpdGhDdXN0b21TdHlsZXMocnVsZXMsIGhpZGluZ1N0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3RvcnMucHVzaChydWxlLnNlbGVjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVN0eWxlc2hlZXQoc2VsZWN0b3JzLCBoaWRpbmdTdHlsZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTG9va3VwVG9rZW5zKGhvc3RuYW1lLCBkb21haW4pIHtcbiAgICBjb25zdCBob3N0bmFtZXNIYXNoZXMgPSBnZXRIb3N0bmFtZUhhc2hlc0Zyb21MYWJlbHNCYWNrd2FyZChob3N0bmFtZSwgZG9tYWluKTtcbiAgICBjb25zdCBlbnRpdGllc0hhc2hlcyA9IGdldEVudGl0eUhhc2hlc0Zyb21MYWJlbHNCYWNrd2FyZChob3N0bmFtZSwgZG9tYWluKTtcbiAgICBjb25zdCB0b2tlbnMgPSBuZXcgVWludDMyQXJyYXkoaG9zdG5hbWVzSGFzaGVzLmxlbmd0aCArIGVudGl0aWVzSGFzaGVzLmxlbmd0aCk7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGhhc2ggb2YgaG9zdG5hbWVzSGFzaGVzKSB7XG4gICAgICAgIHRva2Vuc1tpbmRleCsrXSA9IGhhc2g7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaGFzaCBvZiBlbnRpdGllc0hhc2hlcykge1xuICAgICAgICB0b2tlbnNbaW5kZXgrK10gPSBoYXNoO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zO1xufVxuLyoqXG4gKiBFZmZpY2llbnQgY29udGFpbmVyIGZvciBDb3NtZXRpY0ZpbHRlciBpbnN0YW5jZXMuIEFsbG93cyB0byBxdWlja2x5XG4gKiByZXRyaWV2ZWQgc2NyaXB0cyBhbmQgc3R5bGVzaGVldHMgdG8gaW5qZWN0IGluIHBhZ2VzIGZvciBhIHNwZWNpZmljXG4gKiBob3N0bmFtZS9kb21haW4uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvc21ldGljRmlsdGVyQnVja2V0IHtcbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnVmZmVyLCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgYnVja2V0ID0gbmV3IENvc21ldGljRmlsdGVyQnVja2V0KHsgY29uZmlnIH0pO1xuICAgICAgICBidWNrZXQuZ2VuZXJpY1J1bGVzID0gRmlsdGVyc0NvbnRhaW5lci5kZXNlcmlhbGl6ZShidWZmZXIsIENvc21ldGljRmlsdGVyLmRlc2VyaWFsaXplLCBjb25maWcpO1xuICAgICAgICBidWNrZXQuY2xhc3Nlc0luZGV4ID0gUmV2ZXJzZUluZGV4LmRlc2VyaWFsaXplKGJ1ZmZlciwgQ29zbWV0aWNGaWx0ZXIuZGVzZXJpYWxpemUsIG5vb3BPcHRpbWl6ZUNvc21ldGljLCBjb25maWcpO1xuICAgICAgICBidWNrZXQuaG9zdG5hbWVJbmRleCA9IFJldmVyc2VJbmRleC5kZXNlcmlhbGl6ZShidWZmZXIsIENvc21ldGljRmlsdGVyLmRlc2VyaWFsaXplLCBub29wT3B0aW1pemVDb3NtZXRpYywgY29uZmlnKTtcbiAgICAgICAgYnVja2V0LmhyZWZzSW5kZXggPSBSZXZlcnNlSW5kZXguZGVzZXJpYWxpemUoYnVmZmVyLCBDb3NtZXRpY0ZpbHRlci5kZXNlcmlhbGl6ZSwgbm9vcE9wdGltaXplQ29zbWV0aWMsIGNvbmZpZyk7XG4gICAgICAgIGJ1Y2tldC5pZHNJbmRleCA9IFJldmVyc2VJbmRleC5kZXNlcmlhbGl6ZShidWZmZXIsIENvc21ldGljRmlsdGVyLmRlc2VyaWFsaXplLCBub29wT3B0aW1pemVDb3NtZXRpYywgY29uZmlnKTtcbiAgICAgICAgYnVja2V0LnVuaGlkZUluZGV4ID0gUmV2ZXJzZUluZGV4LmRlc2VyaWFsaXplKGJ1ZmZlciwgQ29zbWV0aWNGaWx0ZXIuZGVzZXJpYWxpemUsIG5vb3BPcHRpbWl6ZUNvc21ldGljLCBjb25maWcpO1xuICAgICAgICByZXR1cm4gYnVja2V0O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IGZpbHRlcnMgPSBbXSwgY29uZmlnIH0pIHtcbiAgICAgICAgdGhpcy5nZW5lcmljUnVsZXMgPSBuZXcgRmlsdGVyc0NvbnRhaW5lcih7XG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZTogQ29zbWV0aWNGaWx0ZXIuZGVzZXJpYWxpemUsXG4gICAgICAgICAgICBmaWx0ZXJzOiBbXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2xhc3Nlc0luZGV4ID0gbmV3IFJldmVyc2VJbmRleCh7XG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZTogQ29zbWV0aWNGaWx0ZXIuZGVzZXJpYWxpemUsXG4gICAgICAgICAgICBmaWx0ZXJzOiBbXSxcbiAgICAgICAgICAgIG9wdGltaXplOiBub29wT3B0aW1pemVDb3NtZXRpYyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaG9zdG5hbWVJbmRleCA9IG5ldyBSZXZlcnNlSW5kZXgoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IENvc21ldGljRmlsdGVyLmRlc2VyaWFsaXplLFxuICAgICAgICAgICAgZmlsdGVyczogW10sXG4gICAgICAgICAgICBvcHRpbWl6ZTogbm9vcE9wdGltaXplQ29zbWV0aWMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhyZWZzSW5kZXggPSBuZXcgUmV2ZXJzZUluZGV4KHtcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGRlc2VyaWFsaXplOiBDb3NtZXRpY0ZpbHRlci5kZXNlcmlhbGl6ZSxcbiAgICAgICAgICAgIGZpbHRlcnM6IFtdLFxuICAgICAgICAgICAgb3B0aW1pemU6IG5vb3BPcHRpbWl6ZUNvc21ldGljLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pZHNJbmRleCA9IG5ldyBSZXZlcnNlSW5kZXgoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IENvc21ldGljRmlsdGVyLmRlc2VyaWFsaXplLFxuICAgICAgICAgICAgZmlsdGVyczogW10sXG4gICAgICAgICAgICBvcHRpbWl6ZTogbm9vcE9wdGltaXplQ29zbWV0aWMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVuaGlkZUluZGV4ID0gbmV3IFJldmVyc2VJbmRleCh7XG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZTogQ29zbWV0aWNGaWx0ZXIuZGVzZXJpYWxpemUsXG4gICAgICAgICAgICBmaWx0ZXJzOiBbXSxcbiAgICAgICAgICAgIG9wdGltaXplOiBub29wT3B0aW1pemVDb3NtZXRpYyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEluLW1lbW9yeSBjYWNoZSwgbGF6aWx5IGluaXRpYWxpemVkXG4gICAgICAgIHRoaXMuYmFzZVN0eWxlc2hlZXQgPSBudWxsO1xuICAgICAgICB0aGlzLmV4dHJhR2VuZXJpY1J1bGVzID0gbnVsbDtcbiAgICAgICAgaWYgKGZpbHRlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShmaWx0ZXJzLCB1bmRlZmluZWQsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RmlsdGVycygpIHtcbiAgICAgICAgY29uc3QgZmlsdGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gZmlsdGVycy5jb25jYXQodGhpcy5nZW5lcmljUnVsZXMuZ2V0RmlsdGVycygpLCB0aGlzLmNsYXNzZXNJbmRleC5nZXRGaWx0ZXJzKCksIHRoaXMuaG9zdG5hbWVJbmRleC5nZXRGaWx0ZXJzKCksIHRoaXMuaHJlZnNJbmRleC5nZXRGaWx0ZXJzKCksIHRoaXMuaWRzSW5kZXguZ2V0RmlsdGVycygpLCB0aGlzLnVuaGlkZUluZGV4LmdldEZpbHRlcnMoKSk7XG4gICAgfVxuICAgIHVwZGF0ZShuZXdGaWx0ZXJzLCByZW1vdmVkRmlsdGVycywgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzU2VsZWN0b3JzID0gW107XG4gICAgICAgIGNvbnN0IGdlbmVyaWNIaWRlUnVsZXMgPSBbXTtcbiAgICAgICAgY29uc3QgaG9zdG5hbWVTcGVjaWZpY1J1bGVzID0gW107XG4gICAgICAgIGNvbnN0IGhyZWZTZWxlY3RvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgaWRTZWxlY3RvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgdW5IaWRlUnVsZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIG5ld0ZpbHRlcnMpIHtcbiAgICAgICAgICAgIGlmIChydWxlLmlzVW5oaWRlKCkpIHtcbiAgICAgICAgICAgICAgICB1bkhpZGVSdWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocnVsZS5pc0dlbmVyaWNIaWRlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5pc0NsYXNzU2VsZWN0b3IoKSkge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc1NlbGVjdG9ycy5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChydWxlLmlzSWRTZWxlY3RvcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkU2VsZWN0b3JzLnB1c2gocnVsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUuaXNIcmVmU2VsZWN0b3IoKSkge1xuICAgICAgICAgICAgICAgICAgICBocmVmU2VsZWN0b3JzLnB1c2gocnVsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmljSGlkZVJ1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocnVsZS5pc0V4dGVuZGVkKCkgPT09IGZhbHNlIHx8IGNvbmZpZy5sb2FkRXh0ZW5kZWRTZWxlY3RvcnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBob3N0bmFtZVNwZWNpZmljUnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdlbmVyaWNSdWxlcy51cGRhdGUoZ2VuZXJpY0hpZGVSdWxlcywgcmVtb3ZlZEZpbHRlcnMpO1xuICAgICAgICB0aGlzLmNsYXNzZXNJbmRleC51cGRhdGUoY2xhc3NTZWxlY3RvcnMsIHJlbW92ZWRGaWx0ZXJzKTtcbiAgICAgICAgdGhpcy5ob3N0bmFtZUluZGV4LnVwZGF0ZShob3N0bmFtZVNwZWNpZmljUnVsZXMsIHJlbW92ZWRGaWx0ZXJzKTtcbiAgICAgICAgdGhpcy5ocmVmc0luZGV4LnVwZGF0ZShocmVmU2VsZWN0b3JzLCByZW1vdmVkRmlsdGVycyk7XG4gICAgICAgIHRoaXMuaWRzSW5kZXgudXBkYXRlKGlkU2VsZWN0b3JzLCByZW1vdmVkRmlsdGVycyk7XG4gICAgICAgIHRoaXMudW5oaWRlSW5kZXgudXBkYXRlKHVuSGlkZVJ1bGVzLCByZW1vdmVkRmlsdGVycyk7XG4gICAgfVxuICAgIGdldFNlcmlhbGl6ZWRTaXplKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZ2VuZXJpY1J1bGVzLmdldFNlcmlhbGl6ZWRTaXplKCkgK1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzSW5kZXguZ2V0U2VyaWFsaXplZFNpemUoKSArXG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lSW5kZXguZ2V0U2VyaWFsaXplZFNpemUoKSArXG4gICAgICAgICAgICB0aGlzLmhyZWZzSW5kZXguZ2V0U2VyaWFsaXplZFNpemUoKSArXG4gICAgICAgICAgICB0aGlzLmlkc0luZGV4LmdldFNlcmlhbGl6ZWRTaXplKCkgK1xuICAgICAgICAgICAgdGhpcy51bmhpZGVJbmRleC5nZXRTZXJpYWxpemVkU2l6ZSgpKTtcbiAgICB9XG4gICAgc2VyaWFsaXplKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLmdlbmVyaWNSdWxlcy5zZXJpYWxpemUoYnVmZmVyKTtcbiAgICAgICAgdGhpcy5jbGFzc2VzSW5kZXguc2VyaWFsaXplKGJ1ZmZlcik7XG4gICAgICAgIHRoaXMuaG9zdG5hbWVJbmRleC5zZXJpYWxpemUoYnVmZmVyKTtcbiAgICAgICAgdGhpcy5ocmVmc0luZGV4LnNlcmlhbGl6ZShidWZmZXIpO1xuICAgICAgICB0aGlzLmlkc0luZGV4LnNlcmlhbGl6ZShidWZmZXIpO1xuICAgICAgICB0aGlzLnVuaGlkZUluZGV4LnNlcmlhbGl6ZShidWZmZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGNvc21ldGljcyBhbmQgc2NyaXB0cyB0byBpbmplY3QgaW4gYSBwYWdlLlxuICAgICAqL1xuICAgIGdldENvc21ldGljc0ZpbHRlcnMoeyBkb21haW4sIGhvc3RuYW1lLCBhbmNlc3RvcnMgPSBbXSwgY2xhc3NlcyA9IFtdLCBocmVmcyA9IFtdLCBpZHMgPSBbXSwgYWxsb3dHZW5lcmljSGlkZXMgPSB0cnVlLCBhbGxvd1NwZWNpZmljSGlkZXMgPSB0cnVlLCBcbiAgICAvLyBBbGxvd3MgdG8gc3BlY2lmeSB3aGljaCBydWxlcyB0byByZXR1cm5cbiAgICBnZXRSdWxlc0Zyb21ET00gPSB0cnVlLCBnZXRSdWxlc0Zyb21Ib3N0bmFtZSA9IHRydWUsIGlzRmlsdGVyRXhjbHVkZWQsIH0pIHtcbiAgICAgICAgLy8gVG9rZW5zIGZyb20gYGhvc3RuYW1lYCBhbmQgYGRvbWFpbmAgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGxvb2t1cCBmaWx0ZXJzXG4gICAgICAgIC8vIGZyb20gdGhlIHJldmVyc2UgaW5kZXguIFRoZSBzYW1lIHRva2VucyBhcmUgcmUtdXNlZCBmb3IgbXVsdGlwbGUgaW5kaWNlcy5cbiAgICAgICAgY29uc3QgaG9zdG5hbWVUb2tlbnMgPSBjcmVhdGVMb29rdXBUb2tlbnMoaG9zdG5hbWUsIGRvbWFpbik7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkSG9zdG5hbWVUb2tlbnMgPSBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAgICAgICAgIC4uLmhvc3RuYW1lVG9rZW5zLFxuICAgICAgICAgICAgLi4uYW5jZXN0b3JzLmZsYXRNYXAoKGFuY2VzdG9yKSA9PiBBcnJheS5mcm9tKGNyZWF0ZUxvb2t1cFRva2VucyhhbmNlc3Rvci5ob3N0bmFtZSwgYW5jZXN0b3IuZG9tYWluKSkpLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgZmlsdGVycyA9IFtdO1xuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAvLyBSdWxlczogaG9zdG5hbWUtc3BlY2lmaWNcbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgLy8gQ29sbGVjdCBtYXRjaGluZyBydWxlcyB3aGljaCBzcGVjaWZ5IGEgaG9zdG5hbWUgY29uc3RyYWludC5cbiAgICAgICAgaWYgKGdldFJ1bGVzRnJvbUhvc3RuYW1lID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lSW5kZXguaXRlck1hdGNoaW5nRmlsdGVycyhjb21iaW5lZEhvc3RuYW1lVG9rZW5zLCAoZmlsdGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQSBob3N0bmFtZS1zcGVjaWZpYyBmaWx0ZXIgaXMgY29uc2lkZXJlZCBpZiBpdCdzIGEgc2NyaXB0bGV0IChub3RcbiAgICAgICAgICAgICAgICAvLyBpbXBhY3RlZCBieSBkaXNhYmxpbmcgb2Ygc3BlY2lmaWMgZmlsdGVycykgb3Igc3BlY2lmaWMgaGlkZXMgYXJlXG4gICAgICAgICAgICAgICAgLy8gYWxsb3dlZC5cbiAgICAgICAgICAgICAgICBpZiAoKGFsbG93U3BlY2lmaWNIaWRlcyA9PT0gdHJ1ZSB8fCBmaWx0ZXIuaXNTY3JpcHRJbmplY3QoKSA9PT0gdHJ1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyLm1hdGNoKGhvc3RuYW1lLCBkb21haW4sIGFuY2VzdG9ycykgJiZcbiAgICAgICAgICAgICAgICAgICAgIShpc0ZpbHRlckV4Y2x1ZGVkID09PSBudWxsIHx8IGlzRmlsdGVyRXhjbHVkZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlzRmlsdGVyRXhjbHVkZWQoZmlsdGVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgLy8gUnVsZXM6IGdlbmVyaWMgaGlkZVxuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAvLyBPcHRpb25hbGx5LCBjb2xsZWN0IGdlbmVyaWNIaWRlIHJ1bGVzLiBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgYHJ1bGVgXG4gICAgICAgIC8vIG1hdGNoZXMgdGhlIGhvc3RuYW1lIGFuZCBkb21haW4gc2luY2Ugc29tZSBnZW5lcmljIHJ1bGVzIGNhbiBzcGVjaWZ5XG4gICAgICAgIC8vIG5lZ2F0ZWQgaG9zdG5hbWVzIGFuZCBlbnRpdGllcyAoZS5nLjogfmZvby4qIyNnZW5lcmljKS5cbiAgICAgICAgaWYgKGFsbG93R2VuZXJpY0hpZGVzID09PSB0cnVlICYmIGdldFJ1bGVzRnJvbUhvc3RuYW1lID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmljUnVsZXMgPSB0aGlzLmdldEdlbmVyaWNSdWxlcygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgZ2VuZXJpY1J1bGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlci5tYXRjaChob3N0bmFtZSwgZG9tYWluKSA9PT0gdHJ1ZSAmJiAhKGlzRmlsdGVyRXhjbHVkZWQgPT09IG51bGwgfHwgaXNGaWx0ZXJFeGNsdWRlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXNGaWx0ZXJFeGNsdWRlZChmaWx0ZXIpKSkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgLy8gQ2xhc3Mgc2VsZWN0b3IgYmFzZWRcbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgaWYgKGFsbG93R2VuZXJpY0hpZGVzID09PSB0cnVlICYmIGdldFJ1bGVzRnJvbURPTSA9PT0gdHJ1ZSAmJiBjbGFzc2VzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzSW5kZXguaXRlck1hdGNoaW5nRmlsdGVycyhoYXNoU3RyaW5ncyhjbGFzc2VzKSwgKGZpbHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIubWF0Y2goaG9zdG5hbWUsIGRvbWFpbikgJiYgIShpc0ZpbHRlckV4Y2x1ZGVkID09PSBudWxsIHx8IGlzRmlsdGVyRXhjbHVkZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlzRmlsdGVyRXhjbHVkZWQoZmlsdGVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgLy8gSWQgc2VsZWN0b3IgYmFzZWRcbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgaWYgKGFsbG93R2VuZXJpY0hpZGVzID09PSB0cnVlICYmIGdldFJ1bGVzRnJvbURPTSA9PT0gdHJ1ZSAmJiBpZHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmlkc0luZGV4Lml0ZXJNYXRjaGluZ0ZpbHRlcnMoaGFzaFN0cmluZ3MoaWRzKSwgKGZpbHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIubWF0Y2goaG9zdG5hbWUsIGRvbWFpbikgJiYgIShpc0ZpbHRlckV4Y2x1ZGVkID09PSBudWxsIHx8IGlzRmlsdGVyRXhjbHVkZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlzRmlsdGVyRXhjbHVkZWQoZmlsdGVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgLy8gSHJlZiBzZWxlY3RvciBiYXNlZFxuICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICBpZiAoYWxsb3dHZW5lcmljSGlkZXMgPT09IHRydWUgJiYgZ2V0UnVsZXNGcm9tRE9NID09PSB0cnVlICYmIGhyZWZzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5ocmVmc0luZGV4Lml0ZXJNYXRjaGluZ0ZpbHRlcnMoY29tcGFjdFRva2Vucyhjb25jYXRUeXBlZEFycmF5cyhocmVmcy5tYXAoKGhyZWYpID0+IHRva2VuaXplTm9Ta2lwKGhyZWYpKSkpLCAoZmlsdGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlci5tYXRjaChob3N0bmFtZSwgZG9tYWluKSAmJiAhKGlzRmlsdGVyRXhjbHVkZWQgPT09IG51bGwgfHwgaXNGaWx0ZXJFeGNsdWRlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXNGaWx0ZXJFeGNsdWRlZChmaWx0ZXIpKSkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bmhpZGVzID0gW107XG4gICAgICAgIC8vIElmIHdlIGZvdW5kIGF0IGxlYXN0IG9uZSBjYW5kaWRhdGUsIGNoZWNrIGlmIHdlIGhhdmUgdW5oaWRkZW4gcnVsZXMsXG4gICAgICAgIC8vIGFwcGx5IHRoZW0gYW5kIGRpc3BhdGNoIHJ1bGVzIGludG8gYGluamVjdGlvbnNgIChpLmUuOiAnK2pzKC4uLiknKSxcbiAgICAgICAgLy8gYGV4dGVuZGVkYCAoaS5lLiA6bm90KC4uLikpLCBhbmQgYHN0eWxlc2AgKGkuZS46ICcjI3J1bGUnKS5cbiAgICAgICAgaWYgKGZpbHRlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gUnVsZXM6IHVuaGlkZVxuICAgICAgICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIENvbGxlY3QgdW5oaWRkZW4gc2VsZWN0b3JzLiBUaGV5IHdpbGwgYmUgdXNlZCB0byBmaWx0ZXItb3V0IGNhbmNlbGVkXG4gICAgICAgICAgICAvLyBydWxlcyBmcm9tIG90aGVyIGluZGljZXMuXG4gICAgICAgICAgICB0aGlzLnVuaGlkZUluZGV4Lml0ZXJNYXRjaGluZ0ZpbHRlcnMoY29tYmluZWRIb3N0bmFtZVRva2VucywgKGZpbHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIubWF0Y2goaG9zdG5hbWUsIGRvbWFpbiwgYW5jZXN0b3JzKSAmJiAhKGlzRmlsdGVyRXhjbHVkZWQgPT09IG51bGwgfHwgaXNGaWx0ZXJFeGNsdWRlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXNGaWx0ZXJFeGNsdWRlZChmaWx0ZXIpKSkge1xuICAgICAgICAgICAgICAgICAgICB1bmhpZGVzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsdGVycyxcbiAgICAgICAgICAgIHVuaGlkZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFN0eWxlc2hlZXRzRnJvbUZpbHRlcnMoeyBmaWx0ZXJzLCBleHRlbmRlZEZpbHRlcnMsIH0sIHsgZ2V0QmFzZVJ1bGVzLCBhbGxvd0dlbmVyaWNIaWRlcywgaGlkaW5nU3R5bGUgPSBERUZBVUxUX0hJRElOR19TVFlMRSwgfSkge1xuICAgICAgICBsZXQgc3R5bGVzaGVldCA9IGdldEJhc2VSdWxlcyA9PT0gZmFsc2UgfHwgYWxsb3dHZW5lcmljSGlkZXMgPT09IGZhbHNlID8gJycgOiB0aGlzLmdldEJhc2VTdHlsZXNoZWV0KCk7XG4gICAgICAgIGlmIChoaWRpbmdTdHlsZSAhPT0gREVGQVVMVF9ISURJTkdfU1RZTEUpIHtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQgPSBzdHlsZXNoZWV0LnJlcGxhY2UoREVGQVVMVF9ISURJTkdfU1RZTEUsIGhpZGluZ1N0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGlmIChzdHlsZXNoZWV0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXQgKz0gJ1xcblxcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZXNoZWV0ICs9IGNyZWF0ZVN0eWxlc2hlZXRGcm9tUnVsZXMoZmlsdGVycywgaGlkaW5nU3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4dGVuZGVkID0gW107XG4gICAgICAgIGlmIChleHRlbmRlZEZpbHRlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBleHRlbmRlZFN0eWxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGV4dGVuZGVkRmlsdGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzdCA9IGZpbHRlci5nZXRTZWxlY3RvckFTVCgpO1xuICAgICAgICAgICAgICAgIGlmIChhc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBmaWx0ZXIuaXNSZW1vdmUoKSA/IHVuZGVmaW5lZCA6IGZpbHRlci5nZXRTdHlsZUF0dHJpYnV0ZUhhc2goKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFN0eWxlcy5zZXQoZmlsdGVyLmdldFN0eWxlKGhpZGluZ1N0eWxlKSwgYXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHRlbmRlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBmaWx0ZXIuZ2V0SWQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZTogZmlsdGVyLmlzUmVtb3ZlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRlbmRlZFN0eWxlcy5zaXplICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlc2hlZXQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXQgKz0gJ1xcblxcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXQgKz0gWy4uLmV4dGVuZGVkU3R5bGVzLmVudHJpZXMoKV1cbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoW3N0eWxlLCBhdHRyaWJ1dGVdKSA9PiBgWyR7YXR0cmlidXRlfV0geyAke3N0eWxlfSB9YClcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcblxcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0eWxlc2hlZXQsIGV4dGVuZGVkIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbGlzdCBvZiBmaWx0ZXJzIHdoaWNoIGNhbiBwb3RlbnRpYWxseSBiZSB1bi1oaWRkZW4gYnkgYW5vdGhlclxuICAgICAqIHJ1bGUgY3VycmVudGx5IGNvbnRhaW5lZCBpbiB0aGUgY29zbWV0aWMgYnVja2V0LlxuICAgICAqL1xuICAgIGdldEdlbmVyaWNSdWxlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuZXh0cmFHZW5lcmljUnVsZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhenlQb3B1bGF0ZUdlbmVyaWNSdWxlc0NhY2hlKCkuZ2VuZXJpY1J1bGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhR2VuZXJpY1J1bGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBzdHlsZXNoZWV0IGlzIG1hZGUgb2YgZ2VuZXJpYyBmaWx0ZXJzIChub3Qgc3BlY2lmaWMgdG8gYW55XG4gICAgICogaG9zdG5hbWUpIHdoaWNoIGNhbm5vdCBiZSBoaWRkZW4gKGkuZS46IHRoZXJlIGlzIGN1cnJlbnRseSBubyBydWxlIHdoaWNoXG4gICAgICogbWlnaHQgaGlkZSB0aGVpciBzZWxlY3RvcikuIFRoaXMgbWVhbnMgdGhhdCBpdCB3aWxsIG5ldmVyIGNoYW5nZSBhbmQgaXNcbiAgICAgKiB0aGUgc2FtZSBmb3IgYWxsIHNpdGVzLiBXZSBnZW5lcmF0ZSBpdCBvbmNlIGFuZCByZS11c2UgaXQgYW55LXRpbWUgd2Ugd2FudFxuICAgICAqIHRvIGluamVjdCBpdC5cbiAgICAgKi9cbiAgICBnZXRCYXNlU3R5bGVzaGVldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVN0eWxlc2hlZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhenlQb3B1bGF0ZUdlbmVyaWNSdWxlc0NhY2hlKCkuYmFzZVN0eWxlc2hlZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVN0eWxlc2hlZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBsYXppbHkgZ2VuZXJhdGUgYm90aCB0aGUgbGlzdCBvZiBnZW5lcmljIHJ1bGVzIHdoaWNoIGNhblxuICAgICAqICpwb3RlbnRpYWxseSBiZSB1bi1oaWRkZW4qIChpLmUuOiB0aGVyZSBleGlzdHMgYXQgbGVhc3Qgb25lIHVuaGlkZSBydWxlXG4gICAgICogZm9yIHRoZSBzZWxlY3RvcikgYW5kIGEgc3R5bGVzaGVldCBjb250YWluaW5nIGFsbCBzZWxlY3RvcnMgd2hpY2ggY2Fubm90XG4gICAgICogYmUgdW4taGlkZGVuLiBTaW5jZSB0aGlzIGxpc3Qgd2lsbCBub3QgY2hhbmdlIGJldHdlZW4gdXBkYXRlcyB3ZSBjYW5cbiAgICAgKiBnZW5lcmF0ZSBvbmNlIGFuZCB1c2UgbWFueSB0aW1lcy5cbiAgICAgKi9cbiAgICBsYXp5UG9wdWxhdGVHZW5lcmljUnVsZXNDYWNoZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVN0eWxlc2hlZXQgPT09IG51bGwgfHwgdGhpcy5leHRyYUdlbmVyaWNSdWxlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29sbGVjdCBhbGwgc2VsZWN0b3JzIHdoaWNoIGNhbiBiZSBzdWJqZWN0ZWQgdG8gYW4gdW5oaWRlIHJ1bGVcbiAgICAgICAgICAgIGNvbnN0IHVuSGlkZVJ1bGVzID0gdGhpcy51bmhpZGVJbmRleC5nZXRGaWx0ZXJzKCk7XG4gICAgICAgICAgICBjb25zdCBjYW5CZUhpZGRlblNlbGVjdG9ycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVsZSBvZiB1bkhpZGVSdWxlcykge1xuICAgICAgICAgICAgICAgIGNhbkJlSGlkZGVuU2VsZWN0b3JzLmFkZChydWxlLmdldFNlbGVjdG9yKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3BsaXQgZ2VuZXJpYyBydWxlcyBpbnRvIHR3byBncm91cHM6XG4gICAgICAgICAgICAvLyAxLiBSdWxlcyB3aGljaCBjYW5ub3QgYmUgaGlkZGVuXG4gICAgICAgICAgICAvLyAyLiBSdWxlcyB3aGljaCBjYW4gYmUgaGlkZGVuIG9uIHNvbWUgZG9tYWluc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHRvIGNyZWF0ZSBhIGJhc2Ugc3R5bGVzaGVldCB3aGljaCB3ZSBrbm93IHdpbGwgbmV2ZXJcbiAgICAgICAgICAgIC8vIGNoYW5nZSB0aGVuIGtlZXAgYSBtaW5vcml0eSBvZiBydWxlcyBpbi1tZW1vcnkgd2hpY2ggY2FuIHBvdGVudGlhbGx5XG4gICAgICAgICAgICAvLyBiZSBoaWRkZW4uXG4gICAgICAgICAgICBjb25zdCBnZW5lcmljUnVsZXMgPSB0aGlzLmdlbmVyaWNSdWxlcy5nZXRGaWx0ZXJzKCk7XG4gICAgICAgICAgICBjb25zdCBjYW5ub3RCZUhpZGRlblJ1bGVzID0gW107XG4gICAgICAgICAgICBjb25zdCBjYW5CZUhpZGRlblJ1bGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZ2VuZXJpY1J1bGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuaGFzQ3VzdG9tU3R5bGUoKSB8fFxuICAgICAgICAgICAgICAgICAgICBydWxlLmlzU2NyaXB0SW5qZWN0KCkgfHxcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5oYXNIb3N0bmFtZUNvbnN0cmFpbnQoKSB8fFxuICAgICAgICAgICAgICAgICAgICBjYW5CZUhpZGRlblNlbGVjdG9ycy5oYXMocnVsZS5nZXRTZWxlY3RvcigpKSkge1xuICAgICAgICAgICAgICAgICAgICBjYW5CZUhpZGRlblJ1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYW5ub3RCZUhpZGRlblJ1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iYXNlU3R5bGVzaGVldCA9IGNyZWF0ZVN0eWxlc2hlZXRGcm9tUnVsZXMoY2Fubm90QmVIaWRkZW5SdWxlcyk7XG4gICAgICAgICAgICB0aGlzLmV4dHJhR2VuZXJpY1J1bGVzID0gY2FuQmVIaWRkZW5SdWxlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFzZVN0eWxlc2hlZXQ6IHRoaXMuYmFzZVN0eWxlc2hlZXQsXG4gICAgICAgICAgICBnZW5lcmljUnVsZXM6IHRoaXMuZXh0cmFHZW5lcmljUnVsZXMsXG4gICAgICAgIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29zbWV0aWMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/cosmetic.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/filters.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/filters.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FiltersContainer)\n/* harmony export */ });\n/* harmony import */ var _data_view_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data-view.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/data-view.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n// Empty filters is 4 bytes because we need at least one 32 bits number to keep\n// track of the number of filters in the container. If there is no filter then\n// the number will be 0.\nconst EMPTY_FILTERS = new Uint8Array(4);\n/**\n * Generic filters container (for both CosmeticFilter and NetworkFilter\n * instances). This abstracts away some of the logic to serialize/lazy-load\n * lists of filters (which is useful for things like generic cosmetic filters\n * or $badfilter).\n */\nclass FiltersContainer {\n    static deserialize(buffer, deserialize, config) {\n        const container = new FiltersContainer({ deserialize, config, filters: [] });\n        container.filters = buffer.getBytes();\n        return container;\n    }\n    constructor({ config, deserialize, filters, }) {\n        this.deserialize = deserialize;\n        this.filters = EMPTY_FILTERS;\n        this.config = config;\n        if (filters.length !== 0) {\n            this.update(filters, undefined);\n        }\n    }\n    /**\n     * Update filters based on `newFilters` and `removedFilters`.\n     */\n    update(newFilters, removedFilters) {\n        // Estimate size of the buffer we will need to store filters. This avoids\n        // having to allocate a big chunk of memory up-front if it's not needed.\n        // We start with the current size of `this.filters` then update it with\n        // removed/added filters.\n        let bufferSizeEstimation = this.filters.byteLength;\n        let selected = [];\n        const compression = this.config.enableCompression;\n        // Add existing rules (removing the ones with ids in `removedFilters`)\n        const currentFilters = this.getFilters();\n        if (currentFilters.length !== 0) {\n            // If no filter was removed (we only add new ones), we don't need to\n            // filter out removed existing filters. So we just assign the array to\n            // `selected` directly to save a bit of effort.\n            if (removedFilters === undefined || removedFilters.size === 0) {\n                selected = currentFilters;\n            }\n            else {\n                // There might be some removed selected filters, so we iterate through\n                // them and make sure we keep only the ones not having been deleted.\n                for (const filter of currentFilters) {\n                    if (removedFilters.has(filter.getId()) === false) {\n                        selected.push(filter);\n                    }\n                    else {\n                        bufferSizeEstimation -= filter.getSerializedSize(compression);\n                    }\n                }\n            }\n        }\n        // If `selected` and `currentFilters` have the same length then no filter was removed.\n        const storedFiltersRemoved = selected.length !== currentFilters.length;\n        // Add new rules.\n        const numberOfExistingFilters = selected.length;\n        for (const filter of newFilters) {\n            bufferSizeEstimation += filter.getSerializedSize(compression);\n            selected.push(filter);\n        }\n        // Check if any new filter was added in `selected` (from `newFilters`).\n        const storedFiltersAdded = selected.length > numberOfExistingFilters;\n        // If selected changed, then update the compact representation of filters.\n        if (selected.length === 0) {\n            this.filters = EMPTY_FILTERS;\n        }\n        else if (storedFiltersAdded === true || storedFiltersRemoved === true) {\n            // Store filters in their compact form\n            const buffer = _data_view_js__WEBPACK_IMPORTED_MODULE_0__.StaticDataView.allocate(bufferSizeEstimation, this.config);\n            buffer.pushUint32(selected.length);\n            // When we run in `debug` mode, we enable fully deterministic updates of\n            // internal data-structure. To this effect, we sort all filters before\n            // insertion.\n            if (this.config.debug === true) {\n                selected.sort((f1, f2) => f1.getId() - f2.getId());\n            }\n            for (const filter of selected) {\n                filter.serialize(buffer);\n            }\n            // Update internals\n            this.filters = buffer.buffer;\n        }\n    }\n    getSerializedSize() {\n        return (0,_data_view_js__WEBPACK_IMPORTED_MODULE_0__.sizeOfBytes)(this.filters, false /* no alignement */);\n    }\n    serialize(buffer) {\n        buffer.pushBytes(this.filters);\n    }\n    getFilters() {\n        // No filter stored in the container\n        if (this.filters.byteLength <= 4) {\n            return [];\n        }\n        // Load all filters in memory and store them in `cache`\n        const filters = [];\n        const buffer = _data_view_js__WEBPACK_IMPORTED_MODULE_0__.StaticDataView.fromUint8Array(this.filters, this.config);\n        const numberOfFilters = buffer.getUint32();\n        for (let i = 0; i < numberOfFilters; i += 1) {\n            filters.push(this.deserialize(buffer));\n        }\n        return filters;\n    }\n}\n//# sourceMappingURL=filters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvYnVja2V0L2ZpbHRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQSxpREFBaUQsa0NBQWtDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQkFBK0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5REFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQWM7QUFDckM7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXIvZGlzdC9lc20vZW5naW5lL2J1Y2tldC9maWx0ZXJzLmpzP2M4MDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCBHaG9zdGVyeSBHbWJILiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgeyBTdGF0aWNEYXRhVmlldywgc2l6ZU9mQnl0ZXMgfSBmcm9tICcuLi8uLi9kYXRhLXZpZXcuanMnO1xuLy8gRW1wdHkgZmlsdGVycyBpcyA0IGJ5dGVzIGJlY2F1c2Ugd2UgbmVlZCBhdCBsZWFzdCBvbmUgMzIgYml0cyBudW1iZXIgdG8ga2VlcFxuLy8gdHJhY2sgb2YgdGhlIG51bWJlciBvZiBmaWx0ZXJzIGluIHRoZSBjb250YWluZXIuIElmIHRoZXJlIGlzIG5vIGZpbHRlciB0aGVuXG4vLyB0aGUgbnVtYmVyIHdpbGwgYmUgMC5cbmNvbnN0IEVNUFRZX0ZJTFRFUlMgPSBuZXcgVWludDhBcnJheSg0KTtcbi8qKlxuICogR2VuZXJpYyBmaWx0ZXJzIGNvbnRhaW5lciAoZm9yIGJvdGggQ29zbWV0aWNGaWx0ZXIgYW5kIE5ldHdvcmtGaWx0ZXJcbiAqIGluc3RhbmNlcykuIFRoaXMgYWJzdHJhY3RzIGF3YXkgc29tZSBvZiB0aGUgbG9naWMgdG8gc2VyaWFsaXplL2xhenktbG9hZFxuICogbGlzdHMgb2YgZmlsdGVycyAod2hpY2ggaXMgdXNlZnVsIGZvciB0aGluZ3MgbGlrZSBnZW5lcmljIGNvc21ldGljIGZpbHRlcnNcbiAqIG9yICRiYWRmaWx0ZXIpLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWx0ZXJzQ29udGFpbmVyIHtcbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnVmZmVyLCBkZXNlcmlhbGl6ZSwgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBGaWx0ZXJzQ29udGFpbmVyKHsgZGVzZXJpYWxpemUsIGNvbmZpZywgZmlsdGVyczogW10gfSk7XG4gICAgICAgIGNvbnRhaW5lci5maWx0ZXJzID0gYnVmZmVyLmdldEJ5dGVzKCk7XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsgY29uZmlnLCBkZXNlcmlhbGl6ZSwgZmlsdGVycywgfSkge1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemU7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IEVNUFRZX0ZJTFRFUlM7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICBpZiAoZmlsdGVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKGZpbHRlcnMsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGZpbHRlcnMgYmFzZWQgb24gYG5ld0ZpbHRlcnNgIGFuZCBgcmVtb3ZlZEZpbHRlcnNgLlxuICAgICAqL1xuICAgIHVwZGF0ZShuZXdGaWx0ZXJzLCByZW1vdmVkRmlsdGVycykge1xuICAgICAgICAvLyBFc3RpbWF0ZSBzaXplIG9mIHRoZSBidWZmZXIgd2Ugd2lsbCBuZWVkIHRvIHN0b3JlIGZpbHRlcnMuIFRoaXMgYXZvaWRzXG4gICAgICAgIC8vIGhhdmluZyB0byBhbGxvY2F0ZSBhIGJpZyBjaHVuayBvZiBtZW1vcnkgdXAtZnJvbnQgaWYgaXQncyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBXZSBzdGFydCB3aXRoIHRoZSBjdXJyZW50IHNpemUgb2YgYHRoaXMuZmlsdGVyc2AgdGhlbiB1cGRhdGUgaXQgd2l0aFxuICAgICAgICAvLyByZW1vdmVkL2FkZGVkIGZpbHRlcnMuXG4gICAgICAgIGxldCBidWZmZXJTaXplRXN0aW1hdGlvbiA9IHRoaXMuZmlsdGVycy5ieXRlTGVuZ3RoO1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSBbXTtcbiAgICAgICAgY29uc3QgY29tcHJlc3Npb24gPSB0aGlzLmNvbmZpZy5lbmFibGVDb21wcmVzc2lvbjtcbiAgICAgICAgLy8gQWRkIGV4aXN0aW5nIHJ1bGVzIChyZW1vdmluZyB0aGUgb25lcyB3aXRoIGlkcyBpbiBgcmVtb3ZlZEZpbHRlcnNgKVxuICAgICAgICBjb25zdCBjdXJyZW50RmlsdGVycyA9IHRoaXMuZ2V0RmlsdGVycygpO1xuICAgICAgICBpZiAoY3VycmVudEZpbHRlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBJZiBubyBmaWx0ZXIgd2FzIHJlbW92ZWQgKHdlIG9ubHkgYWRkIG5ldyBvbmVzKSwgd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCByZW1vdmVkIGV4aXN0aW5nIGZpbHRlcnMuIFNvIHdlIGp1c3QgYXNzaWduIHRoZSBhcnJheSB0b1xuICAgICAgICAgICAgLy8gYHNlbGVjdGVkYCBkaXJlY3RseSB0byBzYXZlIGEgYml0IG9mIGVmZm9ydC5cbiAgICAgICAgICAgIGlmIChyZW1vdmVkRmlsdGVycyA9PT0gdW5kZWZpbmVkIHx8IHJlbW92ZWRGaWx0ZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGN1cnJlbnRGaWx0ZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgc29tZSByZW1vdmVkIHNlbGVjdGVkIGZpbHRlcnMsIHNvIHdlIGl0ZXJhdGUgdGhyb3VnaFxuICAgICAgICAgICAgICAgIC8vIHRoZW0gYW5kIG1ha2Ugc3VyZSB3ZSBrZWVwIG9ubHkgdGhlIG9uZXMgbm90IGhhdmluZyBiZWVuIGRlbGV0ZWQuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgY3VycmVudEZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRGaWx0ZXJzLmhhcyhmaWx0ZXIuZ2V0SWQoKSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZC5wdXNoKGZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJTaXplRXN0aW1hdGlvbiAtPSBmaWx0ZXIuZ2V0U2VyaWFsaXplZFNpemUoY29tcHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIGBzZWxlY3RlZGAgYW5kIGBjdXJyZW50RmlsdGVyc2AgaGF2ZSB0aGUgc2FtZSBsZW5ndGggdGhlbiBubyBmaWx0ZXIgd2FzIHJlbW92ZWQuXG4gICAgICAgIGNvbnN0IHN0b3JlZEZpbHRlcnNSZW1vdmVkID0gc2VsZWN0ZWQubGVuZ3RoICE9PSBjdXJyZW50RmlsdGVycy5sZW5ndGg7XG4gICAgICAgIC8vIEFkZCBuZXcgcnVsZXMuXG4gICAgICAgIGNvbnN0IG51bWJlck9mRXhpc3RpbmdGaWx0ZXJzID0gc2VsZWN0ZWQubGVuZ3RoO1xuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBuZXdGaWx0ZXJzKSB7XG4gICAgICAgICAgICBidWZmZXJTaXplRXN0aW1hdGlvbiArPSBmaWx0ZXIuZ2V0U2VyaWFsaXplZFNpemUoY29tcHJlc3Npb24pO1xuICAgICAgICAgICAgc2VsZWN0ZWQucHVzaChmaWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBuZXcgZmlsdGVyIHdhcyBhZGRlZCBpbiBgc2VsZWN0ZWRgIChmcm9tIGBuZXdGaWx0ZXJzYCkuXG4gICAgICAgIGNvbnN0IHN0b3JlZEZpbHRlcnNBZGRlZCA9IHNlbGVjdGVkLmxlbmd0aCA+IG51bWJlck9mRXhpc3RpbmdGaWx0ZXJzO1xuICAgICAgICAvLyBJZiBzZWxlY3RlZCBjaGFuZ2VkLCB0aGVuIHVwZGF0ZSB0aGUgY29tcGFjdCByZXByZXNlbnRhdGlvbiBvZiBmaWx0ZXJzLlxuICAgICAgICBpZiAoc2VsZWN0ZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcnMgPSBFTVBUWV9GSUxURVJTO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0b3JlZEZpbHRlcnNBZGRlZCA9PT0gdHJ1ZSB8fCBzdG9yZWRGaWx0ZXJzUmVtb3ZlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gU3RvcmUgZmlsdGVycyBpbiB0aGVpciBjb21wYWN0IGZvcm1cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IFN0YXRpY0RhdGFWaWV3LmFsbG9jYXRlKGJ1ZmZlclNpemVFc3RpbWF0aW9uLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgICAgICBidWZmZXIucHVzaFVpbnQzMihzZWxlY3RlZC5sZW5ndGgpO1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBydW4gaW4gYGRlYnVnYCBtb2RlLCB3ZSBlbmFibGUgZnVsbHkgZGV0ZXJtaW5pc3RpYyB1cGRhdGVzIG9mXG4gICAgICAgICAgICAvLyBpbnRlcm5hbCBkYXRhLXN0cnVjdHVyZS4gVG8gdGhpcyBlZmZlY3QsIHdlIHNvcnQgYWxsIGZpbHRlcnMgYmVmb3JlXG4gICAgICAgICAgICAvLyBpbnNlcnRpb24uXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcuZGVidWcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZC5zb3J0KChmMSwgZjIpID0+IGYxLmdldElkKCkgLSBmMi5nZXRJZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLnNlcmlhbGl6ZShidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIGludGVybmFsc1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gYnVmZmVyLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTZXJpYWxpemVkU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHNpemVPZkJ5dGVzKHRoaXMuZmlsdGVycywgZmFsc2UgLyogbm8gYWxpZ25lbWVudCAqLyk7XG4gICAgfVxuICAgIHNlcmlhbGl6ZShidWZmZXIpIHtcbiAgICAgICAgYnVmZmVyLnB1c2hCeXRlcyh0aGlzLmZpbHRlcnMpO1xuICAgIH1cbiAgICBnZXRGaWx0ZXJzKCkge1xuICAgICAgICAvLyBObyBmaWx0ZXIgc3RvcmVkIGluIHRoZSBjb250YWluZXJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVycy5ieXRlTGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb2FkIGFsbCBmaWx0ZXJzIGluIG1lbW9yeSBhbmQgc3RvcmUgdGhlbSBpbiBgY2FjaGVgXG4gICAgICAgIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gU3RhdGljRGF0YVZpZXcuZnJvbVVpbnQ4QXJyYXkodGhpcy5maWx0ZXJzLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIGNvbnN0IG51bWJlck9mRmlsdGVycyA9IGJ1ZmZlci5nZXRVaW50MzIoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkZpbHRlcnM7IGkgKz0gMSkge1xuICAgICAgICAgICAgZmlsdGVycy5wdXNoKHRoaXMuZGVzZXJpYWxpemUoYnVmZmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbHRlcnM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/filters.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/html.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/html.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ HTMLBucket)\n/* harmony export */ });\n/* harmony import */ var _filters_network_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../filters/network.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/network.js\");\n/* harmony import */ var _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../filters/cosmetic.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/cosmetic.js\");\n/* harmony import */ var _optimizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../optimizer.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/optimizer.js\");\n/* harmony import */ var _reverse_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../reverse-index.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/reverse-index.js\");\n/* harmony import */ var _cosmetic_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cosmetic.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/cosmetic.js\");\n\n\n\n\n\nclass HTMLBucket {\n    static deserialize(buffer, config) {\n        const bucket = new HTMLBucket({ config });\n        bucket.networkIndex = _reverse_index_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].deserialize(buffer, _filters_network_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deserialize, config.enableOptimizations ? _optimizer_js__WEBPACK_IMPORTED_MODULE_2__.optimizeNetwork : _optimizer_js__WEBPACK_IMPORTED_MODULE_2__.noopOptimizeNetwork, config);\n        bucket.exceptionsIndex = _reverse_index_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].deserialize(buffer, _filters_network_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deserialize, config.enableOptimizations ? _optimizer_js__WEBPACK_IMPORTED_MODULE_2__.optimizeNetwork : _optimizer_js__WEBPACK_IMPORTED_MODULE_2__.noopOptimizeNetwork, config);\n        bucket.cosmeticIndex = _reverse_index_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].deserialize(buffer, _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize, _optimizer_js__WEBPACK_IMPORTED_MODULE_2__.noopOptimizeCosmetic, config);\n        bucket.unhideIndex = _reverse_index_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].deserialize(buffer, _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize, _optimizer_js__WEBPACK_IMPORTED_MODULE_2__.noopOptimizeCosmetic, config);\n        return bucket;\n    }\n    constructor({ filters = [], config, }) {\n        this.config = config;\n        this.networkIndex = new _reverse_index_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n            config,\n            deserialize: _filters_network_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deserialize,\n            filters: [],\n            optimize: config.enableOptimizations ? _optimizer_js__WEBPACK_IMPORTED_MODULE_2__.optimizeNetwork : _optimizer_js__WEBPACK_IMPORTED_MODULE_2__.noopOptimizeNetwork,\n        });\n        this.exceptionsIndex = new _reverse_index_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n            config,\n            deserialize: _filters_network_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deserialize,\n            filters: [],\n            optimize: config.enableOptimizations ? _optimizer_js__WEBPACK_IMPORTED_MODULE_2__.optimizeNetwork : _optimizer_js__WEBPACK_IMPORTED_MODULE_2__.noopOptimizeNetwork,\n        });\n        this.cosmeticIndex = new _reverse_index_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n            config,\n            deserialize: _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize,\n            filters: [],\n            optimize: _optimizer_js__WEBPACK_IMPORTED_MODULE_2__.noopOptimizeCosmetic,\n        });\n        this.unhideIndex = new _reverse_index_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n            config,\n            deserialize: _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize,\n            filters: [],\n            optimize: _optimizer_js__WEBPACK_IMPORTED_MODULE_2__.noopOptimizeCosmetic,\n        });\n        if (filters.length !== 0) {\n            this.update(filters, undefined);\n        }\n    }\n    update(newFilters, removedFilters) {\n        const networkFilters = [];\n        const exceptionFilters = [];\n        const cosmeticFilters = [];\n        const unhideFilters = [];\n        for (const filter of newFilters) {\n            if (filter.isNetworkFilter()) {\n                if (filter.isException()) {\n                    exceptionFilters.push(filter);\n                }\n                else {\n                    networkFilters.push(filter);\n                }\n            }\n            else if (filter.isCosmeticFilter()) {\n                if (filter.isUnhide()) {\n                    unhideFilters.push(filter);\n                }\n                else {\n                    cosmeticFilters.push(filter);\n                }\n            }\n        }\n        this.networkIndex.update(networkFilters, removedFilters);\n        this.exceptionsIndex.update(exceptionFilters, removedFilters);\n        this.cosmeticIndex.update(cosmeticFilters, removedFilters);\n        this.unhideIndex.update(unhideFilters, removedFilters);\n    }\n    serialize(buffer) {\n        this.networkIndex.serialize(buffer);\n        this.exceptionsIndex.serialize(buffer);\n        this.cosmeticIndex.serialize(buffer);\n        this.unhideIndex.serialize(buffer);\n    }\n    getSerializedSize() {\n        return (this.networkIndex.getSerializedSize() +\n            this.exceptionsIndex.getSerializedSize() +\n            this.cosmeticIndex.getSerializedSize() +\n            this.unhideIndex.getSerializedSize());\n    }\n    getHTMLFilters(request, isFilterExcluded) {\n        const networkFilters = [];\n        const cosmeticFilters = [];\n        const exceptions = [];\n        const unhides = [];\n        if (this.config.loadNetworkFilters === true) {\n            this.networkIndex.iterMatchingFilters(request.getTokens(), (filter) => {\n                if (filter.match(request) && !(isFilterExcluded === null || isFilterExcluded === void 0 ? void 0 : isFilterExcluded(filter))) {\n                    networkFilters.push(filter);\n                }\n                return true;\n            });\n        }\n        // If we found at least one candidate, check if we have exceptions.\n        if (networkFilters.length !== 0) {\n            this.exceptionsIndex.iterMatchingFilters(request.getTokens(), (filter) => {\n                if (filter.match(request) && !(isFilterExcluded === null || isFilterExcluded === void 0 ? void 0 : isFilterExcluded(filter))) {\n                    exceptions.push(filter);\n                }\n                return true;\n            });\n        }\n        if (this.config.loadCosmeticFilters === true && request.isMainFrame()) {\n            const { hostname, domain = '' } = request;\n            const hostnameTokens = (0,_cosmetic_js__WEBPACK_IMPORTED_MODULE_4__.createLookupTokens)(hostname, domain);\n            this.cosmeticIndex.iterMatchingFilters(hostnameTokens, (filter) => {\n                if (filter.match(hostname, domain) && !(isFilterExcluded === null || isFilterExcluded === void 0 ? void 0 : isFilterExcluded(filter))) {\n                    cosmeticFilters.push(filter);\n                }\n                return true;\n            });\n            // If we found at least one candidate, check if we have unhidden rules.\n            if (cosmeticFilters.length !== 0) {\n                this.unhideIndex.iterMatchingFilters(hostnameTokens, (rule) => {\n                    if (rule.match(hostname, domain) && !(isFilterExcluded === null || isFilterExcluded === void 0 ? void 0 : isFilterExcluded(rule))) {\n                        unhides.push(rule);\n                    }\n                    return true;\n                });\n            }\n        }\n        return {\n            networkFilters,\n            cosmeticFilters,\n            unhides,\n            exceptions,\n        };\n    }\n    getFilters() {\n        const filters = [];\n        return filters.concat(this.networkIndex.getFilters(), this.exceptionsIndex.getFilters(), this.cosmeticIndex.getFilters(), this.unhideIndex.getFilters());\n    }\n}\n//# sourceMappingURL=html.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvYnVja2V0L2h0bWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXFEO0FBQ0U7QUFDc0M7QUFDOUM7QUFDSTtBQUNwQztBQUNmO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQsOEJBQThCLHlEQUFZLHFCQUFxQiwyREFBYSwyQ0FBMkMsMERBQWUsR0FBRyw4REFBbUI7QUFDNUosaUNBQWlDLHlEQUFZLHFCQUFxQiwyREFBYSwyQ0FBMkMsMERBQWUsR0FBRyw4REFBbUI7QUFDL0osK0JBQStCLHlEQUFZLHFCQUFxQiw0REFBYyxjQUFjLCtEQUFvQjtBQUNoSCw2QkFBNkIseURBQVkscUJBQXFCLDREQUFjLGNBQWMsK0RBQW9CO0FBQzlHO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0EsZ0NBQWdDLHlEQUFZO0FBQzVDO0FBQ0EseUJBQXlCLDJEQUFhO0FBQ3RDO0FBQ0EsbURBQW1ELDBEQUFlLEdBQUcsOERBQW1CO0FBQ3hGLFNBQVM7QUFDVCxtQ0FBbUMseURBQVk7QUFDL0M7QUFDQSx5QkFBeUIsMkRBQWE7QUFDdEM7QUFDQSxtREFBbUQsMERBQWUsR0FBRyw4REFBbUI7QUFDeEYsU0FBUztBQUNULGlDQUFpQyx5REFBWTtBQUM3QztBQUNBLHlCQUF5Qiw0REFBYztBQUN2QztBQUNBLHNCQUFzQiwrREFBb0I7QUFDMUMsU0FBUztBQUNULCtCQUErQix5REFBWTtBQUMzQztBQUNBLHlCQUF5Qiw0REFBYztBQUN2QztBQUNBLHNCQUFzQiwrREFBb0I7QUFDMUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsbUNBQW1DLGdFQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXIvZGlzdC9lc20vZW5naW5lL2J1Y2tldC9odG1sLmpzPzA3OTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE5ldHdvcmtGaWx0ZXIgZnJvbSAnLi4vLi4vZmlsdGVycy9uZXR3b3JrLmpzJztcbmltcG9ydCBDb3NtZXRpY0ZpbHRlciBmcm9tICcuLi8uLi9maWx0ZXJzL2Nvc21ldGljLmpzJztcbmltcG9ydCB7IG5vb3BPcHRpbWl6ZU5ldHdvcmssIG9wdGltaXplTmV0d29yaywgbm9vcE9wdGltaXplQ29zbWV0aWMgfSBmcm9tICcuLi9vcHRpbWl6ZXIuanMnO1xuaW1wb3J0IFJldmVyc2VJbmRleCBmcm9tICcuLi9yZXZlcnNlLWluZGV4LmpzJztcbmltcG9ydCB7IGNyZWF0ZUxvb2t1cFRva2VucyB9IGZyb20gJy4vY29zbWV0aWMuanMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSFRNTEJ1Y2tldCB7XG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ1ZmZlciwgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGJ1Y2tldCA9IG5ldyBIVE1MQnVja2V0KHsgY29uZmlnIH0pO1xuICAgICAgICBidWNrZXQubmV0d29ya0luZGV4ID0gUmV2ZXJzZUluZGV4LmRlc2VyaWFsaXplKGJ1ZmZlciwgTmV0d29ya0ZpbHRlci5kZXNlcmlhbGl6ZSwgY29uZmlnLmVuYWJsZU9wdGltaXphdGlvbnMgPyBvcHRpbWl6ZU5ldHdvcmsgOiBub29wT3B0aW1pemVOZXR3b3JrLCBjb25maWcpO1xuICAgICAgICBidWNrZXQuZXhjZXB0aW9uc0luZGV4ID0gUmV2ZXJzZUluZGV4LmRlc2VyaWFsaXplKGJ1ZmZlciwgTmV0d29ya0ZpbHRlci5kZXNlcmlhbGl6ZSwgY29uZmlnLmVuYWJsZU9wdGltaXphdGlvbnMgPyBvcHRpbWl6ZU5ldHdvcmsgOiBub29wT3B0aW1pemVOZXR3b3JrLCBjb25maWcpO1xuICAgICAgICBidWNrZXQuY29zbWV0aWNJbmRleCA9IFJldmVyc2VJbmRleC5kZXNlcmlhbGl6ZShidWZmZXIsIENvc21ldGljRmlsdGVyLmRlc2VyaWFsaXplLCBub29wT3B0aW1pemVDb3NtZXRpYywgY29uZmlnKTtcbiAgICAgICAgYnVja2V0LnVuaGlkZUluZGV4ID0gUmV2ZXJzZUluZGV4LmRlc2VyaWFsaXplKGJ1ZmZlciwgQ29zbWV0aWNGaWx0ZXIuZGVzZXJpYWxpemUsIG5vb3BPcHRpbWl6ZUNvc21ldGljLCBjb25maWcpO1xuICAgICAgICByZXR1cm4gYnVja2V0O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IGZpbHRlcnMgPSBbXSwgY29uZmlnLCB9KSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLm5ldHdvcmtJbmRleCA9IG5ldyBSZXZlcnNlSW5kZXgoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IE5ldHdvcmtGaWx0ZXIuZGVzZXJpYWxpemUsXG4gICAgICAgICAgICBmaWx0ZXJzOiBbXSxcbiAgICAgICAgICAgIG9wdGltaXplOiBjb25maWcuZW5hYmxlT3B0aW1pemF0aW9ucyA/IG9wdGltaXplTmV0d29yayA6IG5vb3BPcHRpbWl6ZU5ldHdvcmssXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV4Y2VwdGlvbnNJbmRleCA9IG5ldyBSZXZlcnNlSW5kZXgoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IE5ldHdvcmtGaWx0ZXIuZGVzZXJpYWxpemUsXG4gICAgICAgICAgICBmaWx0ZXJzOiBbXSxcbiAgICAgICAgICAgIG9wdGltaXplOiBjb25maWcuZW5hYmxlT3B0aW1pemF0aW9ucyA/IG9wdGltaXplTmV0d29yayA6IG5vb3BPcHRpbWl6ZU5ldHdvcmssXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvc21ldGljSW5kZXggPSBuZXcgUmV2ZXJzZUluZGV4KHtcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGRlc2VyaWFsaXplOiBDb3NtZXRpY0ZpbHRlci5kZXNlcmlhbGl6ZSxcbiAgICAgICAgICAgIGZpbHRlcnM6IFtdLFxuICAgICAgICAgICAgb3B0aW1pemU6IG5vb3BPcHRpbWl6ZUNvc21ldGljLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51bmhpZGVJbmRleCA9IG5ldyBSZXZlcnNlSW5kZXgoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgZGVzZXJpYWxpemU6IENvc21ldGljRmlsdGVyLmRlc2VyaWFsaXplLFxuICAgICAgICAgICAgZmlsdGVyczogW10sXG4gICAgICAgICAgICBvcHRpbWl6ZTogbm9vcE9wdGltaXplQ29zbWV0aWMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZmlsdGVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKGZpbHRlcnMsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKG5ld0ZpbHRlcnMsIHJlbW92ZWRGaWx0ZXJzKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtGaWx0ZXJzID0gW107XG4gICAgICAgIGNvbnN0IGV4Y2VwdGlvbkZpbHRlcnMgPSBbXTtcbiAgICAgICAgY29uc3QgY29zbWV0aWNGaWx0ZXJzID0gW107XG4gICAgICAgIGNvbnN0IHVuaGlkZUZpbHRlcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgbmV3RmlsdGVycykge1xuICAgICAgICAgICAgaWYgKGZpbHRlci5pc05ldHdvcmtGaWx0ZXIoKSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIuaXNFeGNlcHRpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICBleGNlcHRpb25GaWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtGaWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWx0ZXIuaXNDb3NtZXRpY0ZpbHRlcigpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlci5pc1VuaGlkZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaGlkZUZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29zbWV0aWNGaWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXR3b3JrSW5kZXgudXBkYXRlKG5ldHdvcmtGaWx0ZXJzLCByZW1vdmVkRmlsdGVycyk7XG4gICAgICAgIHRoaXMuZXhjZXB0aW9uc0luZGV4LnVwZGF0ZShleGNlcHRpb25GaWx0ZXJzLCByZW1vdmVkRmlsdGVycyk7XG4gICAgICAgIHRoaXMuY29zbWV0aWNJbmRleC51cGRhdGUoY29zbWV0aWNGaWx0ZXJzLCByZW1vdmVkRmlsdGVycyk7XG4gICAgICAgIHRoaXMudW5oaWRlSW5kZXgudXBkYXRlKHVuaGlkZUZpbHRlcnMsIHJlbW92ZWRGaWx0ZXJzKTtcbiAgICB9XG4gICAgc2VyaWFsaXplKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLm5ldHdvcmtJbmRleC5zZXJpYWxpemUoYnVmZmVyKTtcbiAgICAgICAgdGhpcy5leGNlcHRpb25zSW5kZXguc2VyaWFsaXplKGJ1ZmZlcik7XG4gICAgICAgIHRoaXMuY29zbWV0aWNJbmRleC5zZXJpYWxpemUoYnVmZmVyKTtcbiAgICAgICAgdGhpcy51bmhpZGVJbmRleC5zZXJpYWxpemUoYnVmZmVyKTtcbiAgICB9XG4gICAgZ2V0U2VyaWFsaXplZFNpemUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5uZXR3b3JrSW5kZXguZ2V0U2VyaWFsaXplZFNpemUoKSArXG4gICAgICAgICAgICB0aGlzLmV4Y2VwdGlvbnNJbmRleC5nZXRTZXJpYWxpemVkU2l6ZSgpICtcbiAgICAgICAgICAgIHRoaXMuY29zbWV0aWNJbmRleC5nZXRTZXJpYWxpemVkU2l6ZSgpICtcbiAgICAgICAgICAgIHRoaXMudW5oaWRlSW5kZXguZ2V0U2VyaWFsaXplZFNpemUoKSk7XG4gICAgfVxuICAgIGdldEhUTUxGaWx0ZXJzKHJlcXVlc3QsIGlzRmlsdGVyRXhjbHVkZWQpIHtcbiAgICAgICAgY29uc3QgbmV0d29ya0ZpbHRlcnMgPSBbXTtcbiAgICAgICAgY29uc3QgY29zbWV0aWNGaWx0ZXJzID0gW107XG4gICAgICAgIGNvbnN0IGV4Y2VwdGlvbnMgPSBbXTtcbiAgICAgICAgY29uc3QgdW5oaWRlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5jb25maWcubG9hZE5ldHdvcmtGaWx0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLm5ldHdvcmtJbmRleC5pdGVyTWF0Y2hpbmdGaWx0ZXJzKHJlcXVlc3QuZ2V0VG9rZW5zKCksIChmaWx0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLm1hdGNoKHJlcXVlc3QpICYmICEoaXNGaWx0ZXJFeGNsdWRlZCA9PT0gbnVsbCB8fCBpc0ZpbHRlckV4Y2x1ZGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0ZpbHRlckV4Y2x1ZGVkKGZpbHRlcikpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtGaWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhdCBsZWFzdCBvbmUgY2FuZGlkYXRlLCBjaGVjayBpZiB3ZSBoYXZlIGV4Y2VwdGlvbnMuXG4gICAgICAgIGlmIChuZXR3b3JrRmlsdGVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZXhjZXB0aW9uc0luZGV4Lml0ZXJNYXRjaGluZ0ZpbHRlcnMocmVxdWVzdC5nZXRUb2tlbnMoKSwgKGZpbHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIubWF0Y2gocmVxdWVzdCkgJiYgIShpc0ZpbHRlckV4Y2x1ZGVkID09PSBudWxsIHx8IGlzRmlsdGVyRXhjbHVkZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlzRmlsdGVyRXhjbHVkZWQoZmlsdGVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9ucy5wdXNoKGZpbHRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYWRDb3NtZXRpY0ZpbHRlcnMgPT09IHRydWUgJiYgcmVxdWVzdC5pc01haW5GcmFtZSgpKSB7XG4gICAgICAgICAgICBjb25zdCB7IGhvc3RuYW1lLCBkb21haW4gPSAnJyB9ID0gcmVxdWVzdDtcbiAgICAgICAgICAgIGNvbnN0IGhvc3RuYW1lVG9rZW5zID0gY3JlYXRlTG9va3VwVG9rZW5zKGhvc3RuYW1lLCBkb21haW4pO1xuICAgICAgICAgICAgdGhpcy5jb3NtZXRpY0luZGV4Lml0ZXJNYXRjaGluZ0ZpbHRlcnMoaG9zdG5hbWVUb2tlbnMsIChmaWx0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLm1hdGNoKGhvc3RuYW1lLCBkb21haW4pICYmICEoaXNGaWx0ZXJFeGNsdWRlZCA9PT0gbnVsbCB8fCBpc0ZpbHRlckV4Y2x1ZGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0ZpbHRlckV4Y2x1ZGVkKGZpbHRlcikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvc21ldGljRmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhdCBsZWFzdCBvbmUgY2FuZGlkYXRlLCBjaGVjayBpZiB3ZSBoYXZlIHVuaGlkZGVuIHJ1bGVzLlxuICAgICAgICAgICAgaWYgKGNvc21ldGljRmlsdGVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuaGlkZUluZGV4Lml0ZXJNYXRjaGluZ0ZpbHRlcnMoaG9zdG5hbWVUb2tlbnMsIChydWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlLm1hdGNoKGhvc3RuYW1lLCBkb21haW4pICYmICEoaXNGaWx0ZXJFeGNsdWRlZCA9PT0gbnVsbCB8fCBpc0ZpbHRlckV4Y2x1ZGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0ZpbHRlckV4Y2x1ZGVkKHJ1bGUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5oaWRlcy5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXR3b3JrRmlsdGVycyxcbiAgICAgICAgICAgIGNvc21ldGljRmlsdGVycyxcbiAgICAgICAgICAgIHVuaGlkZXMsXG4gICAgICAgICAgICBleGNlcHRpb25zLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRGaWx0ZXJzKCkge1xuICAgICAgICBjb25zdCBmaWx0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBmaWx0ZXJzLmNvbmNhdCh0aGlzLm5ldHdvcmtJbmRleC5nZXRGaWx0ZXJzKCksIHRoaXMuZXhjZXB0aW9uc0luZGV4LmdldEZpbHRlcnMoKSwgdGhpcy5jb3NtZXRpY0luZGV4LmdldEZpbHRlcnMoKSwgdGhpcy51bmhpZGVJbmRleC5nZXRGaWx0ZXJzKCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0bWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/html.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/network.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/network.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ NetworkFilterBucket)\n/* harmony export */ });\n/* harmony import */ var _filters_network_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../filters/network.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/network.js\");\n/* harmony import */ var _optimizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../optimizer.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/optimizer.js\");\n/* harmony import */ var _reverse_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../reverse-index.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/reverse-index.js\");\n/* harmony import */ var _filters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filters.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/filters.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n/**\n * Accelerating data structure for network filters matching.\n */\nclass NetworkFilterBucket {\n    static deserialize(buffer, config) {\n        const bucket = new NetworkFilterBucket({ config });\n        bucket.index = _reverse_index_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].deserialize(buffer, _filters_network_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deserialize, config.enableOptimizations ? _optimizer_js__WEBPACK_IMPORTED_MODULE_1__.optimizeNetwork : _optimizer_js__WEBPACK_IMPORTED_MODULE_1__.noopOptimizeNetwork, config);\n        bucket.badFilters = _filters_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].deserialize(buffer, _filters_network_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deserialize, config);\n        return bucket;\n    }\n    constructor({ filters = [], config }) {\n        this.index = new _reverse_index_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n            config,\n            deserialize: _filters_network_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deserialize,\n            filters: [],\n            optimize: config.enableOptimizations ? _optimizer_js__WEBPACK_IMPORTED_MODULE_1__.optimizeNetwork : _optimizer_js__WEBPACK_IMPORTED_MODULE_1__.noopOptimizeNetwork,\n        });\n        this.badFiltersIds = null;\n        this.badFilters = new _filters_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n            config,\n            deserialize: _filters_network_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deserialize,\n            filters: [],\n        });\n        if (filters.length !== 0) {\n            this.update(filters, undefined);\n        }\n    }\n    getFilters() {\n        const filters = [];\n        return filters.concat(this.badFilters.getFilters(), this.index.getFilters());\n    }\n    update(newFilters, removedFilters) {\n        const badFilters = [];\n        const remaining = [];\n        for (const filter of newFilters) {\n            if (filter.isBadFilter()) {\n                badFilters.push(filter);\n            }\n            else {\n                remaining.push(filter);\n            }\n        }\n        this.badFilters.update(badFilters, removedFilters);\n        this.index.update(remaining, removedFilters);\n        this.badFiltersIds = null;\n    }\n    getSerializedSize() {\n        return this.badFilters.getSerializedSize() + this.index.getSerializedSize();\n    }\n    serialize(buffer) {\n        this.index.serialize(buffer);\n        this.badFilters.serialize(buffer);\n    }\n    matchAll(request, isFilterExcluded) {\n        const filters = [];\n        this.index.iterMatchingFilters(request.getTokens(), (filter) => {\n            if (filter.match(request) &&\n                this.isFilterDisabled(filter) === false &&\n                !(isFilterExcluded === null || isFilterExcluded === void 0 ? void 0 : isFilterExcluded(filter))) {\n                filters.push(filter);\n            }\n            return true;\n        });\n        return filters;\n    }\n    match(request, isFilterExcluded) {\n        let match;\n        this.index.iterMatchingFilters(request.getTokens(), (filter) => {\n            if (filter.match(request) &&\n                this.isFilterDisabled(filter) === false &&\n                !(isFilterExcluded === null || isFilterExcluded === void 0 ? void 0 : isFilterExcluded(filter))) {\n                match = filter;\n                return false;\n            }\n            return true;\n        });\n        return match;\n    }\n    /**\n     * Given a matching filter, check if it is disabled by a $badfilter.\n     */\n    isFilterDisabled(filter) {\n        // Lazily load information about bad filters in memory. The only thing we\n        // keep in memory is the list of IDs from $badfilter (ignoring the\n        // $badfilter option from mask). This allows to check if a matching filter\n        // should be ignored just by doing a lookup in a set of IDs.\n        if (this.badFiltersIds === null) {\n            const badFilters = this.badFilters.getFilters();\n            // Shortcut if there is no badfilter in this bucket\n            if (badFilters.length === 0) {\n                return false;\n            }\n            // Create in-memory list of disabled filter IDs\n            const badFiltersIds = new Set();\n            for (const badFilter of badFilters) {\n                badFiltersIds.add(badFilter.getIdWithoutBadFilter());\n            }\n            this.badFiltersIds = badFiltersIds;\n        }\n        return this.badFiltersIds.has(filter.getId());\n    }\n}\n//# sourceMappingURL=network.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvYnVja2V0L25ldHdvcmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxRDtBQUNrQjtBQUN4QjtBQUNIO0FBQzVDO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQSxpREFBaUQsUUFBUTtBQUN6RCx1QkFBdUIseURBQVkscUJBQXFCLDJEQUFhLDJDQUEyQywwREFBZSxHQUFHLDhEQUFtQjtBQUNySiw0QkFBNEIsbURBQWdCLHFCQUFxQiwyREFBYTtBQUM5RTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4Qyx5QkFBeUIseURBQVk7QUFDckM7QUFDQSx5QkFBeUIsMkRBQWE7QUFDdEM7QUFDQSxtREFBbUQsMERBQWUsR0FBRyw4REFBbUI7QUFDeEYsU0FBUztBQUNUO0FBQ0EsOEJBQThCLG1EQUFnQjtBQUM5QztBQUNBLHlCQUF5QiwyREFBYTtBQUN0QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXIvZGlzdC9lc20vZW5naW5lL2J1Y2tldC9uZXR3b3JrLmpzPzcyOGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCBHaG9zdGVyeSBHbWJILiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgTmV0d29ya0ZpbHRlciBmcm9tICcuLi8uLi9maWx0ZXJzL25ldHdvcmsuanMnO1xuaW1wb3J0IHsgbm9vcE9wdGltaXplTmV0d29yaywgb3B0aW1pemVOZXR3b3JrIH0gZnJvbSAnLi4vb3B0aW1pemVyLmpzJztcbmltcG9ydCBSZXZlcnNlSW5kZXggZnJvbSAnLi4vcmV2ZXJzZS1pbmRleC5qcyc7XG5pbXBvcnQgRmlsdGVyc0NvbnRhaW5lciBmcm9tICcuL2ZpbHRlcnMuanMnO1xuLyoqXG4gKiBBY2NlbGVyYXRpbmcgZGF0YSBzdHJ1Y3R1cmUgZm9yIG5ldHdvcmsgZmlsdGVycyBtYXRjaGluZy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmV0d29ya0ZpbHRlckJ1Y2tldCB7XG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ1ZmZlciwgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGJ1Y2tldCA9IG5ldyBOZXR3b3JrRmlsdGVyQnVja2V0KHsgY29uZmlnIH0pO1xuICAgICAgICBidWNrZXQuaW5kZXggPSBSZXZlcnNlSW5kZXguZGVzZXJpYWxpemUoYnVmZmVyLCBOZXR3b3JrRmlsdGVyLmRlc2VyaWFsaXplLCBjb25maWcuZW5hYmxlT3B0aW1pemF0aW9ucyA/IG9wdGltaXplTmV0d29yayA6IG5vb3BPcHRpbWl6ZU5ldHdvcmssIGNvbmZpZyk7XG4gICAgICAgIGJ1Y2tldC5iYWRGaWx0ZXJzID0gRmlsdGVyc0NvbnRhaW5lci5kZXNlcmlhbGl6ZShidWZmZXIsIE5ldHdvcmtGaWx0ZXIuZGVzZXJpYWxpemUsIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiBidWNrZXQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsgZmlsdGVycyA9IFtdLCBjb25maWcgfSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gbmV3IFJldmVyc2VJbmRleCh7XG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZTogTmV0d29ya0ZpbHRlci5kZXNlcmlhbGl6ZSxcbiAgICAgICAgICAgIGZpbHRlcnM6IFtdLFxuICAgICAgICAgICAgb3B0aW1pemU6IGNvbmZpZy5lbmFibGVPcHRpbWl6YXRpb25zID8gb3B0aW1pemVOZXR3b3JrIDogbm9vcE9wdGltaXplTmV0d29yayxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYmFkRmlsdGVyc0lkcyA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFkRmlsdGVycyA9IG5ldyBGaWx0ZXJzQ29udGFpbmVyKHtcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGRlc2VyaWFsaXplOiBOZXR3b3JrRmlsdGVyLmRlc2VyaWFsaXplLFxuICAgICAgICAgICAgZmlsdGVyczogW10sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZmlsdGVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKGZpbHRlcnMsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RmlsdGVycygpIHtcbiAgICAgICAgY29uc3QgZmlsdGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gZmlsdGVycy5jb25jYXQodGhpcy5iYWRGaWx0ZXJzLmdldEZpbHRlcnMoKSwgdGhpcy5pbmRleC5nZXRGaWx0ZXJzKCkpO1xuICAgIH1cbiAgICB1cGRhdGUobmV3RmlsdGVycywgcmVtb3ZlZEZpbHRlcnMpIHtcbiAgICAgICAgY29uc3QgYmFkRmlsdGVycyA9IFtdO1xuICAgICAgICBjb25zdCByZW1haW5pbmcgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgbmV3RmlsdGVycykge1xuICAgICAgICAgICAgaWYgKGZpbHRlci5pc0JhZEZpbHRlcigpKSB7XG4gICAgICAgICAgICAgICAgYmFkRmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1haW5pbmcucHVzaChmaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmFkRmlsdGVycy51cGRhdGUoYmFkRmlsdGVycywgcmVtb3ZlZEZpbHRlcnMpO1xuICAgICAgICB0aGlzLmluZGV4LnVwZGF0ZShyZW1haW5pbmcsIHJlbW92ZWRGaWx0ZXJzKTtcbiAgICAgICAgdGhpcy5iYWRGaWx0ZXJzSWRzID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0U2VyaWFsaXplZFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhZEZpbHRlcnMuZ2V0U2VyaWFsaXplZFNpemUoKSArIHRoaXMuaW5kZXguZ2V0U2VyaWFsaXplZFNpemUoKTtcbiAgICB9XG4gICAgc2VyaWFsaXplKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLmluZGV4LnNlcmlhbGl6ZShidWZmZXIpO1xuICAgICAgICB0aGlzLmJhZEZpbHRlcnMuc2VyaWFsaXplKGJ1ZmZlcik7XG4gICAgfVxuICAgIG1hdGNoQWxsKHJlcXVlc3QsIGlzRmlsdGVyRXhjbHVkZWQpIHtcbiAgICAgICAgY29uc3QgZmlsdGVycyA9IFtdO1xuICAgICAgICB0aGlzLmluZGV4Lml0ZXJNYXRjaGluZ0ZpbHRlcnMocmVxdWVzdC5nZXRUb2tlbnMoKSwgKGZpbHRlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGZpbHRlci5tYXRjaChyZXF1ZXN0KSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaXNGaWx0ZXJEaXNhYmxlZChmaWx0ZXIpID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICEoaXNGaWx0ZXJFeGNsdWRlZCA9PT0gbnVsbCB8fCBpc0ZpbHRlckV4Y2x1ZGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0ZpbHRlckV4Y2x1ZGVkKGZpbHRlcikpKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJzO1xuICAgIH1cbiAgICBtYXRjaChyZXF1ZXN0LCBpc0ZpbHRlckV4Y2x1ZGVkKSB7XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgdGhpcy5pbmRleC5pdGVyTWF0Y2hpbmdGaWx0ZXJzKHJlcXVlc3QuZ2V0VG9rZW5zKCksIChmaWx0ZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIubWF0Y2gocmVxdWVzdCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmlzRmlsdGVyRGlzYWJsZWQoZmlsdGVyKSA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAhKGlzRmlsdGVyRXhjbHVkZWQgPT09IG51bGwgfHwgaXNGaWx0ZXJFeGNsdWRlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXNGaWx0ZXJFeGNsdWRlZChmaWx0ZXIpKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gZmlsdGVyO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIG1hdGNoaW5nIGZpbHRlciwgY2hlY2sgaWYgaXQgaXMgZGlzYWJsZWQgYnkgYSAkYmFkZmlsdGVyLlxuICAgICAqL1xuICAgIGlzRmlsdGVyRGlzYWJsZWQoZmlsdGVyKSB7XG4gICAgICAgIC8vIExhemlseSBsb2FkIGluZm9ybWF0aW9uIGFib3V0IGJhZCBmaWx0ZXJzIGluIG1lbW9yeS4gVGhlIG9ubHkgdGhpbmcgd2VcbiAgICAgICAgLy8ga2VlcCBpbiBtZW1vcnkgaXMgdGhlIGxpc3Qgb2YgSURzIGZyb20gJGJhZGZpbHRlciAoaWdub3JpbmcgdGhlXG4gICAgICAgIC8vICRiYWRmaWx0ZXIgb3B0aW9uIGZyb20gbWFzaykuIFRoaXMgYWxsb3dzIHRvIGNoZWNrIGlmIGEgbWF0Y2hpbmcgZmlsdGVyXG4gICAgICAgIC8vIHNob3VsZCBiZSBpZ25vcmVkIGp1c3QgYnkgZG9pbmcgYSBsb29rdXAgaW4gYSBzZXQgb2YgSURzLlxuICAgICAgICBpZiAodGhpcy5iYWRGaWx0ZXJzSWRzID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBiYWRGaWx0ZXJzID0gdGhpcy5iYWRGaWx0ZXJzLmdldEZpbHRlcnMoKTtcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0IGlmIHRoZXJlIGlzIG5vIGJhZGZpbHRlciBpbiB0aGlzIGJ1Y2tldFxuICAgICAgICAgICAgaWYgKGJhZEZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3JlYXRlIGluLW1lbW9yeSBsaXN0IG9mIGRpc2FibGVkIGZpbHRlciBJRHNcbiAgICAgICAgICAgIGNvbnN0IGJhZEZpbHRlcnNJZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJhZEZpbHRlciBvZiBiYWRGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgYmFkRmlsdGVyc0lkcy5hZGQoYmFkRmlsdGVyLmdldElkV2l0aG91dEJhZEZpbHRlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmFkRmlsdGVyc0lkcyA9IGJhZEZpbHRlcnNJZHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYmFkRmlsdGVyc0lkcy5oYXMoZmlsdGVyLmdldElkKCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmsuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/network.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/preprocessor.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/preprocessor.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PreprocessorBucket)\n/* harmony export */ });\n/* harmony import */ var _preprocessor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../preprocessor.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/preprocessor.js\");\n\nclass PreprocessorBucket {\n    static deserialize(view) {\n        const excluded = new Set();\n        for (let i = 0, l = view.getUint32(); i < l; i++) {\n            excluded.add(view.getUint32());\n        }\n        const preprocessors = [];\n        for (let i = 0, l = view.getUint32(); i < l; i++) {\n            preprocessors.push(_preprocessor_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].deserialize(view));\n        }\n        return new this({\n            excluded,\n            preprocessors,\n        });\n    }\n    constructor({ excluded = new Set(), preprocessors = [], }) {\n        this.excluded = excluded;\n        this.preprocessors = preprocessors;\n    }\n    isFilterExcluded(filter) {\n        return this.excluded.has(filter.getId());\n    }\n    updateEnv(env) {\n        // Update excluded filter ids based on bindings\n        this.excluded.clear();\n        for (const preprocessor of this.preprocessors) {\n            if (!preprocessor.evaluate(env)) {\n                for (const filterID of preprocessor.filterIDs) {\n                    this.excluded.add(filterID);\n                }\n            }\n        }\n    }\n    update({ added, removed, }, env) {\n        if (removed) {\n            for (const preprocessor of removed) {\n                const local = this.preprocessors.find((local) => local.condition === preprocessor.condition);\n                // Skip if we don't have any preprocessor on local\n                // In the context of filters updates from CDN this should never happen.\n                if (!local) {\n                    continue;\n                }\n                for (const filterID of preprocessor.filterIDs) {\n                    local.filterIDs.delete(filterID);\n                }\n            }\n        }\n        if (added) {\n            for (const preprocessor of added) {\n                const local = this.preprocessors.find((local) => local.condition === preprocessor.condition);\n                if (!local) {\n                    this.preprocessors.push(preprocessor);\n                    continue;\n                }\n                for (const filterID of preprocessor.filterIDs) {\n                    local.filterIDs.add(filterID);\n                }\n            }\n        }\n        if ((removed && removed.length !== 0) || (added && added.length !== 0)) {\n            this.updateEnv(env);\n        }\n    }\n    serialize(view) {\n        view.pushUint32(this.excluded.size);\n        for (const filterID of this.excluded) {\n            view.pushUint32(filterID);\n        }\n        view.pushUint32(this.preprocessors.length);\n        for (const preprocessor of this.preprocessors) {\n            preprocessor.serialize(view);\n        }\n    }\n    getSerializedSize() {\n        let estimatedSize = (1 + this.excluded.size) * 4;\n        estimatedSize += 4;\n        for (const preprocessor of this.preprocessors) {\n            estimatedSize += preprocessor.getSerializedSize();\n        }\n        return estimatedSize;\n    }\n}\n//# sourceMappingURL=preprocessor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvYnVja2V0L3ByZXByb2Nlc3Nvci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRDtBQUNsQztBQUNmO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRCwrQkFBK0Isd0RBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsMkNBQTJDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXIvZGlzdC9lc20vZW5naW5lL2J1Y2tldC9wcmVwcm9jZXNzb3IuanM/Yzk0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUHJlcHJvY2Vzc29yIGZyb20gJy4uLy4uL3ByZXByb2Nlc3Nvci5qcyc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVwcm9jZXNzb3JCdWNrZXQge1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZSh2aWV3KSB7XG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHZpZXcuZ2V0VWludDMyKCk7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGV4Y2x1ZGVkLmFkZCh2aWV3LmdldFVpbnQzMigpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVwcm9jZXNzb3JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdmlldy5nZXRVaW50MzIoKTsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgcHJlcHJvY2Vzc29ycy5wdXNoKFByZXByb2Nlc3Nvci5kZXNlcmlhbGl6ZSh2aWV3KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHtcbiAgICAgICAgICAgIGV4Y2x1ZGVkLFxuICAgICAgICAgICAgcHJlcHJvY2Vzc29ycyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsgZXhjbHVkZWQgPSBuZXcgU2V0KCksIHByZXByb2Nlc3NvcnMgPSBbXSwgfSkge1xuICAgICAgICB0aGlzLmV4Y2x1ZGVkID0gZXhjbHVkZWQ7XG4gICAgICAgIHRoaXMucHJlcHJvY2Vzc29ycyA9IHByZXByb2Nlc3NvcnM7XG4gICAgfVxuICAgIGlzRmlsdGVyRXhjbHVkZWQoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4Y2x1ZGVkLmhhcyhmaWx0ZXIuZ2V0SWQoKSk7XG4gICAgfVxuICAgIHVwZGF0ZUVudihlbnYpIHtcbiAgICAgICAgLy8gVXBkYXRlIGV4Y2x1ZGVkIGZpbHRlciBpZHMgYmFzZWQgb24gYmluZGluZ3NcbiAgICAgICAgdGhpcy5leGNsdWRlZC5jbGVhcigpO1xuICAgICAgICBmb3IgKGNvbnN0IHByZXByb2Nlc3NvciBvZiB0aGlzLnByZXByb2Nlc3NvcnMpIHtcbiAgICAgICAgICAgIGlmICghcHJlcHJvY2Vzc29yLmV2YWx1YXRlKGVudikpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpbHRlcklEIG9mIHByZXByb2Nlc3Nvci5maWx0ZXJJRHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leGNsdWRlZC5hZGQoZmlsdGVySUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUoeyBhZGRlZCwgcmVtb3ZlZCwgfSwgZW52KSB7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByZXByb2Nlc3NvciBvZiByZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWwgPSB0aGlzLnByZXByb2Nlc3NvcnMuZmluZCgobG9jYWwpID0+IGxvY2FsLmNvbmRpdGlvbiA9PT0gcHJlcHJvY2Vzc29yLmNvbmRpdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBpZiB3ZSBkb24ndCBoYXZlIGFueSBwcmVwcm9jZXNzb3Igb24gbG9jYWxcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgY29udGV4dCBvZiBmaWx0ZXJzIHVwZGF0ZXMgZnJvbSBDRE4gdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLlxuICAgICAgICAgICAgICAgIGlmICghbG9jYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmlsdGVySUQgb2YgcHJlcHJvY2Vzc29yLmZpbHRlcklEcykge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbC5maWx0ZXJJRHMuZGVsZXRlKGZpbHRlcklEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZGVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByZXByb2Nlc3NvciBvZiBhZGRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsID0gdGhpcy5wcmVwcm9jZXNzb3JzLmZpbmQoKGxvY2FsKSA9PiBsb2NhbC5jb25kaXRpb24gPT09IHByZXByb2Nlc3Nvci5jb25kaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmICghbG9jYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVwcm9jZXNzb3JzLnB1c2gocHJlcHJvY2Vzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmlsdGVySUQgb2YgcHJlcHJvY2Vzc29yLmZpbHRlcklEcykge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbC5maWx0ZXJJRHMuYWRkKGZpbHRlcklEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChyZW1vdmVkICYmIHJlbW92ZWQubGVuZ3RoICE9PSAwKSB8fCAoYWRkZWQgJiYgYWRkZWQubGVuZ3RoICE9PSAwKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFbnYoZW52KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXJpYWxpemUodmlldykge1xuICAgICAgICB2aWV3LnB1c2hVaW50MzIodGhpcy5leGNsdWRlZC5zaXplKTtcbiAgICAgICAgZm9yIChjb25zdCBmaWx0ZXJJRCBvZiB0aGlzLmV4Y2x1ZGVkKSB7XG4gICAgICAgICAgICB2aWV3LnB1c2hVaW50MzIoZmlsdGVySUQpO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcucHVzaFVpbnQzMih0aGlzLnByZXByb2Nlc3NvcnMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChjb25zdCBwcmVwcm9jZXNzb3Igb2YgdGhpcy5wcmVwcm9jZXNzb3JzKSB7XG4gICAgICAgICAgICBwcmVwcm9jZXNzb3Iuc2VyaWFsaXplKHZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNlcmlhbGl6ZWRTaXplKCkge1xuICAgICAgICBsZXQgZXN0aW1hdGVkU2l6ZSA9ICgxICsgdGhpcy5leGNsdWRlZC5zaXplKSAqIDQ7XG4gICAgICAgIGVzdGltYXRlZFNpemUgKz0gNDtcbiAgICAgICAgZm9yIChjb25zdCBwcmVwcm9jZXNzb3Igb2YgdGhpcy5wcmVwcm9jZXNzb3JzKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZWRTaXplICs9IHByZXByb2Nlc3Nvci5nZXRTZXJpYWxpemVkU2l6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlc3RpbWF0ZWRTaXplO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZXByb2Nlc3Nvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/preprocessor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/domains.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/engine/domains.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Domains: () => (/* binding */ Domains)\n/* harmony export */ });\n/* harmony import */ var _request_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../request.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/request.js\");\n/* harmony import */ var _punycode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../punycode.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/punycode.js\");\n/* harmony import */ var _data_view_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data-view.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/data-view.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/utils.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\nclass Domains {\n    static parse(value, { delimiter = ',', debug = false } = {}) {\n        if (typeof value === 'string') {\n            if (value.length === 0) {\n                return undefined;\n            }\n        }\n        else if (value.size === 0) {\n            return undefined;\n        }\n        const parts = typeof value === 'string' ? value.split(delimiter) : value;\n        for (const part of parts) {\n            if (part.length === 0) {\n                return undefined;\n            }\n        }\n        const entities = [];\n        const notEntities = [];\n        const hostnames = [];\n        const notHostnames = [];\n        const rawParts = [];\n        for (const rawHostname of parts) {\n            let hostname = rawHostname;\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.hasUnicode)(hostname)) {\n                hostname = (0,_punycode_js__WEBPACK_IMPORTED_MODULE_1__.toASCII)(hostname);\n            }\n            const negation = hostname.charCodeAt(0) === 126; /* '~' */\n            const entity = hostname.charCodeAt(hostname.length - 1) === 42 /* '*' */ &&\n                hostname.charCodeAt(hostname.length - 2) === 46; /* '.' */\n            const start = negation ? 1 : 0;\n            const end = entity ? hostname.length - 2 : hostname.length;\n            const hash = (0,_request_js__WEBPACK_IMPORTED_MODULE_0__.hashHostnameBackward)(negation === true || entity === true ? hostname.slice(start, end) : hostname);\n            if (negation) {\n                if (entity) {\n                    notEntities.push(hash);\n                }\n                else {\n                    notHostnames.push(hash);\n                }\n                if (debug) {\n                    rawParts.push(negation ? rawHostname : `~${rawHostname}`);\n                }\n            }\n            else {\n                if (entity) {\n                    entities.push(hash);\n                }\n                else {\n                    hostnames.push(hash);\n                }\n                if (debug) {\n                    rawParts.push(negation ? rawHostname.slice(1) : rawHostname);\n                }\n            }\n        }\n        return new Domains({\n            entities: entities.length !== 0 ? new Uint32Array(entities).sort() : undefined,\n            hostnames: hostnames.length !== 0 ? new Uint32Array(hostnames).sort() : undefined,\n            notEntities: notEntities.length !== 0 ? new Uint32Array(notEntities).sort() : undefined,\n            notHostnames: notHostnames.length !== 0 ? new Uint32Array(notHostnames).sort() : undefined,\n            parts: debug === true ? rawParts.join(delimiter) : undefined,\n        });\n    }\n    static deserialize(buffer) {\n        const optionalParts = buffer.getUint8();\n        // The order of these fields should be the same as when we serialize them.\n        return new Domains({\n            entities: (optionalParts & 1) === 1 ? buffer.getUint32Array() : undefined,\n            hostnames: (optionalParts & 2) === 2 ? buffer.getUint32Array() : undefined,\n            notEntities: (optionalParts & 4) === 4 ? buffer.getUint32Array() : undefined,\n            notHostnames: (optionalParts & 8) === 8 ? buffer.getUint32Array() : undefined,\n            parts: (optionalParts & 16) === 16 ? buffer.getUTF8() : undefined,\n        });\n    }\n    constructor({ entities, hostnames, notEntities, notHostnames, parts, }) {\n        // Hostname constraints\n        this.entities = entities;\n        this.hostnames = hostnames;\n        // Hostname exceptions\n        this.notEntities = notEntities;\n        this.notHostnames = notHostnames;\n        // Debug\n        this.parts = parts;\n    }\n    updateId(hash) {\n        const { hostnames, entities, notHostnames, notEntities } = this;\n        if (hostnames !== undefined) {\n            for (const hostname of hostnames) {\n                hash = (hash * _utils_js__WEBPACK_IMPORTED_MODULE_3__.HASH_INTERNAL_MULT) ^ hostname;\n            }\n        }\n        if (entities !== undefined) {\n            for (const entity of entities) {\n                hash = (hash * _utils_js__WEBPACK_IMPORTED_MODULE_3__.HASH_INTERNAL_MULT) ^ entity;\n            }\n        }\n        if (notHostnames !== undefined) {\n            for (const notHostname of notHostnames) {\n                hash = (hash * _utils_js__WEBPACK_IMPORTED_MODULE_3__.HASH_INTERNAL_MULT) ^ notHostname;\n            }\n        }\n        if (notEntities !== undefined) {\n            for (const notEntity of notEntities) {\n                hash = (hash * _utils_js__WEBPACK_IMPORTED_MODULE_3__.HASH_INTERNAL_MULT) ^ notEntity;\n            }\n        }\n        return hash;\n    }\n    serialize(buffer) {\n        // Mandatory fields\n        const index = buffer.getPos();\n        buffer.pushUint8(0);\n        // This bit-mask indicates which optional parts of the filter were serialized.\n        let optionalParts = 0;\n        if (this.entities !== undefined) {\n            optionalParts |= 1;\n            buffer.pushUint32Array(this.entities);\n        }\n        if (this.hostnames !== undefined) {\n            optionalParts |= 2;\n            buffer.pushUint32Array(this.hostnames);\n        }\n        if (this.notEntities !== undefined) {\n            optionalParts |= 4;\n            buffer.pushUint32Array(this.notEntities);\n        }\n        if (this.notHostnames !== undefined) {\n            optionalParts |= 8;\n            buffer.pushUint32Array(this.notHostnames);\n        }\n        if (this.parts !== undefined) {\n            optionalParts |= 16;\n            buffer.pushUTF8(this.parts);\n        }\n        buffer.setByte(index, optionalParts);\n    }\n    getSerializedSize() {\n        let estimate = 1; // optional parts (1 byte)\n        if (this.entities !== undefined) {\n            estimate += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_2__.sizeOfUint32Array)(this.entities);\n        }\n        if (this.hostnames !== undefined) {\n            estimate += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_2__.sizeOfUint32Array)(this.hostnames);\n        }\n        if (this.notHostnames !== undefined) {\n            estimate += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_2__.sizeOfUint32Array)(this.notHostnames);\n        }\n        if (this.notEntities !== undefined) {\n            estimate += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_2__.sizeOfUint32Array)(this.notEntities);\n        }\n        if (this.parts !== undefined) {\n            estimate += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_2__.sizeOfUTF8)(this.parts);\n        }\n        return estimate;\n    }\n    match(hostnameHashes, entityHashes) {\n        // Check if `hostname` is blacklisted\n        if (this.notHostnames !== undefined) {\n            for (const hash of hostnameHashes) {\n                if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.binLookup)(this.notHostnames, hash)) {\n                    return false;\n                }\n            }\n        }\n        // Check if `hostname` is blacklisted by *entity*\n        if (this.notEntities !== undefined) {\n            for (const hash of entityHashes) {\n                if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.binLookup)(this.notEntities, hash)) {\n                    return false;\n                }\n            }\n        }\n        // Check if `hostname` is allowed\n        if (this.hostnames !== undefined || this.entities !== undefined) {\n            if (this.hostnames !== undefined) {\n                for (const hash of hostnameHashes) {\n                    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.binLookup)(this.hostnames, hash)) {\n                        return true;\n                    }\n                }\n            }\n            if (this.entities !== undefined) {\n                for (const hash of entityHashes) {\n                    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.binLookup)(this.entities, hash)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=domains.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvZG9tYWlucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FEO0FBQ1o7QUFDdUI7QUFDUTtBQUNqRTtBQUNQLDBCQUEwQixpQ0FBaUMsSUFBSTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQVU7QUFDMUIsMkJBQTJCLHFEQUFPO0FBQ2xDO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQSx5QkFBeUIsaUVBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsWUFBWTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLHdEQUF3RDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBaUQ7QUFDakU7QUFDQTtBQUNBLCtCQUErQix5REFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseURBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlEQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5REFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0Esd0JBQXdCLGdFQUFpQjtBQUN6QztBQUNBO0FBQ0Esd0JBQXdCLGdFQUFpQjtBQUN6QztBQUNBO0FBQ0Esd0JBQXdCLGdFQUFpQjtBQUN6QztBQUNBO0FBQ0Esd0JBQXdCLGdFQUFpQjtBQUN6QztBQUNBO0FBQ0Esd0JBQXdCLHlEQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0RBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9EQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvZG9tYWlucy5qcz8wZDU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQgR2hvc3RlcnkgR21iSC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgaGFzaEhvc3RuYW1lQmFja3dhcmQgfSBmcm9tICcuLi9yZXF1ZXN0LmpzJztcbmltcG9ydCB7IHRvQVNDSUkgfSBmcm9tICcuLi9wdW55Y29kZS5qcyc7XG5pbXBvcnQgeyBzaXplT2ZVaW50MzJBcnJheSwgc2l6ZU9mVVRGOCB9IGZyb20gJy4uL2RhdGEtdmlldy5qcyc7XG5pbXBvcnQgeyBiaW5Mb29rdXAsIGhhc1VuaWNvZGUsIEhBU0hfSU5URVJOQUxfTVVMVCB9IGZyb20gJy4uL3V0aWxzLmpzJztcbmV4cG9ydCBjbGFzcyBEb21haW5zIHtcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUsIHsgZGVsaW1pdGVyID0gJywnLCBkZWJ1ZyA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZS5zcGxpdChkZWxpbWl0ZXIpIDogdmFsdWU7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRpdGllcyA9IFtdO1xuICAgICAgICBjb25zdCBub3RFbnRpdGllcyA9IFtdO1xuICAgICAgICBjb25zdCBob3N0bmFtZXMgPSBbXTtcbiAgICAgICAgY29uc3Qgbm90SG9zdG5hbWVzID0gW107XG4gICAgICAgIGNvbnN0IHJhd1BhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcmF3SG9zdG5hbWUgb2YgcGFydHMpIHtcbiAgICAgICAgICAgIGxldCBob3N0bmFtZSA9IHJhd0hvc3RuYW1lO1xuICAgICAgICAgICAgaWYgKGhhc1VuaWNvZGUoaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaG9zdG5hbWUgPSB0b0FTQ0lJKGhvc3RuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5lZ2F0aW9uID0gaG9zdG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gMTI2OyAvKiAnficgKi9cbiAgICAgICAgICAgIGNvbnN0IGVudGl0eSA9IGhvc3RuYW1lLmNoYXJDb2RlQXQoaG9zdG5hbWUubGVuZ3RoIC0gMSkgPT09IDQyIC8qICcqJyAqLyAmJlxuICAgICAgICAgICAgICAgIGhvc3RuYW1lLmNoYXJDb2RlQXQoaG9zdG5hbWUubGVuZ3RoIC0gMikgPT09IDQ2OyAvKiAnLicgKi9cbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbmVnYXRpb24gPyAxIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGVudGl0eSA/IGhvc3RuYW1lLmxlbmd0aCAtIDIgOiBob3N0bmFtZS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gaGFzaEhvc3RuYW1lQmFja3dhcmQobmVnYXRpb24gPT09IHRydWUgfHwgZW50aXR5ID09PSB0cnVlID8gaG9zdG5hbWUuc2xpY2Uoc3RhcnQsIGVuZCkgOiBob3N0bmFtZSk7XG4gICAgICAgICAgICBpZiAobmVnYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdEVudGl0aWVzLnB1c2goaGFzaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub3RIb3N0bmFtZXMucHVzaChoYXNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhd1BhcnRzLnB1c2gobmVnYXRpb24gPyByYXdIb3N0bmFtZSA6IGB+JHtyYXdIb3N0bmFtZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLnB1c2goaGFzaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBob3N0bmFtZXMucHVzaChoYXNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhd1BhcnRzLnB1c2gobmVnYXRpb24gPyByYXdIb3N0bmFtZS5zbGljZSgxKSA6IHJhd0hvc3RuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEb21haW5zKHtcbiAgICAgICAgICAgIGVudGl0aWVzOiBlbnRpdGllcy5sZW5ndGggIT09IDAgPyBuZXcgVWludDMyQXJyYXkoZW50aXRpZXMpLnNvcnQoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhvc3RuYW1lczogaG9zdG5hbWVzLmxlbmd0aCAhPT0gMCA/IG5ldyBVaW50MzJBcnJheShob3N0bmFtZXMpLnNvcnQoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG5vdEVudGl0aWVzOiBub3RFbnRpdGllcy5sZW5ndGggIT09IDAgPyBuZXcgVWludDMyQXJyYXkobm90RW50aXRpZXMpLnNvcnQoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG5vdEhvc3RuYW1lczogbm90SG9zdG5hbWVzLmxlbmd0aCAhPT0gMCA/IG5ldyBVaW50MzJBcnJheShub3RIb3N0bmFtZXMpLnNvcnQoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBhcnRzOiBkZWJ1ZyA9PT0gdHJ1ZSA/IHJhd1BhcnRzLmpvaW4oZGVsaW1pdGVyKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShidWZmZXIpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWxQYXJ0cyA9IGJ1ZmZlci5nZXRVaW50OCgpO1xuICAgICAgICAvLyBUaGUgb3JkZXIgb2YgdGhlc2UgZmllbGRzIHNob3VsZCBiZSB0aGUgc2FtZSBhcyB3aGVuIHdlIHNlcmlhbGl6ZSB0aGVtLlxuICAgICAgICByZXR1cm4gbmV3IERvbWFpbnMoe1xuICAgICAgICAgICAgZW50aXRpZXM6IChvcHRpb25hbFBhcnRzICYgMSkgPT09IDEgPyBidWZmZXIuZ2V0VWludDMyQXJyYXkoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhvc3RuYW1lczogKG9wdGlvbmFsUGFydHMgJiAyKSA9PT0gMiA/IGJ1ZmZlci5nZXRVaW50MzJBcnJheSgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbm90RW50aXRpZXM6IChvcHRpb25hbFBhcnRzICYgNCkgPT09IDQgPyBidWZmZXIuZ2V0VWludDMyQXJyYXkoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG5vdEhvc3RuYW1lczogKG9wdGlvbmFsUGFydHMgJiA4KSA9PT0gOCA/IGJ1ZmZlci5nZXRVaW50MzJBcnJheSgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFydHM6IChvcHRpb25hbFBhcnRzICYgMTYpID09PSAxNiA/IGJ1ZmZlci5nZXRVVEY4KCkgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IGVudGl0aWVzLCBob3N0bmFtZXMsIG5vdEVudGl0aWVzLCBub3RIb3N0bmFtZXMsIHBhcnRzLCB9KSB7XG4gICAgICAgIC8vIEhvc3RuYW1lIGNvbnN0cmFpbnRzXG4gICAgICAgIHRoaXMuZW50aXRpZXMgPSBlbnRpdGllcztcbiAgICAgICAgdGhpcy5ob3N0bmFtZXMgPSBob3N0bmFtZXM7XG4gICAgICAgIC8vIEhvc3RuYW1lIGV4Y2VwdGlvbnNcbiAgICAgICAgdGhpcy5ub3RFbnRpdGllcyA9IG5vdEVudGl0aWVzO1xuICAgICAgICB0aGlzLm5vdEhvc3RuYW1lcyA9IG5vdEhvc3RuYW1lcztcbiAgICAgICAgLy8gRGVidWdcbiAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgIH1cbiAgICB1cGRhdGVJZChoYXNoKSB7XG4gICAgICAgIGNvbnN0IHsgaG9zdG5hbWVzLCBlbnRpdGllcywgbm90SG9zdG5hbWVzLCBub3RFbnRpdGllcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKGhvc3RuYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhvc3RuYW1lIG9mIGhvc3RuYW1lcykge1xuICAgICAgICAgICAgICAgIGhhc2ggPSAoaGFzaCAqIEhBU0hfSU5URVJOQUxfTVVMVCkgXiBob3N0bmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50aXRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgICAgICAgICAgICBoYXNoID0gKGhhc2ggKiBIQVNIX0lOVEVSTkFMX01VTFQpIF4gZW50aXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub3RIb3N0bmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBub3RIb3N0bmFtZSBvZiBub3RIb3N0bmFtZXMpIHtcbiAgICAgICAgICAgICAgICBoYXNoID0gKGhhc2ggKiBIQVNIX0lOVEVSTkFMX01VTFQpIF4gbm90SG9zdG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdEVudGl0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm90RW50aXR5IG9mIG5vdEVudGl0aWVzKSB7XG4gICAgICAgICAgICAgICAgaGFzaCA9IChoYXNoICogSEFTSF9JTlRFUk5BTF9NVUxUKSBeIG5vdEVudGl0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gICAgc2VyaWFsaXplKGJ1ZmZlcikge1xuICAgICAgICAvLyBNYW5kYXRvcnkgZmllbGRzXG4gICAgICAgIGNvbnN0IGluZGV4ID0gYnVmZmVyLmdldFBvcygpO1xuICAgICAgICBidWZmZXIucHVzaFVpbnQ4KDApO1xuICAgICAgICAvLyBUaGlzIGJpdC1tYXNrIGluZGljYXRlcyB3aGljaCBvcHRpb25hbCBwYXJ0cyBvZiB0aGUgZmlsdGVyIHdlcmUgc2VyaWFsaXplZC5cbiAgICAgICAgbGV0IG9wdGlvbmFsUGFydHMgPSAwO1xuICAgICAgICBpZiAodGhpcy5lbnRpdGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25hbFBhcnRzIHw9IDE7XG4gICAgICAgICAgICBidWZmZXIucHVzaFVpbnQzMkFycmF5KHRoaXMuZW50aXRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhvc3RuYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25hbFBhcnRzIHw9IDI7XG4gICAgICAgICAgICBidWZmZXIucHVzaFVpbnQzMkFycmF5KHRoaXMuaG9zdG5hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ub3RFbnRpdGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25hbFBhcnRzIHw9IDQ7XG4gICAgICAgICAgICBidWZmZXIucHVzaFVpbnQzMkFycmF5KHRoaXMubm90RW50aXRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5vdEhvc3RuYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25hbFBhcnRzIHw9IDg7XG4gICAgICAgICAgICBidWZmZXIucHVzaFVpbnQzMkFycmF5KHRoaXMubm90SG9zdG5hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJ0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25hbFBhcnRzIHw9IDE2O1xuICAgICAgICAgICAgYnVmZmVyLnB1c2hVVEY4KHRoaXMucGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5zZXRCeXRlKGluZGV4LCBvcHRpb25hbFBhcnRzKTtcbiAgICB9XG4gICAgZ2V0U2VyaWFsaXplZFNpemUoKSB7XG4gICAgICAgIGxldCBlc3RpbWF0ZSA9IDE7IC8vIG9wdGlvbmFsIHBhcnRzICgxIGJ5dGUpXG4gICAgICAgIGlmICh0aGlzLmVudGl0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVzdGltYXRlICs9IHNpemVPZlVpbnQzMkFycmF5KHRoaXMuZW50aXRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhvc3RuYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZSArPSBzaXplT2ZVaW50MzJBcnJheSh0aGlzLmhvc3RuYW1lcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubm90SG9zdG5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVzdGltYXRlICs9IHNpemVPZlVpbnQzMkFycmF5KHRoaXMubm90SG9zdG5hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ub3RFbnRpdGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZSArPSBzaXplT2ZVaW50MzJBcnJheSh0aGlzLm5vdEVudGl0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJ0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZSArPSBzaXplT2ZVVEY4KHRoaXMucGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlc3RpbWF0ZTtcbiAgICB9XG4gICAgbWF0Y2goaG9zdG5hbWVIYXNoZXMsIGVudGl0eUhhc2hlcykge1xuICAgICAgICAvLyBDaGVjayBpZiBgaG9zdG5hbWVgIGlzIGJsYWNrbGlzdGVkXG4gICAgICAgIGlmICh0aGlzLm5vdEhvc3RuYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhhc2ggb2YgaG9zdG5hbWVIYXNoZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmluTG9va3VwKHRoaXMubm90SG9zdG5hbWVzLCBoYXNoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIGBob3N0bmFtZWAgaXMgYmxhY2tsaXN0ZWQgYnkgKmVudGl0eSpcbiAgICAgICAgaWYgKHRoaXMubm90RW50aXRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBoYXNoIG9mIGVudGl0eUhhc2hlcykge1xuICAgICAgICAgICAgICAgIGlmIChiaW5Mb29rdXAodGhpcy5ub3RFbnRpdGllcywgaGFzaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBgaG9zdG5hbWVgIGlzIGFsbG93ZWRcbiAgICAgICAgaWYgKHRoaXMuaG9zdG5hbWVzICE9PSB1bmRlZmluZWQgfHwgdGhpcy5lbnRpdGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ob3N0bmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaGFzaCBvZiBob3N0bmFtZUhhc2hlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluTG9va3VwKHRoaXMuaG9zdG5hbWVzLCBoYXNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lbnRpdGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYXNoIG9mIGVudGl0eUhhc2hlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluTG9va3VwKHRoaXMuZW50aXRpZXMsIGhhc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb21haW5zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/domains.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/engine.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/engine/engine.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ENGINE_VERSION: () => (/* binding */ ENGINE_VERSION),\n/* harmony export */   \"default\": () => (/* binding */ FilterEngine)\n/* harmony export */ });\n/* harmony import */ var _ghostery_url_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ghostery/url-parser */ \"(rsc)/./node_modules/@ghostery/url-parser/dist/esm/index.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/config.js\");\n/* harmony import */ var _data_view_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data-view.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/data-view.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/events.js\");\n/* harmony import */ var _fetch_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../fetch.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/fetch.js\");\n/* harmony import */ var _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../filters/cosmetic.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/cosmetic.js\");\n/* harmony import */ var _filters_dsl_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../filters/dsl.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/dsl.js\");\n/* harmony import */ var _lists_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lists.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/lists.js\");\n/* harmony import */ var _request_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../request.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/request.js\");\n/* harmony import */ var _resources_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../resources.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/resources.js\");\n/* harmony import */ var _bucket_cosmetic_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./bucket/cosmetic.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/cosmetic.js\");\n/* harmony import */ var _bucket_network_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./bucket/network.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/network.js\");\n/* harmony import */ var _bucket_html_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./bucket/html.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/html.js\");\n/* harmony import */ var _metadata_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./metadata.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/metadata.js\");\n/* harmony import */ var _preprocessor_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../preprocessor.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/preprocessor.js\");\n/* harmony import */ var _bucket_preprocessor_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./bucket/preprocessor.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/bucket/preprocessor.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst ENGINE_VERSION = 812;\nfunction findApplicableHideException(filters) {\n    if (filters.length === 0) {\n        return;\n    }\n    // Get $Xhide filter with highest priority:\n    // $Xhide,important > $Xhide > @@$Xhide\n    let hideFilter;\n    let currentScore = 0;\n    for (const filter of filters) {\n        // To encode priority between filters, we create a bitmask with the following:\n        // $important,Xhide = 100 (takes precedence)\n        // $Xhide           = 010 (exception to @@$Xhide)\n        // @@$Xhide         = 001 (forbids Xhide filters)\n        const score = (filter.isImportant() ? 4 : 0) | (filter.isException() ? 1 : 2);\n        // Highest `score` has precedence\n        if (score >= currentScore) {\n            currentScore = score;\n            hideFilter = filter;\n        }\n    }\n    if (hideFilter === undefined) {\n        return;\n    }\n    // Check that there is at least one $generichide match and no exception\n    if (hideFilter.isException() === false) {\n        return;\n    }\n    return hideFilter;\n}\nclass FilterEngine extends _events_js__WEBPACK_IMPORTED_MODULE_3__.EventEmitter {\n    static fromCached(init, caching) {\n        if (caching === undefined) {\n            return init();\n        }\n        const { path, read, write } = caching;\n        return read(path)\n            .then((buffer) => this.deserialize(buffer))\n            .catch(() => init().then((engine) => write(path, engine.serialize()).then(() => engine)));\n    }\n    static empty(config = {}) {\n        return new this({ config });\n    }\n    /**\n     * Create an instance of `FiltersEngine` (or subclass like `ElectronBlocker`,\n     * etc.), from the list of subscriptions provided as argument (e.g.:\n     * EasyList).\n     *\n     * Lists are fetched using the instance of `fetch` provided as a first\n     * argument. Optionally resources.txt and config can be provided.\n     */\n    static fromLists(fetch, urls, config = {}, caching) {\n        return this.fromCached(() => {\n            const listsPromises = (0,_fetch_js__WEBPACK_IMPORTED_MODULE_4__.fetchLists)(fetch, urls);\n            const resourcesPromise = (0,_fetch_js__WEBPACK_IMPORTED_MODULE_4__.fetchResources)(fetch);\n            return Promise.all([listsPromises, resourcesPromise]).then(([lists, resources]) => {\n                const engine = this.parse(lists.join('\\n'), config);\n                if (resources !== undefined) {\n                    engine.updateResources(resources, '' + resources.length);\n                }\n                return engine;\n            });\n        }, caching);\n    }\n    /**\n     * Initialize blocker of *ads only*.\n     *\n     * Attempt to initialize a blocking engine using a pre-built version served\n     * from Ghostery's CDN. If this fails (e.g.: if no pre-built engine is available\n     * for this version of the library), then falls-back to using `fromLists(...)`\n     * method with the same subscriptions.\n     */\n    static fromPrebuiltAdsOnly(fetchImpl = fetch, caching) {\n        return this.fromLists(fetchImpl, _fetch_js__WEBPACK_IMPORTED_MODULE_4__.adsLists, {}, caching);\n    }\n    /**\n     * Same as `fromPrebuiltAdsOnly(...)` but also contains rules to block\n     * tracking (i.e.: using extra lists such as EasyPrivacy and more).\n     */\n    static fromPrebuiltAdsAndTracking(fetchImpl = fetch, caching) {\n        return this.fromLists(fetchImpl, _fetch_js__WEBPACK_IMPORTED_MODULE_4__.adsAndTrackingLists, {}, caching);\n    }\n    /**\n     * Same as `fromPrebuiltAdsAndTracking(...)` but also contains annoyances\n     * rules to block things like cookie notices.\n     */\n    static fromPrebuiltFull(fetchImpl = fetch, caching) {\n        return this.fromLists(fetchImpl, _fetch_js__WEBPACK_IMPORTED_MODULE_4__.fullLists, {}, caching);\n    }\n    static fromTrackerDB(rawJsonDump, options = {}) {\n        const config = new _config_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](options);\n        const metadata = new _metadata_js__WEBPACK_IMPORTED_MODULE_13__.Metadata(rawJsonDump);\n        const filters = [];\n        for (const pattern of metadata.getPatterns()) {\n            filters.push(...pattern.filters);\n        }\n        const engine = this.parse(filters.join('\\n'), config);\n        engine.metadata = metadata;\n        return engine;\n    }\n    /**\n     * Merges compatible engines into one.\n     *\n     * This action references objects from the source engines, including\n     * network filters, cosmetic filters, preprocessors, metadata, and lists.\n     * These objects are not deep-copied, so modifying them directly can have\n     * unintended side effects.\n     * However, resources are deep-copied from the first engine.\n     *\n     * Optionally, you can specify a second parameter to skip merging specific resources.\n     * If resource merging is skipped, the resulting engine will be assigned empty resources.\n     */\n    static merge(engines, { skipResources = false, overrideConfig = {}, } = {}) {\n        if (!engines || engines.length < 2) {\n            throw new Error('merging engines requires at least two engines');\n        }\n        for (const engine of engines) {\n            if (engine.config.enableCompression !== engines[0].config.enableCompression) {\n                throw new Error(`compression of all merged engines must match with the first one: \"${engines[0].config.enableCompression}\" but got: \"${engine.config.enableCompression}\"`);\n            }\n        }\n        const lists = new Map();\n        const networkFilters = new Map();\n        const cosmeticFilters = new Map();\n        const preprocessors = [];\n        const metadata = {\n            organizations: {},\n            categories: {},\n            patterns: {},\n        };\n        for (const engine of engines) {\n            const filters = engine.getFilters();\n            for (const networkFilter of filters.networkFilters) {\n                networkFilters.set(networkFilter.getId(), networkFilter);\n            }\n            for (const cosmeticFilter of filters.cosmeticFilters) {\n                cosmeticFilters.set(cosmeticFilter.getId(), cosmeticFilter);\n            }\n            for (const preprocessor of engine.preprocessors.preprocessors) {\n                preprocessors.push(preprocessor);\n            }\n            for (const [key, value] of engine.lists) {\n                if (lists.has(key)) {\n                    continue;\n                }\n                lists.set(key, value);\n            }\n            if (engine.metadata !== undefined) {\n                for (const organization of engine.metadata.organizations.getValues()) {\n                    if (metadata.organizations[organization.key] === undefined) {\n                        metadata.organizations[organization.key] = organization;\n                    }\n                }\n                for (const category of engine.metadata.categories.getValues()) {\n                    if (metadata.categories[category.key] === undefined) {\n                        metadata.categories[category.key] = category;\n                    }\n                }\n                for (const pattern of engine.metadata.patterns.getValues()) {\n                    if (metadata.patterns[pattern.key] === undefined) {\n                        metadata.patterns[pattern.key] = pattern;\n                    }\n                }\n            }\n        }\n        const engine = new this({\n            networkFilters: Array.from(networkFilters.values()),\n            cosmeticFilters: Array.from(cosmeticFilters.values()),\n            preprocessors,\n            lists,\n            config: new _config_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({ ...engines[0].config, ...overrideConfig }),\n        });\n        if (Object.keys(metadata.categories).length +\n            Object.keys(metadata.organizations).length +\n            Object.keys(metadata.patterns).length !==\n            0) {\n            engine.metadata = new _metadata_js__WEBPACK_IMPORTED_MODULE_13__.Metadata(metadata);\n        }\n        if (skipResources !== true) {\n            for (const engine of engines.slice(1)) {\n                if (engine.resources.checksum !== engines[0].resources.checksum) {\n                    throw new Error(`resource checksum of all merged engines must match with the first one: \"${engines[0].resources.checksum}\" but got: \"${engine.resources.checksum}\"`);\n                }\n            }\n            engine.resources = _resources_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].copy(engines[0].resources);\n        }\n        return engine;\n    }\n    static parse(filters, options = {}) {\n        const config = new _config_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](options);\n        return new this({\n            ...(0,_lists_js__WEBPACK_IMPORTED_MODULE_7__.parseFilters)(filters, config),\n            config,\n        });\n    }\n    static deserialize(serialized) {\n        const buffer = _data_view_js__WEBPACK_IMPORTED_MODULE_2__.StaticDataView.fromUint8Array(serialized, {\n            enableCompression: false,\n        });\n        // Before starting deserialization, we make sure that the version of the\n        // serialized engine is the same as the current source code. If not, we\n        // start fresh and create a new engine from the lists.\n        const serializedEngineVersion = buffer.getUint16();\n        if (ENGINE_VERSION !== serializedEngineVersion) {\n            throw new Error(`serialized engine version mismatch, expected ${ENGINE_VERSION} but got ${serializedEngineVersion}`);\n        }\n        // Create a new engine with same options\n        const config = _config_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deserialize(buffer);\n        // Optionally turn compression ON\n        if (config.enableCompression) {\n            buffer.enableCompression();\n        }\n        // Also make sure that the built-in checksum is correct. This allows to\n        // detect data corruption and start fresh if the serialized version was\n        // altered.\n        if (config.integrityCheck) {\n            const currentPos = buffer.pos;\n            buffer.pos = serialized.length - 4;\n            const checksum = buffer.checksum();\n            const expected = buffer.getUint32();\n            if (checksum !== expected) {\n                throw new Error(`serialized engine checksum mismatch, expected ${expected} but got ${checksum}`);\n            }\n            buffer.pos = currentPos;\n        }\n        const engine = new this({ config });\n        // Deserialize resources\n        engine.resources = _resources_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].deserialize(buffer);\n        // Deserialize lists\n        const lists = new Map();\n        const numberOfLists = buffer.getUint16();\n        for (let i = 0; i < numberOfLists; i += 1) {\n            lists.set(buffer.getASCII(), buffer.getASCII());\n        }\n        engine.lists = lists;\n        // Deserialize preprocessors\n        engine.preprocessors = _bucket_preprocessor_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"].deserialize(buffer);\n        // Deserialize buckets\n        engine.importants = _bucket_network_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"].deserialize(buffer, config);\n        engine.redirects = _bucket_network_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"].deserialize(buffer, config);\n        engine.removeparams = _bucket_network_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"].deserialize(buffer, config);\n        engine.filters = _bucket_network_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"].deserialize(buffer, config);\n        engine.exceptions = _bucket_network_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"].deserialize(buffer, config);\n        engine.csp = _bucket_network_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"].deserialize(buffer, config);\n        engine.cosmetics = _bucket_cosmetic_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].deserialize(buffer, config);\n        engine.hideExceptions = _bucket_network_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"].deserialize(buffer, config);\n        engine.htmlFilters = _bucket_html_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"].deserialize(buffer, config);\n        // Optionally deserialize metadata\n        const hasMetadata = buffer.getBool();\n        if (hasMetadata) {\n            engine.metadata = _metadata_js__WEBPACK_IMPORTED_MODULE_13__.Metadata.deserialize(buffer);\n        }\n        buffer.seekZero();\n        return engine;\n    }\n    constructor({ \n    // Optionally initialize the engine with filters\n    cosmeticFilters = [], networkFilters = [], preprocessors = [], config = new _config_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](), lists = new Map(), } = {}) {\n        super(); // init super-class EventEmitter\n        this.config = new _config_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](config);\n        // Subscription management: disabled by default\n        this.lists = lists;\n        // Preprocessors\n        this.preprocessors = new _bucket_preprocessor_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"]({});\n        // $csp=\n        this.csp = new _bucket_network_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]({ config: this.config });\n        // $elemhide\n        // $generichide\n        // $specifichide\n        this.hideExceptions = new _bucket_network_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]({ config: this.config });\n        // @@filter\n        this.exceptions = new _bucket_network_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]({ config: this.config });\n        // $important\n        this.importants = new _bucket_network_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]({ config: this.config });\n        // $redirect\n        this.redirects = new _bucket_network_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]({ config: this.config });\n        // $removeparam\n        this.removeparams = new _bucket_network_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]({ config: this.config });\n        // All other filters\n        this.filters = new _bucket_network_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]({ config: this.config });\n        // Cosmetic filters\n        this.cosmetics = new _bucket_cosmetic_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]({ config: this.config });\n        // HTML filters\n        this.htmlFilters = new _bucket_html_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"]({ config: this.config });\n        // Injections\n        this.resources = new _resources_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]();\n        if (networkFilters.length !== 0 || cosmeticFilters.length !== 0) {\n            this.update({\n                newCosmeticFilters: cosmeticFilters,\n                newNetworkFilters: networkFilters,\n                newPreprocessors: preprocessors,\n            });\n        }\n    }\n    isFilterExcluded(filter) {\n        return this.preprocessors.isFilterExcluded(filter);\n    }\n    updateEnv(env) {\n        this.preprocessors.updateEnv(env);\n    }\n    /**\n     * Estimate the number of bytes needed to serialize this instance of\n     * `FiltersEngine` using the `serialize(...)` method. It is used internally\n     * by `serialize(...)` to allocate a buffer of the right size and you should\n     * not have to call it yourself most of the time.\n     *\n     * There are cases where we cannot estimate statically the exact size of the\n     * resulting buffer (due to alignement which needs to be performed); this\n     * method will return a safe estimate which will always be at least equal to\n     * the real number of bytes needed, or bigger (usually of a few bytes only:\n     * ~20 bytes is to be expected).\n     */\n    getSerializedSize() {\n        let estimatedSize = (0,_data_view_js__WEBPACK_IMPORTED_MODULE_2__.sizeOfByte)() + // engine version\n            this.config.getSerializedSize() +\n            this.resources.getSerializedSize() +\n            this.preprocessors.getSerializedSize() +\n            this.filters.getSerializedSize() +\n            this.exceptions.getSerializedSize() +\n            this.importants.getSerializedSize() +\n            this.redirects.getSerializedSize() +\n            this.removeparams.getSerializedSize() +\n            this.csp.getSerializedSize() +\n            this.cosmetics.getSerializedSize() +\n            this.hideExceptions.getSerializedSize() +\n            this.htmlFilters.getSerializedSize() +\n            4; // checksum\n        // Estimate size of `this.lists` which stores information of checksum for each list.\n        for (const [name, checksum] of this.lists) {\n            estimatedSize += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_2__.sizeOfASCII)(name) + (0,_data_view_js__WEBPACK_IMPORTED_MODULE_2__.sizeOfASCII)(checksum);\n        }\n        estimatedSize += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_2__.sizeOfBool)();\n        if (this.metadata !== undefined) {\n            estimatedSize += this.metadata.getSerializedSize();\n        }\n        return estimatedSize;\n    }\n    /**\n     * Creates a binary representation of the full engine. It can be stored\n     * on-disk for faster loading of the adblocker. The `deserialize` static\n     * method of Engine can be used to restore the engine.\n     */\n    serialize(array) {\n        const buffer = _data_view_js__WEBPACK_IMPORTED_MODULE_2__.StaticDataView.fromUint8Array(array || new Uint8Array(this.getSerializedSize()), this.config);\n        buffer.pushUint16(ENGINE_VERSION);\n        // Config\n        this.config.serialize(buffer);\n        // Resources (js, resources)\n        this.resources.serialize(buffer);\n        // Serialize the state of lists (names and checksums)\n        buffer.pushUint16(this.lists.size);\n        for (const [name, value] of Array.from(this.lists.entries()).sort()) {\n            buffer.pushASCII(name);\n            buffer.pushASCII(value);\n        }\n        // Preprocessors\n        this.preprocessors.serialize(buffer);\n        // Filters buckets\n        this.importants.serialize(buffer);\n        this.redirects.serialize(buffer);\n        this.removeparams.serialize(buffer);\n        this.filters.serialize(buffer);\n        this.exceptions.serialize(buffer);\n        this.csp.serialize(buffer);\n        this.cosmetics.serialize(buffer);\n        this.hideExceptions.serialize(buffer);\n        this.htmlFilters.serialize(buffer);\n        // Optionally serialize metadata\n        buffer.pushBool(this.metadata !== undefined);\n        if (this.metadata !== undefined) {\n            this.metadata.serialize(buffer);\n        }\n        // Optionally append a checksum at the end\n        if (this.config.integrityCheck) {\n            buffer.pushUint32(buffer.checksum());\n        }\n        return buffer.subarray();\n    }\n    /**\n     * Update engine with new filters or resources.\n     */\n    loadedLists() {\n        return Array.from(this.lists.keys());\n    }\n    hasList(name, checksum) {\n        return this.lists.has(name) && this.lists.get(name) === checksum;\n    }\n    /**\n     * Update engine with `resources.txt` content.\n     */\n    updateResources(data, checksum) {\n        if (this.resources.checksum === checksum) {\n            return false;\n        }\n        this.resources = _resources_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].parse(data, { checksum });\n        return true;\n    }\n    getFilters() {\n        const cosmeticFilters = this.cosmetics.getFilters();\n        const networkFilters = [\n            ...this.filters.getFilters(),\n            ...this.exceptions.getFilters(),\n            ...this.importants.getFilters(),\n            ...this.redirects.getFilters(),\n            ...this.csp.getFilters(),\n            ...this.hideExceptions.getFilters(),\n        ];\n        for (const filter of this.htmlFilters.getFilters()) {\n            if (filter.isNetworkFilter()) {\n                networkFilters.push(filter);\n            }\n            else if (filter.isCosmeticFilter()) {\n                cosmeticFilters.push(filter);\n            }\n        }\n        return {\n            cosmeticFilters,\n            networkFilters,\n        };\n    }\n    /**\n     * Update engine with new filters as well as optionally removed filters.\n     */\n    update({ newNetworkFilters = [], newCosmeticFilters = [], newPreprocessors = [], removedCosmeticFilters = [], removedNetworkFilters = [], removedPreprocessors = [], }, env = new _preprocessor_js__WEBPACK_IMPORTED_MODULE_14__.Env()) {\n        let updated = false;\n        // Update preprocessors\n        if (this.config.loadPreprocessors &&\n            (newPreprocessors.length !== 0 || removedPreprocessors.length !== 0)) {\n            updated = true;\n            this.preprocessors.update({\n                added: newPreprocessors,\n                removed: removedPreprocessors,\n            }, env);\n        }\n        const htmlFilters = [];\n        // Update cosmetic filters\n        if (this.config.loadCosmeticFilters &&\n            (newCosmeticFilters.length !== 0 || removedCosmeticFilters.length !== 0)) {\n            updated = true;\n            const cosmeticFitlers = [];\n            for (const filter of newCosmeticFilters) {\n                if (filter.isHtmlFiltering()) {\n                    htmlFilters.push(filter);\n                }\n                else {\n                    cosmeticFitlers.push(filter);\n                }\n            }\n            this.cosmetics.update(cosmeticFitlers, removedCosmeticFilters.length === 0 ? undefined : new Set(removedCosmeticFilters), this.config);\n        }\n        // Update network filters\n        if (this.config.loadNetworkFilters &&\n            (newNetworkFilters.length !== 0 || removedNetworkFilters.length !== 0)) {\n            updated = true;\n            const filters = [];\n            const csp = [];\n            const exceptions = [];\n            const importants = [];\n            const redirects = [];\n            const removeparams = [];\n            const hideExceptions = [];\n            for (const filter of newNetworkFilters) {\n                // NOTE: it's important to check for $generichide, $elemhide,\n                // $specifichide and $csp before exceptions and important as we store\n                // all of them in the same filter bucket. The check for exceptions is\n                // done at match-time directly.\n                if (filter.isCSP()) {\n                    csp.push(filter);\n                }\n                else if (filter.isHtmlFilteringRule()) {\n                    htmlFilters.push(filter);\n                }\n                else if (filter.isGenericHide() || filter.isSpecificHide()) {\n                    hideExceptions.push(filter);\n                }\n                else if (filter.isException()) {\n                    if (filter.isRemoveParam()) {\n                        removeparams.push(filter);\n                    }\n                    else {\n                        exceptions.push(filter);\n                    }\n                }\n                else if (filter.isImportant()) {\n                    importants.push(filter);\n                }\n                else if (filter.isRedirect()) {\n                    redirects.push(filter);\n                }\n                else if (filter.isRemoveParam()) {\n                    removeparams.push(filter);\n                }\n                else {\n                    filters.push(filter);\n                }\n            }\n            const removedNetworkFiltersSet = removedNetworkFilters.length === 0 ? undefined : new Set(removedNetworkFilters);\n            // Update buckets in-place\n            this.importants.update(importants, removedNetworkFiltersSet);\n            this.redirects.update(redirects, removedNetworkFiltersSet);\n            this.removeparams.update(removeparams, removedNetworkFiltersSet);\n            this.filters.update(filters, removedNetworkFiltersSet);\n            if (this.config.loadExceptionFilters === true) {\n                this.exceptions.update(exceptions, removedNetworkFiltersSet);\n            }\n            if (this.config.loadCSPFilters === true) {\n                this.csp.update(csp, removedNetworkFiltersSet);\n            }\n            this.hideExceptions.update(hideExceptions, removedNetworkFiltersSet);\n        }\n        if (this.config.enableHtmlFiltering &&\n            (htmlFilters.length !== 0 ||\n                removedNetworkFilters.length !== 0 ||\n                removedCosmeticFilters.length !== 0)) {\n            const removeFilters = new Set([...removedNetworkFilters, ...removedCosmeticFilters]);\n            this.htmlFilters.update(htmlFilters, removeFilters);\n        }\n        return updated;\n    }\n    updateFromDiff({ added, removed, preprocessors }, env) {\n        const newCosmeticFilters = [];\n        const newNetworkFilters = [];\n        const newPreprocessors = [];\n        const removedCosmeticFilters = [];\n        const removedNetworkFilters = [];\n        const removedPreprocessors = [];\n        if (removed !== undefined && removed.length !== 0) {\n            const { networkFilters, cosmeticFilters } = (0,_lists_js__WEBPACK_IMPORTED_MODULE_7__.parseFilters)(removed.join('\\n'), this.config);\n            Array.prototype.push.apply(removedCosmeticFilters, cosmeticFilters);\n            Array.prototype.push.apply(removedNetworkFilters, networkFilters);\n        }\n        if (added !== undefined && added.length !== 0) {\n            const { networkFilters, cosmeticFilters } = (0,_lists_js__WEBPACK_IMPORTED_MODULE_7__.parseFilters)(added.join('\\n'), this.config);\n            Array.prototype.push.apply(newCosmeticFilters, cosmeticFilters);\n            Array.prototype.push.apply(newNetworkFilters, networkFilters);\n        }\n        if (preprocessors !== undefined) {\n            for (const [condition, details] of Object.entries(preprocessors)) {\n                if (details.removed !== undefined && details.removed.length !== 0) {\n                    const { networkFilters, cosmeticFilters } = (0,_lists_js__WEBPACK_IMPORTED_MODULE_7__.parseFilters)(details.removed.join('\\n'), this.config);\n                    const filterIDs = new Set([]\n                        .concat(cosmeticFilters.map((filter) => filter.getId()))\n                        .concat(networkFilters.map((filter) => filter.getId())));\n                    removedPreprocessors.push(new _preprocessor_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"]({\n                        condition,\n                        filterIDs,\n                    }));\n                }\n                if (details.added !== undefined && details.added.length !== 0) {\n                    const { networkFilters, cosmeticFilters } = (0,_lists_js__WEBPACK_IMPORTED_MODULE_7__.parseFilters)(details.added.join('\\n'), this.config);\n                    const filterIDs = new Set([]\n                        .concat(cosmeticFilters.map((filter) => filter.getId()))\n                        .concat(networkFilters.map((filter) => filter.getId())));\n                    newPreprocessors.push(new _preprocessor_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"]({\n                        condition,\n                        filterIDs,\n                    }));\n                }\n            }\n        }\n        return this.update({\n            newCosmeticFilters,\n            newNetworkFilters,\n            newPreprocessors,\n            removedCosmeticFilters: removedCosmeticFilters.map((f) => f.getId()),\n            removedNetworkFilters: removedNetworkFilters.map((f) => f.getId()),\n            removedPreprocessors,\n        }, env);\n    }\n    /**\n     * Return a list of HTML filtering rules.\n     */\n    getHtmlFilters(request) {\n        const htmlSelectors = [];\n        if (this.config.enableHtmlFiltering === false) {\n            return htmlSelectors;\n        }\n        const { networkFilters, exceptions, cosmeticFilters, unhides } = this.htmlFilters.getHTMLFilters(request, this.isFilterExcluded.bind(this));\n        if (cosmeticFilters.length !== 0) {\n            const unhideMap = new Map(unhides.map((unhide) => [unhide.getSelector(), unhide]));\n            for (const filter of cosmeticFilters) {\n                const extended = filter.getExtendedSelector();\n                if (extended === undefined) {\n                    continue;\n                }\n                const unhide = unhideMap.get(filter.getSelector());\n                if (unhide === undefined) {\n                    htmlSelectors.push(extended);\n                }\n                this.emit('filter-matched', { filter, exception: unhide }, {\n                    request,\n                    filterType: _lists_js__WEBPACK_IMPORTED_MODULE_7__.FilterType.COSMETIC,\n                });\n            }\n        }\n        if (networkFilters.length !== 0) {\n            const exceptionsMap = new Map();\n            let replaceDisabledException;\n            for (const exception of exceptions) {\n                const optionValue = exception.optionValue;\n                if (optionValue === '') {\n                    replaceDisabledException = exception;\n                    break;\n                }\n                exceptionsMap.set(optionValue, exception);\n            }\n            for (const filter of networkFilters) {\n                const modifier = filter.getHtmlModifier();\n                if (modifier === null) {\n                    continue;\n                }\n                const exception = replaceDisabledException || exceptionsMap.get(filter.optionValue);\n                this.emit('filter-matched', { filter, exception }, {\n                    request,\n                    filterType: _lists_js__WEBPACK_IMPORTED_MODULE_7__.FilterType.NETWORK,\n                });\n                if (exception === undefined) {\n                    htmlSelectors.push(['replace', modifier]);\n                }\n            }\n        }\n        if (htmlSelectors.length !== 0) {\n            this.emit('html-filtered', htmlSelectors, request.url);\n        }\n        return htmlSelectors;\n    }\n    /**\n     * Given `hostname` and `domain` of a page (or frame), return the list of\n     * styles and scripts to inject in the page.\n     */\n    getCosmeticsFilters({ \n    // Page information\n    url, hostname, domain, ancestors, \n    // DOM information\n    classes, hrefs, ids, \n    // Allows to specify which rules to return\n    getBaseRules = true, getInjectionRules = true, getExtendedRules = true, getRulesFromDOM = true, getRulesFromHostname = true, hidingStyle, callerContext, }) {\n        if (this.config.loadCosmeticFilters === false) {\n            return {\n                active: false,\n                extended: [],\n                scripts: [],\n                styles: '',\n            };\n        }\n        const { matches, allowGenericHides } = this.matchCosmeticFilters({\n            url,\n            hostname,\n            domain,\n            ancestors,\n            classes,\n            hrefs,\n            ids,\n            getRulesFromDOM,\n            getRulesFromHostname,\n            getInjectionRules,\n            getExtendedRules,\n            callerContext,\n        });\n        const filters = [];\n        for (const { filter, exception } of matches) {\n            if (filter !== undefined && exception === undefined) {\n                filters.push(filter);\n            }\n        }\n        const { extended, scripts, styles } = this.injectCosmeticFilters(filters, {\n            url,\n            injectScriptlets: getInjectionRules,\n            injectExtended: getExtendedRules,\n            allowGenericHides,\n            getBaseRules,\n            hidingStyle,\n        });\n        return {\n            active: true,\n            extended,\n            scripts,\n            styles,\n        };\n    }\n    /**\n     * Prepares cosmetic filters to be injected by compiling them to stylesheets, scripts and extented selector ASTs.\n     */\n    injectCosmeticFilters(filters, { url, injectStyles = true, injectScriptlets, injectExtended, allowGenericHides = true, getBaseRules, hidingStyle, }) {\n        const scripts = [];\n        const styleFilters = [];\n        const extendedFilters = [];\n        for (const filter of filters) {\n            if (injectScriptlets && filter.isScriptInject()) {\n                const script = filter.getScript(this.resources.getScriptlet.bind(this.resources));\n                if (script !== undefined) {\n                    scripts.push(script);\n                }\n            }\n            else if (filter.isExtended()) {\n                if (injectExtended === true && this.config.loadExtendedSelectors) {\n                    extendedFilters.push(filter);\n                }\n            }\n            else if (injectStyles === true) {\n                styleFilters.push(filter);\n            }\n        }\n        const stylesheets = this.cosmetics.getStylesheetsFromFilters({\n            filters: styleFilters,\n            extendedFilters,\n        }, { getBaseRules, allowGenericHides, hidingStyle });\n        for (const script of scripts) {\n            this.emit('script-injected', script, url);\n        }\n        if (stylesheets.stylesheet.length !== 0) {\n            this.emit('style-injected', stylesheets.stylesheet, url);\n        }\n        return {\n            extended: stylesheets.extended,\n            scripts,\n            styles: stylesheets.stylesheet,\n        };\n    }\n    matchCosmeticFilters({ \n    // Page information\n    url, hostname, domain, ancestors, \n    // DOM information\n    classes, hrefs, ids, getRulesFromDOM = true, getRulesFromHostname = true, getInjectionRules, getExtendedRules, callerContext, }) {\n        domain || (domain = '');\n        const matches = [];\n        const exceptions = this.hideExceptions.matchAll(_request_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].fromRawDetails({\n            domain,\n            hostname,\n            url,\n            sourceDomain: '',\n            sourceHostname: '',\n            sourceUrl: '',\n        }), this.isFilterExcluded.bind(this));\n        const genericHides = [];\n        const specificHides = [];\n        for (const filter of exceptions) {\n            // A filter can be both specific ($shide) and generic ($ghide).\n            // In that case, it is an $elemhide, and we have to consider both cases here to calculate the priority later on.\n            if (filter.isSpecificHide()) {\n                specificHides.push(filter);\n            }\n            if (filter.isGenericHide()) {\n                genericHides.push(filter);\n            }\n        }\n        const genericHideException = findApplicableHideException(genericHides);\n        const specificHideException = findApplicableHideException(specificHides);\n        if (genericHideException !== undefined) {\n            const match = {\n                filter: undefined,\n                exception: genericHideException,\n            };\n            matches.push(match);\n            this.emit('filter-matched', match, {\n                url,\n                callerContext,\n                filterType: _lists_js__WEBPACK_IMPORTED_MODULE_7__.FilterType.COSMETIC,\n            });\n        }\n        if (specificHideException !== undefined &&\n            // The filter can be $elemhide which get set both for ghide and shide\n            genericHideException !== specificHideException) {\n            const match = {\n                filter: undefined,\n                exception: specificHideException,\n            };\n            matches.push(match);\n            this.emit('filter-matched', match, {\n                url,\n                callerContext,\n                filterType: _lists_js__WEBPACK_IMPORTED_MODULE_7__.FilterType.COSMETIC,\n            });\n        }\n        const { filters, unhides } = this.cosmetics.getCosmeticsFilters({\n            domain,\n            hostname,\n            ancestors,\n            classes,\n            hrefs,\n            ids,\n            allowGenericHides: genericHideException === undefined,\n            allowSpecificHides: specificHideException === undefined,\n            getRulesFromDOM,\n            getRulesFromHostname,\n            isFilterExcluded: this.isFilterExcluded.bind(this),\n        });\n        let injectionsDisabledFilter = undefined;\n        const unhideExceptions = new Map();\n        for (const unhide of unhides) {\n            if (unhide.isScriptInject() === true &&\n                unhide.isUnhide() === true &&\n                unhide.getSelector().length === 0) {\n                injectionsDisabledFilter = unhide;\n            }\n            else {\n                unhideExceptions.set((0,_filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_5__.normalizeSelector)(unhide, this.resources.getScriptletCanonicalName.bind(this.resources)), unhide);\n            }\n        }\n        for (const filter of filters) {\n            if (filter.isExtended() && getExtendedRules === false) {\n                continue;\n            }\n            let exception = unhideExceptions.get((0,_filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_5__.normalizeSelector)(filter, this.resources.getScriptletCanonicalName.bind(this.resources)));\n            if (filter.isScriptInject()) {\n                if (injectionsDisabledFilter !== undefined) {\n                    exception = injectionsDisabledFilter;\n                }\n                if (getInjectionRules === false) {\n                    continue;\n                }\n            }\n            matches.push({ filter, exception });\n            this.emit('filter-matched', {\n                filter,\n                exception,\n            }, {\n                url,\n                callerContext,\n                filterType: _lists_js__WEBPACK_IMPORTED_MODULE_7__.FilterType.COSMETIC,\n            });\n        }\n        return {\n            matches,\n            allowGenericHides: genericHideException === undefined,\n        };\n    }\n    /**\n     * Given a `request`, return all matching network filters found in the engine.\n     */\n    matchAll(request) {\n        const filters = [];\n        if (request.isSupported) {\n            Array.prototype.push.apply(filters, this.importants.matchAll(request, this.isFilterExcluded.bind(this)));\n            Array.prototype.push.apply(filters, this.filters.matchAll(request, this.isFilterExcluded.bind(this)));\n            Array.prototype.push.apply(filters, this.exceptions.matchAll(request, this.isFilterExcluded.bind(this)));\n            Array.prototype.push.apply(filters, this.csp.matchAll(request, this.isFilterExcluded.bind(this)));\n            Array.prototype.push.apply(filters, this.hideExceptions.matchAll(request, this.isFilterExcluded.bind(this)));\n            Array.prototype.push.apply(filters, this.redirects.matchAll(request, this.isFilterExcluded.bind(this)));\n        }\n        return new Set(filters);\n    }\n    /**\n     * Given a \"main_frame\" request, check if some content security policies\n     * should be injected in the page.\n     */\n    getCSPDirectives(request) {\n        if (!this.config.loadNetworkFilters) {\n            return undefined;\n        }\n        if (request.isSupported !== true || request.isMainFrame() === false) {\n            return undefined;\n        }\n        const matches = this.csp.matchAll(request, this.isFilterExcluded.bind(this));\n        // No $csp filter found\n        if (matches.length === 0) {\n            return undefined;\n        }\n        // Collect all CSP directives and keep track of exceptions\n        const cspExceptions = new Map();\n        const cspFilters = [];\n        for (const filter of matches) {\n            if (filter.isException()) {\n                if (filter.csp === undefined) {\n                    // All CSP directives are disabled for this site\n                    this.emit('filter-matched', { exception: filter }, { request, filterType: _lists_js__WEBPACK_IMPORTED_MODULE_7__.FilterType.NETWORK });\n                    return undefined;\n                }\n                cspExceptions.set(filter.csp, filter);\n            }\n            else {\n                cspFilters.push(filter);\n            }\n        }\n        if (cspFilters.length === 0) {\n            return undefined;\n        }\n        const enabledCsp = new Set();\n        // Combine all CSPs (except the black-listed ones)\n        for (const filter of cspFilters.values()) {\n            const exception = cspExceptions.get(filter.csp);\n            if (exception === undefined) {\n                enabledCsp.add(filter.csp);\n            }\n            this.emit('filter-matched', { filter, exception }, { request, filterType: _lists_js__WEBPACK_IMPORTED_MODULE_7__.FilterType.NETWORK });\n        }\n        const csps = Array.from(enabledCsp).join('; ');\n        if (csps.length > 0) {\n            this.emit('csp-injected', request, csps);\n        }\n        return csps;\n    }\n    /**\n     * Decide if a network request (usually from WebRequest API) should be\n     * blocked, redirected or allowed.\n     */\n    match(request, withMetadata = false) {\n        var _a;\n        const result = {\n            exception: undefined,\n            filter: undefined,\n            match: false,\n            redirect: undefined,\n            rewrite: undefined,\n            metadata: undefined,\n        };\n        if (!this.config.loadNetworkFilters) {\n            return result;\n        }\n        if (request.isSupported) {\n            // Check the filters in the following order:\n            // 1. $important (not subject to exceptions)\n            // 2. redirection ($redirect=resource)\n            // 3. normal filters\n            // 4. exceptions\n            // 5. url rewrites ($removeparam)\n            result.filter = this.importants.match(request, this.isFilterExcluded.bind(this));\n            let redirectNone;\n            let redirectRule;\n            // If `result.filter` is `undefined`, it means there was no $important\n            // filter found so far. We look for a $redirect filter.  There is some\n            // extra logic to handle special cases like redirect-rule and\n            // redirect=none.\n            //\n            // * If redirect=none is found, then cancel all redirects.\n            // * Else if redirect-rule is found, only redirect if request would be blocked.\n            // * Else if redirect is found, redirect.\n            if (result.filter === undefined) {\n                const redirects = this.redirects\n                    .matchAll(request, this.isFilterExcluded.bind(this))\n                    // highest priorty wins\n                    .sort((a, b) => b.getRedirectPriority() - a.getRedirectPriority());\n                // There is some extra logic to handle special cases like\n                // redirect-rule and redirect=none.\n                //\n                // * If redirect=none is found, then cancel all redirects.\n                // * Else if redirect-rule is found, only redirect if request would be blocked.\n                // * Else if redirect is found, redirect.\n                if (redirects.length !== 0) {\n                    for (const filter of redirects) {\n                        if (filter.getRedirectResource() === 'none') {\n                            redirectNone = filter;\n                        }\n                        else if (filter.isRedirectRule()) {\n                            if (redirectRule === undefined) {\n                                redirectRule = filter;\n                            }\n                        }\n                        else if (result.filter === undefined) {\n                            result.filter = filter;\n                        }\n                    }\n                }\n                // If `result.filter` is still `undefined`, it means that there was no\n                // redirection rule triggered for the request. We look for a normal\n                // match.\n                if (result.filter === undefined) {\n                    result.filter = this.filters.match(request, this.isFilterExcluded.bind(this));\n                    // If we found a match, and a `$redirect-rule` as found previously,\n                    // then we transform the match into a redirect, following the\n                    // semantics of redirect-rule.\n                    if (redirectRule !== undefined && result.filter !== undefined) {\n                        result.filter = redirectRule;\n                    }\n                }\n                // If we found either a redirection rule or a normal match, then check\n                // for exceptions which could apply on the request and un-block it.\n                if (result.filter !== undefined) {\n                    result.exception = this.exceptions.match(request, this.isFilterExcluded.bind(this));\n                }\n                // If the request is allowed in any way, we match request removeparam.\n                if (result.filter === undefined) {\n                    const searchParamSeparatorIndex = request.url.indexOf('?');\n                    if (searchParamSeparatorIndex !== -1 &&\n                        searchParamSeparatorIndex !== request.url.length - 1) {\n                        const searchParamLiteral = request.url.slice(searchParamSeparatorIndex);\n                        const searchParams = new _ghostery_url_parser__WEBPACK_IMPORTED_MODULE_0__.URLSearchParams(searchParamLiteral);\n                        let modified = false;\n                        // Handle $removeparam filters:\n                        // 1st priority: @@||<entity>$removeparam\n                        // 2nd priority: ||<entity>$removeparam\n                        // 3rd priority: @@||<entity>$removeparam=x\n                        // 4th priority: ||<entity>$removeparam=x\n                        const removeparamFilters = new Map();\n                        const removeparamExceptions = new Map();\n                        for (const filter of this.removeparams.matchAll(request, this.isFilterExcluded.bind(this))) {\n                            if (filter.isException()) {\n                                removeparamExceptions.set(filter.removeparam, filter);\n                            }\n                            else {\n                                removeparamFilters.set(filter.removeparam, filter);\n                            }\n                        }\n                        const removeparamIgnoreFilter = \n                        // `result.exception` is conditionally matched only if `result.filter` is available.\n                        (result.filter === undefined\n                            ? this.exceptions.match(request, this.isFilterExcluded.bind(this))\n                            : result.exception) || removeparamExceptions.get('');\n                        for (const [key, filter] of removeparamFilters) {\n                            // Remove all params in case of option value is empty.\n                            // We will not match individual exceptions since it has a higher priority than them.\n                            if (key === '') {\n                                // In case of non-existence of global exception, we will remove all params.\n                                if (removeparamIgnoreFilter === undefined) {\n                                    // We need to collect all keys before the execution of `delete()`.\n                                    // Running `delete()` will inference with an iterator and its inner index.\n                                    for (const key of Array.from(searchParams.keys())) {\n                                        searchParams.delete(key);\n                                    }\n                                    modified = true;\n                                }\n                                this.emit('filter-matched', { filter, exception: removeparamIgnoreFilter }, { request, filterType: _lists_js__WEBPACK_IMPORTED_MODULE_7__.FilterType.NETWORK });\n                                break;\n                            }\n                            if (!key.startsWith('~') &&\n                                // Try to find `?${key}` pattern.\n                                searchParamLiteral.slice(1, key.length + 1) !== key &&\n                                !searchParamLiteral.includes(`&${key}`)) {\n                                continue;\n                            }\n                            const exception = (_a = removeparamExceptions.get(key)) !== null && _a !== void 0 ? _a : removeparamIgnoreFilter;\n                            if (exception === undefined) {\n                                // Handle removeparam inversions.\n                                if (key.startsWith('~')) {\n                                    const inversionKey = key.slice(1);\n                                    for (const param of Array.from(searchParams.keys())) {\n                                        if (param !== inversionKey && !removeparamExceptions.has(param)) {\n                                            searchParams.delete(param);\n                                            modified = true;\n                                        }\n                                    }\n                                }\n                                else {\n                                    searchParams.delete(key);\n                                    modified = true;\n                                }\n                            }\n                            this.emit('filter-matched', { filter, exception }, { request, filterType: _lists_js__WEBPACK_IMPORTED_MODULE_7__.FilterType.NETWORK });\n                        }\n                        if (modified) {\n                            let url = request.url.slice(0, searchParamSeparatorIndex);\n                            if (searchParams.size > 0) {\n                                url += '?' + searchParams.toString();\n                            }\n                            result.rewrite = {\n                                url,\n                            };\n                        }\n                    }\n                }\n            }\n            // If there was a redirect match and no exception was found, then we\n            // proceed and process the redirect rule. This means two things:\n            //\n            // 1. Check if there's a removeparam exception was found, which acts as exception.\n            // 2. Check if a redirect=none rule was found, which acts as exception.\n            // 3. If no exception was found, prepare `result.redirect` response.\n            if (result.filter !== undefined &&\n                result.exception === undefined &&\n                result.filter.isRedirect()) {\n                if (redirectNone !== undefined) {\n                    result.exception = redirectNone;\n                }\n                else {\n                    result.redirect = this.resources.getResource(result.filter.getRedirectResource());\n                }\n            }\n        }\n        result.match = result.exception === undefined && result.filter !== undefined;\n        if (result.filter) {\n            this.emit('filter-matched', { filter: result.filter, exception: result.exception }, { request, filterType: _lists_js__WEBPACK_IMPORTED_MODULE_7__.FilterType.NETWORK });\n        }\n        if (result.exception !== undefined) {\n            this.emit('request-whitelisted', request, result);\n        }\n        else if (result.redirect !== undefined) {\n            this.emit('request-redirected', request, result);\n        }\n        else if (result.filter !== undefined) {\n            this.emit('request-blocked', request, result);\n        }\n        else {\n            this.emit('request-allowed', request, result);\n        }\n        if (withMetadata === true && result.filter !== undefined && this.metadata) {\n            result.metadata = this.metadata.fromFilter(result.filter);\n        }\n        return result;\n    }\n    getPatternMetadata(request, { getDomainMetadata = false } = {}) {\n        if (this.metadata === undefined) {\n            return [];\n        }\n        const seenPatterns = new Set();\n        const patterns = [];\n        for (const filter of this.matchAll(request)) {\n            for (const patternInfo of this.metadata.fromFilter(filter)) {\n                if (!seenPatterns.has(patternInfo.pattern.key)) {\n                    seenPatterns.add(patternInfo.pattern.key);\n                    patterns.push(patternInfo);\n                }\n            }\n        }\n        if (getDomainMetadata) {\n            for (const patternInfo of this.metadata.fromDomain(request.hostname)) {\n                if (!seenPatterns.has(patternInfo.pattern.key)) {\n                    seenPatterns.add(patternInfo.pattern.key);\n                    patterns.push(patternInfo);\n                }\n            }\n        }\n        return patterns;\n    }\n    blockScripts() {\n        this.updateFromDiff({\n            added: [(0,_filters_dsl_js__WEBPACK_IMPORTED_MODULE_6__.block)().scripts().redirectTo('javascript').toString()],\n        });\n        return this;\n    }\n    blockImages() {\n        this.updateFromDiff({\n            added: [(0,_filters_dsl_js__WEBPACK_IMPORTED_MODULE_6__.block)().images().redirectTo('png').toString()],\n        });\n        return this;\n    }\n    blockMedias() {\n        this.updateFromDiff({\n            added: [(0,_filters_dsl_js__WEBPACK_IMPORTED_MODULE_6__.block)().medias().redirectTo('mp4').toString()],\n        });\n        return this;\n    }\n    blockFrames() {\n        this.updateFromDiff({\n            added: [(0,_filters_dsl_js__WEBPACK_IMPORTED_MODULE_6__.block)().frames().redirectTo('html').toString()],\n        });\n        return this;\n    }\n    blockFonts() {\n        this.updateFromDiff({\n            added: [(0,_filters_dsl_js__WEBPACK_IMPORTED_MODULE_6__.block)().fonts().toString()],\n        });\n        return this;\n    }\n    blockStyles() {\n        this.updateFromDiff({\n            added: [(0,_filters_dsl_js__WEBPACK_IMPORTED_MODULE_6__.block)().styles().toString()],\n        });\n        return this;\n    }\n}\n//# sourceMappingURL=engine.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvZW5naW5lLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEO0FBQ3JCO0FBQ29EO0FBQzFDO0FBQ3dEO0FBQ3pDO0FBQ2pCO0FBQ2E7QUFDbkI7QUFDSTtBQUNnQjtBQUNGO0FBQ1o7QUFDRDtBQUNjO0FBQ0c7QUFDbkQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsMkJBQTJCLG9EQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxrQ0FBa0MscURBQVU7QUFDNUMscUNBQXFDLHlEQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsK0NBQVEsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMERBQW1CLElBQUk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdEQUFTLElBQUk7QUFDdEQ7QUFDQSxrREFBa0Q7QUFDbEQsMkJBQTJCLGtEQUFNO0FBQ2pDLDZCQUE2QixtREFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBDQUEwQyxJQUFJLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxvQ0FBb0MsY0FBYyxnQ0FBZ0M7QUFDdkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtEQUFNLEdBQUcseUNBQXlDO0FBQzFFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtREFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRyw4QkFBOEIsY0FBYywwQkFBMEI7QUFDckw7QUFDQTtBQUNBLCtCQUErQixxREFBUztBQUN4QztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMkJBQTJCLGtEQUFNO0FBQ2pDO0FBQ0EsZUFBZSx1REFBWTtBQUMzQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFjO0FBQ3JDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsZ0JBQWdCLFVBQVUsd0JBQXdCO0FBQzlIO0FBQ0E7QUFDQSx1QkFBdUIsa0RBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsVUFBVSxVQUFVLFNBQVM7QUFDOUc7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQSwyQkFBMkIscURBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnRUFBa0I7QUFDakQ7QUFDQSw0QkFBNEIsMkRBQW1CO0FBQy9DLDJCQUEyQiwyREFBbUI7QUFDOUMsOEJBQThCLDJEQUFtQjtBQUNqRCx5QkFBeUIsMkRBQW1CO0FBQzVDLDRCQUE0QiwyREFBbUI7QUFDL0MscUJBQXFCLDJEQUFtQjtBQUN4QywyQkFBMkIsNERBQW9CO0FBQy9DLGdDQUFnQywyREFBbUI7QUFDbkQsNkJBQTZCLHdEQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtREFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Ysa0RBQU0seUJBQXlCLElBQUk7QUFDbkgsaUJBQWlCO0FBQ2pCLDBCQUEwQixrREFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0VBQWtCLEdBQUc7QUFDdEQ7QUFDQSx1QkFBdUIsMkRBQW1CLEdBQUcscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyREFBbUIsR0FBRyxxQkFBcUI7QUFDN0U7QUFDQSw4QkFBOEIsMkRBQW1CLEdBQUcscUJBQXFCO0FBQ3pFO0FBQ0EsOEJBQThCLDJEQUFtQixHQUFHLHFCQUFxQjtBQUN6RTtBQUNBLDZCQUE2QiwyREFBbUIsR0FBRyxxQkFBcUI7QUFDeEU7QUFDQSxnQ0FBZ0MsMkRBQW1CLEdBQUcscUJBQXFCO0FBQzNFO0FBQ0EsMkJBQTJCLDJEQUFtQixHQUFHLHFCQUFxQjtBQUN0RTtBQUNBLDZCQUE2Qiw0REFBb0IsR0FBRyxxQkFBcUI7QUFDekU7QUFDQSwrQkFBK0Isd0RBQVUsR0FBRyxxQkFBcUI7QUFDakU7QUFDQSw2QkFBNkIscURBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5REFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLDZCQUE2QiwwREFBVyxTQUFTLDBEQUFXO0FBQzVEO0FBQ0EseUJBQXlCLHlEQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBUyxlQUFlLFVBQVU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZKQUE2SixZQUFZLGtEQUFHO0FBQ3pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDLEVBQUUsdURBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDLEVBQUUsdURBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtDQUFrQyxFQUFFLHVEQUFZO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx5REFBWTtBQUM5RDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDLEVBQUUsdURBQVk7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlEQUFZO0FBQzFEO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVEQUF1RDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDJCQUEyQjtBQUN6RTtBQUNBLGdDQUFnQyxpREFBVTtBQUMxQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsbUJBQW1CO0FBQ2pFO0FBQ0EsZ0NBQWdDLGlEQUFVO0FBQzFDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEpBQThKO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrSEFBa0g7QUFDdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUksOENBQThDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUlBQW1JO0FBQ25JO0FBQ0E7QUFDQSx3REFBd0QsbURBQU87QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaURBQVU7QUFDdEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpREFBVTtBQUN0QyxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHVFQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsdUVBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNEJBQTRCLGlEQUFVO0FBQ3RDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG1CQUFtQixJQUFJLHFCQUFxQixpREFBVSxVQUFVO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUIsSUFBSSxxQkFBcUIsaURBQVUsVUFBVTtBQUMxRztBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlFQUFlO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELDRDQUE0QyxJQUFJLHFCQUFxQixpREFBVSxVQUFVO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJO0FBQ3ZEO0FBQ0EsaUVBQWlFLElBQUk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsbUJBQW1CLElBQUkscUJBQXFCLGlEQUFVLFVBQVU7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvREFBb0QsSUFBSSxxQkFBcUIsaURBQVUsVUFBVTtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNEJBQTRCLElBQUk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQUs7QUFDekIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFLO0FBQ3pCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBSztBQUN6QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQUs7QUFDekIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFLO0FBQ3pCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBSztBQUN6QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvYWRibG9ja2VyL2Rpc3QvZXNtL2VuZ2luZS9lbmdpbmUuanM/NmYwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50IEdob3N0ZXJ5IEdtYkguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmltcG9ydCB7IFVSTFNlYXJjaFBhcmFtcyB9IGZyb20gJ0BnaG9zdGVyeS91cmwtcGFyc2VyJztcbmltcG9ydCBDb25maWcgZnJvbSAnLi4vY29uZmlnLmpzJztcbmltcG9ydCB7IFN0YXRpY0RhdGFWaWV3LCBzaXplT2ZBU0NJSSwgc2l6ZU9mQnl0ZSwgc2l6ZU9mQm9vbCB9IGZyb20gJy4uL2RhdGEtdmlldy5qcyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IHsgYWRzQW5kVHJhY2tpbmdMaXN0cywgYWRzTGlzdHMsIGZldGNoTGlzdHMsIGZldGNoUmVzb3VyY2VzLCBmdWxsTGlzdHMsIH0gZnJvbSAnLi4vZmV0Y2guanMnO1xuaW1wb3J0IHsgbm9ybWFsaXplU2VsZWN0b3IgfSBmcm9tICcuLi9maWx0ZXJzL2Nvc21ldGljLmpzJztcbmltcG9ydCB7IGJsb2NrIH0gZnJvbSAnLi4vZmlsdGVycy9kc2wuanMnO1xuaW1wb3J0IHsgRmlsdGVyVHlwZSwgcGFyc2VGaWx0ZXJzIH0gZnJvbSAnLi4vbGlzdHMuanMnO1xuaW1wb3J0IFJlcXVlc3QgZnJvbSAnLi4vcmVxdWVzdC5qcyc7XG5pbXBvcnQgUmVzb3VyY2VzIGZyb20gJy4uL3Jlc291cmNlcy5qcyc7XG5pbXBvcnQgQ29zbWV0aWNGaWx0ZXJCdWNrZXQgZnJvbSAnLi9idWNrZXQvY29zbWV0aWMuanMnO1xuaW1wb3J0IE5ldHdvcmtGaWx0ZXJCdWNrZXQgZnJvbSAnLi9idWNrZXQvbmV0d29yay5qcyc7XG5pbXBvcnQgSFRNTEJ1Y2tldCBmcm9tICcuL2J1Y2tldC9odG1sLmpzJztcbmltcG9ydCB7IE1ldGFkYXRhIH0gZnJvbSAnLi9tZXRhZGF0YS5qcyc7XG5pbXBvcnQgUHJlcHJvY2Vzc29yLCB7IEVudiB9IGZyb20gJy4uL3ByZXByb2Nlc3Nvci5qcyc7XG5pbXBvcnQgUHJlcHJvY2Vzc29yQnVja2V0IGZyb20gJy4vYnVja2V0L3ByZXByb2Nlc3Nvci5qcyc7XG5leHBvcnQgY29uc3QgRU5HSU5FX1ZFUlNJT04gPSA4MTI7XG5mdW5jdGlvbiBmaW5kQXBwbGljYWJsZUhpZGVFeGNlcHRpb24oZmlsdGVycykge1xuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEdldCAkWGhpZGUgZmlsdGVyIHdpdGggaGlnaGVzdCBwcmlvcml0eTpcbiAgICAvLyAkWGhpZGUsaW1wb3J0YW50ID4gJFhoaWRlID4gQEAkWGhpZGVcbiAgICBsZXQgaGlkZUZpbHRlcjtcbiAgICBsZXQgY3VycmVudFNjb3JlID0gMDtcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBmaWx0ZXJzKSB7XG4gICAgICAgIC8vIFRvIGVuY29kZSBwcmlvcml0eSBiZXR3ZWVuIGZpbHRlcnMsIHdlIGNyZWF0ZSBhIGJpdG1hc2sgd2l0aCB0aGUgZm9sbG93aW5nOlxuICAgICAgICAvLyAkaW1wb3J0YW50LFhoaWRlID0gMTAwICh0YWtlcyBwcmVjZWRlbmNlKVxuICAgICAgICAvLyAkWGhpZGUgICAgICAgICAgID0gMDEwIChleGNlcHRpb24gdG8gQEAkWGhpZGUpXG4gICAgICAgIC8vIEBAJFhoaWRlICAgICAgICAgPSAwMDEgKGZvcmJpZHMgWGhpZGUgZmlsdGVycylcbiAgICAgICAgY29uc3Qgc2NvcmUgPSAoZmlsdGVyLmlzSW1wb3J0YW50KCkgPyA0IDogMCkgfCAoZmlsdGVyLmlzRXhjZXB0aW9uKCkgPyAxIDogMik7XG4gICAgICAgIC8vIEhpZ2hlc3QgYHNjb3JlYCBoYXMgcHJlY2VkZW5jZVxuICAgICAgICBpZiAoc2NvcmUgPj0gY3VycmVudFNjb3JlKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSBzY29yZTtcbiAgICAgICAgICAgIGhpZGVGaWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhpZGVGaWx0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENoZWNrIHRoYXQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lICRnZW5lcmljaGlkZSBtYXRjaCBhbmQgbm8gZXhjZXB0aW9uXG4gICAgaWYgKGhpZGVGaWx0ZXIuaXNFeGNlcHRpb24oKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gaGlkZUZpbHRlcjtcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbHRlckVuZ2luZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgc3RhdGljIGZyb21DYWNoZWQoaW5pdCwgY2FjaGluZykge1xuICAgICAgICBpZiAoY2FjaGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcGF0aCwgcmVhZCwgd3JpdGUgfSA9IGNhY2hpbmc7XG4gICAgICAgIHJldHVybiByZWFkKHBhdGgpXG4gICAgICAgICAgICAudGhlbigoYnVmZmVyKSA9PiB0aGlzLmRlc2VyaWFsaXplKGJ1ZmZlcikpXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4gaW5pdCgpLnRoZW4oKGVuZ2luZSkgPT4gd3JpdGUocGF0aCwgZW5naW5lLnNlcmlhbGl6ZSgpKS50aGVuKCgpID0+IGVuZ2luZSkpKTtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5KGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh7IGNvbmZpZyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGBGaWx0ZXJzRW5naW5lYCAob3Igc3ViY2xhc3MgbGlrZSBgRWxlY3Ryb25CbG9ja2VyYCxcbiAgICAgKiBldGMuKSwgZnJvbSB0aGUgbGlzdCBvZiBzdWJzY3JpcHRpb25zIHByb3ZpZGVkIGFzIGFyZ3VtZW50IChlLmcuOlxuICAgICAqIEVhc3lMaXN0KS5cbiAgICAgKlxuICAgICAqIExpc3RzIGFyZSBmZXRjaGVkIHVzaW5nIHRoZSBpbnN0YW5jZSBvZiBgZmV0Y2hgIHByb3ZpZGVkIGFzIGEgZmlyc3RcbiAgICAgKiBhcmd1bWVudC4gT3B0aW9uYWxseSByZXNvdXJjZXMudHh0IGFuZCBjb25maWcgY2FuIGJlIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTGlzdHMoZmV0Y2gsIHVybHMsIGNvbmZpZyA9IHt9LCBjYWNoaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21DYWNoZWQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlzdHNQcm9taXNlcyA9IGZldGNoTGlzdHMoZmV0Y2gsIHVybHMpO1xuICAgICAgICAgICAgY29uc3QgcmVzb3VyY2VzUHJvbWlzZSA9IGZldGNoUmVzb3VyY2VzKGZldGNoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbGlzdHNQcm9taXNlcywgcmVzb3VyY2VzUHJvbWlzZV0pLnRoZW4oKFtsaXN0cywgcmVzb3VyY2VzXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMucGFyc2UobGlzdHMuam9pbignXFxuJyksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc291cmNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZ2luZS51cGRhdGVSZXNvdXJjZXMocmVzb3VyY2VzLCAnJyArIHJlc291cmNlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZW5naW5lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGNhY2hpbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGJsb2NrZXIgb2YgKmFkcyBvbmx5Ki5cbiAgICAgKlxuICAgICAqIEF0dGVtcHQgdG8gaW5pdGlhbGl6ZSBhIGJsb2NraW5nIGVuZ2luZSB1c2luZyBhIHByZS1idWlsdCB2ZXJzaW9uIHNlcnZlZFxuICAgICAqIGZyb20gR2hvc3RlcnkncyBDRE4uIElmIHRoaXMgZmFpbHMgKGUuZy46IGlmIG5vIHByZS1idWlsdCBlbmdpbmUgaXMgYXZhaWxhYmxlXG4gICAgICogZm9yIHRoaXMgdmVyc2lvbiBvZiB0aGUgbGlicmFyeSksIHRoZW4gZmFsbHMtYmFjayB0byB1c2luZyBgZnJvbUxpc3RzKC4uLilgXG4gICAgICogbWV0aG9kIHdpdGggdGhlIHNhbWUgc3Vic2NyaXB0aW9ucy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVByZWJ1aWx0QWRzT25seShmZXRjaEltcGwgPSBmZXRjaCwgY2FjaGluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tTGlzdHMoZmV0Y2hJbXBsLCBhZHNMaXN0cywge30sIGNhY2hpbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIGBmcm9tUHJlYnVpbHRBZHNPbmx5KC4uLilgIGJ1dCBhbHNvIGNvbnRhaW5zIHJ1bGVzIHRvIGJsb2NrXG4gICAgICogdHJhY2tpbmcgKGkuZS46IHVzaW5nIGV4dHJhIGxpc3RzIHN1Y2ggYXMgRWFzeVByaXZhY3kgYW5kIG1vcmUpLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUHJlYnVpbHRBZHNBbmRUcmFja2luZyhmZXRjaEltcGwgPSBmZXRjaCwgY2FjaGluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tTGlzdHMoZmV0Y2hJbXBsLCBhZHNBbmRUcmFja2luZ0xpc3RzLCB7fSwgY2FjaGluZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNhbWUgYXMgYGZyb21QcmVidWlsdEFkc0FuZFRyYWNraW5nKC4uLilgIGJ1dCBhbHNvIGNvbnRhaW5zIGFubm95YW5jZXNcbiAgICAgKiBydWxlcyB0byBibG9jayB0aGluZ3MgbGlrZSBjb29raWUgbm90aWNlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVByZWJ1aWx0RnVsbChmZXRjaEltcGwgPSBmZXRjaCwgY2FjaGluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tTGlzdHMoZmV0Y2hJbXBsLCBmdWxsTGlzdHMsIHt9LCBjYWNoaW5nKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21UcmFja2VyREIocmF3SnNvbkR1bXAsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBjb25maWcgPSBuZXcgQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBNZXRhZGF0YShyYXdKc29uRHVtcCk7XG4gICAgICAgIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIG1ldGFkYXRhLmdldFBhdHRlcm5zKCkpIHtcbiAgICAgICAgICAgIGZpbHRlcnMucHVzaCguLi5wYXR0ZXJuLmZpbHRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMucGFyc2UoZmlsdGVycy5qb2luKCdcXG4nKSwgY29uZmlnKTtcbiAgICAgICAgZW5naW5lLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHJldHVybiBlbmdpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBjb21wYXRpYmxlIGVuZ2luZXMgaW50byBvbmUuXG4gICAgICpcbiAgICAgKiBUaGlzIGFjdGlvbiByZWZlcmVuY2VzIG9iamVjdHMgZnJvbSB0aGUgc291cmNlIGVuZ2luZXMsIGluY2x1ZGluZ1xuICAgICAqIG5ldHdvcmsgZmlsdGVycywgY29zbWV0aWMgZmlsdGVycywgcHJlcHJvY2Vzc29ycywgbWV0YWRhdGEsIGFuZCBsaXN0cy5cbiAgICAgKiBUaGVzZSBvYmplY3RzIGFyZSBub3QgZGVlcC1jb3BpZWQsIHNvIG1vZGlmeWluZyB0aGVtIGRpcmVjdGx5IGNhbiBoYXZlXG4gICAgICogdW5pbnRlbmRlZCBzaWRlIGVmZmVjdHMuXG4gICAgICogSG93ZXZlciwgcmVzb3VyY2VzIGFyZSBkZWVwLWNvcGllZCBmcm9tIHRoZSBmaXJzdCBlbmdpbmUuXG4gICAgICpcbiAgICAgKiBPcHRpb25hbGx5LCB5b3UgY2FuIHNwZWNpZnkgYSBzZWNvbmQgcGFyYW1ldGVyIHRvIHNraXAgbWVyZ2luZyBzcGVjaWZpYyByZXNvdXJjZXMuXG4gICAgICogSWYgcmVzb3VyY2UgbWVyZ2luZyBpcyBza2lwcGVkLCB0aGUgcmVzdWx0aW5nIGVuZ2luZSB3aWxsIGJlIGFzc2lnbmVkIGVtcHR5IHJlc291cmNlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgbWVyZ2UoZW5naW5lcywgeyBza2lwUmVzb3VyY2VzID0gZmFsc2UsIG92ZXJyaWRlQ29uZmlnID0ge30sIH0gPSB7fSkge1xuICAgICAgICBpZiAoIWVuZ2luZXMgfHwgZW5naW5lcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21lcmdpbmcgZW5naW5lcyByZXF1aXJlcyBhdCBsZWFzdCB0d28gZW5naW5lcycpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZW5naW5lIG9mIGVuZ2luZXMpIHtcbiAgICAgICAgICAgIGlmIChlbmdpbmUuY29uZmlnLmVuYWJsZUNvbXByZXNzaW9uICE9PSBlbmdpbmVzWzBdLmNvbmZpZy5lbmFibGVDb21wcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29tcHJlc3Npb24gb2YgYWxsIG1lcmdlZCBlbmdpbmVzIG11c3QgbWF0Y2ggd2l0aCB0aGUgZmlyc3Qgb25lOiBcIiR7ZW5naW5lc1swXS5jb25maWcuZW5hYmxlQ29tcHJlc3Npb259XCIgYnV0IGdvdDogXCIke2VuZ2luZS5jb25maWcuZW5hYmxlQ29tcHJlc3Npb259XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgbmV0d29ya0ZpbHRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGNvc21ldGljRmlsdGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgcHJlcHJvY2Vzc29ycyA9IFtdO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIG9yZ2FuaXphdGlvbnM6IHt9LFxuICAgICAgICAgICAgY2F0ZWdvcmllczoge30sXG4gICAgICAgICAgICBwYXR0ZXJuczoge30sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgZW5naW5lIG9mIGVuZ2luZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcnMgPSBlbmdpbmUuZ2V0RmlsdGVycygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBuZXR3b3JrRmlsdGVyIG9mIGZpbHRlcnMubmV0d29ya0ZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICBuZXR3b3JrRmlsdGVycy5zZXQobmV0d29ya0ZpbHRlci5nZXRJZCgpLCBuZXR3b3JrRmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgY29zbWV0aWNGaWx0ZXIgb2YgZmlsdGVycy5jb3NtZXRpY0ZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICBjb3NtZXRpY0ZpbHRlcnMuc2V0KGNvc21ldGljRmlsdGVyLmdldElkKCksIGNvc21ldGljRmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJlcHJvY2Vzc29yIG9mIGVuZ2luZS5wcmVwcm9jZXNzb3JzLnByZXByb2Nlc3NvcnMpIHtcbiAgICAgICAgICAgICAgICBwcmVwcm9jZXNzb3JzLnB1c2gocHJlcHJvY2Vzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVuZ2luZS5saXN0cykge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGlzdHMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZ2luZS5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBvcmdhbml6YXRpb24gb2YgZW5naW5lLm1ldGFkYXRhLm9yZ2FuaXphdGlvbnMuZ2V0VmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhLm9yZ2FuaXphdGlvbnNbb3JnYW5pemF0aW9uLmtleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEub3JnYW5pemF0aW9uc1tvcmdhbml6YXRpb24ua2V5XSA9IG9yZ2FuaXphdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhdGVnb3J5IG9mIGVuZ2luZS5tZXRhZGF0YS5jYXRlZ29yaWVzLmdldFZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YS5jYXRlZ29yaWVzW2NhdGVnb3J5LmtleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEuY2F0ZWdvcmllc1tjYXRlZ29yeS5rZXldID0gY2F0ZWdvcnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGVuZ2luZS5tZXRhZGF0YS5wYXR0ZXJucy5nZXRWYWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEucGF0dGVybnNbcGF0dGVybi5rZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLnBhdHRlcm5zW3BhdHRlcm4ua2V5XSA9IHBhdHRlcm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5naW5lID0gbmV3IHRoaXMoe1xuICAgICAgICAgICAgbmV0d29ya0ZpbHRlcnM6IEFycmF5LmZyb20obmV0d29ya0ZpbHRlcnMudmFsdWVzKCkpLFxuICAgICAgICAgICAgY29zbWV0aWNGaWx0ZXJzOiBBcnJheS5mcm9tKGNvc21ldGljRmlsdGVycy52YWx1ZXMoKSksXG4gICAgICAgICAgICBwcmVwcm9jZXNzb3JzLFxuICAgICAgICAgICAgbGlzdHMsXG4gICAgICAgICAgICBjb25maWc6IG5ldyBDb25maWcoeyAuLi5lbmdpbmVzWzBdLmNvbmZpZywgLi4ub3ZlcnJpZGVDb25maWcgfSksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMobWV0YWRhdGEuY2F0ZWdvcmllcykubGVuZ3RoICtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG1ldGFkYXRhLm9yZ2FuaXphdGlvbnMpLmxlbmd0aCArXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhtZXRhZGF0YS5wYXR0ZXJucykubGVuZ3RoICE9PVxuICAgICAgICAgICAgMCkge1xuICAgICAgICAgICAgZW5naW5lLm1ldGFkYXRhID0gbmV3IE1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcFJlc291cmNlcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmdpbmUgb2YgZW5naW5lcy5zbGljZSgxKSkge1xuICAgICAgICAgICAgICAgIGlmIChlbmdpbmUucmVzb3VyY2VzLmNoZWNrc3VtICE9PSBlbmdpbmVzWzBdLnJlc291cmNlcy5jaGVja3N1bSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlc291cmNlIGNoZWNrc3VtIG9mIGFsbCBtZXJnZWQgZW5naW5lcyBtdXN0IG1hdGNoIHdpdGggdGhlIGZpcnN0IG9uZTogXCIke2VuZ2luZXNbMF0ucmVzb3VyY2VzLmNoZWNrc3VtfVwiIGJ1dCBnb3Q6IFwiJHtlbmdpbmUucmVzb3VyY2VzLmNoZWNrc3VtfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5naW5lLnJlc291cmNlcyA9IFJlc291cmNlcy5jb3B5KGVuZ2luZXNbMF0ucmVzb3VyY2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5naW5lO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UoZmlsdGVycywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBDb25maWcob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh7XG4gICAgICAgICAgICAuLi5wYXJzZUZpbHRlcnMoZmlsdGVycywgY29uZmlnKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShzZXJpYWxpemVkKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IFN0YXRpY0RhdGFWaWV3LmZyb21VaW50OEFycmF5KHNlcmlhbGl6ZWQsIHtcbiAgICAgICAgICAgIGVuYWJsZUNvbXByZXNzaW9uOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEJlZm9yZSBzdGFydGluZyBkZXNlcmlhbGl6YXRpb24sIHdlIG1ha2Ugc3VyZSB0aGF0IHRoZSB2ZXJzaW9uIG9mIHRoZVxuICAgICAgICAvLyBzZXJpYWxpemVkIGVuZ2luZSBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCBzb3VyY2UgY29kZS4gSWYgbm90LCB3ZVxuICAgICAgICAvLyBzdGFydCBmcmVzaCBhbmQgY3JlYXRlIGEgbmV3IGVuZ2luZSBmcm9tIHRoZSBsaXN0cy5cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZEVuZ2luZVZlcnNpb24gPSBidWZmZXIuZ2V0VWludDE2KCk7XG4gICAgICAgIGlmIChFTkdJTkVfVkVSU0lPTiAhPT0gc2VyaWFsaXplZEVuZ2luZVZlcnNpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2VyaWFsaXplZCBlbmdpbmUgdmVyc2lvbiBtaXNtYXRjaCwgZXhwZWN0ZWQgJHtFTkdJTkVfVkVSU0lPTn0gYnV0IGdvdCAke3NlcmlhbGl6ZWRFbmdpbmVWZXJzaW9ufWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBlbmdpbmUgd2l0aCBzYW1lIG9wdGlvbnNcbiAgICAgICAgY29uc3QgY29uZmlnID0gQ29uZmlnLmRlc2VyaWFsaXplKGJ1ZmZlcik7XG4gICAgICAgIC8vIE9wdGlvbmFsbHkgdHVybiBjb21wcmVzc2lvbiBPTlxuICAgICAgICBpZiAoY29uZmlnLmVuYWJsZUNvbXByZXNzaW9uKSB7XG4gICAgICAgICAgICBidWZmZXIuZW5hYmxlQ29tcHJlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbHNvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBjaGVja3N1bSBpcyBjb3JyZWN0LiBUaGlzIGFsbG93cyB0b1xuICAgICAgICAvLyBkZXRlY3QgZGF0YSBjb3JydXB0aW9uIGFuZCBzdGFydCBmcmVzaCBpZiB0aGUgc2VyaWFsaXplZCB2ZXJzaW9uIHdhc1xuICAgICAgICAvLyBhbHRlcmVkLlxuICAgICAgICBpZiAoY29uZmlnLmludGVncml0eUNoZWNrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UG9zID0gYnVmZmVyLnBvcztcbiAgICAgICAgICAgIGJ1ZmZlci5wb3MgPSBzZXJpYWxpemVkLmxlbmd0aCAtIDQ7XG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bSA9IGJ1ZmZlci5jaGVja3N1bSgpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBidWZmZXIuZ2V0VWludDMyKCk7XG4gICAgICAgICAgICBpZiAoY2hlY2tzdW0gIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzZXJpYWxpemVkIGVuZ2luZSBjaGVja3N1bSBtaXNtYXRjaCwgZXhwZWN0ZWQgJHtleHBlY3RlZH0gYnV0IGdvdCAke2NoZWNrc3VtfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnBvcyA9IGN1cnJlbnRQb3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5naW5lID0gbmV3IHRoaXMoeyBjb25maWcgfSk7XG4gICAgICAgIC8vIERlc2VyaWFsaXplIHJlc291cmNlc1xuICAgICAgICBlbmdpbmUucmVzb3VyY2VzID0gUmVzb3VyY2VzLmRlc2VyaWFsaXplKGJ1ZmZlcik7XG4gICAgICAgIC8vIERlc2VyaWFsaXplIGxpc3RzXG4gICAgICAgIGNvbnN0IGxpc3RzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBudW1iZXJPZkxpc3RzID0gYnVmZmVyLmdldFVpbnQxNigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mTGlzdHM7IGkgKz0gMSkge1xuICAgICAgICAgICAgbGlzdHMuc2V0KGJ1ZmZlci5nZXRBU0NJSSgpLCBidWZmZXIuZ2V0QVNDSUkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5naW5lLmxpc3RzID0gbGlzdHM7XG4gICAgICAgIC8vIERlc2VyaWFsaXplIHByZXByb2Nlc3NvcnNcbiAgICAgICAgZW5naW5lLnByZXByb2Nlc3NvcnMgPSBQcmVwcm9jZXNzb3JCdWNrZXQuZGVzZXJpYWxpemUoYnVmZmVyKTtcbiAgICAgICAgLy8gRGVzZXJpYWxpemUgYnVja2V0c1xuICAgICAgICBlbmdpbmUuaW1wb3J0YW50cyA9IE5ldHdvcmtGaWx0ZXJCdWNrZXQuZGVzZXJpYWxpemUoYnVmZmVyLCBjb25maWcpO1xuICAgICAgICBlbmdpbmUucmVkaXJlY3RzID0gTmV0d29ya0ZpbHRlckJ1Y2tldC5kZXNlcmlhbGl6ZShidWZmZXIsIGNvbmZpZyk7XG4gICAgICAgIGVuZ2luZS5yZW1vdmVwYXJhbXMgPSBOZXR3b3JrRmlsdGVyQnVja2V0LmRlc2VyaWFsaXplKGJ1ZmZlciwgY29uZmlnKTtcbiAgICAgICAgZW5naW5lLmZpbHRlcnMgPSBOZXR3b3JrRmlsdGVyQnVja2V0LmRlc2VyaWFsaXplKGJ1ZmZlciwgY29uZmlnKTtcbiAgICAgICAgZW5naW5lLmV4Y2VwdGlvbnMgPSBOZXR3b3JrRmlsdGVyQnVja2V0LmRlc2VyaWFsaXplKGJ1ZmZlciwgY29uZmlnKTtcbiAgICAgICAgZW5naW5lLmNzcCA9IE5ldHdvcmtGaWx0ZXJCdWNrZXQuZGVzZXJpYWxpemUoYnVmZmVyLCBjb25maWcpO1xuICAgICAgICBlbmdpbmUuY29zbWV0aWNzID0gQ29zbWV0aWNGaWx0ZXJCdWNrZXQuZGVzZXJpYWxpemUoYnVmZmVyLCBjb25maWcpO1xuICAgICAgICBlbmdpbmUuaGlkZUV4Y2VwdGlvbnMgPSBOZXR3b3JrRmlsdGVyQnVja2V0LmRlc2VyaWFsaXplKGJ1ZmZlciwgY29uZmlnKTtcbiAgICAgICAgZW5naW5lLmh0bWxGaWx0ZXJzID0gSFRNTEJ1Y2tldC5kZXNlcmlhbGl6ZShidWZmZXIsIGNvbmZpZyk7XG4gICAgICAgIC8vIE9wdGlvbmFsbHkgZGVzZXJpYWxpemUgbWV0YWRhdGFcbiAgICAgICAgY29uc3QgaGFzTWV0YWRhdGEgPSBidWZmZXIuZ2V0Qm9vbCgpO1xuICAgICAgICBpZiAoaGFzTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGVuZ2luZS5tZXRhZGF0YSA9IE1ldGFkYXRhLmRlc2VyaWFsaXplKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyLnNlZWtaZXJvKCk7XG4gICAgICAgIHJldHVybiBlbmdpbmU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsgXG4gICAgLy8gT3B0aW9uYWxseSBpbml0aWFsaXplIHRoZSBlbmdpbmUgd2l0aCBmaWx0ZXJzXG4gICAgY29zbWV0aWNGaWx0ZXJzID0gW10sIG5ldHdvcmtGaWx0ZXJzID0gW10sIHByZXByb2Nlc3NvcnMgPSBbXSwgY29uZmlnID0gbmV3IENvbmZpZygpLCBsaXN0cyA9IG5ldyBNYXAoKSwgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7IC8vIGluaXQgc3VwZXItY2xhc3MgRXZlbnRFbWl0dGVyXG4gICAgICAgIHRoaXMuY29uZmlnID0gbmV3IENvbmZpZyhjb25maWcpO1xuICAgICAgICAvLyBTdWJzY3JpcHRpb24gbWFuYWdlbWVudDogZGlzYWJsZWQgYnkgZGVmYXVsdFxuICAgICAgICB0aGlzLmxpc3RzID0gbGlzdHM7XG4gICAgICAgIC8vIFByZXByb2Nlc3NvcnNcbiAgICAgICAgdGhpcy5wcmVwcm9jZXNzb3JzID0gbmV3IFByZXByb2Nlc3NvckJ1Y2tldCh7fSk7XG4gICAgICAgIC8vICRjc3A9XG4gICAgICAgIHRoaXMuY3NwID0gbmV3IE5ldHdvcmtGaWx0ZXJCdWNrZXQoeyBjb25maWc6IHRoaXMuY29uZmlnIH0pO1xuICAgICAgICAvLyAkZWxlbWhpZGVcbiAgICAgICAgLy8gJGdlbmVyaWNoaWRlXG4gICAgICAgIC8vICRzcGVjaWZpY2hpZGVcbiAgICAgICAgdGhpcy5oaWRlRXhjZXB0aW9ucyA9IG5ldyBOZXR3b3JrRmlsdGVyQnVja2V0KHsgY29uZmlnOiB0aGlzLmNvbmZpZyB9KTtcbiAgICAgICAgLy8gQEBmaWx0ZXJcbiAgICAgICAgdGhpcy5leGNlcHRpb25zID0gbmV3IE5ldHdvcmtGaWx0ZXJCdWNrZXQoeyBjb25maWc6IHRoaXMuY29uZmlnIH0pO1xuICAgICAgICAvLyAkaW1wb3J0YW50XG4gICAgICAgIHRoaXMuaW1wb3J0YW50cyA9IG5ldyBOZXR3b3JrRmlsdGVyQnVja2V0KHsgY29uZmlnOiB0aGlzLmNvbmZpZyB9KTtcbiAgICAgICAgLy8gJHJlZGlyZWN0XG4gICAgICAgIHRoaXMucmVkaXJlY3RzID0gbmV3IE5ldHdvcmtGaWx0ZXJCdWNrZXQoeyBjb25maWc6IHRoaXMuY29uZmlnIH0pO1xuICAgICAgICAvLyAkcmVtb3ZlcGFyYW1cbiAgICAgICAgdGhpcy5yZW1vdmVwYXJhbXMgPSBuZXcgTmV0d29ya0ZpbHRlckJ1Y2tldCh7IGNvbmZpZzogdGhpcy5jb25maWcgfSk7XG4gICAgICAgIC8vIEFsbCBvdGhlciBmaWx0ZXJzXG4gICAgICAgIHRoaXMuZmlsdGVycyA9IG5ldyBOZXR3b3JrRmlsdGVyQnVja2V0KHsgY29uZmlnOiB0aGlzLmNvbmZpZyB9KTtcbiAgICAgICAgLy8gQ29zbWV0aWMgZmlsdGVyc1xuICAgICAgICB0aGlzLmNvc21ldGljcyA9IG5ldyBDb3NtZXRpY0ZpbHRlckJ1Y2tldCh7IGNvbmZpZzogdGhpcy5jb25maWcgfSk7XG4gICAgICAgIC8vIEhUTUwgZmlsdGVyc1xuICAgICAgICB0aGlzLmh0bWxGaWx0ZXJzID0gbmV3IEhUTUxCdWNrZXQoeyBjb25maWc6IHRoaXMuY29uZmlnIH0pO1xuICAgICAgICAvLyBJbmplY3Rpb25zXG4gICAgICAgIHRoaXMucmVzb3VyY2VzID0gbmV3IFJlc291cmNlcygpO1xuICAgICAgICBpZiAobmV0d29ya0ZpbHRlcnMubGVuZ3RoICE9PSAwIHx8IGNvc21ldGljRmlsdGVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBuZXdDb3NtZXRpY0ZpbHRlcnM6IGNvc21ldGljRmlsdGVycyxcbiAgICAgICAgICAgICAgICBuZXdOZXR3b3JrRmlsdGVyczogbmV0d29ya0ZpbHRlcnMsXG4gICAgICAgICAgICAgICAgbmV3UHJlcHJvY2Vzc29yczogcHJlcHJvY2Vzc29ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzRmlsdGVyRXhjbHVkZWQoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXByb2Nlc3NvcnMuaXNGaWx0ZXJFeGNsdWRlZChmaWx0ZXIpO1xuICAgIH1cbiAgICB1cGRhdGVFbnYoZW52KSB7XG4gICAgICAgIHRoaXMucHJlcHJvY2Vzc29ycy51cGRhdGVFbnYoZW52KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXN0aW1hdGUgdGhlIG51bWJlciBvZiBieXRlcyBuZWVkZWQgdG8gc2VyaWFsaXplIHRoaXMgaW5zdGFuY2Ugb2ZcbiAgICAgKiBgRmlsdGVyc0VuZ2luZWAgdXNpbmcgdGhlIGBzZXJpYWxpemUoLi4uKWAgbWV0aG9kLiBJdCBpcyB1c2VkIGludGVybmFsbHlcbiAgICAgKiBieSBgc2VyaWFsaXplKC4uLilgIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHRoZSByaWdodCBzaXplIGFuZCB5b3Ugc2hvdWxkXG4gICAgICogbm90IGhhdmUgdG8gY2FsbCBpdCB5b3Vyc2VsZiBtb3N0IG9mIHRoZSB0aW1lLlxuICAgICAqXG4gICAgICogVGhlcmUgYXJlIGNhc2VzIHdoZXJlIHdlIGNhbm5vdCBlc3RpbWF0ZSBzdGF0aWNhbGx5IHRoZSBleGFjdCBzaXplIG9mIHRoZVxuICAgICAqIHJlc3VsdGluZyBidWZmZXIgKGR1ZSB0byBhbGlnbmVtZW50IHdoaWNoIG5lZWRzIHRvIGJlIHBlcmZvcm1lZCk7IHRoaXNcbiAgICAgKiBtZXRob2Qgd2lsbCByZXR1cm4gYSBzYWZlIGVzdGltYXRlIHdoaWNoIHdpbGwgYWx3YXlzIGJlIGF0IGxlYXN0IGVxdWFsIHRvXG4gICAgICogdGhlIHJlYWwgbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCwgb3IgYmlnZ2VyICh1c3VhbGx5IG9mIGEgZmV3IGJ5dGVzIG9ubHk6XG4gICAgICogfjIwIGJ5dGVzIGlzIHRvIGJlIGV4cGVjdGVkKS5cbiAgICAgKi9cbiAgICBnZXRTZXJpYWxpemVkU2l6ZSgpIHtcbiAgICAgICAgbGV0IGVzdGltYXRlZFNpemUgPSBzaXplT2ZCeXRlKCkgKyAvLyBlbmdpbmUgdmVyc2lvblxuICAgICAgICAgICAgdGhpcy5jb25maWcuZ2V0U2VyaWFsaXplZFNpemUoKSArXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlcy5nZXRTZXJpYWxpemVkU2l6ZSgpICtcbiAgICAgICAgICAgIHRoaXMucHJlcHJvY2Vzc29ycy5nZXRTZXJpYWxpemVkU2l6ZSgpICtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVycy5nZXRTZXJpYWxpemVkU2l6ZSgpICtcbiAgICAgICAgICAgIHRoaXMuZXhjZXB0aW9ucy5nZXRTZXJpYWxpemVkU2l6ZSgpICtcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0YW50cy5nZXRTZXJpYWxpemVkU2l6ZSgpICtcbiAgICAgICAgICAgIHRoaXMucmVkaXJlY3RzLmdldFNlcmlhbGl6ZWRTaXplKCkgK1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVwYXJhbXMuZ2V0U2VyaWFsaXplZFNpemUoKSArXG4gICAgICAgICAgICB0aGlzLmNzcC5nZXRTZXJpYWxpemVkU2l6ZSgpICtcbiAgICAgICAgICAgIHRoaXMuY29zbWV0aWNzLmdldFNlcmlhbGl6ZWRTaXplKCkgK1xuICAgICAgICAgICAgdGhpcy5oaWRlRXhjZXB0aW9ucy5nZXRTZXJpYWxpemVkU2l6ZSgpICtcbiAgICAgICAgICAgIHRoaXMuaHRtbEZpbHRlcnMuZ2V0U2VyaWFsaXplZFNpemUoKSArXG4gICAgICAgICAgICA0OyAvLyBjaGVja3N1bVxuICAgICAgICAvLyBFc3RpbWF0ZSBzaXplIG9mIGB0aGlzLmxpc3RzYCB3aGljaCBzdG9yZXMgaW5mb3JtYXRpb24gb2YgY2hlY2tzdW0gZm9yIGVhY2ggbGlzdC5cbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgY2hlY2tzdW1dIG9mIHRoaXMubGlzdHMpIHtcbiAgICAgICAgICAgIGVzdGltYXRlZFNpemUgKz0gc2l6ZU9mQVNDSUkobmFtZSkgKyBzaXplT2ZBU0NJSShjaGVja3N1bSk7XG4gICAgICAgIH1cbiAgICAgICAgZXN0aW1hdGVkU2l6ZSArPSBzaXplT2ZCb29sKCk7XG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVzdGltYXRlZFNpemUgKz0gdGhpcy5tZXRhZGF0YS5nZXRTZXJpYWxpemVkU2l6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlc3RpbWF0ZWRTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmdWxsIGVuZ2luZS4gSXQgY2FuIGJlIHN0b3JlZFxuICAgICAqIG9uLWRpc2sgZm9yIGZhc3RlciBsb2FkaW5nIG9mIHRoZSBhZGJsb2NrZXIuIFRoZSBgZGVzZXJpYWxpemVgIHN0YXRpY1xuICAgICAqIG1ldGhvZCBvZiBFbmdpbmUgY2FuIGJlIHVzZWQgdG8gcmVzdG9yZSB0aGUgZW5naW5lLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZShhcnJheSkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBTdGF0aWNEYXRhVmlldy5mcm9tVWludDhBcnJheShhcnJheSB8fCBuZXcgVWludDhBcnJheSh0aGlzLmdldFNlcmlhbGl6ZWRTaXplKCkpLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIGJ1ZmZlci5wdXNoVWludDE2KEVOR0lORV9WRVJTSU9OKTtcbiAgICAgICAgLy8gQ29uZmlnXG4gICAgICAgIHRoaXMuY29uZmlnLnNlcmlhbGl6ZShidWZmZXIpO1xuICAgICAgICAvLyBSZXNvdXJjZXMgKGpzLCByZXNvdXJjZXMpXG4gICAgICAgIHRoaXMucmVzb3VyY2VzLnNlcmlhbGl6ZShidWZmZXIpO1xuICAgICAgICAvLyBTZXJpYWxpemUgdGhlIHN0YXRlIG9mIGxpc3RzIChuYW1lcyBhbmQgY2hlY2tzdW1zKVxuICAgICAgICBidWZmZXIucHVzaFVpbnQxNih0aGlzLmxpc3RzLnNpemUpO1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgQXJyYXkuZnJvbSh0aGlzLmxpc3RzLmVudHJpZXMoKSkuc29ydCgpKSB7XG4gICAgICAgICAgICBidWZmZXIucHVzaEFTQ0lJKG5hbWUpO1xuICAgICAgICAgICAgYnVmZmVyLnB1c2hBU0NJSSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlcHJvY2Vzc29yc1xuICAgICAgICB0aGlzLnByZXByb2Nlc3NvcnMuc2VyaWFsaXplKGJ1ZmZlcik7XG4gICAgICAgIC8vIEZpbHRlcnMgYnVja2V0c1xuICAgICAgICB0aGlzLmltcG9ydGFudHMuc2VyaWFsaXplKGJ1ZmZlcik7XG4gICAgICAgIHRoaXMucmVkaXJlY3RzLnNlcmlhbGl6ZShidWZmZXIpO1xuICAgICAgICB0aGlzLnJlbW92ZXBhcmFtcy5zZXJpYWxpemUoYnVmZmVyKTtcbiAgICAgICAgdGhpcy5maWx0ZXJzLnNlcmlhbGl6ZShidWZmZXIpO1xuICAgICAgICB0aGlzLmV4Y2VwdGlvbnMuc2VyaWFsaXplKGJ1ZmZlcik7XG4gICAgICAgIHRoaXMuY3NwLnNlcmlhbGl6ZShidWZmZXIpO1xuICAgICAgICB0aGlzLmNvc21ldGljcy5zZXJpYWxpemUoYnVmZmVyKTtcbiAgICAgICAgdGhpcy5oaWRlRXhjZXB0aW9ucy5zZXJpYWxpemUoYnVmZmVyKTtcbiAgICAgICAgdGhpcy5odG1sRmlsdGVycy5zZXJpYWxpemUoYnVmZmVyKTtcbiAgICAgICAgLy8gT3B0aW9uYWxseSBzZXJpYWxpemUgbWV0YWRhdGFcbiAgICAgICAgYnVmZmVyLnB1c2hCb29sKHRoaXMubWV0YWRhdGEgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2VyaWFsaXplKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3B0aW9uYWxseSBhcHBlbmQgYSBjaGVja3N1bSBhdCB0aGUgZW5kXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pbnRlZ3JpdHlDaGVjaykge1xuICAgICAgICAgICAgYnVmZmVyLnB1c2hVaW50MzIoYnVmZmVyLmNoZWNrc3VtKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXIuc3ViYXJyYXkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGVuZ2luZSB3aXRoIG5ldyBmaWx0ZXJzIG9yIHJlc291cmNlcy5cbiAgICAgKi9cbiAgICBsb2FkZWRMaXN0cygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5saXN0cy5rZXlzKCkpO1xuICAgIH1cbiAgICBoYXNMaXN0KG5hbWUsIGNoZWNrc3VtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RzLmhhcyhuYW1lKSAmJiB0aGlzLmxpc3RzLmdldChuYW1lKSA9PT0gY2hlY2tzdW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBlbmdpbmUgd2l0aCBgcmVzb3VyY2VzLnR4dGAgY29udGVudC5cbiAgICAgKi9cbiAgICB1cGRhdGVSZXNvdXJjZXMoZGF0YSwgY2hlY2tzdW0pIHtcbiAgICAgICAgaWYgKHRoaXMucmVzb3VyY2VzLmNoZWNrc3VtID09PSBjaGVja3N1bSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzb3VyY2VzID0gUmVzb3VyY2VzLnBhcnNlKGRhdGEsIHsgY2hlY2tzdW0gfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXRGaWx0ZXJzKCkge1xuICAgICAgICBjb25zdCBjb3NtZXRpY0ZpbHRlcnMgPSB0aGlzLmNvc21ldGljcy5nZXRGaWx0ZXJzKCk7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtGaWx0ZXJzID0gW1xuICAgICAgICAgICAgLi4udGhpcy5maWx0ZXJzLmdldEZpbHRlcnMoKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZXhjZXB0aW9ucy5nZXRGaWx0ZXJzKCksXG4gICAgICAgICAgICAuLi50aGlzLmltcG9ydGFudHMuZ2V0RmlsdGVycygpLFxuICAgICAgICAgICAgLi4udGhpcy5yZWRpcmVjdHMuZ2V0RmlsdGVycygpLFxuICAgICAgICAgICAgLi4udGhpcy5jc3AuZ2V0RmlsdGVycygpLFxuICAgICAgICAgICAgLi4udGhpcy5oaWRlRXhjZXB0aW9ucy5nZXRGaWx0ZXJzKCksXG4gICAgICAgIF07XG4gICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHRoaXMuaHRtbEZpbHRlcnMuZ2V0RmlsdGVycygpKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmlzTmV0d29ya0ZpbHRlcigpKSB7XG4gICAgICAgICAgICAgICAgbmV0d29ya0ZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyLmlzQ29zbWV0aWNGaWx0ZXIoKSkge1xuICAgICAgICAgICAgICAgIGNvc21ldGljRmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvc21ldGljRmlsdGVycyxcbiAgICAgICAgICAgIG5ldHdvcmtGaWx0ZXJzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZW5naW5lIHdpdGggbmV3IGZpbHRlcnMgYXMgd2VsbCBhcyBvcHRpb25hbGx5IHJlbW92ZWQgZmlsdGVycy5cbiAgICAgKi9cbiAgICB1cGRhdGUoeyBuZXdOZXR3b3JrRmlsdGVycyA9IFtdLCBuZXdDb3NtZXRpY0ZpbHRlcnMgPSBbXSwgbmV3UHJlcHJvY2Vzc29ycyA9IFtdLCByZW1vdmVkQ29zbWV0aWNGaWx0ZXJzID0gW10sIHJlbW92ZWROZXR3b3JrRmlsdGVycyA9IFtdLCByZW1vdmVkUHJlcHJvY2Vzc29ycyA9IFtdLCB9LCBlbnYgPSBuZXcgRW52KCkpIHtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gVXBkYXRlIHByZXByb2Nlc3NvcnNcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYWRQcmVwcm9jZXNzb3JzICYmXG4gICAgICAgICAgICAobmV3UHJlcHJvY2Vzc29ycy5sZW5ndGggIT09IDAgfHwgcmVtb3ZlZFByZXByb2Nlc3NvcnMubGVuZ3RoICE9PSAwKSkge1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnByZXByb2Nlc3NvcnMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBhZGRlZDogbmV3UHJlcHJvY2Vzc29ycyxcbiAgICAgICAgICAgICAgICByZW1vdmVkOiByZW1vdmVkUHJlcHJvY2Vzc29ycyxcbiAgICAgICAgICAgIH0sIGVudik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaHRtbEZpbHRlcnMgPSBbXTtcbiAgICAgICAgLy8gVXBkYXRlIGNvc21ldGljIGZpbHRlcnNcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYWRDb3NtZXRpY0ZpbHRlcnMgJiZcbiAgICAgICAgICAgIChuZXdDb3NtZXRpY0ZpbHRlcnMubGVuZ3RoICE9PSAwIHx8IHJlbW92ZWRDb3NtZXRpY0ZpbHRlcnMubGVuZ3RoICE9PSAwKSkge1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBjb3NtZXRpY0ZpdGxlcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIG5ld0Nvc21ldGljRmlsdGVycykge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIuaXNIdG1sRmlsdGVyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbEZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29zbWV0aWNGaXRsZXJzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvc21ldGljcy51cGRhdGUoY29zbWV0aWNGaXRsZXJzLCByZW1vdmVkQ29zbWV0aWNGaWx0ZXJzLmxlbmd0aCA9PT0gMCA/IHVuZGVmaW5lZCA6IG5ldyBTZXQocmVtb3ZlZENvc21ldGljRmlsdGVycyksIHRoaXMuY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgbmV0d29yayBmaWx0ZXJzXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb2FkTmV0d29ya0ZpbHRlcnMgJiZcbiAgICAgICAgICAgIChuZXdOZXR3b3JrRmlsdGVycy5sZW5ndGggIT09IDAgfHwgcmVtb3ZlZE5ldHdvcmtGaWx0ZXJzLmxlbmd0aCAhPT0gMCkpIHtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgZmlsdGVycyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgY3NwID0gW107XG4gICAgICAgICAgICBjb25zdCBleGNlcHRpb25zID0gW107XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRhbnRzID0gW107XG4gICAgICAgICAgICBjb25zdCByZWRpcmVjdHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZXBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgaGlkZUV4Y2VwdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIG5ld05ldHdvcmtGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gTk9URTogaXQncyBpbXBvcnRhbnQgdG8gY2hlY2sgZm9yICRnZW5lcmljaGlkZSwgJGVsZW1oaWRlLFxuICAgICAgICAgICAgICAgIC8vICRzcGVjaWZpY2hpZGUgYW5kICRjc3AgYmVmb3JlIGV4Y2VwdGlvbnMgYW5kIGltcG9ydGFudCBhcyB3ZSBzdG9yZVxuICAgICAgICAgICAgICAgIC8vIGFsbCBvZiB0aGVtIGluIHRoZSBzYW1lIGZpbHRlciBidWNrZXQuIFRoZSBjaGVjayBmb3IgZXhjZXB0aW9ucyBpc1xuICAgICAgICAgICAgICAgIC8vIGRvbmUgYXQgbWF0Y2gtdGltZSBkaXJlY3RseS5cbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLmlzQ1NQKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3NwLnB1c2goZmlsdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyLmlzSHRtbEZpbHRlcmluZ1J1bGUoKSkge1xuICAgICAgICAgICAgICAgICAgICBodG1sRmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlci5pc0dlbmVyaWNIaWRlKCkgfHwgZmlsdGVyLmlzU3BlY2lmaWNIaWRlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV4Y2VwdGlvbnMucHVzaChmaWx0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWx0ZXIuaXNFeGNlcHRpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLmlzUmVtb3ZlUGFyYW0oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlcGFyYW1zLnB1c2goZmlsdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbnMucHVzaChmaWx0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlci5pc0ltcG9ydGFudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGFudHMucHVzaChmaWx0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWx0ZXIuaXNSZWRpcmVjdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0cy5wdXNoKGZpbHRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlci5pc1JlbW92ZVBhcmFtKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlcGFyYW1zLnB1c2goZmlsdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWROZXR3b3JrRmlsdGVyc1NldCA9IHJlbW92ZWROZXR3b3JrRmlsdGVycy5sZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiBuZXcgU2V0KHJlbW92ZWROZXR3b3JrRmlsdGVycyk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgYnVja2V0cyBpbi1wbGFjZVxuICAgICAgICAgICAgdGhpcy5pbXBvcnRhbnRzLnVwZGF0ZShpbXBvcnRhbnRzLCByZW1vdmVkTmV0d29ya0ZpbHRlcnNTZXQpO1xuICAgICAgICAgICAgdGhpcy5yZWRpcmVjdHMudXBkYXRlKHJlZGlyZWN0cywgcmVtb3ZlZE5ldHdvcmtGaWx0ZXJzU2V0KTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlcGFyYW1zLnVwZGF0ZShyZW1vdmVwYXJhbXMsIHJlbW92ZWROZXR3b3JrRmlsdGVyc1NldCk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcnMudXBkYXRlKGZpbHRlcnMsIHJlbW92ZWROZXR3b3JrRmlsdGVyc1NldCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcubG9hZEV4Y2VwdGlvbkZpbHRlcnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4Y2VwdGlvbnMudXBkYXRlKGV4Y2VwdGlvbnMsIHJlbW92ZWROZXR3b3JrRmlsdGVyc1NldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcubG9hZENTUEZpbHRlcnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNzcC51cGRhdGUoY3NwLCByZW1vdmVkTmV0d29ya0ZpbHRlcnNTZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oaWRlRXhjZXB0aW9ucy51cGRhdGUoaGlkZUV4Y2VwdGlvbnMsIHJlbW92ZWROZXR3b3JrRmlsdGVyc1NldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUh0bWxGaWx0ZXJpbmcgJiZcbiAgICAgICAgICAgIChodG1sRmlsdGVycy5sZW5ndGggIT09IDAgfHxcbiAgICAgICAgICAgICAgICByZW1vdmVkTmV0d29ya0ZpbHRlcnMubGVuZ3RoICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgcmVtb3ZlZENvc21ldGljRmlsdGVycy5sZW5ndGggIT09IDApKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVGaWx0ZXJzID0gbmV3IFNldChbLi4ucmVtb3ZlZE5ldHdvcmtGaWx0ZXJzLCAuLi5yZW1vdmVkQ29zbWV0aWNGaWx0ZXJzXSk7XG4gICAgICAgICAgICB0aGlzLmh0bWxGaWx0ZXJzLnVwZGF0ZShodG1sRmlsdGVycywgcmVtb3ZlRmlsdGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuICAgIHVwZGF0ZUZyb21EaWZmKHsgYWRkZWQsIHJlbW92ZWQsIHByZXByb2Nlc3NvcnMgfSwgZW52KSB7XG4gICAgICAgIGNvbnN0IG5ld0Nvc21ldGljRmlsdGVycyA9IFtdO1xuICAgICAgICBjb25zdCBuZXdOZXR3b3JrRmlsdGVycyA9IFtdO1xuICAgICAgICBjb25zdCBuZXdQcmVwcm9jZXNzb3JzID0gW107XG4gICAgICAgIGNvbnN0IHJlbW92ZWRDb3NtZXRpY0ZpbHRlcnMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZE5ldHdvcmtGaWx0ZXJzID0gW107XG4gICAgICAgIGNvbnN0IHJlbW92ZWRQcmVwcm9jZXNzb3JzID0gW107XG4gICAgICAgIGlmIChyZW1vdmVkICE9PSB1bmRlZmluZWQgJiYgcmVtb3ZlZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmV0d29ya0ZpbHRlcnMsIGNvc21ldGljRmlsdGVycyB9ID0gcGFyc2VGaWx0ZXJzKHJlbW92ZWQuam9pbignXFxuJyksIHRoaXMuY29uZmlnKTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlbW92ZWRDb3NtZXRpY0ZpbHRlcnMsIGNvc21ldGljRmlsdGVycyk7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZW1vdmVkTmV0d29ya0ZpbHRlcnMsIG5ldHdvcmtGaWx0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkZWQgIT09IHVuZGVmaW5lZCAmJiBhZGRlZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmV0d29ya0ZpbHRlcnMsIGNvc21ldGljRmlsdGVycyB9ID0gcGFyc2VGaWx0ZXJzKGFkZGVkLmpvaW4oJ1xcbicpLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShuZXdDb3NtZXRpY0ZpbHRlcnMsIGNvc21ldGljRmlsdGVycyk7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShuZXdOZXR3b3JrRmlsdGVycywgbmV0d29ya0ZpbHRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVwcm9jZXNzb3JzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2NvbmRpdGlvbiwgZGV0YWlsc10gb2YgT2JqZWN0LmVudHJpZXMocHJlcHJvY2Vzc29ycykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGV0YWlscy5yZW1vdmVkICE9PSB1bmRlZmluZWQgJiYgZGV0YWlscy5yZW1vdmVkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG5ldHdvcmtGaWx0ZXJzLCBjb3NtZXRpY0ZpbHRlcnMgfSA9IHBhcnNlRmlsdGVycyhkZXRhaWxzLnJlbW92ZWQuam9pbignXFxuJyksIHRoaXMuY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVySURzID0gbmV3IFNldChbXVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChjb3NtZXRpY0ZpbHRlcnMubWFwKChmaWx0ZXIpID0+IGZpbHRlci5nZXRJZCgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQobmV0d29ya0ZpbHRlcnMubWFwKChmaWx0ZXIpID0+IGZpbHRlci5nZXRJZCgpKSkpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkUHJlcHJvY2Vzc29ycy5wdXNoKG5ldyBQcmVwcm9jZXNzb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVySURzLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZXRhaWxzLmFkZGVkICE9PSB1bmRlZmluZWQgJiYgZGV0YWlscy5hZGRlZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBuZXR3b3JrRmlsdGVycywgY29zbWV0aWNGaWx0ZXJzIH0gPSBwYXJzZUZpbHRlcnMoZGV0YWlscy5hZGRlZC5qb2luKCdcXG4nKSwgdGhpcy5jb25maWcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJJRHMgPSBuZXcgU2V0KFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGNvc21ldGljRmlsdGVycy5tYXAoKGZpbHRlcikgPT4gZmlsdGVyLmdldElkKCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChuZXR3b3JrRmlsdGVycy5tYXAoKGZpbHRlcikgPT4gZmlsdGVyLmdldElkKCkpKSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ByZXByb2Nlc3NvcnMucHVzaChuZXcgUHJlcHJvY2Vzc29yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcklEcyxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgbmV3Q29zbWV0aWNGaWx0ZXJzLFxuICAgICAgICAgICAgbmV3TmV0d29ya0ZpbHRlcnMsXG4gICAgICAgICAgICBuZXdQcmVwcm9jZXNzb3JzLFxuICAgICAgICAgICAgcmVtb3ZlZENvc21ldGljRmlsdGVyczogcmVtb3ZlZENvc21ldGljRmlsdGVycy5tYXAoKGYpID0+IGYuZ2V0SWQoKSksXG4gICAgICAgICAgICByZW1vdmVkTmV0d29ya0ZpbHRlcnM6IHJlbW92ZWROZXR3b3JrRmlsdGVycy5tYXAoKGYpID0+IGYuZ2V0SWQoKSksXG4gICAgICAgICAgICByZW1vdmVkUHJlcHJvY2Vzc29ycyxcbiAgICAgICAgfSwgZW52KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbGlzdCBvZiBIVE1MIGZpbHRlcmluZyBydWxlcy5cbiAgICAgKi9cbiAgICBnZXRIdG1sRmlsdGVycyhyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGh0bWxTZWxlY3RvcnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUh0bWxGaWx0ZXJpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbFNlbGVjdG9ycztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG5ldHdvcmtGaWx0ZXJzLCBleGNlcHRpb25zLCBjb3NtZXRpY0ZpbHRlcnMsIHVuaGlkZXMgfSA9IHRoaXMuaHRtbEZpbHRlcnMuZ2V0SFRNTEZpbHRlcnMocmVxdWVzdCwgdGhpcy5pc0ZpbHRlckV4Y2x1ZGVkLmJpbmQodGhpcykpO1xuICAgICAgICBpZiAoY29zbWV0aWNGaWx0ZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgY29uc3QgdW5oaWRlTWFwID0gbmV3IE1hcCh1bmhpZGVzLm1hcCgodW5oaWRlKSA9PiBbdW5oaWRlLmdldFNlbGVjdG9yKCksIHVuaGlkZV0pKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGNvc21ldGljRmlsdGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVuZGVkID0gZmlsdGVyLmdldEV4dGVuZGVkU2VsZWN0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdW5oaWRlID0gdW5oaWRlTWFwLmdldChmaWx0ZXIuZ2V0U2VsZWN0b3IoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHVuaGlkZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWxTZWxlY3RvcnMucHVzaChleHRlbmRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZmlsdGVyLW1hdGNoZWQnLCB7IGZpbHRlciwgZXhjZXB0aW9uOiB1bmhpZGUgfSwge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUeXBlOiBGaWx0ZXJUeXBlLkNPU01FVElDLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXR3b3JrRmlsdGVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGV4Y2VwdGlvbnNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBsZXQgcmVwbGFjZURpc2FibGVkRXhjZXB0aW9uO1xuICAgICAgICAgICAgZm9yIChjb25zdCBleGNlcHRpb24gb2YgZXhjZXB0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvblZhbHVlID0gZXhjZXB0aW9uLm9wdGlvblZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25WYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZURpc2FibGVkRXhjZXB0aW9uID0gZXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhjZXB0aW9uc01hcC5zZXQob3B0aW9uVmFsdWUsIGV4Y2VwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBuZXR3b3JrRmlsdGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVyID0gZmlsdGVyLmdldEh0bWxNb2RpZmllcigpO1xuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXhjZXB0aW9uID0gcmVwbGFjZURpc2FibGVkRXhjZXB0aW9uIHx8IGV4Y2VwdGlvbnNNYXAuZ2V0KGZpbHRlci5vcHRpb25WYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdmaWx0ZXItbWF0Y2hlZCcsIHsgZmlsdGVyLCBleGNlcHRpb24gfSwge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUeXBlOiBGaWx0ZXJUeXBlLk5FVFdPUkssXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4Y2VwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWxTZWxlY3RvcnMucHVzaChbJ3JlcGxhY2UnLCBtb2RpZmllcl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaHRtbFNlbGVjdG9ycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnaHRtbC1maWx0ZXJlZCcsIGh0bWxTZWxlY3RvcnMsIHJlcXVlc3QudXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbFNlbGVjdG9ycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYGhvc3RuYW1lYCBhbmQgYGRvbWFpbmAgb2YgYSBwYWdlIChvciBmcmFtZSksIHJldHVybiB0aGUgbGlzdCBvZlxuICAgICAqIHN0eWxlcyBhbmQgc2NyaXB0cyB0byBpbmplY3QgaW4gdGhlIHBhZ2UuXG4gICAgICovXG4gICAgZ2V0Q29zbWV0aWNzRmlsdGVycyh7IFxuICAgIC8vIFBhZ2UgaW5mb3JtYXRpb25cbiAgICB1cmwsIGhvc3RuYW1lLCBkb21haW4sIGFuY2VzdG9ycywgXG4gICAgLy8gRE9NIGluZm9ybWF0aW9uXG4gICAgY2xhc3NlcywgaHJlZnMsIGlkcywgXG4gICAgLy8gQWxsb3dzIHRvIHNwZWNpZnkgd2hpY2ggcnVsZXMgdG8gcmV0dXJuXG4gICAgZ2V0QmFzZVJ1bGVzID0gdHJ1ZSwgZ2V0SW5qZWN0aW9uUnVsZXMgPSB0cnVlLCBnZXRFeHRlbmRlZFJ1bGVzID0gdHJ1ZSwgZ2V0UnVsZXNGcm9tRE9NID0gdHJ1ZSwgZ2V0UnVsZXNGcm9tSG9zdG5hbWUgPSB0cnVlLCBoaWRpbmdTdHlsZSwgY2FsbGVyQ29udGV4dCwgfSkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubG9hZENvc21ldGljRmlsdGVycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBleHRlbmRlZDogW10sXG4gICAgICAgICAgICAgICAgc2NyaXB0czogW10sXG4gICAgICAgICAgICAgICAgc3R5bGVzOiAnJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBtYXRjaGVzLCBhbGxvd0dlbmVyaWNIaWRlcyB9ID0gdGhpcy5tYXRjaENvc21ldGljRmlsdGVycyh7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgICAgIGRvbWFpbixcbiAgICAgICAgICAgIGFuY2VzdG9ycyxcbiAgICAgICAgICAgIGNsYXNzZXMsXG4gICAgICAgICAgICBocmVmcyxcbiAgICAgICAgICAgIGlkcyxcbiAgICAgICAgICAgIGdldFJ1bGVzRnJvbURPTSxcbiAgICAgICAgICAgIGdldFJ1bGVzRnJvbUhvc3RuYW1lLFxuICAgICAgICAgICAgZ2V0SW5qZWN0aW9uUnVsZXMsXG4gICAgICAgICAgICBnZXRFeHRlbmRlZFJ1bGVzLFxuICAgICAgICAgICAgY2FsbGVyQ29udGV4dCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGZpbHRlciwgZXhjZXB0aW9uIH0gb2YgbWF0Y2hlcykge1xuICAgICAgICAgICAgaWYgKGZpbHRlciAhPT0gdW5kZWZpbmVkICYmIGV4Y2VwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBleHRlbmRlZCwgc2NyaXB0cywgc3R5bGVzIH0gPSB0aGlzLmluamVjdENvc21ldGljRmlsdGVycyhmaWx0ZXJzLCB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBpbmplY3RTY3JpcHRsZXRzOiBnZXRJbmplY3Rpb25SdWxlcyxcbiAgICAgICAgICAgIGluamVjdEV4dGVuZGVkOiBnZXRFeHRlbmRlZFJ1bGVzLFxuICAgICAgICAgICAgYWxsb3dHZW5lcmljSGlkZXMsXG4gICAgICAgICAgICBnZXRCYXNlUnVsZXMsXG4gICAgICAgICAgICBoaWRpbmdTdHlsZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICBleHRlbmRlZCxcbiAgICAgICAgICAgIHNjcmlwdHMsXG4gICAgICAgICAgICBzdHlsZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGNvc21ldGljIGZpbHRlcnMgdG8gYmUgaW5qZWN0ZWQgYnkgY29tcGlsaW5nIHRoZW0gdG8gc3R5bGVzaGVldHMsIHNjcmlwdHMgYW5kIGV4dGVudGVkIHNlbGVjdG9yIEFTVHMuXG4gICAgICovXG4gICAgaW5qZWN0Q29zbWV0aWNGaWx0ZXJzKGZpbHRlcnMsIHsgdXJsLCBpbmplY3RTdHlsZXMgPSB0cnVlLCBpbmplY3RTY3JpcHRsZXRzLCBpbmplY3RFeHRlbmRlZCwgYWxsb3dHZW5lcmljSGlkZXMgPSB0cnVlLCBnZXRCYXNlUnVsZXMsIGhpZGluZ1N0eWxlLCB9KSB7XG4gICAgICAgIGNvbnN0IHNjcmlwdHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc3R5bGVGaWx0ZXJzID0gW107XG4gICAgICAgIGNvbnN0IGV4dGVuZGVkRmlsdGVycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBmaWx0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoaW5qZWN0U2NyaXB0bGV0cyAmJiBmaWx0ZXIuaXNTY3JpcHRJbmplY3QoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IGZpbHRlci5nZXRTY3JpcHQodGhpcy5yZXNvdXJjZXMuZ2V0U2NyaXB0bGV0LmJpbmQodGhpcy5yZXNvdXJjZXMpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2NyaXB0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0cy5wdXNoKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyLmlzRXh0ZW5kZWQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmplY3RFeHRlbmRlZCA9PT0gdHJ1ZSAmJiB0aGlzLmNvbmZpZy5sb2FkRXh0ZW5kZWRTZWxlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRGaWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmplY3RTdHlsZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzdHlsZUZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlc2hlZXRzID0gdGhpcy5jb3NtZXRpY3MuZ2V0U3R5bGVzaGVldHNGcm9tRmlsdGVycyh7XG4gICAgICAgICAgICBmaWx0ZXJzOiBzdHlsZUZpbHRlcnMsXG4gICAgICAgICAgICBleHRlbmRlZEZpbHRlcnMsXG4gICAgICAgIH0sIHsgZ2V0QmFzZVJ1bGVzLCBhbGxvd0dlbmVyaWNIaWRlcywgaGlkaW5nU3R5bGUgfSk7XG4gICAgICAgIGZvciAoY29uc3Qgc2NyaXB0IG9mIHNjcmlwdHMpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc2NyaXB0LWluamVjdGVkJywgc2NyaXB0LCB1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZXNoZWV0cy5zdHlsZXNoZWV0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzdHlsZS1pbmplY3RlZCcsIHN0eWxlc2hlZXRzLnN0eWxlc2hlZXQsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4dGVuZGVkOiBzdHlsZXNoZWV0cy5leHRlbmRlZCxcbiAgICAgICAgICAgIHNjcmlwdHMsXG4gICAgICAgICAgICBzdHlsZXM6IHN0eWxlc2hlZXRzLnN0eWxlc2hlZXQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIG1hdGNoQ29zbWV0aWNGaWx0ZXJzKHsgXG4gICAgLy8gUGFnZSBpbmZvcm1hdGlvblxuICAgIHVybCwgaG9zdG5hbWUsIGRvbWFpbiwgYW5jZXN0b3JzLCBcbiAgICAvLyBET00gaW5mb3JtYXRpb25cbiAgICBjbGFzc2VzLCBocmVmcywgaWRzLCBnZXRSdWxlc0Zyb21ET00gPSB0cnVlLCBnZXRSdWxlc0Zyb21Ib3N0bmFtZSA9IHRydWUsIGdldEluamVjdGlvblJ1bGVzLCBnZXRFeHRlbmRlZFJ1bGVzLCBjYWxsZXJDb250ZXh0LCB9KSB7XG4gICAgICAgIGRvbWFpbiB8fCAoZG9tYWluID0gJycpO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgICAgIGNvbnN0IGV4Y2VwdGlvbnMgPSB0aGlzLmhpZGVFeGNlcHRpb25zLm1hdGNoQWxsKFJlcXVlc3QuZnJvbVJhd0RldGFpbHMoe1xuICAgICAgICAgICAgZG9tYWluLFxuICAgICAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBzb3VyY2VEb21haW46ICcnLFxuICAgICAgICAgICAgc291cmNlSG9zdG5hbWU6ICcnLFxuICAgICAgICAgICAgc291cmNlVXJsOiAnJyxcbiAgICAgICAgfSksIHRoaXMuaXNGaWx0ZXJFeGNsdWRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgY29uc3QgZ2VuZXJpY0hpZGVzID0gW107XG4gICAgICAgIGNvbnN0IHNwZWNpZmljSGlkZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgZXhjZXB0aW9ucykge1xuICAgICAgICAgICAgLy8gQSBmaWx0ZXIgY2FuIGJlIGJvdGggc3BlY2lmaWMgKCRzaGlkZSkgYW5kIGdlbmVyaWMgKCRnaGlkZSkuXG4gICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIGl0IGlzIGFuICRlbGVtaGlkZSwgYW5kIHdlIGhhdmUgdG8gY29uc2lkZXIgYm90aCBjYXNlcyBoZXJlIHRvIGNhbGN1bGF0ZSB0aGUgcHJpb3JpdHkgbGF0ZXIgb24uXG4gICAgICAgICAgICBpZiAoZmlsdGVyLmlzU3BlY2lmaWNIaWRlKCkpIHtcbiAgICAgICAgICAgICAgICBzcGVjaWZpY0hpZGVzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWx0ZXIuaXNHZW5lcmljSGlkZSgpKSB7XG4gICAgICAgICAgICAgICAgZ2VuZXJpY0hpZGVzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnZW5lcmljSGlkZUV4Y2VwdGlvbiA9IGZpbmRBcHBsaWNhYmxlSGlkZUV4Y2VwdGlvbihnZW5lcmljSGlkZXMpO1xuICAgICAgICBjb25zdCBzcGVjaWZpY0hpZGVFeGNlcHRpb24gPSBmaW5kQXBwbGljYWJsZUhpZGVFeGNlcHRpb24oc3BlY2lmaWNIaWRlcyk7XG4gICAgICAgIGlmIChnZW5lcmljSGlkZUV4Y2VwdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBleGNlcHRpb246IGdlbmVyaWNIaWRlRXhjZXB0aW9uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbHRlci1tYXRjaGVkJywgbWF0Y2gsIHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgY2FsbGVyQ29udGV4dCxcbiAgICAgICAgICAgICAgICBmaWx0ZXJUeXBlOiBGaWx0ZXJUeXBlLkNPU01FVElDLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwZWNpZmljSGlkZUV4Y2VwdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAvLyBUaGUgZmlsdGVyIGNhbiBiZSAkZWxlbWhpZGUgd2hpY2ggZ2V0IHNldCBib3RoIGZvciBnaGlkZSBhbmQgc2hpZGVcbiAgICAgICAgICAgIGdlbmVyaWNIaWRlRXhjZXB0aW9uICE9PSBzcGVjaWZpY0hpZGVFeGNlcHRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0ge1xuICAgICAgICAgICAgICAgIGZpbHRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGV4Y2VwdGlvbjogc3BlY2lmaWNIaWRlRXhjZXB0aW9uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbHRlci1tYXRjaGVkJywgbWF0Y2gsIHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgY2FsbGVyQ29udGV4dCxcbiAgICAgICAgICAgICAgICBmaWx0ZXJUeXBlOiBGaWx0ZXJUeXBlLkNPU01FVElDLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBmaWx0ZXJzLCB1bmhpZGVzIH0gPSB0aGlzLmNvc21ldGljcy5nZXRDb3NtZXRpY3NGaWx0ZXJzKHtcbiAgICAgICAgICAgIGRvbWFpbixcbiAgICAgICAgICAgIGhvc3RuYW1lLFxuICAgICAgICAgICAgYW5jZXN0b3JzLFxuICAgICAgICAgICAgY2xhc3NlcyxcbiAgICAgICAgICAgIGhyZWZzLFxuICAgICAgICAgICAgaWRzLFxuICAgICAgICAgICAgYWxsb3dHZW5lcmljSGlkZXM6IGdlbmVyaWNIaWRlRXhjZXB0aW9uID09PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBhbGxvd1NwZWNpZmljSGlkZXM6IHNwZWNpZmljSGlkZUV4Y2VwdGlvbiA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ2V0UnVsZXNGcm9tRE9NLFxuICAgICAgICAgICAgZ2V0UnVsZXNGcm9tSG9zdG5hbWUsXG4gICAgICAgICAgICBpc0ZpbHRlckV4Y2x1ZGVkOiB0aGlzLmlzRmlsdGVyRXhjbHVkZWQuYmluZCh0aGlzKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBpbmplY3Rpb25zRGlzYWJsZWRGaWx0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHVuaGlkZUV4Y2VwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgdW5oaWRlIG9mIHVuaGlkZXMpIHtcbiAgICAgICAgICAgIGlmICh1bmhpZGUuaXNTY3JpcHRJbmplY3QoKSA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAgIHVuaGlkZS5pc1VuaGlkZSgpID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgdW5oaWRlLmdldFNlbGVjdG9yKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaW5qZWN0aW9uc0Rpc2FibGVkRmlsdGVyID0gdW5oaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5oaWRlRXhjZXB0aW9ucy5zZXQobm9ybWFsaXplU2VsZWN0b3IodW5oaWRlLCB0aGlzLnJlc291cmNlcy5nZXRTY3JpcHRsZXRDYW5vbmljYWxOYW1lLmJpbmQodGhpcy5yZXNvdXJjZXMpKSwgdW5oaWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBmaWx0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmlzRXh0ZW5kZWQoKSAmJiBnZXRFeHRlbmRlZFJ1bGVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV4Y2VwdGlvbiA9IHVuaGlkZUV4Y2VwdGlvbnMuZ2V0KG5vcm1hbGl6ZVNlbGVjdG9yKGZpbHRlciwgdGhpcy5yZXNvdXJjZXMuZ2V0U2NyaXB0bGV0Q2Fub25pY2FsTmFtZS5iaW5kKHRoaXMucmVzb3VyY2VzKSkpO1xuICAgICAgICAgICAgaWYgKGZpbHRlci5pc1NjcmlwdEluamVjdCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluamVjdGlvbnNEaXNhYmxlZEZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbiA9IGluamVjdGlvbnNEaXNhYmxlZEZpbHRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdldEluamVjdGlvblJ1bGVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2goeyBmaWx0ZXIsIGV4Y2VwdGlvbiB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZmlsdGVyLW1hdGNoZWQnLCB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICAgIGV4Y2VwdGlvbixcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgY2FsbGVyQ29udGV4dCxcbiAgICAgICAgICAgICAgICBmaWx0ZXJUeXBlOiBGaWx0ZXJUeXBlLkNPU01FVElDLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICBhbGxvd0dlbmVyaWNIaWRlczogZ2VuZXJpY0hpZGVFeGNlcHRpb24gPT09IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBgcmVxdWVzdGAsIHJldHVybiBhbGwgbWF0Y2hpbmcgbmV0d29yayBmaWx0ZXJzIGZvdW5kIGluIHRoZSBlbmdpbmUuXG4gICAgICovXG4gICAgbWF0Y2hBbGwocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBmaWx0ZXJzID0gW107XG4gICAgICAgIGlmIChyZXF1ZXN0LmlzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShmaWx0ZXJzLCB0aGlzLmltcG9ydGFudHMubWF0Y2hBbGwocmVxdWVzdCwgdGhpcy5pc0ZpbHRlckV4Y2x1ZGVkLmJpbmQodGhpcykpKTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGZpbHRlcnMsIHRoaXMuZmlsdGVycy5tYXRjaEFsbChyZXF1ZXN0LCB0aGlzLmlzRmlsdGVyRXhjbHVkZWQuYmluZCh0aGlzKSkpO1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZmlsdGVycywgdGhpcy5leGNlcHRpb25zLm1hdGNoQWxsKHJlcXVlc3QsIHRoaXMuaXNGaWx0ZXJFeGNsdWRlZC5iaW5kKHRoaXMpKSk7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShmaWx0ZXJzLCB0aGlzLmNzcC5tYXRjaEFsbChyZXF1ZXN0LCB0aGlzLmlzRmlsdGVyRXhjbHVkZWQuYmluZCh0aGlzKSkpO1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZmlsdGVycywgdGhpcy5oaWRlRXhjZXB0aW9ucy5tYXRjaEFsbChyZXF1ZXN0LCB0aGlzLmlzRmlsdGVyRXhjbHVkZWQuYmluZCh0aGlzKSkpO1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZmlsdGVycywgdGhpcy5yZWRpcmVjdHMubWF0Y2hBbGwocmVxdWVzdCwgdGhpcy5pc0ZpbHRlckV4Y2x1ZGVkLmJpbmQodGhpcykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNldChmaWx0ZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBcIm1haW5fZnJhbWVcIiByZXF1ZXN0LCBjaGVjayBpZiBzb21lIGNvbnRlbnQgc2VjdXJpdHkgcG9saWNpZXNcbiAgICAgKiBzaG91bGQgYmUgaW5qZWN0ZWQgaW4gdGhlIHBhZ2UuXG4gICAgICovXG4gICAgZ2V0Q1NQRGlyZWN0aXZlcyhyZXF1ZXN0KSB7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcubG9hZE5ldHdvcmtGaWx0ZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0LmlzU3VwcG9ydGVkICE9PSB0cnVlIHx8IHJlcXVlc3QuaXNNYWluRnJhbWUoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuY3NwLm1hdGNoQWxsKHJlcXVlc3QsIHRoaXMuaXNGaWx0ZXJFeGNsdWRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gTm8gJGNzcCBmaWx0ZXIgZm91bmRcbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbGxlY3QgYWxsIENTUCBkaXJlY3RpdmVzIGFuZCBrZWVwIHRyYWNrIG9mIGV4Y2VwdGlvbnNcbiAgICAgICAgY29uc3QgY3NwRXhjZXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgY3NwRmlsdGVycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBtYXRjaGVzKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmlzRXhjZXB0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLmNzcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbCBDU1AgZGlyZWN0aXZlcyBhcmUgZGlzYWJsZWQgZm9yIHRoaXMgc2l0ZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbHRlci1tYXRjaGVkJywgeyBleGNlcHRpb246IGZpbHRlciB9LCB7IHJlcXVlc3QsIGZpbHRlclR5cGU6IEZpbHRlclR5cGUuTkVUV09SSyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3NwRXhjZXB0aW9ucy5zZXQoZmlsdGVyLmNzcCwgZmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNzcEZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjc3BGaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmFibGVkQ3NwID0gbmV3IFNldCgpO1xuICAgICAgICAvLyBDb21iaW5lIGFsbCBDU1BzIChleGNlcHQgdGhlIGJsYWNrLWxpc3RlZCBvbmVzKVxuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBjc3BGaWx0ZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBjb25zdCBleGNlcHRpb24gPSBjc3BFeGNlcHRpb25zLmdldChmaWx0ZXIuY3NwKTtcbiAgICAgICAgICAgIGlmIChleGNlcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVuYWJsZWRDc3AuYWRkKGZpbHRlci5jc3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdmaWx0ZXItbWF0Y2hlZCcsIHsgZmlsdGVyLCBleGNlcHRpb24gfSwgeyByZXF1ZXN0LCBmaWx0ZXJUeXBlOiBGaWx0ZXJUeXBlLk5FVFdPUksgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3NwcyA9IEFycmF5LmZyb20oZW5hYmxlZENzcCkuam9pbignOyAnKTtcbiAgICAgICAgaWYgKGNzcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjc3AtaW5qZWN0ZWQnLCByZXF1ZXN0LCBjc3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3NwcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjaWRlIGlmIGEgbmV0d29yayByZXF1ZXN0ICh1c3VhbGx5IGZyb20gV2ViUmVxdWVzdCBBUEkpIHNob3VsZCBiZVxuICAgICAqIGJsb2NrZWQsIHJlZGlyZWN0ZWQgb3IgYWxsb3dlZC5cbiAgICAgKi9cbiAgICBtYXRjaChyZXF1ZXN0LCB3aXRoTWV0YWRhdGEgPSBmYWxzZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGV4Y2VwdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsdGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtYXRjaDogZmFsc2UsXG4gICAgICAgICAgICByZWRpcmVjdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmV3cml0ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5sb2FkTmV0d29ya0ZpbHRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QuaXNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBmaWx0ZXJzIGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6XG4gICAgICAgICAgICAvLyAxLiAkaW1wb3J0YW50IChub3Qgc3ViamVjdCB0byBleGNlcHRpb25zKVxuICAgICAgICAgICAgLy8gMi4gcmVkaXJlY3Rpb24gKCRyZWRpcmVjdD1yZXNvdXJjZSlcbiAgICAgICAgICAgIC8vIDMuIG5vcm1hbCBmaWx0ZXJzXG4gICAgICAgICAgICAvLyA0LiBleGNlcHRpb25zXG4gICAgICAgICAgICAvLyA1LiB1cmwgcmV3cml0ZXMgKCRyZW1vdmVwYXJhbSlcbiAgICAgICAgICAgIHJlc3VsdC5maWx0ZXIgPSB0aGlzLmltcG9ydGFudHMubWF0Y2gocmVxdWVzdCwgdGhpcy5pc0ZpbHRlckV4Y2x1ZGVkLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgbGV0IHJlZGlyZWN0Tm9uZTtcbiAgICAgICAgICAgIGxldCByZWRpcmVjdFJ1bGU7XG4gICAgICAgICAgICAvLyBJZiBgcmVzdWx0LmZpbHRlcmAgaXMgYHVuZGVmaW5lZGAsIGl0IG1lYW5zIHRoZXJlIHdhcyBubyAkaW1wb3J0YW50XG4gICAgICAgICAgICAvLyBmaWx0ZXIgZm91bmQgc28gZmFyLiBXZSBsb29rIGZvciBhICRyZWRpcmVjdCBmaWx0ZXIuICBUaGVyZSBpcyBzb21lXG4gICAgICAgICAgICAvLyBleHRyYSBsb2dpYyB0byBoYW5kbGUgc3BlY2lhbCBjYXNlcyBsaWtlIHJlZGlyZWN0LXJ1bGUgYW5kXG4gICAgICAgICAgICAvLyByZWRpcmVjdD1ub25lLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICogSWYgcmVkaXJlY3Q9bm9uZSBpcyBmb3VuZCwgdGhlbiBjYW5jZWwgYWxsIHJlZGlyZWN0cy5cbiAgICAgICAgICAgIC8vICogRWxzZSBpZiByZWRpcmVjdC1ydWxlIGlzIGZvdW5kLCBvbmx5IHJlZGlyZWN0IGlmIHJlcXVlc3Qgd291bGQgYmUgYmxvY2tlZC5cbiAgICAgICAgICAgIC8vICogRWxzZSBpZiByZWRpcmVjdCBpcyBmb3VuZCwgcmVkaXJlY3QuXG4gICAgICAgICAgICBpZiAocmVzdWx0LmZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RzID0gdGhpcy5yZWRpcmVjdHNcbiAgICAgICAgICAgICAgICAgICAgLm1hdGNoQWxsKHJlcXVlc3QsIHRoaXMuaXNGaWx0ZXJFeGNsdWRlZC5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAvLyBoaWdoZXN0IHByaW9ydHkgd2luc1xuICAgICAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5nZXRSZWRpcmVjdFByaW9yaXR5KCkgLSBhLmdldFJlZGlyZWN0UHJpb3JpdHkoKSk7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgc29tZSBleHRyYSBsb2dpYyB0byBoYW5kbGUgc3BlY2lhbCBjYXNlcyBsaWtlXG4gICAgICAgICAgICAgICAgLy8gcmVkaXJlY3QtcnVsZSBhbmQgcmVkaXJlY3Q9bm9uZS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICogSWYgcmVkaXJlY3Q9bm9uZSBpcyBmb3VuZCwgdGhlbiBjYW5jZWwgYWxsIHJlZGlyZWN0cy5cbiAgICAgICAgICAgICAgICAvLyAqIEVsc2UgaWYgcmVkaXJlY3QtcnVsZSBpcyBmb3VuZCwgb25seSByZWRpcmVjdCBpZiByZXF1ZXN0IHdvdWxkIGJlIGJsb2NrZWQuXG4gICAgICAgICAgICAgICAgLy8gKiBFbHNlIGlmIHJlZGlyZWN0IGlzIGZvdW5kLCByZWRpcmVjdC5cbiAgICAgICAgICAgICAgICBpZiAocmVkaXJlY3RzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiByZWRpcmVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIuZ2V0UmVkaXJlY3RSZXNvdXJjZSgpID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcmVjdE5vbmUgPSBmaWx0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWx0ZXIuaXNSZWRpcmVjdFJ1bGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdFJ1bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFJ1bGUgPSBmaWx0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LmZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBgcmVzdWx0LmZpbHRlcmAgaXMgc3RpbGwgYHVuZGVmaW5lZGAsIGl0IG1lYW5zIHRoYXQgdGhlcmUgd2FzIG5vXG4gICAgICAgICAgICAgICAgLy8gcmVkaXJlY3Rpb24gcnVsZSB0cmlnZ2VyZWQgZm9yIHRoZSByZXF1ZXN0LiBXZSBsb29rIGZvciBhIG5vcm1hbFxuICAgICAgICAgICAgICAgIC8vIG1hdGNoLlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZmlsdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZpbHRlciA9IHRoaXMuZmlsdGVycy5tYXRjaChyZXF1ZXN0LCB0aGlzLmlzRmlsdGVyRXhjbHVkZWQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgbWF0Y2gsIGFuZCBhIGAkcmVkaXJlY3QtcnVsZWAgYXMgZm91bmQgcHJldmlvdXNseSxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSB0cmFuc2Zvcm0gdGhlIG1hdGNoIGludG8gYSByZWRpcmVjdCwgZm9sbG93aW5nIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBzZW1hbnRpY3Mgb2YgcmVkaXJlY3QtcnVsZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZGlyZWN0UnVsZSAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdC5maWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZpbHRlciA9IHJlZGlyZWN0UnVsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBlaXRoZXIgYSByZWRpcmVjdGlvbiBydWxlIG9yIGEgbm9ybWFsIG1hdGNoLCB0aGVuIGNoZWNrXG4gICAgICAgICAgICAgICAgLy8gZm9yIGV4Y2VwdGlvbnMgd2hpY2ggY291bGQgYXBwbHkgb24gdGhlIHJlcXVlc3QgYW5kIHVuLWJsb2NrIGl0LlxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmV4Y2VwdGlvbiA9IHRoaXMuZXhjZXB0aW9ucy5tYXRjaChyZXF1ZXN0LCB0aGlzLmlzRmlsdGVyRXhjbHVkZWQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IGlzIGFsbG93ZWQgaW4gYW55IHdheSwgd2UgbWF0Y2ggcmVxdWVzdCByZW1vdmVwYXJhbS5cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtU2VwYXJhdG9ySW5kZXggPSByZXF1ZXN0LnVybC5pbmRleE9mKCc/Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2hQYXJhbVNlcGFyYXRvckluZGV4ICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoUGFyYW1TZXBhcmF0b3JJbmRleCAhPT0gcmVxdWVzdC51cmwubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoUGFyYW1MaXRlcmFsID0gcmVxdWVzdC51cmwuc2xpY2Uoc2VhcmNoUGFyYW1TZXBhcmF0b3JJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHNlYXJjaFBhcmFtTGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSAkcmVtb3ZlcGFyYW0gZmlsdGVyczpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDFzdCBwcmlvcml0eTogQEB8fDxlbnRpdHk+JHJlbW92ZXBhcmFtXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAybmQgcHJpb3JpdHk6IHx8PGVudGl0eT4kcmVtb3ZlcGFyYW1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDNyZCBwcmlvcml0eTogQEB8fDxlbnRpdHk+JHJlbW92ZXBhcmFtPXhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDR0aCBwcmlvcml0eTogfHw8ZW50aXR5PiRyZW1vdmVwYXJhbT14XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVwYXJhbUZpbHRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVwYXJhbUV4Y2VwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiB0aGlzLnJlbW92ZXBhcmFtcy5tYXRjaEFsbChyZXF1ZXN0LCB0aGlzLmlzRmlsdGVyRXhjbHVkZWQuYmluZCh0aGlzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLmlzRXhjZXB0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlcGFyYW1FeGNlcHRpb25zLnNldChmaWx0ZXIucmVtb3ZlcGFyYW0sIGZpbHRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVwYXJhbUZpbHRlcnMuc2V0KGZpbHRlci5yZW1vdmVwYXJhbSwgZmlsdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVwYXJhbUlnbm9yZUZpbHRlciA9IFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYHJlc3VsdC5leGNlcHRpb25gIGlzIGNvbmRpdGlvbmFsbHkgbWF0Y2hlZCBvbmx5IGlmIGByZXN1bHQuZmlsdGVyYCBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0LmZpbHRlciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmV4Y2VwdGlvbnMubWF0Y2gocmVxdWVzdCwgdGhpcy5pc0ZpbHRlckV4Y2x1ZGVkLmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXN1bHQuZXhjZXB0aW9uKSB8fCByZW1vdmVwYXJhbUV4Y2VwdGlvbnMuZ2V0KCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgZmlsdGVyXSBvZiByZW1vdmVwYXJhbUZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIHBhcmFtcyBpbiBjYXNlIG9mIG9wdGlvbiB2YWx1ZSBpcyBlbXB0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSB3aWxsIG5vdCBtYXRjaCBpbmRpdmlkdWFsIGV4Y2VwdGlvbnMgc2luY2UgaXQgaGFzIGEgaGlnaGVyIHByaW9yaXR5IHRoYW4gdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIG5vbi1leGlzdGVuY2Ugb2YgZ2xvYmFsIGV4Y2VwdGlvbiwgd2Ugd2lsbCByZW1vdmUgYWxsIHBhcmFtcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZXBhcmFtSWdub3JlRmlsdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY29sbGVjdCBhbGwga2V5cyBiZWZvcmUgdGhlIGV4ZWN1dGlvbiBvZiBgZGVsZXRlKClgLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUnVubmluZyBgZGVsZXRlKClgIHdpbGwgaW5mZXJlbmNlIHdpdGggYW4gaXRlcmF0b3IgYW5kIGl0cyBpbm5lciBpbmRleC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIEFycmF5LmZyb20oc2VhcmNoUGFyYW1zLmtleXMoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hQYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdmaWx0ZXItbWF0Y2hlZCcsIHsgZmlsdGVyLCBleGNlcHRpb246IHJlbW92ZXBhcmFtSWdub3JlRmlsdGVyIH0sIHsgcmVxdWVzdCwgZmlsdGVyVHlwZTogRmlsdGVyVHlwZS5ORVRXT1JLIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXkuc3RhcnRzV2l0aCgnficpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBmaW5kIGA/JHtrZXl9YCBwYXR0ZXJuLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hQYXJhbUxpdGVyYWwuc2xpY2UoMSwga2V5Lmxlbmd0aCArIDEpICE9PSBrZXkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIXNlYXJjaFBhcmFtTGl0ZXJhbC5pbmNsdWRlcyhgJiR7a2V5fWApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGNlcHRpb24gPSAoX2EgPSByZW1vdmVwYXJhbUV4Y2VwdGlvbnMuZ2V0KGtleSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJlbW92ZXBhcmFtSWdub3JlRmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGNlcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgcmVtb3ZlcGFyYW0gaW52ZXJzaW9ucy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKCd+JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGludmVyc2lvbktleSA9IGtleS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2YgQXJyYXkuZnJvbShzZWFyY2hQYXJhbXMua2V5cygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbSAhPT0gaW52ZXJzaW9uS2V5ICYmICFyZW1vdmVwYXJhbUV4Y2VwdGlvbnMuaGFzKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hQYXJhbXMuZGVsZXRlKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbHRlci1tYXRjaGVkJywgeyBmaWx0ZXIsIGV4Y2VwdGlvbiB9LCB7IHJlcXVlc3QsIGZpbHRlclR5cGU6IEZpbHRlclR5cGUuTkVUV09SSyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1cmwgPSByZXF1ZXN0LnVybC5zbGljZSgwLCBzZWFyY2hQYXJhbVNlcGFyYXRvckluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoUGFyYW1zLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyBzZWFyY2hQYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJld3JpdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcmVkaXJlY3QgbWF0Y2ggYW5kIG5vIGV4Y2VwdGlvbiB3YXMgZm91bmQsIHRoZW4gd2VcbiAgICAgICAgICAgIC8vIHByb2NlZWQgYW5kIHByb2Nlc3MgdGhlIHJlZGlyZWN0IHJ1bGUuIFRoaXMgbWVhbnMgdHdvIHRoaW5nczpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAxLiBDaGVjayBpZiB0aGVyZSdzIGEgcmVtb3ZlcGFyYW0gZXhjZXB0aW9uIHdhcyBmb3VuZCwgd2hpY2ggYWN0cyBhcyBleGNlcHRpb24uXG4gICAgICAgICAgICAvLyAyLiBDaGVjayBpZiBhIHJlZGlyZWN0PW5vbmUgcnVsZSB3YXMgZm91bmQsIHdoaWNoIGFjdHMgYXMgZXhjZXB0aW9uLlxuICAgICAgICAgICAgLy8gMy4gSWYgbm8gZXhjZXB0aW9uIHdhcyBmb3VuZCwgcHJlcGFyZSBgcmVzdWx0LnJlZGlyZWN0YCByZXNwb25zZS5cbiAgICAgICAgICAgIGlmIChyZXN1bHQuZmlsdGVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICByZXN1bHQuZXhjZXB0aW9uID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICByZXN1bHQuZmlsdGVyLmlzUmVkaXJlY3QoKSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdE5vbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXhjZXB0aW9uID0gcmVkaXJlY3ROb25lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlZGlyZWN0ID0gdGhpcy5yZXNvdXJjZXMuZ2V0UmVzb3VyY2UocmVzdWx0LmZpbHRlci5nZXRSZWRpcmVjdFJlc291cmNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQubWF0Y2ggPSByZXN1bHQuZXhjZXB0aW9uID09PSB1bmRlZmluZWQgJiYgcmVzdWx0LmZpbHRlciAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocmVzdWx0LmZpbHRlcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdmaWx0ZXItbWF0Y2hlZCcsIHsgZmlsdGVyOiByZXN1bHQuZmlsdGVyLCBleGNlcHRpb246IHJlc3VsdC5leGNlcHRpb24gfSwgeyByZXF1ZXN0LCBmaWx0ZXJUeXBlOiBGaWx0ZXJUeXBlLk5FVFdPUksgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5leGNlcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXF1ZXN0LXdoaXRlbGlzdGVkJywgcmVxdWVzdCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXN1bHQucmVkaXJlY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXF1ZXN0LXJlZGlyZWN0ZWQnLCByZXF1ZXN0LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdC5maWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXF1ZXN0LWJsb2NrZWQnLCByZXF1ZXN0LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXF1ZXN0LWFsbG93ZWQnLCByZXF1ZXN0LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aXRoTWV0YWRhdGEgPT09IHRydWUgJiYgcmVzdWx0LmZpbHRlciAhPT0gdW5kZWZpbmVkICYmIHRoaXMubWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tZXRhZGF0YSA9IHRoaXMubWV0YWRhdGEuZnJvbUZpbHRlcihyZXN1bHQuZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXRQYXR0ZXJuTWV0YWRhdGEocmVxdWVzdCwgeyBnZXREb21haW5NZXRhZGF0YSA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlblBhdHRlcm5zID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBwYXR0ZXJucyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiB0aGlzLm1hdGNoQWxsKHJlcXVlc3QpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm5JbmZvIG9mIHRoaXMubWV0YWRhdGEuZnJvbUZpbHRlcihmaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWVuUGF0dGVybnMuaGFzKHBhdHRlcm5JbmZvLnBhdHRlcm4ua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBzZWVuUGF0dGVybnMuYWRkKHBhdHRlcm5JbmZvLnBhdHRlcm4ua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybnMucHVzaChwYXR0ZXJuSW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChnZXREb21haW5NZXRhZGF0YSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuSW5mbyBvZiB0aGlzLm1ldGFkYXRhLmZyb21Eb21haW4ocmVxdWVzdC5ob3N0bmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlZW5QYXR0ZXJucy5oYXMocGF0dGVybkluZm8ucGF0dGVybi5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5QYXR0ZXJucy5hZGQocGF0dGVybkluZm8ucGF0dGVybi5rZXkpO1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJucy5wdXNoKHBhdHRlcm5JbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdHRlcm5zO1xuICAgIH1cbiAgICBibG9ja1NjcmlwdHMoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRnJvbURpZmYoe1xuICAgICAgICAgICAgYWRkZWQ6IFtibG9jaygpLnNjcmlwdHMoKS5yZWRpcmVjdFRvKCdqYXZhc2NyaXB0JykudG9TdHJpbmcoKV0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYmxvY2tJbWFnZXMoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRnJvbURpZmYoe1xuICAgICAgICAgICAgYWRkZWQ6IFtibG9jaygpLmltYWdlcygpLnJlZGlyZWN0VG8oJ3BuZycpLnRvU3RyaW5nKCldLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJsb2NrTWVkaWFzKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUZyb21EaWZmKHtcbiAgICAgICAgICAgIGFkZGVkOiBbYmxvY2soKS5tZWRpYXMoKS5yZWRpcmVjdFRvKCdtcDQnKS50b1N0cmluZygpXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBibG9ja0ZyYW1lcygpIHtcbiAgICAgICAgdGhpcy51cGRhdGVGcm9tRGlmZih7XG4gICAgICAgICAgICBhZGRlZDogW2Jsb2NrKCkuZnJhbWVzKCkucmVkaXJlY3RUbygnaHRtbCcpLnRvU3RyaW5nKCldLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJsb2NrRm9udHMoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRnJvbURpZmYoe1xuICAgICAgICAgICAgYWRkZWQ6IFtibG9jaygpLmZvbnRzKCkudG9TdHJpbmcoKV0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYmxvY2tTdHlsZXMoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRnJvbURpZmYoe1xuICAgICAgICAgICAgYWRkZWQ6IFtibG9jaygpLnN0eWxlcygpLnRvU3RyaW5nKCldLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5naW5lLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/engine.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/map.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/engine/map.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompactMap: () => (/* binding */ CompactMap)\n/* harmony export */ });\n/* harmony import */ var _data_view_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data-view.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/data-view.js\");\n/* harmony import */ var _reverse_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reverse-index.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/reverse-index.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\nconst EMPTY_BUCKET = Number.MAX_SAFE_INTEGER >>> 0;\n/**\n * This is a simpler version of reverse-index data structure which implements\n * a simple Map-like class, backed by compact typed arrays. This means that\n * the structure can be serialized to a typed array very quickly and loaded\n * back instantly.\n */\nclass CompactMap {\n    static deserialize(buffer, deserialize) {\n        const tokensLookupIndexSize = buffer.getUint32();\n        const bucketsIndexSize = buffer.getUint32();\n        const numberOfValues = buffer.getUint32();\n        // Alignement to 4 bytes is important here since `view` (Uint8Array) can\n        // appear at any offset of `buffer`. But to be sure we can read back\n        // Uint32Array directly from raw buffer, the alignement has to be a\n        // multiple of 4. The same alignement is taken care of in `serialize`.\n        const view = _data_view_js__WEBPACK_IMPORTED_MODULE_0__.StaticDataView.fromUint8Array(buffer.getBytes(true /* align */), {\n            enableCompression: false,\n        });\n        const tokensLookupIndex = view.getUint32ArrayView(tokensLookupIndexSize);\n        const bucketsIndex = view.getUint32ArrayView(bucketsIndexSize);\n        const valuesIndexStart = view.pos;\n        view.seekZero(); // not strictly needed but make sure reverse index can be compared with deep equal\n        return new CompactMap({\n            deserialize,\n            // Left empty on purpose since we don't need these to deserialize (all\n            // the data is already in the serialized data).\n            values: [],\n            getKeys: () => [],\n            getSerializedSize: () => 0,\n            serialize: () => {\n                /* Empty */\n            },\n        }).updateInternals({\n            bucketsIndex,\n            valuesIndexStart,\n            numberOfValues,\n            tokensLookupIndex,\n            view,\n        });\n    }\n    constructor({ serialize, deserialize, getKeys, getSerializedSize, values, }) {\n        // In-memory cache used to keep track of metadata which has already been\n        // loaded from the compact representation (i.e.: this.view). It is not\n        // strictly necessary but will speed-up retrival of popular patterns\n        // (since we do not have to perform the lookup again).\n        this.cache = new Map();\n        this.bucketsIndex = _data_view_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_UINT32_ARRAY;\n        this.tokensLookupIndex = _data_view_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_UINT32_ARRAY;\n        this.valuesIndexStart = 0;\n        this.numberOfValues = 0;\n        this.view = _data_view_js__WEBPACK_IMPORTED_MODULE_0__.StaticDataView.empty({ enableCompression: false });\n        this.deserializeValue = deserialize;\n        if (values.length !== 0) {\n            const patternsKeys = [];\n            // Keep track of the final size of the buckets index. `bucketsIndexSize`\n            // is the number of indexed values, multiplied by 2 (since we store both\n            // the `key` a value is indexed with and the index of the value itself).\n            let bucketsIndexSize = 0;\n            // Create a list of all values which will be part of the map. This means\n            // computing an estimation of the buffer size needed to store this index.\n            let estimatedBufferSize = 0;\n            for (const value of values) {\n                estimatedBufferSize += getSerializedSize(value);\n            }\n            // No values given; reset to empty index and abort.\n            if (values.length === 0) {\n                this.updateInternals({\n                    bucketsIndex: _data_view_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_UINT32_ARRAY,\n                    valuesIndexStart: 0,\n                    numberOfValues: 0,\n                    tokensLookupIndex: _data_view_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_UINT32_ARRAY,\n                    view: _data_view_js__WEBPACK_IMPORTED_MODULE_0__.StaticDataView.empty({ enableCompression: false }),\n                });\n                return;\n            }\n            for (const value of values) {\n                // Get keys from `value` and store the result in `patternsKeys` which\n                // will be used in the next step to select the best key for each value.\n                const keys = getKeys(value);\n                patternsKeys.push(keys);\n                bucketsIndexSize += 2 * keys.length; // key + value index\n            }\n            // Add size of bucketsIndex to total size (x4 because these are 32 bits numbers)\n            estimatedBufferSize += bucketsIndexSize * 4;\n            // Prepare \"tokens index\" (see documentation in constructor of `ReverseIndex` class).\n            const tokensLookupIndexSize = Math.max(2, (0,_reverse_index_js__WEBPACK_IMPORTED_MODULE_1__.nextPow2)(values.length));\n            const mask = tokensLookupIndexSize - 1;\n            const suffixes = [];\n            for (let i = 0; i < tokensLookupIndexSize; i += 1) {\n                suffixes.push([]);\n            }\n            // Add size of tokensLookupIndex to total size (x4 because these are 32 bits numbers)\n            estimatedBufferSize += tokensLookupIndexSize * 4;\n            // At this point we know the number of bytes needed for the compact\n            // representation of this map (\"tokens index\" + \"buckets index\" +\n            // \"values index\"). We allocate it at once and proceed with populating it.\n            const buffer = _data_view_js__WEBPACK_IMPORTED_MODULE_0__.StaticDataView.allocate(estimatedBufferSize, { enableCompression: false });\n            const tokensLookupIndex = buffer.getUint32ArrayView(tokensLookupIndexSize);\n            const bucketsIndex = buffer.getUint32ArrayView(bucketsIndexSize);\n            const valuesIndexStart = buffer.getPos();\n            // For each value, find the best token (least seen) based on histogram.\n            // Since we are iterating again on the values, we populate \"values index\"\n            // in the same loop and keep track of their indices so that we can later\n            // populate \"buckets index\".\n            for (let i = 0; i < patternsKeys.length; i += 1) {\n                const value = values[i];\n                const keys = patternsKeys[i];\n                // Serialize this value and keep track of its index in the byte array;\n                // it will be used in \"buckets index\" to point to this value.\n                const valueIndex = buffer.pos;\n                serialize(value, buffer);\n                for (const key of keys) {\n                    // `key & mask` represents the N last bits of `key`. We group all\n                    // values indexed with the same `key` sharing the same N bits.\n                    suffixes[key & mask].push([key, valueIndex]);\n                }\n            }\n            // Populate \"tokens index\" and \"buckets index\" based on keys for each value.\n            let indexInBucketsIndex = 0;\n            for (let i = 0; i < tokensLookupIndexSize; i += 1) {\n                const valuesForMask = suffixes[i];\n                tokensLookupIndex[i] = indexInBucketsIndex;\n                for (const [token, valueIndex] of valuesForMask) {\n                    bucketsIndex[indexInBucketsIndex++] = token;\n                    bucketsIndex[indexInBucketsIndex++] = valueIndex;\n                }\n            }\n            // Update internals\n            this.updateInternals({\n                bucketsIndex,\n                valuesIndexStart,\n                numberOfValues: patternsKeys.length,\n                tokensLookupIndex,\n                view: buffer,\n            });\n        }\n    }\n    updateInternals({ bucketsIndex, valuesIndexStart, numberOfValues, tokensLookupIndex, view, }) {\n        this.bucketsIndex = bucketsIndex;\n        this.valuesIndexStart = valuesIndexStart;\n        this.numberOfValues = numberOfValues;\n        this.tokensLookupIndex = tokensLookupIndex;\n        this.view = view;\n        view.seekZero();\n        return this;\n    }\n    getValues() {\n        const values = [];\n        if (this.numberOfValues === 0) {\n            return values;\n        }\n        // set view cursor at the start of \"values index\"\n        this.view.setPos(this.valuesIndexStart);\n        for (let i = 0; i < this.numberOfValues; i += 1) {\n            values.push(this.deserializeValue(this.view));\n        }\n        this.view.seekZero();\n        return values;\n    }\n    /**\n     * Estimate the number of bytes needed to serialize this instance of `Map`.\n     */\n    getSerializedSize() {\n        // 12 = 4 bytes (tokensLookupIndex.length) + 4 bytes (bucketsIndex.length) + 4 bytes (numberOfValues)\n        return 12 + (0,_data_view_js__WEBPACK_IMPORTED_MODULE_0__.sizeOfBytes)(this.view.buffer, true /* align */);\n    }\n    /**\n     * Dump this index to `buffer`.\n     */\n    serialize(buffer) {\n        buffer.pushUint32(this.tokensLookupIndex.length);\n        buffer.pushUint32(this.bucketsIndex.length);\n        buffer.pushUint32(this.numberOfValues);\n        // Aligmenent is crucial here, see comment in `deserialize` for more info.\n        buffer.pushBytes(this.view.buffer, true /* align */);\n    }\n    get(key) {\n        const cachedValues = this.cache.get(key);\n        if (cachedValues !== undefined) {\n            return cachedValues;\n        }\n        const offset = key & (this.tokensLookupIndex.length - 1);\n        const startOfBucket = this.tokensLookupIndex[offset];\n        // We do not have any values for this token\n        if (startOfBucket === EMPTY_BUCKET) {\n            return [];\n        }\n        // Since we do not store explicitly the number of values in each\n        // \"bucket\", we check the index of the next one and use it to infer the\n        // number of values (each value being stored as a token + index to the\n        // \"values store\")\n        const endOfBucket = offset === this.tokensLookupIndex.length - 1\n            ? this.bucketsIndex.length\n            : this.tokensLookupIndex[offset + 1];\n        // Get indices of values indexed with `token`, if any.\n        const valuesIndices = [];\n        for (let i = startOfBucket; i < endOfBucket; i += 2) {\n            const currentToken = this.bucketsIndex[i];\n            if (currentToken === key) {\n                valuesIndices.push(this.bucketsIndex[i + 1]);\n            }\n        }\n        // No value indexed with `token`.\n        if (valuesIndices.length === 0) {\n            return []; // continue looking for a match\n        }\n        // If we have values for `token` then deserialize values in memory and\n        // create a `Bucket` instance to hold them for future access.\n        const values = [];\n        const view = this.view;\n        for (let i = 0; i < valuesIndices.length; i += 1) {\n            view.setPos(valuesIndices[i]);\n            values.push(this.deserializeValue(view));\n        }\n        this.cache.set(key, values);\n        return values;\n    }\n}\n//# sourceMappingURL=map.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvbWFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tGO0FBQ3BDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlEQUFjO0FBQ25DO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsNkRBQTZEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkRBQWtCO0FBQzlDLGlDQUFpQyw2REFBa0I7QUFDbkQ7QUFDQTtBQUNBLG9CQUFvQix5REFBYyxTQUFTLDBCQUEwQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0Esa0NBQWtDLDZEQUFrQjtBQUNwRDtBQUNBO0FBQ0EsdUNBQXVDLDZEQUFrQjtBQUN6RCwwQkFBMEIseURBQWMsU0FBUywwQkFBMEI7QUFDM0UsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDJEQUFRO0FBQzlEO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlEQUFjLGlDQUFpQywwQkFBMEI7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHNCQUFzQiwwRUFBMEU7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwREFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXIvZGlzdC9lc20vZW5naW5lL21hcC5qcz80OTdlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQgR2hvc3RlcnkgR21iSC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgU3RhdGljRGF0YVZpZXcsIHNpemVPZkJ5dGVzLCBFTVBUWV9VSU5UMzJfQVJSQVkgfSBmcm9tICcuLi9kYXRhLXZpZXcuanMnO1xuaW1wb3J0IHsgbmV4dFBvdzIgfSBmcm9tICcuL3JldmVyc2UtaW5kZXguanMnO1xuY29uc3QgRU1QVFlfQlVDS0VUID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgPj4+IDA7XG4vKipcbiAqIFRoaXMgaXMgYSBzaW1wbGVyIHZlcnNpb24gb2YgcmV2ZXJzZS1pbmRleCBkYXRhIHN0cnVjdHVyZSB3aGljaCBpbXBsZW1lbnRzXG4gKiBhIHNpbXBsZSBNYXAtbGlrZSBjbGFzcywgYmFja2VkIGJ5IGNvbXBhY3QgdHlwZWQgYXJyYXlzLiBUaGlzIG1lYW5zIHRoYXRcbiAqIHRoZSBzdHJ1Y3R1cmUgY2FuIGJlIHNlcmlhbGl6ZWQgdG8gYSB0eXBlZCBhcnJheSB2ZXJ5IHF1aWNrbHkgYW5kIGxvYWRlZFxuICogYmFjayBpbnN0YW50bHkuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb21wYWN0TWFwIHtcbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnVmZmVyLCBkZXNlcmlhbGl6ZSkge1xuICAgICAgICBjb25zdCB0b2tlbnNMb29rdXBJbmRleFNpemUgPSBidWZmZXIuZ2V0VWludDMyKCk7XG4gICAgICAgIGNvbnN0IGJ1Y2tldHNJbmRleFNpemUgPSBidWZmZXIuZ2V0VWludDMyKCk7XG4gICAgICAgIGNvbnN0IG51bWJlck9mVmFsdWVzID0gYnVmZmVyLmdldFVpbnQzMigpO1xuICAgICAgICAvLyBBbGlnbmVtZW50IHRvIDQgYnl0ZXMgaXMgaW1wb3J0YW50IGhlcmUgc2luY2UgYHZpZXdgIChVaW50OEFycmF5KSBjYW5cbiAgICAgICAgLy8gYXBwZWFyIGF0IGFueSBvZmZzZXQgb2YgYGJ1ZmZlcmAuIEJ1dCB0byBiZSBzdXJlIHdlIGNhbiByZWFkIGJhY2tcbiAgICAgICAgLy8gVWludDMyQXJyYXkgZGlyZWN0bHkgZnJvbSByYXcgYnVmZmVyLCB0aGUgYWxpZ25lbWVudCBoYXMgdG8gYmUgYVxuICAgICAgICAvLyBtdWx0aXBsZSBvZiA0LiBUaGUgc2FtZSBhbGlnbmVtZW50IGlzIHRha2VuIGNhcmUgb2YgaW4gYHNlcmlhbGl6ZWAuXG4gICAgICAgIGNvbnN0IHZpZXcgPSBTdGF0aWNEYXRhVmlldy5mcm9tVWludDhBcnJheShidWZmZXIuZ2V0Qnl0ZXModHJ1ZSAvKiBhbGlnbiAqLyksIHtcbiAgICAgICAgICAgIGVuYWJsZUNvbXByZXNzaW9uOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRva2Vuc0xvb2t1cEluZGV4ID0gdmlldy5nZXRVaW50MzJBcnJheVZpZXcodG9rZW5zTG9va3VwSW5kZXhTaXplKTtcbiAgICAgICAgY29uc3QgYnVja2V0c0luZGV4ID0gdmlldy5nZXRVaW50MzJBcnJheVZpZXcoYnVja2V0c0luZGV4U2l6ZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlc0luZGV4U3RhcnQgPSB2aWV3LnBvcztcbiAgICAgICAgdmlldy5zZWVrWmVybygpOyAvLyBub3Qgc3RyaWN0bHkgbmVlZGVkIGJ1dCBtYWtlIHN1cmUgcmV2ZXJzZSBpbmRleCBjYW4gYmUgY29tcGFyZWQgd2l0aCBkZWVwIGVxdWFsXG4gICAgICAgIHJldHVybiBuZXcgQ29tcGFjdE1hcCh7XG4gICAgICAgICAgICBkZXNlcmlhbGl6ZSxcbiAgICAgICAgICAgIC8vIExlZnQgZW1wdHkgb24gcHVycG9zZSBzaW5jZSB3ZSBkb24ndCBuZWVkIHRoZXNlIHRvIGRlc2VyaWFsaXplIChhbGxcbiAgICAgICAgICAgIC8vIHRoZSBkYXRhIGlzIGFscmVhZHkgaW4gdGhlIHNlcmlhbGl6ZWQgZGF0YSkuXG4gICAgICAgICAgICB2YWx1ZXM6IFtdLFxuICAgICAgICAgICAgZ2V0S2V5czogKCkgPT4gW10sXG4gICAgICAgICAgICBnZXRTZXJpYWxpemVkU2l6ZTogKCkgPT4gMCxcbiAgICAgICAgICAgIHNlcmlhbGl6ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8qIEVtcHR5ICovXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KS51cGRhdGVJbnRlcm5hbHMoe1xuICAgICAgICAgICAgYnVja2V0c0luZGV4LFxuICAgICAgICAgICAgdmFsdWVzSW5kZXhTdGFydCxcbiAgICAgICAgICAgIG51bWJlck9mVmFsdWVzLFxuICAgICAgICAgICAgdG9rZW5zTG9va3VwSW5kZXgsXG4gICAgICAgICAgICB2aWV3LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBnZXRLZXlzLCBnZXRTZXJpYWxpemVkU2l6ZSwgdmFsdWVzLCB9KSB7XG4gICAgICAgIC8vIEluLW1lbW9yeSBjYWNoZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgbWV0YWRhdGEgd2hpY2ggaGFzIGFscmVhZHkgYmVlblxuICAgICAgICAvLyBsb2FkZWQgZnJvbSB0aGUgY29tcGFjdCByZXByZXNlbnRhdGlvbiAoaS5lLjogdGhpcy52aWV3KS4gSXQgaXMgbm90XG4gICAgICAgIC8vIHN0cmljdGx5IG5lY2Vzc2FyeSBidXQgd2lsbCBzcGVlZC11cCByZXRyaXZhbCBvZiBwb3B1bGFyIHBhdHRlcm5zXG4gICAgICAgIC8vIChzaW5jZSB3ZSBkbyBub3QgaGF2ZSB0byBwZXJmb3JtIHRoZSBsb29rdXAgYWdhaW4pLlxuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmJ1Y2tldHNJbmRleCA9IEVNUFRZX1VJTlQzMl9BUlJBWTtcbiAgICAgICAgdGhpcy50b2tlbnNMb29rdXBJbmRleCA9IEVNUFRZX1VJTlQzMl9BUlJBWTtcbiAgICAgICAgdGhpcy52YWx1ZXNJbmRleFN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5udW1iZXJPZlZhbHVlcyA9IDA7XG4gICAgICAgIHRoaXMudmlldyA9IFN0YXRpY0RhdGFWaWV3LmVtcHR5KHsgZW5hYmxlQ29tcHJlc3Npb246IGZhbHNlIH0pO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplVmFsdWUgPSBkZXNlcmlhbGl6ZTtcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5zS2V5cyA9IFtdO1xuICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgZmluYWwgc2l6ZSBvZiB0aGUgYnVja2V0cyBpbmRleC4gYGJ1Y2tldHNJbmRleFNpemVgXG4gICAgICAgICAgICAvLyBpcyB0aGUgbnVtYmVyIG9mIGluZGV4ZWQgdmFsdWVzLCBtdWx0aXBsaWVkIGJ5IDIgKHNpbmNlIHdlIHN0b3JlIGJvdGhcbiAgICAgICAgICAgIC8vIHRoZSBga2V5YCBhIHZhbHVlIGlzIGluZGV4ZWQgd2l0aCBhbmQgdGhlIGluZGV4IG9mIHRoZSB2YWx1ZSBpdHNlbGYpLlxuICAgICAgICAgICAgbGV0IGJ1Y2tldHNJbmRleFNpemUgPSAwO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbGlzdCBvZiBhbGwgdmFsdWVzIHdoaWNoIHdpbGwgYmUgcGFydCBvZiB0aGUgbWFwLiBUaGlzIG1lYW5zXG4gICAgICAgICAgICAvLyBjb21wdXRpbmcgYW4gZXN0aW1hdGlvbiBvZiB0aGUgYnVmZmVyIHNpemUgbmVlZGVkIHRvIHN0b3JlIHRoaXMgaW5kZXguXG4gICAgICAgICAgICBsZXQgZXN0aW1hdGVkQnVmZmVyU2l6ZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGVzdGltYXRlZEJ1ZmZlclNpemUgKz0gZ2V0U2VyaWFsaXplZFNpemUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gdmFsdWVzIGdpdmVuOyByZXNldCB0byBlbXB0eSBpbmRleCBhbmQgYWJvcnQuXG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW50ZXJuYWxzKHtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0c0luZGV4OiBFTVBUWV9VSU5UMzJfQVJSQVksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc0luZGV4U3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIG51bWJlck9mVmFsdWVzOiAwLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnNMb29rdXBJbmRleDogRU1QVFlfVUlOVDMyX0FSUkFZLFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBTdGF0aWNEYXRhVmlldy5lbXB0eSh7IGVuYWJsZUNvbXByZXNzaW9uOiBmYWxzZSB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgIC8vIEdldCBrZXlzIGZyb20gYHZhbHVlYCBhbmQgc3RvcmUgdGhlIHJlc3VsdCBpbiBgcGF0dGVybnNLZXlzYCB3aGljaFxuICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgdXNlZCBpbiB0aGUgbmV4dCBzdGVwIHRvIHNlbGVjdCB0aGUgYmVzdCBrZXkgZm9yIGVhY2ggdmFsdWUuXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IGdldEtleXModmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhdHRlcm5zS2V5cy5wdXNoKGtleXMpO1xuICAgICAgICAgICAgICAgIGJ1Y2tldHNJbmRleFNpemUgKz0gMiAqIGtleXMubGVuZ3RoOyAvLyBrZXkgKyB2YWx1ZSBpbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHNpemUgb2YgYnVja2V0c0luZGV4IHRvIHRvdGFsIHNpemUgKHg0IGJlY2F1c2UgdGhlc2UgYXJlIDMyIGJpdHMgbnVtYmVycylcbiAgICAgICAgICAgIGVzdGltYXRlZEJ1ZmZlclNpemUgKz0gYnVja2V0c0luZGV4U2l6ZSAqIDQ7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIFwidG9rZW5zIGluZGV4XCIgKHNlZSBkb2N1bWVudGF0aW9uIGluIGNvbnN0cnVjdG9yIG9mIGBSZXZlcnNlSW5kZXhgIGNsYXNzKS5cbiAgICAgICAgICAgIGNvbnN0IHRva2Vuc0xvb2t1cEluZGV4U2l6ZSA9IE1hdGgubWF4KDIsIG5leHRQb3cyKHZhbHVlcy5sZW5ndGgpKTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSB0b2tlbnNMb29rdXBJbmRleFNpemUgLSAxO1xuICAgICAgICAgICAgY29uc3Qgc3VmZml4ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zTG9va3VwSW5kZXhTaXplOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBzdWZmaXhlcy5wdXNoKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBzaXplIG9mIHRva2Vuc0xvb2t1cEluZGV4IHRvIHRvdGFsIHNpemUgKHg0IGJlY2F1c2UgdGhlc2UgYXJlIDMyIGJpdHMgbnVtYmVycylcbiAgICAgICAgICAgIGVzdGltYXRlZEJ1ZmZlclNpemUgKz0gdG9rZW5zTG9va3VwSW5kZXhTaXplICogNDtcbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyB0aGUgbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCBmb3IgdGhlIGNvbXBhY3RcbiAgICAgICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbWFwIChcInRva2VucyBpbmRleFwiICsgXCJidWNrZXRzIGluZGV4XCIgK1xuICAgICAgICAgICAgLy8gXCJ2YWx1ZXMgaW5kZXhcIikuIFdlIGFsbG9jYXRlIGl0IGF0IG9uY2UgYW5kIHByb2NlZWQgd2l0aCBwb3B1bGF0aW5nIGl0LlxuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gU3RhdGljRGF0YVZpZXcuYWxsb2NhdGUoZXN0aW1hdGVkQnVmZmVyU2l6ZSwgeyBlbmFibGVDb21wcmVzc2lvbjogZmFsc2UgfSk7XG4gICAgICAgICAgICBjb25zdCB0b2tlbnNMb29rdXBJbmRleCA9IGJ1ZmZlci5nZXRVaW50MzJBcnJheVZpZXcodG9rZW5zTG9va3VwSW5kZXhTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1Y2tldHNJbmRleCA9IGJ1ZmZlci5nZXRVaW50MzJBcnJheVZpZXcoYnVja2V0c0luZGV4U2l6ZSk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXNJbmRleFN0YXJ0ID0gYnVmZmVyLmdldFBvcygpO1xuICAgICAgICAgICAgLy8gRm9yIGVhY2ggdmFsdWUsIGZpbmQgdGhlIGJlc3QgdG9rZW4gKGxlYXN0IHNlZW4pIGJhc2VkIG9uIGhpc3RvZ3JhbS5cbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGFyZSBpdGVyYXRpbmcgYWdhaW4gb24gdGhlIHZhbHVlcywgd2UgcG9wdWxhdGUgXCJ2YWx1ZXMgaW5kZXhcIlxuICAgICAgICAgICAgLy8gaW4gdGhlIHNhbWUgbG9vcCBhbmQga2VlcCB0cmFjayBvZiB0aGVpciBpbmRpY2VzIHNvIHRoYXQgd2UgY2FuIGxhdGVyXG4gICAgICAgICAgICAvLyBwb3B1bGF0ZSBcImJ1Y2tldHMgaW5kZXhcIi5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybnNLZXlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IHBhdHRlcm5zS2V5c1tpXTtcbiAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgdGhpcyB2YWx1ZSBhbmQga2VlcCB0cmFjayBvZiBpdHMgaW5kZXggaW4gdGhlIGJ5dGUgYXJyYXk7XG4gICAgICAgICAgICAgICAgLy8gaXQgd2lsbCBiZSB1c2VkIGluIFwiYnVja2V0cyBpbmRleFwiIHRvIHBvaW50IHRvIHRoaXMgdmFsdWUuXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVJbmRleCA9IGJ1ZmZlci5wb3M7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplKHZhbHVlLCBidWZmZXIpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYGtleSAmIG1hc2tgIHJlcHJlc2VudHMgdGhlIE4gbGFzdCBiaXRzIG9mIGBrZXlgLiBXZSBncm91cCBhbGxcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGluZGV4ZWQgd2l0aCB0aGUgc2FtZSBga2V5YCBzaGFyaW5nIHRoZSBzYW1lIE4gYml0cy5cbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ZXNba2V5ICYgbWFza10ucHVzaChba2V5LCB2YWx1ZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUG9wdWxhdGUgXCJ0b2tlbnMgaW5kZXhcIiBhbmQgXCJidWNrZXRzIGluZGV4XCIgYmFzZWQgb24ga2V5cyBmb3IgZWFjaCB2YWx1ZS5cbiAgICAgICAgICAgIGxldCBpbmRleEluQnVja2V0c0luZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zTG9va3VwSW5kZXhTaXplOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXNGb3JNYXNrID0gc3VmZml4ZXNbaV07XG4gICAgICAgICAgICAgICAgdG9rZW5zTG9va3VwSW5kZXhbaV0gPSBpbmRleEluQnVja2V0c0luZGV4O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3Rva2VuLCB2YWx1ZUluZGV4XSBvZiB2YWx1ZXNGb3JNYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldHNJbmRleFtpbmRleEluQnVja2V0c0luZGV4KytdID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldHNJbmRleFtpbmRleEluQnVja2V0c0luZGV4KytdID0gdmFsdWVJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgaW50ZXJuYWxzXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUludGVybmFscyh7XG4gICAgICAgICAgICAgICAgYnVja2V0c0luZGV4LFxuICAgICAgICAgICAgICAgIHZhbHVlc0luZGV4U3RhcnQsXG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZWYWx1ZXM6IHBhdHRlcm5zS2V5cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdG9rZW5zTG9va3VwSW5kZXgsXG4gICAgICAgICAgICAgICAgdmlldzogYnVmZmVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSW50ZXJuYWxzKHsgYnVja2V0c0luZGV4LCB2YWx1ZXNJbmRleFN0YXJ0LCBudW1iZXJPZlZhbHVlcywgdG9rZW5zTG9va3VwSW5kZXgsIHZpZXcsIH0pIHtcbiAgICAgICAgdGhpcy5idWNrZXRzSW5kZXggPSBidWNrZXRzSW5kZXg7XG4gICAgICAgIHRoaXMudmFsdWVzSW5kZXhTdGFydCA9IHZhbHVlc0luZGV4U3RhcnQ7XG4gICAgICAgIHRoaXMubnVtYmVyT2ZWYWx1ZXMgPSBudW1iZXJPZlZhbHVlcztcbiAgICAgICAgdGhpcy50b2tlbnNMb29rdXBJbmRleCA9IHRva2Vuc0xvb2t1cEluZGV4O1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB2aWV3LnNlZWtaZXJvKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRWYWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5udW1iZXJPZlZhbHVlcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdmlldyBjdXJzb3IgYXQgdGhlIHN0YXJ0IG9mIFwidmFsdWVzIGluZGV4XCJcbiAgICAgICAgdGhpcy52aWV3LnNldFBvcyh0aGlzLnZhbHVlc0luZGV4U3RhcnQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtYmVyT2ZWYWx1ZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5kZXNlcmlhbGl6ZVZhbHVlKHRoaXMudmlldykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlldy5zZWVrWmVybygpO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFc3RpbWF0ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCB0byBzZXJpYWxpemUgdGhpcyBpbnN0YW5jZSBvZiBgTWFwYC5cbiAgICAgKi9cbiAgICBnZXRTZXJpYWxpemVkU2l6ZSgpIHtcbiAgICAgICAgLy8gMTIgPSA0IGJ5dGVzICh0b2tlbnNMb29rdXBJbmRleC5sZW5ndGgpICsgNCBieXRlcyAoYnVja2V0c0luZGV4Lmxlbmd0aCkgKyA0IGJ5dGVzIChudW1iZXJPZlZhbHVlcylcbiAgICAgICAgcmV0dXJuIDEyICsgc2l6ZU9mQnl0ZXModGhpcy52aWV3LmJ1ZmZlciwgdHJ1ZSAvKiBhbGlnbiAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIER1bXAgdGhpcyBpbmRleCB0byBgYnVmZmVyYC5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoYnVmZmVyKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoVWludDMyKHRoaXMudG9rZW5zTG9va3VwSW5kZXgubGVuZ3RoKTtcbiAgICAgICAgYnVmZmVyLnB1c2hVaW50MzIodGhpcy5idWNrZXRzSW5kZXgubGVuZ3RoKTtcbiAgICAgICAgYnVmZmVyLnB1c2hVaW50MzIodGhpcy5udW1iZXJPZlZhbHVlcyk7XG4gICAgICAgIC8vIEFsaWdtZW5lbnQgaXMgY3J1Y2lhbCBoZXJlLCBzZWUgY29tbWVudCBpbiBgZGVzZXJpYWxpemVgIGZvciBtb3JlIGluZm8uXG4gICAgICAgIGJ1ZmZlci5wdXNoQnl0ZXModGhpcy52aWV3LmJ1ZmZlciwgdHJ1ZSAvKiBhbGlnbiAqLyk7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkVmFsdWVzID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZFZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkVmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGtleSAmICh0aGlzLnRva2Vuc0xvb2t1cEluZGV4Lmxlbmd0aCAtIDEpO1xuICAgICAgICBjb25zdCBzdGFydE9mQnVja2V0ID0gdGhpcy50b2tlbnNMb29rdXBJbmRleFtvZmZzZXRdO1xuICAgICAgICAvLyBXZSBkbyBub3QgaGF2ZSBhbnkgdmFsdWVzIGZvciB0aGlzIHRva2VuXG4gICAgICAgIGlmIChzdGFydE9mQnVja2V0ID09PSBFTVBUWV9CVUNLRVQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSB3ZSBkbyBub3Qgc3RvcmUgZXhwbGljaXRseSB0aGUgbnVtYmVyIG9mIHZhbHVlcyBpbiBlYWNoXG4gICAgICAgIC8vIFwiYnVja2V0XCIsIHdlIGNoZWNrIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBvbmUgYW5kIHVzZSBpdCB0byBpbmZlciB0aGVcbiAgICAgICAgLy8gbnVtYmVyIG9mIHZhbHVlcyAoZWFjaCB2YWx1ZSBiZWluZyBzdG9yZWQgYXMgYSB0b2tlbiArIGluZGV4IHRvIHRoZVxuICAgICAgICAvLyBcInZhbHVlcyBzdG9yZVwiKVxuICAgICAgICBjb25zdCBlbmRPZkJ1Y2tldCA9IG9mZnNldCA9PT0gdGhpcy50b2tlbnNMb29rdXBJbmRleC5sZW5ndGggLSAxXG4gICAgICAgICAgICA/IHRoaXMuYnVja2V0c0luZGV4Lmxlbmd0aFxuICAgICAgICAgICAgOiB0aGlzLnRva2Vuc0xvb2t1cEluZGV4W29mZnNldCArIDFdO1xuICAgICAgICAvLyBHZXQgaW5kaWNlcyBvZiB2YWx1ZXMgaW5kZXhlZCB3aXRoIGB0b2tlbmAsIGlmIGFueS5cbiAgICAgICAgY29uc3QgdmFsdWVzSW5kaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRPZkJ1Y2tldDsgaSA8IGVuZE9mQnVja2V0OyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUb2tlbiA9IHRoaXMuYnVja2V0c0luZGV4W2ldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRUb2tlbiA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzSW5kaWNlcy5wdXNoKHRoaXMuYnVja2V0c0luZGV4W2kgKyAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gdmFsdWUgaW5kZXhlZCB3aXRoIGB0b2tlbmAuXG4gICAgICAgIGlmICh2YWx1ZXNJbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBjb250aW51ZSBsb29raW5nIGZvciBhIG1hdGNoXG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSB2YWx1ZXMgZm9yIGB0b2tlbmAgdGhlbiBkZXNlcmlhbGl6ZSB2YWx1ZXMgaW4gbWVtb3J5IGFuZFxuICAgICAgICAvLyBjcmVhdGUgYSBgQnVja2V0YCBpbnN0YW5jZSB0byBob2xkIHRoZW0gZm9yIGZ1dHVyZSBhY2Nlc3MuXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy52aWV3O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlc0luZGljZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZpZXcuc2V0UG9zKHZhbHVlc0luZGljZXNbaV0pO1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5kZXNlcmlhbGl6ZVZhbHVlKHZpZXcpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlcyk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/map.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/metadata.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/engine/metadata.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Metadata: () => (/* binding */ Metadata)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/map.js\");\n/* harmony import */ var _filters_network_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../filters/network.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/network.js\");\n/* harmony import */ var _metadata_categories_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./metadata/categories.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/metadata/categories.js\");\n/* harmony import */ var _metadata_organizations_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./metadata/organizations.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/metadata/organizations.js\");\n/* harmony import */ var _metadata_patterns_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./metadata/patterns.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/metadata/patterns.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n// Optionally, we can also compress their names and descriptions but I think that should not be necessary as it's probably pretty small.\n// Usage in MV3 extension\n// ======================\n// 1. The extension will load the binary engine containing metadata and store it locally\n// 2. Either on webRequest events or DNR filter IDs (requires to synchronize the IDs), we tag the request with their metadata\n// (2.) At runtime, we will either feed it a request and we expect to get metadata (match, get filter, then from filter ID, get metadata)\n//    Or we feed it the filter ID directly, from the DNR engine (but then it means we need to use the filter hash as an ID there as well and hope for no collision)\nclass Metadata {\n    static deserialize(buffer) {\n        const metadata = new Metadata(null);\n        metadata.categories = _map_js__WEBPACK_IMPORTED_MODULE_0__.CompactMap.deserialize(buffer, _metadata_categories_js__WEBPACK_IMPORTED_MODULE_2__.deserialize);\n        metadata.organizations = _map_js__WEBPACK_IMPORTED_MODULE_0__.CompactMap.deserialize(buffer, _metadata_organizations_js__WEBPACK_IMPORTED_MODULE_3__.deserialize);\n        metadata.patterns = _map_js__WEBPACK_IMPORTED_MODULE_0__.CompactMap.deserialize(buffer, _metadata_patterns_js__WEBPACK_IMPORTED_MODULE_4__.deserialize);\n        return metadata;\n    }\n    constructor(rawTrackerDB) {\n        if (!rawTrackerDB) {\n            this.organizations = (0,_metadata_organizations_js__WEBPACK_IMPORTED_MODULE_3__.createMap)([]);\n            this.categories = (0,_metadata_categories_js__WEBPACK_IMPORTED_MODULE_2__.createMap)([]);\n            this.patterns = (0,_metadata_patterns_js__WEBPACK_IMPORTED_MODULE_4__.createMap)([]);\n            return;\n        }\n        const { patterns: rawPatterns, organizations: rawOrganizations, categories: rawCategories, } = rawTrackerDB;\n        // Type-check categories\n        const categories = [];\n        if (typeof rawCategories === 'object') {\n            for (const [key, category] of Object.entries(rawCategories)) {\n                if (typeof category !== 'object') {\n                    continue;\n                }\n                const categoryWithKey = { key, ...category };\n                if ((0,_metadata_categories_js__WEBPACK_IMPORTED_MODULE_2__.isValid)(categoryWithKey)) {\n                    categories.push(categoryWithKey);\n                }\n                else {\n                    console.error('?? invalid category', categoryWithKey);\n                }\n            }\n        }\n        this.categories = (0,_metadata_categories_js__WEBPACK_IMPORTED_MODULE_2__.createMap)(categories);\n        // Type-check organizations\n        const organizations = [];\n        if (typeof rawOrganizations === 'object') {\n            for (const [key, organization] of Object.entries(rawOrganizations)) {\n                if (typeof organization !== 'object') {\n                    continue;\n                }\n                const organizationWithKey = { key, ...organization };\n                if ((0,_metadata_organizations_js__WEBPACK_IMPORTED_MODULE_3__.isValid)(organizationWithKey)) {\n                    organizations.push(organizationWithKey);\n                }\n                else {\n                    console.error('?? invalid organization', organizationWithKey);\n                }\n            }\n        }\n        this.organizations = (0,_metadata_organizations_js__WEBPACK_IMPORTED_MODULE_3__.createMap)(organizations);\n        // Type-check patterns\n        const patterns = [];\n        if (typeof rawPatterns === 'object') {\n            for (const [key, pattern] of Object.entries(rawPatterns)) {\n                if (typeof pattern !== 'object') {\n                    continue;\n                }\n                const patternWithKey = { key, ...pattern };\n                if ((0,_metadata_patterns_js__WEBPACK_IMPORTED_MODULE_4__.isValid)(patternWithKey)) {\n                    patterns.push(patternWithKey);\n                }\n                else {\n                    console.error('?? invalid pattern', patternWithKey);\n                }\n            }\n        }\n        this.patterns = (0,_metadata_patterns_js__WEBPACK_IMPORTED_MODULE_4__.createMap)(patterns);\n    }\n    getCategories() {\n        return this.categories.getValues();\n    }\n    getOrganizations() {\n        return this.organizations.getValues();\n    }\n    getPatterns() {\n        return this.patterns.getValues();\n    }\n    /**\n     * Estimate the total serialized size of this Metadata instance.\n     */\n    getSerializedSize() {\n        return (this.categories.getSerializedSize() +\n            this.organizations.getSerializedSize() +\n            this.patterns.getSerializedSize());\n    }\n    /**\n     * Serialize this instance of Metadata into `view`\n     */\n    serialize(buffer) {\n        this.categories.serialize(buffer);\n        this.organizations.serialize(buffer);\n        this.patterns.serialize(buffer);\n    }\n    /**\n     * Given an instance of NetworkFilter, retrieve pattern, organization and\n     * category information.\n     */\n    fromFilter(filter) {\n        return this.fromId(filter.getId());\n    }\n    /**\n     * Given a domain, retrieve pattern, organization and category information.\n     */\n    fromDomain(domain) {\n        const domainParts = domain.split('.');\n        for (; domainParts.length >= 2; domainParts.shift()) {\n            const subdomain = domainParts.join('.');\n            const parsedDomainFilter = _filters_network_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].parse(`||${subdomain}^`);\n            if (parsedDomainFilter === null) {\n                continue;\n            }\n            const patterns = this.fromId(parsedDomainFilter.getId());\n            if (patterns.length > 0) {\n                return patterns;\n            }\n        }\n        return [];\n    }\n    /**\n     * Given an `id` from filter, retrieve using the NetworkFilter.getId() method,\n     * lookup associated patterns (including organization and category) in an\n     * efficient way.\n     */\n    fromId(id) {\n        var _a, _b;\n        const results = [];\n        for (const pattern of this.patterns.get(id)) {\n            results.push({\n                pattern,\n                category: (_a = this.categories.get((0,_metadata_categories_js__WEBPACK_IMPORTED_MODULE_2__.getKey)({ key: pattern.category }))) === null || _a === void 0 ? void 0 : _a[0],\n                organization: pattern.organization !== null\n                    ? (_b = this.organizations.get((0,_metadata_organizations_js__WEBPACK_IMPORTED_MODULE_3__.getKey)({ key: pattern.organization }))) === null || _b === void 0 ? void 0 : _b[0]\n                    : null,\n            });\n        }\n        return results;\n    }\n}\n//# sourceMappingURL=metadata.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvbWV0YWRhdGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0M7QUFDWTtBQUNxSDtBQUNrQjtBQUNsRDtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBVSxxQkFBcUIsZ0VBQW1CO0FBQ2hGLGlDQUFpQywrQ0FBVSxxQkFBcUIsbUVBQXVCO0FBQ3ZGLDRCQUE0QiwrQ0FBVSxxQkFBcUIsOERBQWtCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFFQUFzQjtBQUN2RCw4QkFBOEIsa0VBQW1CO0FBQ2pELDRCQUE0QixnRUFBaUI7QUFDN0M7QUFDQTtBQUNBLGdCQUFnQixxRkFBcUY7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsb0JBQW9CLGdFQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtFQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxvQkFBb0IsbUVBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFFQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxvQkFBb0IsOERBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBLHVDQUF1QywyREFBYSxZQUFZLFVBQVU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELCtEQUFjLEdBQUcsdUJBQXVCO0FBQzVGO0FBQ0EsbURBQW1ELGtFQUFrQixHQUFHLDJCQUEyQjtBQUNuRztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvbWV0YWRhdGEuanM/NmRmOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50IEdob3N0ZXJ5IEdtYkguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmltcG9ydCB7IENvbXBhY3RNYXAgfSBmcm9tICcuL21hcC5qcyc7XG5pbXBvcnQgTmV0d29ya0ZpbHRlciBmcm9tICcuLi9maWx0ZXJzL25ldHdvcmsuanMnO1xuaW1wb3J0IHsgY3JlYXRlTWFwIGFzIGNyZWF0ZUNhdGVnb3JpZXNNYXAsIGlzVmFsaWQgYXMgaXNWYWxpZENhdGVnb3J5LCBkZXNlcmlhbGl6ZSBhcyBkZXNlcmlhbGl6ZUNhdGVnb3J5LCBnZXRLZXkgYXMgZ2V0Q2F0ZWdvcnlLZXksIH0gZnJvbSAnLi9tZXRhZGF0YS9jYXRlZ29yaWVzLmpzJztcbmltcG9ydCB7IGNyZWF0ZU1hcCBhcyBjcmVhdGVPcmdhbml6YXRpb25zTWFwLCBpc1ZhbGlkIGFzIGlzVmFsaWRPcmdhbml6YXRpb24sIGRlc2VyaWFsaXplIGFzIGRlc2VyaWFsaXplT3JnYW5pemF0aW9uLCBnZXRLZXkgYXMgZ2V0T3JnYW5pemF0aW9uS2V5LCB9IGZyb20gJy4vbWV0YWRhdGEvb3JnYW5pemF0aW9ucy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVNYXAgYXMgY3JlYXRlUGF0dGVybnNNYXAsIGlzVmFsaWQgYXMgaXNWYWxpZFBhdHRlcm4sIGRlc2VyaWFsaXplIGFzIGRlc2VyaWFsaXplUGF0dGVybiwgfSBmcm9tICcuL21ldGFkYXRhL3BhdHRlcm5zLmpzJztcbi8vIE9wdGlvbmFsbHksIHdlIGNhbiBhbHNvIGNvbXByZXNzIHRoZWlyIG5hbWVzIGFuZCBkZXNjcmlwdGlvbnMgYnV0IEkgdGhpbmsgdGhhdCBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSBhcyBpdCdzIHByb2JhYmx5IHByZXR0eSBzbWFsbC5cbi8vIFVzYWdlIGluIE1WMyBleHRlbnNpb25cbi8vID09PT09PT09PT09PT09PT09PT09PT1cbi8vIDEuIFRoZSBleHRlbnNpb24gd2lsbCBsb2FkIHRoZSBiaW5hcnkgZW5naW5lIGNvbnRhaW5pbmcgbWV0YWRhdGEgYW5kIHN0b3JlIGl0IGxvY2FsbHlcbi8vIDIuIEVpdGhlciBvbiB3ZWJSZXF1ZXN0IGV2ZW50cyBvciBETlIgZmlsdGVyIElEcyAocmVxdWlyZXMgdG8gc3luY2hyb25pemUgdGhlIElEcyksIHdlIHRhZyB0aGUgcmVxdWVzdCB3aXRoIHRoZWlyIG1ldGFkYXRhXG4vLyAoMi4pIEF0IHJ1bnRpbWUsIHdlIHdpbGwgZWl0aGVyIGZlZWQgaXQgYSByZXF1ZXN0IGFuZCB3ZSBleHBlY3QgdG8gZ2V0IG1ldGFkYXRhIChtYXRjaCwgZ2V0IGZpbHRlciwgdGhlbiBmcm9tIGZpbHRlciBJRCwgZ2V0IG1ldGFkYXRhKVxuLy8gICAgT3Igd2UgZmVlZCBpdCB0aGUgZmlsdGVyIElEIGRpcmVjdGx5LCBmcm9tIHRoZSBETlIgZW5naW5lIChidXQgdGhlbiBpdCBtZWFucyB3ZSBuZWVkIHRvIHVzZSB0aGUgZmlsdGVyIGhhc2ggYXMgYW4gSUQgdGhlcmUgYXMgd2VsbCBhbmQgaG9wZSBmb3Igbm8gY29sbGlzaW9uKVxuZXhwb3J0IGNsYXNzIE1ldGFkYXRhIHtcbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gbmV3IE1ldGFkYXRhKG51bGwpO1xuICAgICAgICBtZXRhZGF0YS5jYXRlZ29yaWVzID0gQ29tcGFjdE1hcC5kZXNlcmlhbGl6ZShidWZmZXIsIGRlc2VyaWFsaXplQ2F0ZWdvcnkpO1xuICAgICAgICBtZXRhZGF0YS5vcmdhbml6YXRpb25zID0gQ29tcGFjdE1hcC5kZXNlcmlhbGl6ZShidWZmZXIsIGRlc2VyaWFsaXplT3JnYW5pemF0aW9uKTtcbiAgICAgICAgbWV0YWRhdGEucGF0dGVybnMgPSBDb21wYWN0TWFwLmRlc2VyaWFsaXplKGJ1ZmZlciwgZGVzZXJpYWxpemVQYXR0ZXJuKTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihyYXdUcmFja2VyREIpIHtcbiAgICAgICAgaWYgKCFyYXdUcmFja2VyREIpIHtcbiAgICAgICAgICAgIHRoaXMub3JnYW5pemF0aW9ucyA9IGNyZWF0ZU9yZ2FuaXphdGlvbnNNYXAoW10pO1xuICAgICAgICAgICAgdGhpcy5jYXRlZ29yaWVzID0gY3JlYXRlQ2F0ZWdvcmllc01hcChbXSk7XG4gICAgICAgICAgICB0aGlzLnBhdHRlcm5zID0gY3JlYXRlUGF0dGVybnNNYXAoW10pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcGF0dGVybnM6IHJhd1BhdHRlcm5zLCBvcmdhbml6YXRpb25zOiByYXdPcmdhbml6YXRpb25zLCBjYXRlZ29yaWVzOiByYXdDYXRlZ29yaWVzLCB9ID0gcmF3VHJhY2tlckRCO1xuICAgICAgICAvLyBUeXBlLWNoZWNrIGNhdGVnb3JpZXNcbiAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBpZiAodHlwZW9mIHJhd0NhdGVnb3JpZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGNhdGVnb3J5XSBvZiBPYmplY3QuZW50cmllcyhyYXdDYXRlZ29yaWVzKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2F0ZWdvcnkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYXRlZ29yeVdpdGhLZXkgPSB7IGtleSwgLi4uY2F0ZWdvcnkgfTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZENhdGVnb3J5KGNhdGVnb3J5V2l0aEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllcy5wdXNoKGNhdGVnb3J5V2l0aEtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCc/PyBpbnZhbGlkIGNhdGVnb3J5JywgY2F0ZWdvcnlXaXRoS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYXRlZ29yaWVzID0gY3JlYXRlQ2F0ZWdvcmllc01hcChjYXRlZ29yaWVzKTtcbiAgICAgICAgLy8gVHlwZS1jaGVjayBvcmdhbml6YXRpb25zXG4gICAgICAgIGNvbnN0IG9yZ2FuaXphdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiByYXdPcmdhbml6YXRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCBvcmdhbml6YXRpb25dIG9mIE9iamVjdC5lbnRyaWVzKHJhd09yZ2FuaXphdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmdhbml6YXRpb24gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvcmdhbml6YXRpb25XaXRoS2V5ID0geyBrZXksIC4uLm9yZ2FuaXphdGlvbiB9O1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkT3JnYW5pemF0aW9uKG9yZ2FuaXphdGlvbldpdGhLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZ2FuaXphdGlvbnMucHVzaChvcmdhbml6YXRpb25XaXRoS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJz8/IGludmFsaWQgb3JnYW5pemF0aW9uJywgb3JnYW5pemF0aW9uV2l0aEtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3JnYW5pemF0aW9ucyA9IGNyZWF0ZU9yZ2FuaXphdGlvbnNNYXAob3JnYW5pemF0aW9ucyk7XG4gICAgICAgIC8vIFR5cGUtY2hlY2sgcGF0dGVybnNcbiAgICAgICAgY29uc3QgcGF0dGVybnMgPSBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiByYXdQYXR0ZXJucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgcGF0dGVybl0gb2YgT2JqZWN0LmVudHJpZXMocmF3UGF0dGVybnMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybldpdGhLZXkgPSB7IGtleSwgLi4ucGF0dGVybiB9O1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkUGF0dGVybihwYXR0ZXJuV2l0aEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybnMucHVzaChwYXR0ZXJuV2l0aEtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCc/PyBpbnZhbGlkIHBhdHRlcm4nLCBwYXR0ZXJuV2l0aEtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0dGVybnMgPSBjcmVhdGVQYXR0ZXJuc01hcChwYXR0ZXJucyk7XG4gICAgfVxuICAgIGdldENhdGVnb3JpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhdGVnb3JpZXMuZ2V0VmFsdWVzKCk7XG4gICAgfVxuICAgIGdldE9yZ2FuaXphdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yZ2FuaXphdGlvbnMuZ2V0VmFsdWVzKCk7XG4gICAgfVxuICAgIGdldFBhdHRlcm5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXR0ZXJucy5nZXRWYWx1ZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXN0aW1hdGUgdGhlIHRvdGFsIHNlcmlhbGl6ZWQgc2l6ZSBvZiB0aGlzIE1ldGFkYXRhIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldFNlcmlhbGl6ZWRTaXplKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuY2F0ZWdvcmllcy5nZXRTZXJpYWxpemVkU2l6ZSgpICtcbiAgICAgICAgICAgIHRoaXMub3JnYW5pemF0aW9ucy5nZXRTZXJpYWxpemVkU2l6ZSgpICtcbiAgICAgICAgICAgIHRoaXMucGF0dGVybnMuZ2V0U2VyaWFsaXplZFNpemUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGlzIGluc3RhbmNlIG9mIE1ldGFkYXRhIGludG8gYHZpZXdgXG4gICAgICovXG4gICAgc2VyaWFsaXplKGJ1ZmZlcikge1xuICAgICAgICB0aGlzLmNhdGVnb3JpZXMuc2VyaWFsaXplKGJ1ZmZlcik7XG4gICAgICAgIHRoaXMub3JnYW5pemF0aW9ucy5zZXJpYWxpemUoYnVmZmVyKTtcbiAgICAgICAgdGhpcy5wYXR0ZXJucy5zZXJpYWxpemUoYnVmZmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gaW5zdGFuY2Ugb2YgTmV0d29ya0ZpbHRlciwgcmV0cmlldmUgcGF0dGVybiwgb3JnYW5pemF0aW9uIGFuZFxuICAgICAqIGNhdGVnb3J5IGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIGZyb21GaWx0ZXIoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21JZChmaWx0ZXIuZ2V0SWQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgZG9tYWluLCByZXRyaWV2ZSBwYXR0ZXJuLCBvcmdhbml6YXRpb24gYW5kIGNhdGVnb3J5IGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIGZyb21Eb21haW4oZG9tYWluKSB7XG4gICAgICAgIGNvbnN0IGRvbWFpblBhcnRzID0gZG9tYWluLnNwbGl0KCcuJyk7XG4gICAgICAgIGZvciAoOyBkb21haW5QYXJ0cy5sZW5ndGggPj0gMjsgZG9tYWluUGFydHMuc2hpZnQoKSkge1xuICAgICAgICAgICAgY29uc3Qgc3ViZG9tYWluID0gZG9tYWluUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRG9tYWluRmlsdGVyID0gTmV0d29ya0ZpbHRlci5wYXJzZShgfHwke3N1YmRvbWFpbn1eYCk7XG4gICAgICAgICAgICBpZiAocGFyc2VkRG9tYWluRmlsdGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJucyA9IHRoaXMuZnJvbUlkKHBhcnNlZERvbWFpbkZpbHRlci5nZXRJZCgpKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm5zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gYGlkYCBmcm9tIGZpbHRlciwgcmV0cmlldmUgdXNpbmcgdGhlIE5ldHdvcmtGaWx0ZXIuZ2V0SWQoKSBtZXRob2QsXG4gICAgICogbG9va3VwIGFzc29jaWF0ZWQgcGF0dGVybnMgKGluY2x1ZGluZyBvcmdhbml6YXRpb24gYW5kIGNhdGVnb3J5KSBpbiBhblxuICAgICAqIGVmZmljaWVudCB3YXkuXG4gICAgICovXG4gICAgZnJvbUlkKGlkKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHRoaXMucGF0dGVybnMuZ2V0KGlkKSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAoX2EgPSB0aGlzLmNhdGVnb3JpZXMuZ2V0KGdldENhdGVnb3J5S2V5KHsga2V5OiBwYXR0ZXJuLmNhdGVnb3J5IH0pKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdLFxuICAgICAgICAgICAgICAgIG9yZ2FuaXphdGlvbjogcGF0dGVybi5vcmdhbml6YXRpb24gIT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyAoX2IgPSB0aGlzLm9yZ2FuaXphdGlvbnMuZ2V0KGdldE9yZ2FuaXphdGlvbktleSh7IGtleTogcGF0dGVybi5vcmdhbml6YXRpb24gfSkpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/metadata.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/metadata/categories.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/engine/metadata/categories.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMap: () => (/* binding */ createMap),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   getKey: () => (/* binding */ getKey),\n/* harmony export */   getSerializedSize: () => (/* binding */ getSerializedSize),\n/* harmony export */   isValid: () => (/* binding */ isValid),\n/* harmony export */   serialize: () => (/* binding */ serialize)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../map.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/map.js\");\n/* harmony import */ var _data_view_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data-view.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/data-view.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/utils.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\nfunction isValid(category) {\n    if (category === null) {\n        return false;\n    }\n    if (typeof category !== 'object') {\n        return false;\n    }\n    const { key, name, color, description } = category;\n    if (typeof key !== 'string') {\n        return false;\n    }\n    if (typeof name !== 'string') {\n        return false;\n    }\n    if (typeof color !== 'string') {\n        return false;\n    }\n    if (typeof description !== 'string') {\n        return false;\n    }\n    return true;\n}\nfunction getKey(category) {\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.fastHash)(category.key);\n}\nfunction getSerializedSize(category) {\n    return ((0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(category.key) +\n        (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(category.name) +\n        (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(category.color) +\n        (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(category.description));\n}\nfunction serialize(category, view) {\n    view.pushUTF8(category.key);\n    view.pushUTF8(category.name);\n    view.pushUTF8(category.color);\n    view.pushUTF8(category.description);\n}\nfunction deserialize(view) {\n    return {\n        key: view.getUTF8(),\n        name: view.getUTF8(),\n        color: view.getUTF8(),\n        description: view.getUTF8(),\n    };\n}\nfunction createMap(categories) {\n    return new _map_js__WEBPACK_IMPORTED_MODULE_0__.CompactMap({\n        getSerializedSize,\n        getKeys: (category) => [getKey(category)],\n        serialize,\n        deserialize,\n        values: categories,\n    });\n}\n//# sourceMappingURL=categories.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvbWV0YWRhdGEvY2F0ZWdvcmllcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1QztBQUNTO0FBQ047QUFDbkM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdDQUFnQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLG1EQUFRO0FBQ25CO0FBQ087QUFDUCxZQUFZLHlEQUFVO0FBQ3RCLFFBQVEseURBQVU7QUFDbEIsUUFBUSx5REFBVTtBQUNsQixRQUFRLHlEQUFVO0FBQ2xCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZUFBZSwrQ0FBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvYWRibG9ja2VyL2Rpc3QvZXNtL2VuZ2luZS9tZXRhZGF0YS9jYXRlZ29yaWVzLmpzPzY3MTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCBHaG9zdGVyeSBHbWJILiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgeyBDb21wYWN0TWFwIH0gZnJvbSAnLi4vbWFwLmpzJztcbmltcG9ydCB7IHNpemVPZlVURjggfSBmcm9tICcuLi8uLi9kYXRhLXZpZXcuanMnO1xuaW1wb3J0IHsgZmFzdEhhc2ggfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZChjYXRlZ29yeSkge1xuICAgIGlmIChjYXRlZ29yeSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2F0ZWdvcnkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBrZXksIG5hbWUsIGNvbG9yLCBkZXNjcmlwdGlvbiB9ID0gY2F0ZWdvcnk7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29sb3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXkoY2F0ZWdvcnkpIHtcbiAgICByZXR1cm4gZmFzdEhhc2goY2F0ZWdvcnkua2V5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZXJpYWxpemVkU2l6ZShjYXRlZ29yeSkge1xuICAgIHJldHVybiAoc2l6ZU9mVVRGOChjYXRlZ29yeS5rZXkpICtcbiAgICAgICAgc2l6ZU9mVVRGOChjYXRlZ29yeS5uYW1lKSArXG4gICAgICAgIHNpemVPZlVURjgoY2F0ZWdvcnkuY29sb3IpICtcbiAgICAgICAgc2l6ZU9mVVRGOChjYXRlZ29yeS5kZXNjcmlwdGlvbikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShjYXRlZ29yeSwgdmlldykge1xuICAgIHZpZXcucHVzaFVURjgoY2F0ZWdvcnkua2V5KTtcbiAgICB2aWV3LnB1c2hVVEY4KGNhdGVnb3J5Lm5hbWUpO1xuICAgIHZpZXcucHVzaFVURjgoY2F0ZWdvcnkuY29sb3IpO1xuICAgIHZpZXcucHVzaFVURjgoY2F0ZWdvcnkuZGVzY3JpcHRpb24pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlc2VyaWFsaXplKHZpZXcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IHZpZXcuZ2V0VVRGOCgpLFxuICAgICAgICBuYW1lOiB2aWV3LmdldFVURjgoKSxcbiAgICAgICAgY29sb3I6IHZpZXcuZ2V0VVRGOCgpLFxuICAgICAgICBkZXNjcmlwdGlvbjogdmlldy5nZXRVVEY4KCksXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXAoY2F0ZWdvcmllcykge1xuICAgIHJldHVybiBuZXcgQ29tcGFjdE1hcCh7XG4gICAgICAgIGdldFNlcmlhbGl6ZWRTaXplLFxuICAgICAgICBnZXRLZXlzOiAoY2F0ZWdvcnkpID0+IFtnZXRLZXkoY2F0ZWdvcnkpXSxcbiAgICAgICAgc2VyaWFsaXplLFxuICAgICAgICBkZXNlcmlhbGl6ZSxcbiAgICAgICAgdmFsdWVzOiBjYXRlZ29yaWVzLFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2F0ZWdvcmllcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/metadata/categories.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/metadata/organizations.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/engine/metadata/organizations.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMap: () => (/* binding */ createMap),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   getKey: () => (/* binding */ getKey),\n/* harmony export */   getSerializedSize: () => (/* binding */ getSerializedSize),\n/* harmony export */   isValid: () => (/* binding */ isValid),\n/* harmony export */   serialize: () => (/* binding */ serialize)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../map.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/map.js\");\n/* harmony import */ var _data_view_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data-view.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/data-view.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/utils.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n/**\n * This function takes an object representing an organization from TrackerDB\n * dump and validates its shape. The result is the same object, but strongly\n * typed.\n */\nfunction isValid(organization) {\n    if (organization === null) {\n        return false;\n    }\n    if (typeof organization !== 'object') {\n        return false;\n    }\n    const { key, name, description, country, website_url: websiteUrl, privacy_policy_url: privacyPolicyUrl, privacy_contact: privacyContact, ghostery_id: ghosteryId, } = organization;\n    if (typeof key !== 'string') {\n        return false;\n    }\n    if (typeof name !== 'string') {\n        return false;\n    }\n    if (description !== null && typeof description !== 'string') {\n        return false;\n    }\n    if (country !== null && typeof country !== 'string') {\n        return false;\n    }\n    if (websiteUrl !== null && typeof websiteUrl !== 'string') {\n        return false;\n    }\n    if (privacyPolicyUrl !== null && typeof privacyPolicyUrl !== 'string') {\n        return false;\n    }\n    if (privacyContact !== null && typeof privacyContact !== 'string') {\n        return false;\n    }\n    if (ghosteryId !== null && typeof ghosteryId !== 'string') {\n        return false;\n    }\n    return true;\n}\nfunction getKey(organization) {\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.fastHash)(organization.key);\n}\nfunction getSerializedSize(organization) {\n    return ((0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(organization.key) +\n        (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(organization.name) +\n        (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(organization.description || '') +\n        (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(organization.website_url || '') +\n        (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(organization.country || '') +\n        (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(organization.privacy_policy_url || '') +\n        (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(organization.privacy_contact || '') +\n        (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(organization.ghostery_id || ''));\n}\nfunction serialize(organization, view) {\n    view.pushUTF8(organization.key);\n    view.pushUTF8(organization.name);\n    view.pushUTF8(organization.description || '');\n    view.pushUTF8(organization.website_url || '');\n    view.pushUTF8(organization.country || '');\n    view.pushUTF8(organization.privacy_policy_url || '');\n    view.pushUTF8(organization.privacy_contact || '');\n    view.pushUTF8(organization.ghostery_id || '');\n}\nfunction deserialize(view) {\n    return {\n        key: view.getUTF8(),\n        name: view.getUTF8(),\n        description: view.getUTF8() || null,\n        website_url: view.getUTF8() || null,\n        country: view.getUTF8() || null,\n        privacy_policy_url: view.getUTF8() || null,\n        privacy_contact: view.getUTF8() || null,\n        ghostery_id: view.getUTF8() || null,\n    };\n}\nfunction createMap(organizations) {\n    return new _map_js__WEBPACK_IMPORTED_MODULE_0__.CompactMap({\n        getSerializedSize,\n        getKeys: (organization) => [getKey(organization)],\n        serialize,\n        deserialize,\n        values: organizations,\n    });\n}\n//# sourceMappingURL=organizations.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvbWV0YWRhdGEvb3JnYW5pemF0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1QztBQUNTO0FBQ047QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0SkFBNEo7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxtREFBUTtBQUNuQjtBQUNPO0FBQ1AsWUFBWSx5REFBVTtBQUN0QixRQUFRLHlEQUFVO0FBQ2xCLFFBQVEseURBQVU7QUFDbEIsUUFBUSx5REFBVTtBQUNsQixRQUFRLHlEQUFVO0FBQ2xCLFFBQVEseURBQVU7QUFDbEIsUUFBUSx5REFBVTtBQUNsQixRQUFRLHlEQUFVO0FBQ2xCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGVBQWUsK0NBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvbWV0YWRhdGEvb3JnYW5pemF0aW9ucy5qcz83ZjlhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQgR2hvc3RlcnkgR21iSC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgQ29tcGFjdE1hcCB9IGZyb20gJy4uL21hcC5qcyc7XG5pbXBvcnQgeyBzaXplT2ZVVEY4IH0gZnJvbSAnLi4vLi4vZGF0YS12aWV3LmpzJztcbmltcG9ydCB7IGZhc3RIYXNoIH0gZnJvbSAnLi4vLi4vdXRpbHMuanMnO1xuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYW4gb3JnYW5pemF0aW9uIGZyb20gVHJhY2tlckRCXG4gKiBkdW1wIGFuZCB2YWxpZGF0ZXMgaXRzIHNoYXBlLiBUaGUgcmVzdWx0IGlzIHRoZSBzYW1lIG9iamVjdCwgYnV0IHN0cm9uZ2x5XG4gKiB0eXBlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWQob3JnYW5pemF0aW9uKSB7XG4gICAgaWYgKG9yZ2FuaXphdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3JnYW5pemF0aW9uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsga2V5LCBuYW1lLCBkZXNjcmlwdGlvbiwgY291bnRyeSwgd2Vic2l0ZV91cmw6IHdlYnNpdGVVcmwsIHByaXZhY3lfcG9saWN5X3VybDogcHJpdmFjeVBvbGljeVVybCwgcHJpdmFjeV9jb250YWN0OiBwcml2YWN5Q29udGFjdCwgZ2hvc3RlcnlfaWQ6IGdob3N0ZXJ5SWQsIH0gPSBvcmdhbml6YXRpb247XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkZXNjcmlwdGlvbiAhPT0gbnVsbCAmJiB0eXBlb2YgZGVzY3JpcHRpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGNvdW50cnkgIT09IG51bGwgJiYgdHlwZW9mIGNvdW50cnkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHdlYnNpdGVVcmwgIT09IG51bGwgJiYgdHlwZW9mIHdlYnNpdGVVcmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHByaXZhY3lQb2xpY3lVcmwgIT09IG51bGwgJiYgdHlwZW9mIHByaXZhY3lQb2xpY3lVcmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHByaXZhY3lDb250YWN0ICE9PSBudWxsICYmIHR5cGVvZiBwcml2YWN5Q29udGFjdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZ2hvc3RlcnlJZCAhPT0gbnVsbCAmJiB0eXBlb2YgZ2hvc3RlcnlJZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXkob3JnYW5pemF0aW9uKSB7XG4gICAgcmV0dXJuIGZhc3RIYXNoKG9yZ2FuaXphdGlvbi5rZXkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlcmlhbGl6ZWRTaXplKG9yZ2FuaXphdGlvbikge1xuICAgIHJldHVybiAoc2l6ZU9mVVRGOChvcmdhbml6YXRpb24ua2V5KSArXG4gICAgICAgIHNpemVPZlVURjgob3JnYW5pemF0aW9uLm5hbWUpICtcbiAgICAgICAgc2l6ZU9mVVRGOChvcmdhbml6YXRpb24uZGVzY3JpcHRpb24gfHwgJycpICtcbiAgICAgICAgc2l6ZU9mVVRGOChvcmdhbml6YXRpb24ud2Vic2l0ZV91cmwgfHwgJycpICtcbiAgICAgICAgc2l6ZU9mVVRGOChvcmdhbml6YXRpb24uY291bnRyeSB8fCAnJykgK1xuICAgICAgICBzaXplT2ZVVEY4KG9yZ2FuaXphdGlvbi5wcml2YWN5X3BvbGljeV91cmwgfHwgJycpICtcbiAgICAgICAgc2l6ZU9mVVRGOChvcmdhbml6YXRpb24ucHJpdmFjeV9jb250YWN0IHx8ICcnKSArXG4gICAgICAgIHNpemVPZlVURjgob3JnYW5pemF0aW9uLmdob3N0ZXJ5X2lkIHx8ICcnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKG9yZ2FuaXphdGlvbiwgdmlldykge1xuICAgIHZpZXcucHVzaFVURjgob3JnYW5pemF0aW9uLmtleSk7XG4gICAgdmlldy5wdXNoVVRGOChvcmdhbml6YXRpb24ubmFtZSk7XG4gICAgdmlldy5wdXNoVVRGOChvcmdhbml6YXRpb24uZGVzY3JpcHRpb24gfHwgJycpO1xuICAgIHZpZXcucHVzaFVURjgob3JnYW5pemF0aW9uLndlYnNpdGVfdXJsIHx8ICcnKTtcbiAgICB2aWV3LnB1c2hVVEY4KG9yZ2FuaXphdGlvbi5jb3VudHJ5IHx8ICcnKTtcbiAgICB2aWV3LnB1c2hVVEY4KG9yZ2FuaXphdGlvbi5wcml2YWN5X3BvbGljeV91cmwgfHwgJycpO1xuICAgIHZpZXcucHVzaFVURjgob3JnYW5pemF0aW9uLnByaXZhY3lfY29udGFjdCB8fCAnJyk7XG4gICAgdmlldy5wdXNoVVRGOChvcmdhbml6YXRpb24uZ2hvc3RlcnlfaWQgfHwgJycpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlc2VyaWFsaXplKHZpZXcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IHZpZXcuZ2V0VVRGOCgpLFxuICAgICAgICBuYW1lOiB2aWV3LmdldFVURjgoKSxcbiAgICAgICAgZGVzY3JpcHRpb246IHZpZXcuZ2V0VVRGOCgpIHx8IG51bGwsXG4gICAgICAgIHdlYnNpdGVfdXJsOiB2aWV3LmdldFVURjgoKSB8fCBudWxsLFxuICAgICAgICBjb3VudHJ5OiB2aWV3LmdldFVURjgoKSB8fCBudWxsLFxuICAgICAgICBwcml2YWN5X3BvbGljeV91cmw6IHZpZXcuZ2V0VVRGOCgpIHx8IG51bGwsXG4gICAgICAgIHByaXZhY3lfY29udGFjdDogdmlldy5nZXRVVEY4KCkgfHwgbnVsbCxcbiAgICAgICAgZ2hvc3RlcnlfaWQ6IHZpZXcuZ2V0VVRGOCgpIHx8IG51bGwsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNYXAob3JnYW5pemF0aW9ucykge1xuICAgIHJldHVybiBuZXcgQ29tcGFjdE1hcCh7XG4gICAgICAgIGdldFNlcmlhbGl6ZWRTaXplLFxuICAgICAgICBnZXRLZXlzOiAob3JnYW5pemF0aW9uKSA9PiBbZ2V0S2V5KG9yZ2FuaXphdGlvbildLFxuICAgICAgICBzZXJpYWxpemUsXG4gICAgICAgIGRlc2VyaWFsaXplLFxuICAgICAgICB2YWx1ZXM6IG9yZ2FuaXphdGlvbnMsXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcmdhbml6YXRpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/metadata/organizations.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/metadata/patterns.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/engine/metadata/patterns.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMap: () => (/* binding */ createMap),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   getKeys: () => (/* binding */ getKeys),\n/* harmony export */   getSerializedSize: () => (/* binding */ getSerializedSize),\n/* harmony export */   isValid: () => (/* binding */ isValid),\n/* harmony export */   serialize: () => (/* binding */ serialize)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../map.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/map.js\");\n/* harmony import */ var _data_view_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data-view.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/data-view.js\");\n/* harmony import */ var _filters_network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../filters/network.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/network.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n/**\n * This function takes an object representing a pattern from TrackerDB dump\n * and validates its shape. The result is the same object, but strongly typed.\n */\nfunction isValid(pattern) {\n    if (pattern === null) {\n        return false;\n    }\n    if (typeof pattern !== 'object') {\n        return false;\n    }\n    const { key, name, category, organization, alias, website_url: websiteUrl, domains, filters, } = pattern;\n    if (typeof key !== 'string') {\n        return false;\n    }\n    if (typeof name !== 'string') {\n        return false;\n    }\n    if (typeof category !== 'string') {\n        return false;\n    }\n    if (organization !== null && typeof organization !== 'string') {\n        return false;\n    }\n    if (typeof alias !== 'string' && alias !== null) {\n        return false;\n    }\n    if (websiteUrl !== null && typeof websiteUrl !== 'string') {\n        return false;\n    }\n    if (!Array.isArray(domains) || !domains.every((domain) => typeof domain === 'string')) {\n        return false;\n    }\n    if (!Array.isArray(filters) || !filters.every((filter) => typeof filter === 'string')) {\n        return false;\n    }\n    return true;\n}\nfunction getKeys(pattern) {\n    const keys = [];\n    for (const filter of pattern.filters) {\n        const parsedFilter = _filters_network_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].parse(filter);\n        if (parsedFilter !== null) {\n            keys.push(parsedFilter.getId());\n        }\n    }\n    for (const domain of pattern.domains) {\n        const parsedFilter = _filters_network_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].parse(`||${domain}^`);\n        if (parsedFilter !== null) {\n            keys.push(parsedFilter.getId());\n        }\n    }\n    return [...new Set(keys)];\n}\nfunction getSerializedSize(pattern) {\n    let sizeOfDomains = (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfLength)(pattern.domains.length);\n    for (const domain of pattern.domains) {\n        sizeOfDomains += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(domain);\n    }\n    let sizeOfFilters = (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfLength)(pattern.filters.length);\n    for (const filter of pattern.filters) {\n        sizeOfFilters += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(filter);\n    }\n    return ((0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(pattern.key) +\n        (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(pattern.name) +\n        (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(pattern.category) +\n        (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(pattern.organization || '') +\n        (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(pattern.alias || '') +\n        (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(pattern.website_url || '') +\n        (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(pattern.ghostery_id || '') +\n        sizeOfDomains +\n        sizeOfFilters);\n}\nfunction serialize(pattern, view) {\n    view.pushUTF8(pattern.key);\n    view.pushUTF8(pattern.name);\n    view.pushUTF8(pattern.category);\n    view.pushUTF8(pattern.organization || '');\n    view.pushUTF8(pattern.alias || '');\n    view.pushUTF8(pattern.website_url || '');\n    view.pushUTF8(pattern.ghostery_id || '');\n    view.pushLength(pattern.domains.length);\n    for (const domain of pattern.domains) {\n        view.pushUTF8(domain);\n    }\n    view.pushLength(pattern.filters.length);\n    for (const filter of pattern.filters) {\n        view.pushUTF8(filter);\n    }\n}\nfunction deserialize(view) {\n    const key = view.getUTF8();\n    const name = view.getUTF8();\n    const category = view.getUTF8();\n    const organization = view.getUTF8() || null;\n    const alias = view.getUTF8() || null;\n    const website_url = view.getUTF8() || null;\n    const ghostery_id = view.getUTF8() || null;\n    const numberOfDomains = view.getLength();\n    const domains = [];\n    for (let i = 0; i < numberOfDomains; i += 1) {\n        domains.push(view.getUTF8());\n    }\n    const numberOfFilters = view.getLength();\n    const filters = [];\n    for (let i = 0; i < numberOfFilters; i += 1) {\n        filters.push(view.getUTF8());\n    }\n    return {\n        key,\n        name,\n        category,\n        organization,\n        alias,\n        website_url,\n        ghostery_id,\n        domains,\n        filters,\n    };\n}\nfunction createMap(patterns) {\n    return new _map_js__WEBPACK_IMPORTED_MODULE_0__.CompactMap({\n        getSerializedSize,\n        getKeys,\n        serialize,\n        deserialize,\n        values: patterns,\n    });\n}\n//# sourceMappingURL=patterns.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvbWV0YWRhdGEvcGF0dGVybnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDdUM7QUFDdUI7QUFDVDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1RkFBdUY7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDZCQUE2QiwyREFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJEQUFhLFlBQVksT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHdCQUF3QiwyREFBWTtBQUNwQztBQUNBLHlCQUF5Qix5REFBVTtBQUNuQztBQUNBLHdCQUF3QiwyREFBWTtBQUNwQztBQUNBLHlCQUF5Qix5REFBVTtBQUNuQztBQUNBLFlBQVkseURBQVU7QUFDdEIsUUFBUSx5REFBVTtBQUNsQixRQUFRLHlEQUFVO0FBQ2xCLFFBQVEseURBQVU7QUFDbEIsUUFBUSx5REFBVTtBQUNsQixRQUFRLHlEQUFVO0FBQ2xCLFFBQVEseURBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZUFBZSwrQ0FBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvYWRibG9ja2VyL2Rpc3QvZXNtL2VuZ2luZS9tZXRhZGF0YS9wYXR0ZXJucy5qcz8zMjgwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQgR2hvc3RlcnkgR21iSC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgQ29tcGFjdE1hcCB9IGZyb20gJy4uL21hcC5qcyc7XG5pbXBvcnQgeyBzaXplT2ZVVEY4LCBzaXplT2ZMZW5ndGggfSBmcm9tICcuLi8uLi9kYXRhLXZpZXcuanMnO1xuaW1wb3J0IE5ldHdvcmtGaWx0ZXIgZnJvbSAnLi4vLi4vZmlsdGVycy9uZXR3b3JrLmpzJztcbi8qKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgcGF0dGVybiBmcm9tIFRyYWNrZXJEQiBkdW1wXG4gKiBhbmQgdmFsaWRhdGVzIGl0cyBzaGFwZS4gVGhlIHJlc3VsdCBpcyB0aGUgc2FtZSBvYmplY3QsIGJ1dCBzdHJvbmdseSB0eXBlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWQocGF0dGVybikge1xuICAgIGlmIChwYXR0ZXJuID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsga2V5LCBuYW1lLCBjYXRlZ29yeSwgb3JnYW5pemF0aW9uLCBhbGlhcywgd2Vic2l0ZV91cmw6IHdlYnNpdGVVcmwsIGRvbWFpbnMsIGZpbHRlcnMsIH0gPSBwYXR0ZXJuO1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhdGVnb3J5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvcmdhbml6YXRpb24gIT09IG51bGwgJiYgdHlwZW9mIG9yZ2FuaXphdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFsaWFzICE9PSAnc3RyaW5nJyAmJiBhbGlhcyAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh3ZWJzaXRlVXJsICE9PSBudWxsICYmIHR5cGVvZiB3ZWJzaXRlVXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShkb21haW5zKSB8fCAhZG9tYWlucy5ldmVyeSgoZG9tYWluKSA9PiB0eXBlb2YgZG9tYWluID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsdGVycykgfHwgIWZpbHRlcnMuZXZlcnkoKGZpbHRlcikgPT4gdHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5cyhwYXR0ZXJuKSB7XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHBhdHRlcm4uZmlsdGVycykge1xuICAgICAgICBjb25zdCBwYXJzZWRGaWx0ZXIgPSBOZXR3b3JrRmlsdGVyLnBhcnNlKGZpbHRlcik7XG4gICAgICAgIGlmIChwYXJzZWRGaWx0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChwYXJzZWRGaWx0ZXIuZ2V0SWQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBkb21haW4gb2YgcGF0dGVybi5kb21haW5zKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEZpbHRlciA9IE5ldHdvcmtGaWx0ZXIucGFyc2UoYHx8JHtkb21haW59XmApO1xuICAgICAgICBpZiAocGFyc2VkRmlsdGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2gocGFyc2VkRmlsdGVyLmdldElkKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbLi4ubmV3IFNldChrZXlzKV07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VyaWFsaXplZFNpemUocGF0dGVybikge1xuICAgIGxldCBzaXplT2ZEb21haW5zID0gc2l6ZU9mTGVuZ3RoKHBhdHRlcm4uZG9tYWlucy5sZW5ndGgpO1xuICAgIGZvciAoY29uc3QgZG9tYWluIG9mIHBhdHRlcm4uZG9tYWlucykge1xuICAgICAgICBzaXplT2ZEb21haW5zICs9IHNpemVPZlVURjgoZG9tYWluKTtcbiAgICB9XG4gICAgbGV0IHNpemVPZkZpbHRlcnMgPSBzaXplT2ZMZW5ndGgocGF0dGVybi5maWx0ZXJzLmxlbmd0aCk7XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgcGF0dGVybi5maWx0ZXJzKSB7XG4gICAgICAgIHNpemVPZkZpbHRlcnMgKz0gc2l6ZU9mVVRGOChmaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gKHNpemVPZlVURjgocGF0dGVybi5rZXkpICtcbiAgICAgICAgc2l6ZU9mVVRGOChwYXR0ZXJuLm5hbWUpICtcbiAgICAgICAgc2l6ZU9mVVRGOChwYXR0ZXJuLmNhdGVnb3J5KSArXG4gICAgICAgIHNpemVPZlVURjgocGF0dGVybi5vcmdhbml6YXRpb24gfHwgJycpICtcbiAgICAgICAgc2l6ZU9mVVRGOChwYXR0ZXJuLmFsaWFzIHx8ICcnKSArXG4gICAgICAgIHNpemVPZlVURjgocGF0dGVybi53ZWJzaXRlX3VybCB8fCAnJykgK1xuICAgICAgICBzaXplT2ZVVEY4KHBhdHRlcm4uZ2hvc3RlcnlfaWQgfHwgJycpICtcbiAgICAgICAgc2l6ZU9mRG9tYWlucyArXG4gICAgICAgIHNpemVPZkZpbHRlcnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShwYXR0ZXJuLCB2aWV3KSB7XG4gICAgdmlldy5wdXNoVVRGOChwYXR0ZXJuLmtleSk7XG4gICAgdmlldy5wdXNoVVRGOChwYXR0ZXJuLm5hbWUpO1xuICAgIHZpZXcucHVzaFVURjgocGF0dGVybi5jYXRlZ29yeSk7XG4gICAgdmlldy5wdXNoVVRGOChwYXR0ZXJuLm9yZ2FuaXphdGlvbiB8fCAnJyk7XG4gICAgdmlldy5wdXNoVVRGOChwYXR0ZXJuLmFsaWFzIHx8ICcnKTtcbiAgICB2aWV3LnB1c2hVVEY4KHBhdHRlcm4ud2Vic2l0ZV91cmwgfHwgJycpO1xuICAgIHZpZXcucHVzaFVURjgocGF0dGVybi5naG9zdGVyeV9pZCB8fCAnJyk7XG4gICAgdmlldy5wdXNoTGVuZ3RoKHBhdHRlcm4uZG9tYWlucy5sZW5ndGgpO1xuICAgIGZvciAoY29uc3QgZG9tYWluIG9mIHBhdHRlcm4uZG9tYWlucykge1xuICAgICAgICB2aWV3LnB1c2hVVEY4KGRvbWFpbik7XG4gICAgfVxuICAgIHZpZXcucHVzaExlbmd0aChwYXR0ZXJuLmZpbHRlcnMubGVuZ3RoKTtcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBwYXR0ZXJuLmZpbHRlcnMpIHtcbiAgICAgICAgdmlldy5wdXNoVVRGOChmaWx0ZXIpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZSh2aWV3KSB7XG4gICAgY29uc3Qga2V5ID0gdmlldy5nZXRVVEY4KCk7XG4gICAgY29uc3QgbmFtZSA9IHZpZXcuZ2V0VVRGOCgpO1xuICAgIGNvbnN0IGNhdGVnb3J5ID0gdmlldy5nZXRVVEY4KCk7XG4gICAgY29uc3Qgb3JnYW5pemF0aW9uID0gdmlldy5nZXRVVEY4KCkgfHwgbnVsbDtcbiAgICBjb25zdCBhbGlhcyA9IHZpZXcuZ2V0VVRGOCgpIHx8IG51bGw7XG4gICAgY29uc3Qgd2Vic2l0ZV91cmwgPSB2aWV3LmdldFVURjgoKSB8fCBudWxsO1xuICAgIGNvbnN0IGdob3N0ZXJ5X2lkID0gdmlldy5nZXRVVEY4KCkgfHwgbnVsbDtcbiAgICBjb25zdCBudW1iZXJPZkRvbWFpbnMgPSB2aWV3LmdldExlbmd0aCgpO1xuICAgIGNvbnN0IGRvbWFpbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mRG9tYWluczsgaSArPSAxKSB7XG4gICAgICAgIGRvbWFpbnMucHVzaCh2aWV3LmdldFVURjgoKSk7XG4gICAgfVxuICAgIGNvbnN0IG51bWJlck9mRmlsdGVycyA9IHZpZXcuZ2V0TGVuZ3RoKCk7XG4gICAgY29uc3QgZmlsdGVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZGaWx0ZXJzOyBpICs9IDEpIHtcbiAgICAgICAgZmlsdGVycy5wdXNoKHZpZXcuZ2V0VVRGOCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lLFxuICAgICAgICBjYXRlZ29yeSxcbiAgICAgICAgb3JnYW5pemF0aW9uLFxuICAgICAgICBhbGlhcyxcbiAgICAgICAgd2Vic2l0ZV91cmwsXG4gICAgICAgIGdob3N0ZXJ5X2lkLFxuICAgICAgICBkb21haW5zLFxuICAgICAgICBmaWx0ZXJzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWFwKHBhdHRlcm5zKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wYWN0TWFwKHtcbiAgICAgICAgZ2V0U2VyaWFsaXplZFNpemUsXG4gICAgICAgIGdldEtleXMsXG4gICAgICAgIHNlcmlhbGl6ZSxcbiAgICAgICAgZGVzZXJpYWxpemUsXG4gICAgICAgIHZhbHVlczogcGF0dGVybnMsXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXR0ZXJucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/metadata/patterns.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/optimizer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/engine/optimizer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   noopOptimizeCosmetic: () => (/* binding */ noopOptimizeCosmetic),\n/* harmony export */   noopOptimizeNetwork: () => (/* binding */ noopOptimizeNetwork),\n/* harmony export */   optimizeNetwork: () => (/* binding */ optimizeNetwork)\n/* harmony export */ });\n/* harmony import */ var _filters_network_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../filters/network.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/network.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/utils.js\");\n/* harmony import */ var _engine_domains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../engine/domains.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/domains.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\nfunction processRegex(r) {\n    return `(?:${r.source})`;\n}\nfunction escape(s) {\n    return `(?:${s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')})`;\n}\nfunction setWithDefault(map, key, value) {\n    let bucket = map.get(key);\n    if (bucket === undefined) {\n        bucket = [];\n        map.set(key, bucket);\n    }\n    bucket.push(value);\n}\nfunction groupBy(filters, criteria) {\n    const grouped = new Map();\n    for (const filter of filters) {\n        setWithDefault(grouped, criteria(filter), filter);\n    }\n    return Array.from(grouped.values());\n}\nfunction splitBy(filters, condition) {\n    const positive = [];\n    const negative = [];\n    for (const filter of filters) {\n        if (condition(filter)) {\n            positive.push(filter);\n        }\n        else {\n            negative.push(filter);\n        }\n    }\n    return {\n        negative,\n        positive,\n    };\n}\nconst OPTIMIZATIONS = [\n    {\n        description: 'Remove duplicated filters by ID',\n        fusion: (filters) => filters[0],\n        groupByCriteria: (filter) => '' + filter.getId(),\n        select: () => true,\n    },\n    {\n        description: 'Group idential filter with same mask but different domains in single filters',\n        fusion: (filters) => {\n            const parts = [];\n            const hostnames = new Set();\n            const notHostnames = new Set();\n            const entities = new Set();\n            const notEntities = new Set();\n            for (const { domains } of filters) {\n                if (domains !== undefined) {\n                    if (domains.parts !== undefined) {\n                        parts.push(domains.parts);\n                    }\n                    if (domains.hostnames !== undefined) {\n                        for (const hash of domains.hostnames) {\n                            hostnames.add(hash);\n                        }\n                    }\n                    if (domains.entities !== undefined) {\n                        for (const hash of domains.entities) {\n                            entities.add(hash);\n                        }\n                    }\n                    if (domains.notHostnames !== undefined) {\n                        for (const hash of domains.notHostnames) {\n                            notHostnames.add(hash);\n                        }\n                    }\n                    if (domains.notEntities !== undefined) {\n                        for (const hash of domains.notEntities) {\n                            notEntities.add(hash);\n                        }\n                    }\n                }\n            }\n            return new _filters_network_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](Object.assign({}, filters[0], {\n                domains: new _engine_domains_js__WEBPACK_IMPORTED_MODULE_2__.Domains({\n                    hostnames: hostnames.size !== 0 ? new Uint32Array(hostnames).sort() : undefined,\n                    entities: entities.size !== 0 ? new Uint32Array(entities).sort() : undefined,\n                    notHostnames: notHostnames.size !== 0 ? new Uint32Array(notHostnames).sort() : undefined,\n                    notEntities: notEntities.size !== 0 ? new Uint32Array(notEntities).sort() : undefined,\n                    parts: parts.length !== 0 ? parts.join(',') : undefined,\n                }),\n                rawLine: filters[0].rawLine !== undefined\n                    ? filters.map(({ rawLine }) => rawLine).join(' <+> ')\n                    : undefined,\n            }));\n        },\n        groupByCriteria: (filter) => { var _a; return filter.getHostname() + filter.getFilter() + filter.getMask() + ((_a = filter.optionValue) !== null && _a !== void 0 ? _a : ''); },\n        select: (filter) => !filter.isCSP() && filter.denyallow === undefined && filter.domains !== undefined,\n    },\n    {\n        description: 'Group simple patterns, into a single filter',\n        fusion: (filters) => {\n            const patterns = [];\n            for (const f of filters) {\n                if (f.isRegex()) {\n                    patterns.push(processRegex(f.getRegex()));\n                }\n                else if (f.isRightAnchor()) {\n                    patterns.push(`${escape(f.getFilter())}$`);\n                }\n                else if (f.isLeftAnchor()) {\n                    patterns.push(`^${escape(f.getFilter())}`);\n                }\n                else {\n                    patterns.push(escape(f.getFilter()));\n                }\n            }\n            return new _filters_network_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](Object.assign({}, filters[0], {\n                mask: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.setBit)(filters[0].mask, _filters_network_js__WEBPACK_IMPORTED_MODULE_0__.NETWORK_FILTER_MASK.isRegex),\n                rawLine: filters[0].rawLine !== undefined\n                    ? filters.map(({ rawLine }) => rawLine).join(' <+> ')\n                    : undefined,\n                regex: new RegExp(patterns.join('|')),\n            }));\n        },\n        groupByCriteria: (filter) => '' + (filter.getMask() & ~_filters_network_js__WEBPACK_IMPORTED_MODULE_0__.NETWORK_FILTER_MASK.isRegex & ~_filters_network_js__WEBPACK_IMPORTED_MODULE_0__.NETWORK_FILTER_MASK.isFullRegex),\n        select: (filter) => filter.domains === undefined &&\n            filter.denyallow === undefined &&\n            !filter.isHostnameAnchor() &&\n            !filter.isRedirect() &&\n            !filter.isCSP(),\n    },\n];\n/**\n * Optimizer which returns the list of original filters.\n */\nfunction noopOptimizeNetwork(filters) {\n    return filters;\n}\nfunction noopOptimizeCosmetic(filters) {\n    return filters;\n}\n/**\n * Fusion a set of `filters` by applying optimizations sequentially.\n */\nfunction optimizeNetwork(filters) {\n    const fused = [];\n    let toFuse = filters;\n    for (const { select, fusion, groupByCriteria } of OPTIMIZATIONS) {\n        const { positive, negative } = splitBy(toFuse, select);\n        toFuse = negative;\n        const groups = groupBy(positive, groupByCriteria);\n        for (const group of groups) {\n            if (group.length > 1) {\n                fused.push(fusion(group));\n            }\n            else {\n                toFuse.push(group[0]);\n            }\n        }\n    }\n    for (const filter of toFuse) {\n        fused.push(filter);\n    }\n    return fused;\n}\n//# sourceMappingURL=optimizer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvb3B0aW1pemVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzJFO0FBQ3RDO0FBQ1U7QUFDL0M7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EsaUJBQWlCLDhCQUE4QixhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkRBQWEsaUJBQWlCO0FBQ3JELDZCQUE2Qix1REFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULHVDQUF1QyxRQUFRLHdJQUF3STtBQUN2TDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0JBQXNCO0FBQzNEO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkRBQWEsaUJBQWlCO0FBQ3JELHNCQUFzQixpREFBTSxrQkFBa0Isb0VBQW1CO0FBQ2pFO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsK0RBQStELG9FQUFtQixZQUFZLG9FQUFtQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsaUJBQWlCLGtDQUFrQztBQUNuRCxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvYWRibG9ja2VyL2Rpc3QvZXNtL2VuZ2luZS9vcHRpbWl6ZXIuanM/OTg3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50IEdob3N0ZXJ5IEdtYkguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmltcG9ydCBOZXR3b3JrRmlsdGVyLCB7IE5FVFdPUktfRklMVEVSX01BU0sgfSBmcm9tICcuLi9maWx0ZXJzL25ldHdvcmsuanMnO1xuaW1wb3J0IHsgc2V0Qml0IH0gZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHsgRG9tYWlucyB9IGZyb20gJy4uL2VuZ2luZS9kb21haW5zLmpzJztcbmZ1bmN0aW9uIHByb2Nlc3NSZWdleChyKSB7XG4gICAgcmV0dXJuIGAoPzoke3Iuc291cmNlfSlgO1xufVxuZnVuY3Rpb24gZXNjYXBlKHMpIHtcbiAgICByZXR1cm4gYCg/OiR7cy5yZXBsYWNlKC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyl9KWA7XG59XG5mdW5jdGlvbiBzZXRXaXRoRGVmYXVsdChtYXAsIGtleSwgdmFsdWUpIHtcbiAgICBsZXQgYnVja2V0ID0gbWFwLmdldChrZXkpO1xuICAgIGlmIChidWNrZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBidWNrZXQgPSBbXTtcbiAgICAgICAgbWFwLnNldChrZXksIGJ1Y2tldCk7XG4gICAgfVxuICAgIGJ1Y2tldC5wdXNoKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdyb3VwQnkoZmlsdGVycywgY3JpdGVyaWEpIHtcbiAgICBjb25zdCBncm91cGVkID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICAgICAgc2V0V2l0aERlZmF1bHQoZ3JvdXBlZCwgY3JpdGVyaWEoZmlsdGVyKSwgZmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZ3JvdXBlZC52YWx1ZXMoKSk7XG59XG5mdW5jdGlvbiBzcGxpdEJ5KGZpbHRlcnMsIGNvbmRpdGlvbikge1xuICAgIGNvbnN0IHBvc2l0aXZlID0gW107XG4gICAgY29uc3QgbmVnYXRpdmUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBmaWx0ZXJzKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24oZmlsdGVyKSkge1xuICAgICAgICAgICAgcG9zaXRpdmUucHVzaChmaWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmVnYXRpdmUucHVzaChmaWx0ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG5lZ2F0aXZlLFxuICAgICAgICBwb3NpdGl2ZSxcbiAgICB9O1xufVxuY29uc3QgT1BUSU1JWkFUSU9OUyA9IFtcbiAgICB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiAnUmVtb3ZlIGR1cGxpY2F0ZWQgZmlsdGVycyBieSBJRCcsXG4gICAgICAgIGZ1c2lvbjogKGZpbHRlcnMpID0+IGZpbHRlcnNbMF0sXG4gICAgICAgIGdyb3VwQnlDcml0ZXJpYTogKGZpbHRlcikgPT4gJycgKyBmaWx0ZXIuZ2V0SWQoKSxcbiAgICAgICAgc2VsZWN0OiAoKSA9PiB0cnVlLFxuICAgIH0sXG4gICAge1xuICAgICAgICBkZXNjcmlwdGlvbjogJ0dyb3VwIGlkZW50aWFsIGZpbHRlciB3aXRoIHNhbWUgbWFzayBidXQgZGlmZmVyZW50IGRvbWFpbnMgaW4gc2luZ2xlIGZpbHRlcnMnLFxuICAgICAgICBmdXNpb246IChmaWx0ZXJzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgaG9zdG5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgY29uc3Qgbm90SG9zdG5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgY29uc3QgZW50aXRpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBjb25zdCBub3RFbnRpdGllcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBkb21haW5zIH0gb2YgZmlsdGVycykge1xuICAgICAgICAgICAgICAgIGlmIChkb21haW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbnMucGFydHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaChkb21haW5zLnBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWlucy5ob3N0bmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYXNoIG9mIGRvbWFpbnMuaG9zdG5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdG5hbWVzLmFkZChoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWlucy5lbnRpdGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhhc2ggb2YgZG9tYWlucy5lbnRpdGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0aWVzLmFkZChoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWlucy5ub3RIb3N0bmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBoYXNoIG9mIGRvbWFpbnMubm90SG9zdG5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90SG9zdG5hbWVzLmFkZChoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWlucy5ub3RFbnRpdGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhhc2ggb2YgZG9tYWlucy5ub3RFbnRpdGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdEVudGl0aWVzLmFkZChoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTmV0d29ya0ZpbHRlcihPYmplY3QuYXNzaWduKHt9LCBmaWx0ZXJzWzBdLCB7XG4gICAgICAgICAgICAgICAgZG9tYWluczogbmV3IERvbWFpbnMoe1xuICAgICAgICAgICAgICAgICAgICBob3N0bmFtZXM6IGhvc3RuYW1lcy5zaXplICE9PSAwID8gbmV3IFVpbnQzMkFycmF5KGhvc3RuYW1lcykuc29ydCgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBlbnRpdGllczogZW50aXRpZXMuc2l6ZSAhPT0gMCA/IG5ldyBVaW50MzJBcnJheShlbnRpdGllcykuc29ydCgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBub3RIb3N0bmFtZXM6IG5vdEhvc3RuYW1lcy5zaXplICE9PSAwID8gbmV3IFVpbnQzMkFycmF5KG5vdEhvc3RuYW1lcykuc29ydCgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBub3RFbnRpdGllczogbm90RW50aXRpZXMuc2l6ZSAhPT0gMCA/IG5ldyBVaW50MzJBcnJheShub3RFbnRpdGllcykuc29ydCgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0czogcGFydHMubGVuZ3RoICE9PSAwID8gcGFydHMuam9pbignLCcpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHJhd0xpbmU6IGZpbHRlcnNbMF0ucmF3TGluZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gZmlsdGVycy5tYXAoKHsgcmF3TGluZSB9KSA9PiByYXdMaW5lKS5qb2luKCcgPCs+ICcpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBncm91cEJ5Q3JpdGVyaWE6IChmaWx0ZXIpID0+IHsgdmFyIF9hOyByZXR1cm4gZmlsdGVyLmdldEhvc3RuYW1lKCkgKyBmaWx0ZXIuZ2V0RmlsdGVyKCkgKyBmaWx0ZXIuZ2V0TWFzaygpICsgKChfYSA9IGZpbHRlci5vcHRpb25WYWx1ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpOyB9LFxuICAgICAgICBzZWxlY3Q6IChmaWx0ZXIpID0+ICFmaWx0ZXIuaXNDU1AoKSAmJiBmaWx0ZXIuZGVueWFsbG93ID09PSB1bmRlZmluZWQgJiYgZmlsdGVyLmRvbWFpbnMgIT09IHVuZGVmaW5lZCxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgZGVzY3JpcHRpb246ICdHcm91cCBzaW1wbGUgcGF0dGVybnMsIGludG8gYSBzaW5nbGUgZmlsdGVyJyxcbiAgICAgICAgZnVzaW9uOiAoZmlsdGVycykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZiBvZiBmaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGYuaXNSZWdleCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5zLnB1c2gocHJvY2Vzc1JlZ2V4KGYuZ2V0UmVnZXgoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmLmlzUmlnaHRBbmNob3IoKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJucy5wdXNoKGAke2VzY2FwZShmLmdldEZpbHRlcigpKX0kYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGYuaXNMZWZ0QW5jaG9yKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybnMucHVzaChgXiR7ZXNjYXBlKGYuZ2V0RmlsdGVyKCkpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybnMucHVzaChlc2NhcGUoZi5nZXRGaWx0ZXIoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTmV0d29ya0ZpbHRlcihPYmplY3QuYXNzaWduKHt9LCBmaWx0ZXJzWzBdLCB7XG4gICAgICAgICAgICAgICAgbWFzazogc2V0Qml0KGZpbHRlcnNbMF0ubWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc1JlZ2V4KSxcbiAgICAgICAgICAgICAgICByYXdMaW5lOiBmaWx0ZXJzWzBdLnJhd0xpbmUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IGZpbHRlcnMubWFwKCh7IHJhd0xpbmUgfSkgPT4gcmF3TGluZSkuam9pbignIDwrPiAnKVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZWdleDogbmV3IFJlZ0V4cChwYXR0ZXJucy5qb2luKCd8JykpLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBncm91cEJ5Q3JpdGVyaWE6IChmaWx0ZXIpID0+ICcnICsgKGZpbHRlci5nZXRNYXNrKCkgJiB+TkVUV09SS19GSUxURVJfTUFTSy5pc1JlZ2V4ICYgfk5FVFdPUktfRklMVEVSX01BU0suaXNGdWxsUmVnZXgpLFxuICAgICAgICBzZWxlY3Q6IChmaWx0ZXIpID0+IGZpbHRlci5kb21haW5zID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGZpbHRlci5kZW55YWxsb3cgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgIWZpbHRlci5pc0hvc3RuYW1lQW5jaG9yKCkgJiZcbiAgICAgICAgICAgICFmaWx0ZXIuaXNSZWRpcmVjdCgpICYmXG4gICAgICAgICAgICAhZmlsdGVyLmlzQ1NQKCksXG4gICAgfSxcbl07XG4vKipcbiAqIE9wdGltaXplciB3aGljaCByZXR1cm5zIHRoZSBsaXN0IG9mIG9yaWdpbmFsIGZpbHRlcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub29wT3B0aW1pemVOZXR3b3JrKGZpbHRlcnMpIHtcbiAgICByZXR1cm4gZmlsdGVycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBub29wT3B0aW1pemVDb3NtZXRpYyhmaWx0ZXJzKSB7XG4gICAgcmV0dXJuIGZpbHRlcnM7XG59XG4vKipcbiAqIEZ1c2lvbiBhIHNldCBvZiBgZmlsdGVyc2AgYnkgYXBwbHlpbmcgb3B0aW1pemF0aW9ucyBzZXF1ZW50aWFsbHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcHRpbWl6ZU5ldHdvcmsoZmlsdGVycykge1xuICAgIGNvbnN0IGZ1c2VkID0gW107XG4gICAgbGV0IHRvRnVzZSA9IGZpbHRlcnM7XG4gICAgZm9yIChjb25zdCB7IHNlbGVjdCwgZnVzaW9uLCBncm91cEJ5Q3JpdGVyaWEgfSBvZiBPUFRJTUlaQVRJT05TKSB7XG4gICAgICAgIGNvbnN0IHsgcG9zaXRpdmUsIG5lZ2F0aXZlIH0gPSBzcGxpdEJ5KHRvRnVzZSwgc2VsZWN0KTtcbiAgICAgICAgdG9GdXNlID0gbmVnYXRpdmU7XG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IGdyb3VwQnkocG9zaXRpdmUsIGdyb3VwQnlDcml0ZXJpYSk7XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgZ3JvdXBzKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXAubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGZ1c2VkLnB1c2goZnVzaW9uKGdyb3VwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b0Z1c2UucHVzaChncm91cFswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgdG9GdXNlKSB7XG4gICAgICAgIGZ1c2VkLnB1c2goZmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1c2VkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3B0aW1pemVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/optimizer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/reverse-index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/engine/reverse-index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ReverseIndex),\n/* harmony export */   nextPow2: () => (/* binding */ nextPow2)\n/* harmony export */ });\n/* harmony import */ var _data_view_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data-view.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/data-view.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n// https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\nfunction nextPow2(v) {\n    v--;\n    v |= v >> 1;\n    v |= v >> 2;\n    v |= v >> 4;\n    v |= v >> 8;\n    v |= v >> 16;\n    v++;\n    return v;\n}\n/**\n * Generate unique IDs for requests, which is used to avoid matching the same\n * buckets multiple times on the same request (which can happen if a token\n * appears more than once in a URL).\n */\nlet UID = 1;\nfunction getNextId() {\n    const id = UID;\n    UID = (UID + 1) % 1000000000;\n    return id;\n}\nconst EMPTY_BUCKET = Number.MAX_SAFE_INTEGER >>> 0;\n/**\n * The ReverseIndex is an accelerating data structure which allows finding a\n * subset of the filters given a list of tokens seen in a URL. It is the core\n * of the adblocker's matching capabilities and speed.\n *\n * It has mainly two caracteristics:\n * 1. It is very compact and is able to load fast.\n * 2. It is *very fast* in finding potential candidates.\n *\n * Conceptually, the reverse index dispatches filters in \"buckets\" (an array of\n * one or more filters). Filters living in the same bucket are guaranteed to\n * share at least one of their tokens (appearing in the pattern). For example:\n *\n *   - Bucket 1 (ads):\n *       - /ads.js\n *       - /script/ads/tracking.js\n *       - /ads/\n *   - Bucket 2 (tracking)\n *       - /tracking.js\n *       - ||tracking.com/cdn\n *\n * We see that filters in \"Bucket 1\" are indexed using the token \"ads\" and\n * \"Bucket 2\" using token \"tracking\".\n *\n * This property allows to quickly discard most of the filters when we match a\n * URL. To achieve this, the URL is tokenized in the same way filters are\n * tokenized and for each token, we check if there are some filters available.\n *\n * For example:\n *\n *  URL \"https://tracking.com/\" has the following tokens: \"https\", \"tracking\"\n *  and \"com\". We immediatly see that we only check the two filters in the\n *  \"tracking\" bucket since they are the only ones having a common token with\n *  the URL.\n *\n * How do we pick the token for each filter?\n * =========================================\n *\n * Each filter is only indexed *once*, which means that we need to pick one of\n * the tokens appearing in the pattern. We choose the token such that each\n * filter is indexed using the token which was the *least seen* globally. In\n * other words, we pick the most discriminative token for each filter. This is\n * done using the following algorithm:\n *   1. Tokenize all the filters which will be stored in the index\n *   2. Compute a histogram of frequency of each token (globally)\n *   3. Select the best token for each filter (lowest frequency)\n */\nclass ReverseIndex {\n    static deserialize(buffer, deserialize, optimize, config) {\n        const tokensLookupIndexSize = buffer.getUint32();\n        const bucketsIndexSize = buffer.getUint32();\n        const numberOfFilters = buffer.getUint32();\n        // Alignement to 4 bytes is important here since `view` (Uint8Array) can\n        // appear at any offset of `buffer`. But to be sure we can read back\n        // Uint32Array directly from raw buffer, the alignement has to be a\n        // multiple of 4. The same alignement is taken care of in `serialize`.\n        const view = _data_view_js__WEBPACK_IMPORTED_MODULE_0__.StaticDataView.fromUint8Array(buffer.getBytes(true /* align */), config);\n        const tokensLookupIndex = view.getUint32ArrayView(tokensLookupIndexSize);\n        const bucketsIndex = view.getUint32ArrayView(bucketsIndexSize);\n        const filtersIndexStart = view.pos;\n        view.seekZero(); // not strictly needed but make sure reverse index can be compared with deep equal\n        return new ReverseIndex({\n            config,\n            deserialize,\n            filters: [],\n            optimize,\n        }).updateInternals({\n            bucketsIndex,\n            filtersIndexStart,\n            numberOfFilters,\n            tokensLookupIndex,\n            view,\n        });\n    }\n    constructor({ deserialize, filters, optimize, config, }) {\n        // Internal, compact representation of the reverse index. It contains three\n        // distinct parts stored in the same typed array:\n        //\n        // 1. \"tokens lookup index\" allows to identify a sub-set of buckets which\n        // likely contain filters for a given token. It is an approximate dispatch\n        // table which maps a mask of N bits (N being smaller than 31 bits, the size\n        // of a token) to a list of buckets having a 'token' sharing these same N\n        // bits sub-set. If the binary representation of the token for bucket1 is\n        // 101010 and suffix has size 3, then we would lookup the \"tokens lookup\n        // index\" using the last 3 bits \"010\" which would give us the offset in our\n        // typed array where we can start reading the filters of buckets having a\n        // token ending with the same 3 bits. The value of N is always a power of 2\n        // depending on the total number of filters stored in the index; determined\n        // at the time `update(...)` is called.\n        //\n        // 2. \"buckets index\" is an array which associates tokens to filters. The\n        // structure is: token, filter, token, filter, etc. To identify all the\n        // filters indexed with 'token' a naive approach would be to iterate on\n        // \"buckets index\" and collect all the filters indexed with 'token'. This\n        // would be *very inefficient*! To make this process faster, filters in\n        // \"buckets index\" are grouped so that buckets sharing the same suffix of N\n        // bits in their indexing token (see \"tokens lookup index\") are stored side\n        // by side in the typed array. To know where this section start given a\n        // particular token, we use \"tokens lookup index\" which associated the suffix\n        // of size N to an index in \"buckets index\". From there we can iterate on the\n        // candidates.\n        //\n        // 3. \"filters index\" contains the filters themselves. \"buckets index\"\n        // presented earlier does not contain filters, but an index to the \"filters\n        // index\". This allows a filter to be indexed multiple times without\n        // introducing any overhead; the filter can be associated with multiple\n        // tokens in \"buckets index\" (each pointing to the same place in \"filters\n        // index\") but its actual representation is stored only once in \"filters\n        // index\".\n        this.bucketsIndex = _data_view_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_UINT32_ARRAY;\n        this.filtersIndexStart = 0;\n        this.numberOfFilters = 0;\n        this.tokensLookupIndex = _data_view_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_UINT32_ARRAY;\n        // In-memory cache used to keep track of buckets which have been loaded from\n        // the compact representation (i.e.: this.view). It is not strictly necessary\n        // but will speed-up retrival of popular filters (since we do not have to\n        // perform the lookup in \"tokens index\" and \"buckets index\" everytime).\n        this.cache = new Map();\n        this.view = _data_view_js__WEBPACK_IMPORTED_MODULE_0__.StaticDataView.empty(config);\n        this.deserializeFilter = deserialize;\n        this.optimize = optimize;\n        this.config = config;\n        if (filters.length !== 0) {\n            this.update(filters, undefined);\n        }\n    }\n    /**\n     * Load all filters from this index in memory (i.e.: deserialize them from\n     * the byte array into NetworkFilter or CosmeticFilter instances). This is\n     * mostly useful for debugging or testing purposes.\n     */\n    getFilters() {\n        const filters = [];\n        if (this.numberOfFilters === 0) {\n            return filters;\n        }\n        // set view cursor at the start of \"filters index\"\n        this.view.setPos(this.filtersIndexStart);\n        for (let i = 0; i < this.numberOfFilters; i += 1) {\n            filters.push(this.deserializeFilter(this.view));\n        }\n        this.view.seekZero();\n        return filters;\n    }\n    /**\n     * Return an array of all the tokens currently used as keys of the \"buckets index\".\n     */\n    getTokens() {\n        const tokens = new Set();\n        for (let i = 0; i < this.bucketsIndex.length; i += 2) {\n            tokens.add(this.bucketsIndex[i]);\n        }\n        return new Uint32Array(tokens);\n    }\n    /**\n     * Estimate the number of bytes needed to serialize this instance of `ReverseIndex`.\n     */\n    getSerializedSize() {\n        // 12 = 4 bytes (tokensLookupIndex.length) + 4 bytes (bucketsIndex.length) + 4 bytes (numberOfFilters)\n        return 12 + (0,_data_view_js__WEBPACK_IMPORTED_MODULE_0__.sizeOfBytes)(this.view.buffer, true /* align */);\n    }\n    /**\n     * Dump this index to `buffer`.\n     */\n    serialize(buffer) {\n        buffer.pushUint32(this.tokensLookupIndex.length);\n        buffer.pushUint32(this.bucketsIndex.length);\n        buffer.pushUint32(this.numberOfFilters);\n        // Aligmenent is crucial here, see comment in `deserialize` for more info.\n        buffer.pushBytes(this.view.buffer, true /* align */);\n    }\n    /**\n     * Iterate on all filters found in buckets associated with the given list of\n     * tokens. The callback is called on each of them. Early termination can be\n     * achieved if the callback returns `false`.\n     *\n     * This will not check if each filter returned would match a given request but\n     * is instead used as a list of potential candidates (much smaller than the\n     * total set of filters; typically between 5 and 10 filters will be checked).\n     */\n    iterMatchingFilters(tokens, cb) {\n        // Each request is assigned an ID so that we can keep track of the last\n        // request seen by each bucket in the reverse index. This provides a cheap\n        // way to prevent filters from being inspected more than once per request\n        // (which could happen if the same token appears more than once in the URL).\n        const requestId = getNextId();\n        for (const token of tokens) {\n            if (this.iterBucket(token, requestId, cb) === false) {\n                return;\n            }\n        }\n        // Fallback to 0 (i.e.: wildcard bucket) bucket if nothing was found before.\n        this.iterBucket(0, requestId, cb);\n    }\n    /**\n     * Re-create the internal data-structure of the reverse index *in-place*. It\n     * needs to be called with a list of new filters and optionally a list of ids\n     * (as returned by either NetworkFilter.getId() or CosmeticFilter.getId())\n     * which need to be removed from the index.\n     */\n    update(newFilters, removedFilters) {\n        // Reset internal cache on each update\n        if (this.cache.size !== 0) {\n            this.cache.clear();\n        }\n        const compression = this.config.enableCompression;\n        let totalNumberOfTokens = 0;\n        let totalNumberOfIndexedFilters = 0;\n        const filtersTokens = [];\n        // Keep track of the final size of the buckets index. `bucketsIndexSize` is\n        // the number of indexed filters, multiplied by 2 (since we store both the\n        // token a filter is indexed with and the index of the filter).\n        let bucketsIndexSize = 0;\n        // Re-use the current size of \"filters index\" as a starting point so that\n        // we only need to update with new or removed filters. This saves time if\n        // we perform a small update on an existing index.\n        let estimatedBufferSize = this.view.buffer.byteLength - this.filtersIndexStart;\n        // Create a list of all filters which will be part of the index. This means\n        // loading existing filters, removing the ones that need to be deleted and\n        // adding the new ones.  At the same time, we update the estimation of\n        // buffer size needed to store this index.\n        let filters = this.getFilters();\n        if (filters.length !== 0) {\n            // If there is at least one existing filter, then we check if some should\n            // be removed. We subtract their size from the total estimated buffer\n            // size.\n            if (removedFilters !== undefined && removedFilters.size !== 0) {\n                filters = filters.filter((f) => {\n                    if (removedFilters.has(f.getId())) {\n                        estimatedBufferSize -= f.getSerializedSize(compression);\n                        return false;\n                    }\n                    return true;\n                });\n            }\n            // Add new filters to the list and also update estimated size\n            for (const filter of newFilters) {\n                estimatedBufferSize += filter.getSerializedSize(compression);\n                filters.push(filter);\n            }\n        }\n        else {\n            // In the case where there is no existing filter in the index (happens on\n            // initialization), then we can take a fast-path and not check removed\n            // filters at all. There is also no need to copy the array of filters.\n            filters = newFilters;\n            for (const filter of newFilters) {\n                estimatedBufferSize += filter.getSerializedSize(compression);\n            }\n        }\n        // No filters given; reset to empty index and abort.\n        if (filters.length === 0) {\n            this.updateInternals({\n                bucketsIndex: _data_view_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_UINT32_ARRAY,\n                filtersIndexStart: 0,\n                numberOfFilters: 0,\n                tokensLookupIndex: _data_view_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_UINT32_ARRAY,\n                view: _data_view_js__WEBPACK_IMPORTED_MODULE_0__.StaticDataView.empty(this.config),\n            });\n            return;\n        }\n        // When we run in `debug` mode, we enable fully deterministic updates of\n        // internal data-structures. To this effect, we sort all filters before\n        // insertion.\n        if (this.config.debug === true) {\n            filters.sort((f1, f2) => f1.getId() - f2.getId());\n        }\n        const histogram = new Uint32Array(Math.max(nextPow2(2 * filters.length), 256));\n        // Tokenize all filters stored in this index. And compute a histogram of\n        // tokens so that we can decide how to index each filter efficiently.\n        for (const filter of filters) {\n            // Tokenize `filter` and store the result in `filtersTokens` which will\n            // be used in the next step to select the best token for each filter.\n            const multiTokens = filter.getTokens();\n            filtersTokens.push(multiTokens);\n            // Update estimated size of \"buckets index\" based on number of times this\n            // particular filter will be indexed.\n            bucketsIndexSize += 2 * multiTokens.length; // token + filter index\n            totalNumberOfIndexedFilters += multiTokens.length;\n            // Each filter can be indexed more than once, so `getTokens(...)` returns\n            // multiple sets of tokens. We iterate on all of them and update the\n            // histogram for each.\n            for (const tokens of multiTokens) {\n                totalNumberOfTokens += tokens.length;\n                for (const token of tokens) {\n                    histogram[token % histogram.length] += 1;\n                }\n            }\n        }\n        // Add size of bucketsIndex to total size (x4 because these are 32 bits numbers)\n        estimatedBufferSize += bucketsIndexSize * 4;\n        // Prepare \"tokens index\" (see documentation in constructor of `ReverseIndex` class above).\n        const tokensLookupIndexSize = Math.max(2, nextPow2(totalNumberOfIndexedFilters));\n        const mask = tokensLookupIndexSize - 1;\n        const suffixes = [];\n        for (let i = 0; i < tokensLookupIndexSize; i += 1) {\n            suffixes.push([]);\n        }\n        // Add size of tokensLookupIndex to total size (x4 because these are 32 bits numbers)\n        estimatedBufferSize += tokensLookupIndexSize * 4;\n        // At this point we know the number of bytes needed for the compact\n        // representation of this reverse index (\"tokens index\" + \"buckets index\" +\n        // \"filters index\"). We allocate it at once and proceed with populating it.\n        const buffer = _data_view_js__WEBPACK_IMPORTED_MODULE_0__.StaticDataView.allocate(estimatedBufferSize, this.config);\n        const tokensLookupIndex = buffer.getUint32ArrayView(tokensLookupIndexSize);\n        const bucketsIndex = buffer.getUint32ArrayView(bucketsIndexSize);\n        const filtersIndexStart = buffer.getPos();\n        // For each filter, find the best token (least seen) based on histogram.\n        // Since we are iterating again on the filters, we populate \"filters index\"\n        // in the same loop and keep track of their indices so that we can later\n        // populate \"buckets index\".\n        for (let i = 0; i < filtersTokens.length; i += 1) {\n            const filter = filters[i];\n            const multiTokens = filtersTokens[i];\n            // Serialize this filter and keep track of its index in the byte array;\n            // it will be used in \"buckets index\" to point to this filter.\n            const filterIndex = buffer.pos;\n            filter.serialize(buffer);\n            // Index the filter once per \"tokens\"\n            for (const tokens of multiTokens) {\n                // Find best token (least seen) from `tokens` using `histogram`.\n                let bestToken = 0; // default = wildcard bucket\n                let minCount = totalNumberOfTokens + 1;\n                for (const token of tokens) {\n                    const tokenCount = histogram[token % histogram.length];\n                    if (tokenCount < minCount) {\n                        minCount = tokenCount;\n                        bestToken = token;\n                        // Fast path, if the current token has only been seen once, we can\n                        // stop iterating since we will not find a better alternarive!\n                        if (minCount === 1) {\n                            break;\n                        }\n                    }\n                }\n                // `bestToken & mask` represents the N last bits of `bestToken`. We\n                // group all filters indexed with a token sharing the same N bits.\n                suffixes[bestToken & mask].push([bestToken, filterIndex]);\n            }\n        }\n        // Populate \"tokens index\" and \"buckets index\" based on best token found for each filter.\n        let indexInBucketsIndex = 0;\n        for (let i = 0; i < tokensLookupIndexSize; i += 1) {\n            const filtersForMask = suffixes[i];\n            tokensLookupIndex[i] = indexInBucketsIndex;\n            for (const [token, filterIndex] of filtersForMask) {\n                bucketsIndex[indexInBucketsIndex++] = token;\n                bucketsIndex[indexInBucketsIndex++] = filterIndex;\n            }\n        }\n        // Update internals\n        buffer.seekZero();\n        this.updateInternals({\n            bucketsIndex,\n            filtersIndexStart,\n            numberOfFilters: filtersTokens.length,\n            tokensLookupIndex,\n            view: buffer,\n        });\n    }\n    updateInternals({ bucketsIndex, filtersIndexStart, numberOfFilters, tokensLookupIndex, view, }) {\n        this.bucketsIndex = bucketsIndex;\n        this.filtersIndexStart = filtersIndexStart;\n        this.numberOfFilters = numberOfFilters;\n        this.tokensLookupIndex = tokensLookupIndex;\n        this.view = view;\n        view.seekZero();\n        return this;\n    }\n    /**\n     * If a bucket exists for the given token, call the callback on each filter\n     * found inside. An early termination mechanism is built-in, to stop iterating\n     * as soon as `false` is returned from the callback.\n     */\n    iterBucket(token, requestId, cb) {\n        let bucket = this.config.enableInMemoryCache === true ? this.cache.get(token) : undefined;\n        // Lazily create bucket if it does not yet exist in memory. Lookup the\n        // compact bucket representation and find all filters being associated with\n        // `token`. Create a `Bucket` out of them and store them in cache.\n        if (bucket === undefined) {\n            const offset = token & (this.tokensLookupIndex.length - 1);\n            const startOfBucket = this.tokensLookupIndex[offset];\n            // We do not have any filters for this token\n            if (startOfBucket === EMPTY_BUCKET) {\n                return true;\n            }\n            // Since we do not store explicitly the number of filters in each\n            // \"bucket\", we check the index of the next one and use it to infer the\n            // number of filters (each filter being stored as a token + index to the\n            // \"filters store\")\n            const endOfBucket = offset === this.tokensLookupIndex.length - 1\n                ? this.bucketsIndex.length\n                : this.tokensLookupIndex[offset + 1];\n            // Get indices of filters indexed with `token`, if any.\n            const filtersIndices = [];\n            for (let i = startOfBucket; i < endOfBucket; i += 2) {\n                const currentToken = this.bucketsIndex[i];\n                if (currentToken === token) {\n                    filtersIndices.push(this.bucketsIndex[i + 1]);\n                }\n            }\n            // No filter indexed with `token`.\n            if (filtersIndices.length === 0) {\n                return true; // continue looking for a match\n            }\n            // If we have filters for `token` then deserialize filters in memory and\n            // create a `Bucket` instance to hold them for future access.\n            const filters = [];\n            const view = this.view;\n            for (let i = 0; i < filtersIndices.length; i += 1) {\n                view.setPos(filtersIndices[i]);\n                filters.push(this.deserializeFilter(view));\n            }\n            // Create new bucket with found filters (only optimize if we have more\n            // than one filter).\n            bucket = {\n                filters: filters.length > 1 ? this.optimize(filters) : filters,\n                lastRequestSeen: -1, // safe because all ids are positive\n            };\n            if (this.config.enableInMemoryCache === true) {\n                this.cache.set(token, bucket);\n            }\n        }\n        // Look for matching filter in this bucket\n        if (bucket.lastRequestSeen !== requestId) {\n            bucket.lastRequestSeen = requestId;\n            const filters = bucket.filters;\n            for (let i = 0; i < filters.length; i += 1) {\n                // Break the loop if the callback returns `false`\n                if (cb(filters[i]) === false) {\n                    // Whenever we get a match from a filter, we also swap it one\n                    // position up in the list. This way, over time, popular filters will\n                    // be first and might match earlier. This should decrease the time\n                    // needed to get a match.\n                    if (i > 0) {\n                        const filter = filters[i];\n                        filters[i] = filters[i - 1];\n                        filters[i - 1] = filter;\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n//# sourceMappingURL=reverse-index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvcmV2ZXJzZS1pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrRjtBQUNsRjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5REFBYztBQUNuQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLHlDQUF5QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkRBQWtCO0FBQzlDO0FBQ0E7QUFDQSxpQ0FBaUMsNkRBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseURBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsOEJBQThCLDZEQUFrQjtBQUNoRDtBQUNBO0FBQ0EsbUNBQW1DLDZEQUFrQjtBQUNyRCxzQkFBc0IseURBQWM7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNCQUFzQiw0RUFBNEU7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9lbmdpbmUvcmV2ZXJzZS1pbmRleC5qcz9mZTAzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQgR2hvc3RlcnkgR21iSC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IHsgU3RhdGljRGF0YVZpZXcsIEVNUFRZX1VJTlQzMl9BUlJBWSwgc2l6ZU9mQnl0ZXMgfSBmcm9tICcuLi9kYXRhLXZpZXcuanMnO1xuLy8gaHR0cHM6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvfnNlYW5kZXIvYml0aGFja3MuaHRtbCNSb3VuZFVwUG93ZXJPZjJcbmV4cG9ydCBmdW5jdGlvbiBuZXh0UG93Mih2KSB7XG4gICAgdi0tO1xuICAgIHYgfD0gdiA+PiAxO1xuICAgIHYgfD0gdiA+PiAyO1xuICAgIHYgfD0gdiA+PiA0O1xuICAgIHYgfD0gdiA+PiA4O1xuICAgIHYgfD0gdiA+PiAxNjtcbiAgICB2Kys7XG4gICAgcmV0dXJuIHY7XG59XG4vKipcbiAqIEdlbmVyYXRlIHVuaXF1ZSBJRHMgZm9yIHJlcXVlc3RzLCB3aGljaCBpcyB1c2VkIHRvIGF2b2lkIG1hdGNoaW5nIHRoZSBzYW1lXG4gKiBidWNrZXRzIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lIHJlcXVlc3QgKHdoaWNoIGNhbiBoYXBwZW4gaWYgYSB0b2tlblxuICogYXBwZWFycyBtb3JlIHRoYW4gb25jZSBpbiBhIFVSTCkuXG4gKi9cbmxldCBVSUQgPSAxO1xuZnVuY3Rpb24gZ2V0TmV4dElkKCkge1xuICAgIGNvbnN0IGlkID0gVUlEO1xuICAgIFVJRCA9IChVSUQgKyAxKSAlIDEwMDAwMDAwMDA7XG4gICAgcmV0dXJuIGlkO1xufVxuY29uc3QgRU1QVFlfQlVDS0VUID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgPj4+IDA7XG4vKipcbiAqIFRoZSBSZXZlcnNlSW5kZXggaXMgYW4gYWNjZWxlcmF0aW5nIGRhdGEgc3RydWN0dXJlIHdoaWNoIGFsbG93cyBmaW5kaW5nIGFcbiAqIHN1YnNldCBvZiB0aGUgZmlsdGVycyBnaXZlbiBhIGxpc3Qgb2YgdG9rZW5zIHNlZW4gaW4gYSBVUkwuIEl0IGlzIHRoZSBjb3JlXG4gKiBvZiB0aGUgYWRibG9ja2VyJ3MgbWF0Y2hpbmcgY2FwYWJpbGl0aWVzIGFuZCBzcGVlZC5cbiAqXG4gKiBJdCBoYXMgbWFpbmx5IHR3byBjYXJhY3RlcmlzdGljczpcbiAqIDEuIEl0IGlzIHZlcnkgY29tcGFjdCBhbmQgaXMgYWJsZSB0byBsb2FkIGZhc3QuXG4gKiAyLiBJdCBpcyAqdmVyeSBmYXN0KiBpbiBmaW5kaW5nIHBvdGVudGlhbCBjYW5kaWRhdGVzLlxuICpcbiAqIENvbmNlcHR1YWxseSwgdGhlIHJldmVyc2UgaW5kZXggZGlzcGF0Y2hlcyBmaWx0ZXJzIGluIFwiYnVja2V0c1wiIChhbiBhcnJheSBvZlxuICogb25lIG9yIG1vcmUgZmlsdGVycykuIEZpbHRlcnMgbGl2aW5nIGluIHRoZSBzYW1lIGJ1Y2tldCBhcmUgZ3VhcmFudGVlZCB0b1xuICogc2hhcmUgYXQgbGVhc3Qgb25lIG9mIHRoZWlyIHRva2VucyAoYXBwZWFyaW5nIGluIHRoZSBwYXR0ZXJuKS4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAtIEJ1Y2tldCAxIChhZHMpOlxuICogICAgICAgLSAvYWRzLmpzXG4gKiAgICAgICAtIC9zY3JpcHQvYWRzL3RyYWNraW5nLmpzXG4gKiAgICAgICAtIC9hZHMvXG4gKiAgIC0gQnVja2V0IDIgKHRyYWNraW5nKVxuICogICAgICAgLSAvdHJhY2tpbmcuanNcbiAqICAgICAgIC0gfHx0cmFja2luZy5jb20vY2RuXG4gKlxuICogV2Ugc2VlIHRoYXQgZmlsdGVycyBpbiBcIkJ1Y2tldCAxXCIgYXJlIGluZGV4ZWQgdXNpbmcgdGhlIHRva2VuIFwiYWRzXCIgYW5kXG4gKiBcIkJ1Y2tldCAyXCIgdXNpbmcgdG9rZW4gXCJ0cmFja2luZ1wiLlxuICpcbiAqIFRoaXMgcHJvcGVydHkgYWxsb3dzIHRvIHF1aWNrbHkgZGlzY2FyZCBtb3N0IG9mIHRoZSBmaWx0ZXJzIHdoZW4gd2UgbWF0Y2ggYVxuICogVVJMLiBUbyBhY2hpZXZlIHRoaXMsIHRoZSBVUkwgaXMgdG9rZW5pemVkIGluIHRoZSBzYW1lIHdheSBmaWx0ZXJzIGFyZVxuICogdG9rZW5pemVkIGFuZCBmb3IgZWFjaCB0b2tlbiwgd2UgY2hlY2sgaWYgdGhlcmUgYXJlIHNvbWUgZmlsdGVycyBhdmFpbGFibGUuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogIFVSTCBcImh0dHBzOi8vdHJhY2tpbmcuY29tL1wiIGhhcyB0aGUgZm9sbG93aW5nIHRva2VuczogXCJodHRwc1wiLCBcInRyYWNraW5nXCJcbiAqICBhbmQgXCJjb21cIi4gV2UgaW1tZWRpYXRseSBzZWUgdGhhdCB3ZSBvbmx5IGNoZWNrIHRoZSB0d28gZmlsdGVycyBpbiB0aGVcbiAqICBcInRyYWNraW5nXCIgYnVja2V0IHNpbmNlIHRoZXkgYXJlIHRoZSBvbmx5IG9uZXMgaGF2aW5nIGEgY29tbW9uIHRva2VuIHdpdGhcbiAqICB0aGUgVVJMLlxuICpcbiAqIEhvdyBkbyB3ZSBwaWNrIHRoZSB0b2tlbiBmb3IgZWFjaCBmaWx0ZXI/XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEVhY2ggZmlsdGVyIGlzIG9ubHkgaW5kZXhlZCAqb25jZSosIHdoaWNoIG1lYW5zIHRoYXQgd2UgbmVlZCB0byBwaWNrIG9uZSBvZlxuICogdGhlIHRva2VucyBhcHBlYXJpbmcgaW4gdGhlIHBhdHRlcm4uIFdlIGNob29zZSB0aGUgdG9rZW4gc3VjaCB0aGF0IGVhY2hcbiAqIGZpbHRlciBpcyBpbmRleGVkIHVzaW5nIHRoZSB0b2tlbiB3aGljaCB3YXMgdGhlICpsZWFzdCBzZWVuKiBnbG9iYWxseS4gSW5cbiAqIG90aGVyIHdvcmRzLCB3ZSBwaWNrIHRoZSBtb3N0IGRpc2NyaW1pbmF0aXZlIHRva2VuIGZvciBlYWNoIGZpbHRlci4gVGhpcyBpc1xuICogZG9uZSB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqICAgMS4gVG9rZW5pemUgYWxsIHRoZSBmaWx0ZXJzIHdoaWNoIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBpbmRleFxuICogICAyLiBDb21wdXRlIGEgaGlzdG9ncmFtIG9mIGZyZXF1ZW5jeSBvZiBlYWNoIHRva2VuIChnbG9iYWxseSlcbiAqICAgMy4gU2VsZWN0IHRoZSBiZXN0IHRva2VuIGZvciBlYWNoIGZpbHRlciAobG93ZXN0IGZyZXF1ZW5jeSlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmV2ZXJzZUluZGV4IHtcbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnVmZmVyLCBkZXNlcmlhbGl6ZSwgb3B0aW1pemUsIGNvbmZpZykge1xuICAgICAgICBjb25zdCB0b2tlbnNMb29rdXBJbmRleFNpemUgPSBidWZmZXIuZ2V0VWludDMyKCk7XG4gICAgICAgIGNvbnN0IGJ1Y2tldHNJbmRleFNpemUgPSBidWZmZXIuZ2V0VWludDMyKCk7XG4gICAgICAgIGNvbnN0IG51bWJlck9mRmlsdGVycyA9IGJ1ZmZlci5nZXRVaW50MzIoKTtcbiAgICAgICAgLy8gQWxpZ25lbWVudCB0byA0IGJ5dGVzIGlzIGltcG9ydGFudCBoZXJlIHNpbmNlIGB2aWV3YCAoVWludDhBcnJheSkgY2FuXG4gICAgICAgIC8vIGFwcGVhciBhdCBhbnkgb2Zmc2V0IG9mIGBidWZmZXJgLiBCdXQgdG8gYmUgc3VyZSB3ZSBjYW4gcmVhZCBiYWNrXG4gICAgICAgIC8vIFVpbnQzMkFycmF5IGRpcmVjdGx5IGZyb20gcmF3IGJ1ZmZlciwgdGhlIGFsaWduZW1lbnQgaGFzIHRvIGJlIGFcbiAgICAgICAgLy8gbXVsdGlwbGUgb2YgNC4gVGhlIHNhbWUgYWxpZ25lbWVudCBpcyB0YWtlbiBjYXJlIG9mIGluIGBzZXJpYWxpemVgLlxuICAgICAgICBjb25zdCB2aWV3ID0gU3RhdGljRGF0YVZpZXcuZnJvbVVpbnQ4QXJyYXkoYnVmZmVyLmdldEJ5dGVzKHRydWUgLyogYWxpZ24gKi8pLCBjb25maWcpO1xuICAgICAgICBjb25zdCB0b2tlbnNMb29rdXBJbmRleCA9IHZpZXcuZ2V0VWludDMyQXJyYXlWaWV3KHRva2Vuc0xvb2t1cEluZGV4U2l6ZSk7XG4gICAgICAgIGNvbnN0IGJ1Y2tldHNJbmRleCA9IHZpZXcuZ2V0VWludDMyQXJyYXlWaWV3KGJ1Y2tldHNJbmRleFNpemUpO1xuICAgICAgICBjb25zdCBmaWx0ZXJzSW5kZXhTdGFydCA9IHZpZXcucG9zO1xuICAgICAgICB2aWV3LnNlZWtaZXJvKCk7IC8vIG5vdCBzdHJpY3RseSBuZWVkZWQgYnV0IG1ha2Ugc3VyZSByZXZlcnNlIGluZGV4IGNhbiBiZSBjb21wYXJlZCB3aXRoIGRlZXAgZXF1YWxcbiAgICAgICAgcmV0dXJuIG5ldyBSZXZlcnNlSW5kZXgoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgZGVzZXJpYWxpemUsXG4gICAgICAgICAgICBmaWx0ZXJzOiBbXSxcbiAgICAgICAgICAgIG9wdGltaXplLFxuICAgICAgICB9KS51cGRhdGVJbnRlcm5hbHMoe1xuICAgICAgICAgICAgYnVja2V0c0luZGV4LFxuICAgICAgICAgICAgZmlsdGVyc0luZGV4U3RhcnQsXG4gICAgICAgICAgICBudW1iZXJPZkZpbHRlcnMsXG4gICAgICAgICAgICB0b2tlbnNMb29rdXBJbmRleCxcbiAgICAgICAgICAgIHZpZXcsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IGRlc2VyaWFsaXplLCBmaWx0ZXJzLCBvcHRpbWl6ZSwgY29uZmlnLCB9KSB7XG4gICAgICAgIC8vIEludGVybmFsLCBjb21wYWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXZlcnNlIGluZGV4LiBJdCBjb250YWlucyB0aHJlZVxuICAgICAgICAvLyBkaXN0aW5jdCBwYXJ0cyBzdG9yZWQgaW4gdGhlIHNhbWUgdHlwZWQgYXJyYXk6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEuIFwidG9rZW5zIGxvb2t1cCBpbmRleFwiIGFsbG93cyB0byBpZGVudGlmeSBhIHN1Yi1zZXQgb2YgYnVja2V0cyB3aGljaFxuICAgICAgICAvLyBsaWtlbHkgY29udGFpbiBmaWx0ZXJzIGZvciBhIGdpdmVuIHRva2VuLiBJdCBpcyBhbiBhcHByb3hpbWF0ZSBkaXNwYXRjaFxuICAgICAgICAvLyB0YWJsZSB3aGljaCBtYXBzIGEgbWFzayBvZiBOIGJpdHMgKE4gYmVpbmcgc21hbGxlciB0aGFuIDMxIGJpdHMsIHRoZSBzaXplXG4gICAgICAgIC8vIG9mIGEgdG9rZW4pIHRvIGEgbGlzdCBvZiBidWNrZXRzIGhhdmluZyBhICd0b2tlbicgc2hhcmluZyB0aGVzZSBzYW1lIE5cbiAgICAgICAgLy8gYml0cyBzdWItc2V0LiBJZiB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0b2tlbiBmb3IgYnVja2V0MSBpc1xuICAgICAgICAvLyAxMDEwMTAgYW5kIHN1ZmZpeCBoYXMgc2l6ZSAzLCB0aGVuIHdlIHdvdWxkIGxvb2t1cCB0aGUgXCJ0b2tlbnMgbG9va3VwXG4gICAgICAgIC8vIGluZGV4XCIgdXNpbmcgdGhlIGxhc3QgMyBiaXRzIFwiMDEwXCIgd2hpY2ggd291bGQgZ2l2ZSB1cyB0aGUgb2Zmc2V0IGluIG91clxuICAgICAgICAvLyB0eXBlZCBhcnJheSB3aGVyZSB3ZSBjYW4gc3RhcnQgcmVhZGluZyB0aGUgZmlsdGVycyBvZiBidWNrZXRzIGhhdmluZyBhXG4gICAgICAgIC8vIHRva2VuIGVuZGluZyB3aXRoIHRoZSBzYW1lIDMgYml0cy4gVGhlIHZhbHVlIG9mIE4gaXMgYWx3YXlzIGEgcG93ZXIgb2YgMlxuICAgICAgICAvLyBkZXBlbmRpbmcgb24gdGhlIHRvdGFsIG51bWJlciBvZiBmaWx0ZXJzIHN0b3JlZCBpbiB0aGUgaW5kZXg7IGRldGVybWluZWRcbiAgICAgICAgLy8gYXQgdGhlIHRpbWUgYHVwZGF0ZSguLi4pYCBpcyBjYWxsZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIDIuIFwiYnVja2V0cyBpbmRleFwiIGlzIGFuIGFycmF5IHdoaWNoIGFzc29jaWF0ZXMgdG9rZW5zIHRvIGZpbHRlcnMuIFRoZVxuICAgICAgICAvLyBzdHJ1Y3R1cmUgaXM6IHRva2VuLCBmaWx0ZXIsIHRva2VuLCBmaWx0ZXIsIGV0Yy4gVG8gaWRlbnRpZnkgYWxsIHRoZVxuICAgICAgICAvLyBmaWx0ZXJzIGluZGV4ZWQgd2l0aCAndG9rZW4nIGEgbmFpdmUgYXBwcm9hY2ggd291bGQgYmUgdG8gaXRlcmF0ZSBvblxuICAgICAgICAvLyBcImJ1Y2tldHMgaW5kZXhcIiBhbmQgY29sbGVjdCBhbGwgdGhlIGZpbHRlcnMgaW5kZXhlZCB3aXRoICd0b2tlbicuIFRoaXNcbiAgICAgICAgLy8gd291bGQgYmUgKnZlcnkgaW5lZmZpY2llbnQqISBUbyBtYWtlIHRoaXMgcHJvY2VzcyBmYXN0ZXIsIGZpbHRlcnMgaW5cbiAgICAgICAgLy8gXCJidWNrZXRzIGluZGV4XCIgYXJlIGdyb3VwZWQgc28gdGhhdCBidWNrZXRzIHNoYXJpbmcgdGhlIHNhbWUgc3VmZml4IG9mIE5cbiAgICAgICAgLy8gYml0cyBpbiB0aGVpciBpbmRleGluZyB0b2tlbiAoc2VlIFwidG9rZW5zIGxvb2t1cCBpbmRleFwiKSBhcmUgc3RvcmVkIHNpZGVcbiAgICAgICAgLy8gYnkgc2lkZSBpbiB0aGUgdHlwZWQgYXJyYXkuIFRvIGtub3cgd2hlcmUgdGhpcyBzZWN0aW9uIHN0YXJ0IGdpdmVuIGFcbiAgICAgICAgLy8gcGFydGljdWxhciB0b2tlbiwgd2UgdXNlIFwidG9rZW5zIGxvb2t1cCBpbmRleFwiIHdoaWNoIGFzc29jaWF0ZWQgdGhlIHN1ZmZpeFxuICAgICAgICAvLyBvZiBzaXplIE4gdG8gYW4gaW5kZXggaW4gXCJidWNrZXRzIGluZGV4XCIuIEZyb20gdGhlcmUgd2UgY2FuIGl0ZXJhdGUgb24gdGhlXG4gICAgICAgIC8vIGNhbmRpZGF0ZXMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIDMuIFwiZmlsdGVycyBpbmRleFwiIGNvbnRhaW5zIHRoZSBmaWx0ZXJzIHRoZW1zZWx2ZXMuIFwiYnVja2V0cyBpbmRleFwiXG4gICAgICAgIC8vIHByZXNlbnRlZCBlYXJsaWVyIGRvZXMgbm90IGNvbnRhaW4gZmlsdGVycywgYnV0IGFuIGluZGV4IHRvIHRoZSBcImZpbHRlcnNcbiAgICAgICAgLy8gaW5kZXhcIi4gVGhpcyBhbGxvd3MgYSBmaWx0ZXIgdG8gYmUgaW5kZXhlZCBtdWx0aXBsZSB0aW1lcyB3aXRob3V0XG4gICAgICAgIC8vIGludHJvZHVjaW5nIGFueSBvdmVyaGVhZDsgdGhlIGZpbHRlciBjYW4gYmUgYXNzb2NpYXRlZCB3aXRoIG11bHRpcGxlXG4gICAgICAgIC8vIHRva2VucyBpbiBcImJ1Y2tldHMgaW5kZXhcIiAoZWFjaCBwb2ludGluZyB0byB0aGUgc2FtZSBwbGFjZSBpbiBcImZpbHRlcnNcbiAgICAgICAgLy8gaW5kZXhcIikgYnV0IGl0cyBhY3R1YWwgcmVwcmVzZW50YXRpb24gaXMgc3RvcmVkIG9ubHkgb25jZSBpbiBcImZpbHRlcnNcbiAgICAgICAgLy8gaW5kZXhcIi5cbiAgICAgICAgdGhpcy5idWNrZXRzSW5kZXggPSBFTVBUWV9VSU5UMzJfQVJSQVk7XG4gICAgICAgIHRoaXMuZmlsdGVyc0luZGV4U3RhcnQgPSAwO1xuICAgICAgICB0aGlzLm51bWJlck9mRmlsdGVycyA9IDA7XG4gICAgICAgIHRoaXMudG9rZW5zTG9va3VwSW5kZXggPSBFTVBUWV9VSU5UMzJfQVJSQVk7XG4gICAgICAgIC8vIEluLW1lbW9yeSBjYWNoZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgYnVja2V0cyB3aGljaCBoYXZlIGJlZW4gbG9hZGVkIGZyb21cbiAgICAgICAgLy8gdGhlIGNvbXBhY3QgcmVwcmVzZW50YXRpb24gKGkuZS46IHRoaXMudmlldykuIEl0IGlzIG5vdCBzdHJpY3RseSBuZWNlc3NhcnlcbiAgICAgICAgLy8gYnV0IHdpbGwgc3BlZWQtdXAgcmV0cml2YWwgb2YgcG9wdWxhciBmaWx0ZXJzIChzaW5jZSB3ZSBkbyBub3QgaGF2ZSB0b1xuICAgICAgICAvLyBwZXJmb3JtIHRoZSBsb29rdXAgaW4gXCJ0b2tlbnMgaW5kZXhcIiBhbmQgXCJidWNrZXRzIGluZGV4XCIgZXZlcnl0aW1lKS5cbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy52aWV3ID0gU3RhdGljRGF0YVZpZXcuZW1wdHkoY29uZmlnKTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZUZpbHRlciA9IGRlc2VyaWFsaXplO1xuICAgICAgICB0aGlzLm9wdGltaXplID0gb3B0aW1pemU7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICBpZiAoZmlsdGVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKGZpbHRlcnMsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZCBhbGwgZmlsdGVycyBmcm9tIHRoaXMgaW5kZXggaW4gbWVtb3J5IChpLmUuOiBkZXNlcmlhbGl6ZSB0aGVtIGZyb21cbiAgICAgKiB0aGUgYnl0ZSBhcnJheSBpbnRvIE5ldHdvcmtGaWx0ZXIgb3IgQ29zbWV0aWNGaWx0ZXIgaW5zdGFuY2VzKS4gVGhpcyBpc1xuICAgICAqIG1vc3RseSB1c2VmdWwgZm9yIGRlYnVnZ2luZyBvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICAgICAqL1xuICAgIGdldEZpbHRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMubnVtYmVyT2ZGaWx0ZXJzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVycztcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdmlldyBjdXJzb3IgYXQgdGhlIHN0YXJ0IG9mIFwiZmlsdGVycyBpbmRleFwiXG4gICAgICAgIHRoaXMudmlldy5zZXRQb3ModGhpcy5maWx0ZXJzSW5kZXhTdGFydCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1iZXJPZkZpbHRlcnM7IGkgKz0gMSkge1xuICAgICAgICAgICAgZmlsdGVycy5wdXNoKHRoaXMuZGVzZXJpYWxpemVGaWx0ZXIodGhpcy52aWV3KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3LnNlZWtaZXJvKCk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgYWxsIHRoZSB0b2tlbnMgY3VycmVudGx5IHVzZWQgYXMga2V5cyBvZiB0aGUgXCJidWNrZXRzIGluZGV4XCIuXG4gICAgICovXG4gICAgZ2V0VG9rZW5zKCkge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5idWNrZXRzSW5kZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHRva2Vucy5hZGQodGhpcy5idWNrZXRzSW5kZXhbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkodG9rZW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXN0aW1hdGUgdGhlIG51bWJlciBvZiBieXRlcyBuZWVkZWQgdG8gc2VyaWFsaXplIHRoaXMgaW5zdGFuY2Ugb2YgYFJldmVyc2VJbmRleGAuXG4gICAgICovXG4gICAgZ2V0U2VyaWFsaXplZFNpemUoKSB7XG4gICAgICAgIC8vIDEyID0gNCBieXRlcyAodG9rZW5zTG9va3VwSW5kZXgubGVuZ3RoKSArIDQgYnl0ZXMgKGJ1Y2tldHNJbmRleC5sZW5ndGgpICsgNCBieXRlcyAobnVtYmVyT2ZGaWx0ZXJzKVxuICAgICAgICByZXR1cm4gMTIgKyBzaXplT2ZCeXRlcyh0aGlzLnZpZXcuYnVmZmVyLCB0cnVlIC8qIGFsaWduICovKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHVtcCB0aGlzIGluZGV4IHRvIGBidWZmZXJgLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZShidWZmZXIpIHtcbiAgICAgICAgYnVmZmVyLnB1c2hVaW50MzIodGhpcy50b2tlbnNMb29rdXBJbmRleC5sZW5ndGgpO1xuICAgICAgICBidWZmZXIucHVzaFVpbnQzMih0aGlzLmJ1Y2tldHNJbmRleC5sZW5ndGgpO1xuICAgICAgICBidWZmZXIucHVzaFVpbnQzMih0aGlzLm51bWJlck9mRmlsdGVycyk7XG4gICAgICAgIC8vIEFsaWdtZW5lbnQgaXMgY3J1Y2lhbCBoZXJlLCBzZWUgY29tbWVudCBpbiBgZGVzZXJpYWxpemVgIGZvciBtb3JlIGluZm8uXG4gICAgICAgIGJ1ZmZlci5wdXNoQnl0ZXModGhpcy52aWV3LmJ1ZmZlciwgdHJ1ZSAvKiBhbGlnbiAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGUgb24gYWxsIGZpbHRlcnMgZm91bmQgaW4gYnVja2V0cyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGxpc3Qgb2ZcbiAgICAgKiB0b2tlbnMuIFRoZSBjYWxsYmFjayBpcyBjYWxsZWQgb24gZWFjaCBvZiB0aGVtLiBFYXJseSB0ZXJtaW5hdGlvbiBjYW4gYmVcbiAgICAgKiBhY2hpZXZlZCBpZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIG5vdCBjaGVjayBpZiBlYWNoIGZpbHRlciByZXR1cm5lZCB3b3VsZCBtYXRjaCBhIGdpdmVuIHJlcXVlc3QgYnV0XG4gICAgICogaXMgaW5zdGVhZCB1c2VkIGFzIGEgbGlzdCBvZiBwb3RlbnRpYWwgY2FuZGlkYXRlcyAobXVjaCBzbWFsbGVyIHRoYW4gdGhlXG4gICAgICogdG90YWwgc2V0IG9mIGZpbHRlcnM7IHR5cGljYWxseSBiZXR3ZWVuIDUgYW5kIDEwIGZpbHRlcnMgd2lsbCBiZSBjaGVja2VkKS5cbiAgICAgKi9cbiAgICBpdGVyTWF0Y2hpbmdGaWx0ZXJzKHRva2VucywgY2IpIHtcbiAgICAgICAgLy8gRWFjaCByZXF1ZXN0IGlzIGFzc2lnbmVkIGFuIElEIHNvIHRoYXQgd2UgY2FuIGtlZXAgdHJhY2sgb2YgdGhlIGxhc3RcbiAgICAgICAgLy8gcmVxdWVzdCBzZWVuIGJ5IGVhY2ggYnVja2V0IGluIHRoZSByZXZlcnNlIGluZGV4LiBUaGlzIHByb3ZpZGVzIGEgY2hlYXBcbiAgICAgICAgLy8gd2F5IHRvIHByZXZlbnQgZmlsdGVycyBmcm9tIGJlaW5nIGluc3BlY3RlZCBtb3JlIHRoYW4gb25jZSBwZXIgcmVxdWVzdFxuICAgICAgICAvLyAod2hpY2ggY291bGQgaGFwcGVuIGlmIHRoZSBzYW1lIHRva2VuIGFwcGVhcnMgbW9yZSB0aGFuIG9uY2UgaW4gdGhlIFVSTCkuXG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IGdldE5leHRJZCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlckJ1Y2tldCh0b2tlbiwgcmVxdWVzdElkLCBjYikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIDAgKGkuZS46IHdpbGRjYXJkIGJ1Y2tldCkgYnVja2V0IGlmIG5vdGhpbmcgd2FzIGZvdW5kIGJlZm9yZS5cbiAgICAgICAgdGhpcy5pdGVyQnVja2V0KDAsIHJlcXVlc3RJZCwgY2IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZS1jcmVhdGUgdGhlIGludGVybmFsIGRhdGEtc3RydWN0dXJlIG9mIHRoZSByZXZlcnNlIGluZGV4ICppbi1wbGFjZSouIEl0XG4gICAgICogbmVlZHMgdG8gYmUgY2FsbGVkIHdpdGggYSBsaXN0IG9mIG5ldyBmaWx0ZXJzIGFuZCBvcHRpb25hbGx5IGEgbGlzdCBvZiBpZHNcbiAgICAgKiAoYXMgcmV0dXJuZWQgYnkgZWl0aGVyIE5ldHdvcmtGaWx0ZXIuZ2V0SWQoKSBvciBDb3NtZXRpY0ZpbHRlci5nZXRJZCgpKVxuICAgICAqIHdoaWNoIG5lZWQgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBpbmRleC5cbiAgICAgKi9cbiAgICB1cGRhdGUobmV3RmlsdGVycywgcmVtb3ZlZEZpbHRlcnMpIHtcbiAgICAgICAgLy8gUmVzZXQgaW50ZXJuYWwgY2FjaGUgb24gZWFjaCB1cGRhdGVcbiAgICAgICAgaWYgKHRoaXMuY2FjaGUuc2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXByZXNzaW9uID0gdGhpcy5jb25maWcuZW5hYmxlQ29tcHJlc3Npb247XG4gICAgICAgIGxldCB0b3RhbE51bWJlck9mVG9rZW5zID0gMDtcbiAgICAgICAgbGV0IHRvdGFsTnVtYmVyT2ZJbmRleGVkRmlsdGVycyA9IDA7XG4gICAgICAgIGNvbnN0IGZpbHRlcnNUb2tlbnMgPSBbXTtcbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgZmluYWwgc2l6ZSBvZiB0aGUgYnVja2V0cyBpbmRleC4gYGJ1Y2tldHNJbmRleFNpemVgIGlzXG4gICAgICAgIC8vIHRoZSBudW1iZXIgb2YgaW5kZXhlZCBmaWx0ZXJzLCBtdWx0aXBsaWVkIGJ5IDIgKHNpbmNlIHdlIHN0b3JlIGJvdGggdGhlXG4gICAgICAgIC8vIHRva2VuIGEgZmlsdGVyIGlzIGluZGV4ZWQgd2l0aCBhbmQgdGhlIGluZGV4IG9mIHRoZSBmaWx0ZXIpLlxuICAgICAgICBsZXQgYnVja2V0c0luZGV4U2l6ZSA9IDA7XG4gICAgICAgIC8vIFJlLXVzZSB0aGUgY3VycmVudCBzaXplIG9mIFwiZmlsdGVycyBpbmRleFwiIGFzIGEgc3RhcnRpbmcgcG9pbnQgc28gdGhhdFxuICAgICAgICAvLyB3ZSBvbmx5IG5lZWQgdG8gdXBkYXRlIHdpdGggbmV3IG9yIHJlbW92ZWQgZmlsdGVycy4gVGhpcyBzYXZlcyB0aW1lIGlmXG4gICAgICAgIC8vIHdlIHBlcmZvcm0gYSBzbWFsbCB1cGRhdGUgb24gYW4gZXhpc3RpbmcgaW5kZXguXG4gICAgICAgIGxldCBlc3RpbWF0ZWRCdWZmZXJTaXplID0gdGhpcy52aWV3LmJ1ZmZlci5ieXRlTGVuZ3RoIC0gdGhpcy5maWx0ZXJzSW5kZXhTdGFydDtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbGlzdCBvZiBhbGwgZmlsdGVycyB3aGljaCB3aWxsIGJlIHBhcnQgb2YgdGhlIGluZGV4LiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGxvYWRpbmcgZXhpc3RpbmcgZmlsdGVycywgcmVtb3ZpbmcgdGhlIG9uZXMgdGhhdCBuZWVkIHRvIGJlIGRlbGV0ZWQgYW5kXG4gICAgICAgIC8vIGFkZGluZyB0aGUgbmV3IG9uZXMuICBBdCB0aGUgc2FtZSB0aW1lLCB3ZSB1cGRhdGUgdGhlIGVzdGltYXRpb24gb2ZcbiAgICAgICAgLy8gYnVmZmVyIHNpemUgbmVlZGVkIHRvIHN0b3JlIHRoaXMgaW5kZXguXG4gICAgICAgIGxldCBmaWx0ZXJzID0gdGhpcy5nZXRGaWx0ZXJzKCk7XG4gICAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGV4aXN0aW5nIGZpbHRlciwgdGhlbiB3ZSBjaGVjayBpZiBzb21lIHNob3VsZFxuICAgICAgICAgICAgLy8gYmUgcmVtb3ZlZC4gV2Ugc3VidHJhY3QgdGhlaXIgc2l6ZSBmcm9tIHRoZSB0b3RhbCBlc3RpbWF0ZWQgYnVmZmVyXG4gICAgICAgICAgICAvLyBzaXplLlxuICAgICAgICAgICAgaWYgKHJlbW92ZWRGaWx0ZXJzICE9PSB1bmRlZmluZWQgJiYgcmVtb3ZlZEZpbHRlcnMuc2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGZpbHRlcnMgPSBmaWx0ZXJzLmZpbHRlcigoZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZEZpbHRlcnMuaGFzKGYuZ2V0SWQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzdGltYXRlZEJ1ZmZlclNpemUgLT0gZi5nZXRTZXJpYWxpemVkU2l6ZShjb21wcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgbmV3IGZpbHRlcnMgdG8gdGhlIGxpc3QgYW5kIGFsc28gdXBkYXRlIGVzdGltYXRlZCBzaXplXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBuZXdGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgZXN0aW1hdGVkQnVmZmVyU2l6ZSArPSBmaWx0ZXIuZ2V0U2VyaWFsaXplZFNpemUoY29tcHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugd2hlcmUgdGhlcmUgaXMgbm8gZXhpc3RpbmcgZmlsdGVyIGluIHRoZSBpbmRleCAoaGFwcGVucyBvblxuICAgICAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24pLCB0aGVuIHdlIGNhbiB0YWtlIGEgZmFzdC1wYXRoIGFuZCBub3QgY2hlY2sgcmVtb3ZlZFxuICAgICAgICAgICAgLy8gZmlsdGVycyBhdCBhbGwuIFRoZXJlIGlzIGFsc28gbm8gbmVlZCB0byBjb3B5IHRoZSBhcnJheSBvZiBmaWx0ZXJzLlxuICAgICAgICAgICAgZmlsdGVycyA9IG5ld0ZpbHRlcnM7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBuZXdGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgZXN0aW1hdGVkQnVmZmVyU2l6ZSArPSBmaWx0ZXIuZ2V0U2VyaWFsaXplZFNpemUoY29tcHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIGZpbHRlcnMgZ2l2ZW47IHJlc2V0IHRvIGVtcHR5IGluZGV4IGFuZCBhYm9ydC5cbiAgICAgICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUludGVybmFscyh7XG4gICAgICAgICAgICAgICAgYnVja2V0c0luZGV4OiBFTVBUWV9VSU5UMzJfQVJSQVksXG4gICAgICAgICAgICAgICAgZmlsdGVyc0luZGV4U3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZGaWx0ZXJzOiAwLFxuICAgICAgICAgICAgICAgIHRva2Vuc0xvb2t1cEluZGV4OiBFTVBUWV9VSU5UMzJfQVJSQVksXG4gICAgICAgICAgICAgICAgdmlldzogU3RhdGljRGF0YVZpZXcuZW1wdHkodGhpcy5jb25maWcpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB3ZSBydW4gaW4gYGRlYnVnYCBtb2RlLCB3ZSBlbmFibGUgZnVsbHkgZGV0ZXJtaW5pc3RpYyB1cGRhdGVzIG9mXG4gICAgICAgIC8vIGludGVybmFsIGRhdGEtc3RydWN0dXJlcy4gVG8gdGhpcyBlZmZlY3QsIHdlIHNvcnQgYWxsIGZpbHRlcnMgYmVmb3JlXG4gICAgICAgIC8vIGluc2VydGlvbi5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmRlYnVnID09PSB0cnVlKSB7XG4gICAgICAgICAgICBmaWx0ZXJzLnNvcnQoKGYxLCBmMikgPT4gZjEuZ2V0SWQoKSAtIGYyLmdldElkKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhpc3RvZ3JhbSA9IG5ldyBVaW50MzJBcnJheShNYXRoLm1heChuZXh0UG93MigyICogZmlsdGVycy5sZW5ndGgpLCAyNTYpKTtcbiAgICAgICAgLy8gVG9rZW5pemUgYWxsIGZpbHRlcnMgc3RvcmVkIGluIHRoaXMgaW5kZXguIEFuZCBjb21wdXRlIGEgaGlzdG9ncmFtIG9mXG4gICAgICAgIC8vIHRva2VucyBzbyB0aGF0IHdlIGNhbiBkZWNpZGUgaG93IHRvIGluZGV4IGVhY2ggZmlsdGVyIGVmZmljaWVudGx5LlxuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBmaWx0ZXJzKSB7XG4gICAgICAgICAgICAvLyBUb2tlbml6ZSBgZmlsdGVyYCBhbmQgc3RvcmUgdGhlIHJlc3VsdCBpbiBgZmlsdGVyc1Rva2Vuc2Agd2hpY2ggd2lsbFxuICAgICAgICAgICAgLy8gYmUgdXNlZCBpbiB0aGUgbmV4dCBzdGVwIHRvIHNlbGVjdCB0aGUgYmVzdCB0b2tlbiBmb3IgZWFjaCBmaWx0ZXIuXG4gICAgICAgICAgICBjb25zdCBtdWx0aVRva2VucyA9IGZpbHRlci5nZXRUb2tlbnMoKTtcbiAgICAgICAgICAgIGZpbHRlcnNUb2tlbnMucHVzaChtdWx0aVRva2Vucyk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgZXN0aW1hdGVkIHNpemUgb2YgXCJidWNrZXRzIGluZGV4XCIgYmFzZWQgb24gbnVtYmVyIG9mIHRpbWVzIHRoaXNcbiAgICAgICAgICAgIC8vIHBhcnRpY3VsYXIgZmlsdGVyIHdpbGwgYmUgaW5kZXhlZC5cbiAgICAgICAgICAgIGJ1Y2tldHNJbmRleFNpemUgKz0gMiAqIG11bHRpVG9rZW5zLmxlbmd0aDsgLy8gdG9rZW4gKyBmaWx0ZXIgaW5kZXhcbiAgICAgICAgICAgIHRvdGFsTnVtYmVyT2ZJbmRleGVkRmlsdGVycyArPSBtdWx0aVRva2Vucy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBFYWNoIGZpbHRlciBjYW4gYmUgaW5kZXhlZCBtb3JlIHRoYW4gb25jZSwgc28gYGdldFRva2VucyguLi4pYCByZXR1cm5zXG4gICAgICAgICAgICAvLyBtdWx0aXBsZSBzZXRzIG9mIHRva2Vucy4gV2UgaXRlcmF0ZSBvbiBhbGwgb2YgdGhlbSBhbmQgdXBkYXRlIHRoZVxuICAgICAgICAgICAgLy8gaGlzdG9ncmFtIGZvciBlYWNoLlxuICAgICAgICAgICAgZm9yIChjb25zdCB0b2tlbnMgb2YgbXVsdGlUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICB0b3RhbE51bWJlck9mVG9rZW5zICs9IHRva2Vucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaGlzdG9ncmFtW3Rva2VuICUgaGlzdG9ncmFtLmxlbmd0aF0gKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHNpemUgb2YgYnVja2V0c0luZGV4IHRvIHRvdGFsIHNpemUgKHg0IGJlY2F1c2UgdGhlc2UgYXJlIDMyIGJpdHMgbnVtYmVycylcbiAgICAgICAgZXN0aW1hdGVkQnVmZmVyU2l6ZSArPSBidWNrZXRzSW5kZXhTaXplICogNDtcbiAgICAgICAgLy8gUHJlcGFyZSBcInRva2VucyBpbmRleFwiIChzZWUgZG9jdW1lbnRhdGlvbiBpbiBjb25zdHJ1Y3RvciBvZiBgUmV2ZXJzZUluZGV4YCBjbGFzcyBhYm92ZSkuXG4gICAgICAgIGNvbnN0IHRva2Vuc0xvb2t1cEluZGV4U2l6ZSA9IE1hdGgubWF4KDIsIG5leHRQb3cyKHRvdGFsTnVtYmVyT2ZJbmRleGVkRmlsdGVycykpO1xuICAgICAgICBjb25zdCBtYXNrID0gdG9rZW5zTG9va3VwSW5kZXhTaXplIC0gMTtcbiAgICAgICAgY29uc3Qgc3VmZml4ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnNMb29rdXBJbmRleFNpemU7IGkgKz0gMSkge1xuICAgICAgICAgICAgc3VmZml4ZXMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHNpemUgb2YgdG9rZW5zTG9va3VwSW5kZXggdG8gdG90YWwgc2l6ZSAoeDQgYmVjYXVzZSB0aGVzZSBhcmUgMzIgYml0cyBudW1iZXJzKVxuICAgICAgICBlc3RpbWF0ZWRCdWZmZXJTaXplICs9IHRva2Vuc0xvb2t1cEluZGV4U2l6ZSAqIDQ7XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyB0aGUgbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCBmb3IgdGhlIGNvbXBhY3RcbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gb2YgdGhpcyByZXZlcnNlIGluZGV4IChcInRva2VucyBpbmRleFwiICsgXCJidWNrZXRzIGluZGV4XCIgK1xuICAgICAgICAvLyBcImZpbHRlcnMgaW5kZXhcIikuIFdlIGFsbG9jYXRlIGl0IGF0IG9uY2UgYW5kIHByb2NlZWQgd2l0aCBwb3B1bGF0aW5nIGl0LlxuICAgICAgICBjb25zdCBidWZmZXIgPSBTdGF0aWNEYXRhVmlldy5hbGxvY2F0ZShlc3RpbWF0ZWRCdWZmZXJTaXplLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHRva2Vuc0xvb2t1cEluZGV4ID0gYnVmZmVyLmdldFVpbnQzMkFycmF5Vmlldyh0b2tlbnNMb29rdXBJbmRleFNpemUpO1xuICAgICAgICBjb25zdCBidWNrZXRzSW5kZXggPSBidWZmZXIuZ2V0VWludDMyQXJyYXlWaWV3KGJ1Y2tldHNJbmRleFNpemUpO1xuICAgICAgICBjb25zdCBmaWx0ZXJzSW5kZXhTdGFydCA9IGJ1ZmZlci5nZXRQb3MoKTtcbiAgICAgICAgLy8gRm9yIGVhY2ggZmlsdGVyLCBmaW5kIHRoZSBiZXN0IHRva2VuIChsZWFzdCBzZWVuKSBiYXNlZCBvbiBoaXN0b2dyYW0uXG4gICAgICAgIC8vIFNpbmNlIHdlIGFyZSBpdGVyYXRpbmcgYWdhaW4gb24gdGhlIGZpbHRlcnMsIHdlIHBvcHVsYXRlIFwiZmlsdGVycyBpbmRleFwiXG4gICAgICAgIC8vIGluIHRoZSBzYW1lIGxvb3AgYW5kIGtlZXAgdHJhY2sgb2YgdGhlaXIgaW5kaWNlcyBzbyB0aGF0IHdlIGNhbiBsYXRlclxuICAgICAgICAvLyBwb3B1bGF0ZSBcImJ1Y2tldHMgaW5kZXhcIi5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJzVG9rZW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xuICAgICAgICAgICAgY29uc3QgbXVsdGlUb2tlbnMgPSBmaWx0ZXJzVG9rZW5zW2ldO1xuICAgICAgICAgICAgLy8gU2VyaWFsaXplIHRoaXMgZmlsdGVyIGFuZCBrZWVwIHRyYWNrIG9mIGl0cyBpbmRleCBpbiB0aGUgYnl0ZSBhcnJheTtcbiAgICAgICAgICAgIC8vIGl0IHdpbGwgYmUgdXNlZCBpbiBcImJ1Y2tldHMgaW5kZXhcIiB0byBwb2ludCB0byB0aGlzIGZpbHRlci5cbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckluZGV4ID0gYnVmZmVyLnBvcztcbiAgICAgICAgICAgIGZpbHRlci5zZXJpYWxpemUoYnVmZmVyKTtcbiAgICAgICAgICAgIC8vIEluZGV4IHRoZSBmaWx0ZXIgb25jZSBwZXIgXCJ0b2tlbnNcIlxuICAgICAgICAgICAgZm9yIChjb25zdCB0b2tlbnMgb2YgbXVsdGlUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIGJlc3QgdG9rZW4gKGxlYXN0IHNlZW4pIGZyb20gYHRva2Vuc2AgdXNpbmcgYGhpc3RvZ3JhbWAuXG4gICAgICAgICAgICAgICAgbGV0IGJlc3RUb2tlbiA9IDA7IC8vIGRlZmF1bHQgPSB3aWxkY2FyZCBidWNrZXRcbiAgICAgICAgICAgICAgICBsZXQgbWluQ291bnQgPSB0b3RhbE51bWJlck9mVG9rZW5zICsgMTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbkNvdW50ID0gaGlzdG9ncmFtW3Rva2VuICUgaGlzdG9ncmFtLmxlbmd0aF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbkNvdW50IDwgbWluQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkNvdW50ID0gdG9rZW5Db3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoLCBpZiB0aGUgY3VycmVudCB0b2tlbiBoYXMgb25seSBiZWVuIHNlZW4gb25jZSwgd2UgY2FuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIGl0ZXJhdGluZyBzaW5jZSB3ZSB3aWxsIG5vdCBmaW5kIGEgYmV0dGVyIGFsdGVybmFyaXZlIVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbkNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYGJlc3RUb2tlbiAmIG1hc2tgIHJlcHJlc2VudHMgdGhlIE4gbGFzdCBiaXRzIG9mIGBiZXN0VG9rZW5gLiBXZVxuICAgICAgICAgICAgICAgIC8vIGdyb3VwIGFsbCBmaWx0ZXJzIGluZGV4ZWQgd2l0aCBhIHRva2VuIHNoYXJpbmcgdGhlIHNhbWUgTiBiaXRzLlxuICAgICAgICAgICAgICAgIHN1ZmZpeGVzW2Jlc3RUb2tlbiAmIG1hc2tdLnB1c2goW2Jlc3RUb2tlbiwgZmlsdGVySW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQb3B1bGF0ZSBcInRva2VucyBpbmRleFwiIGFuZCBcImJ1Y2tldHMgaW5kZXhcIiBiYXNlZCBvbiBiZXN0IHRva2VuIGZvdW5kIGZvciBlYWNoIGZpbHRlci5cbiAgICAgICAgbGV0IGluZGV4SW5CdWNrZXRzSW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vuc0xvb2t1cEluZGV4U2l6ZTsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJzRm9yTWFzayA9IHN1ZmZpeGVzW2ldO1xuICAgICAgICAgICAgdG9rZW5zTG9va3VwSW5kZXhbaV0gPSBpbmRleEluQnVja2V0c0luZGV4O1xuICAgICAgICAgICAgZm9yIChjb25zdCBbdG9rZW4sIGZpbHRlckluZGV4XSBvZiBmaWx0ZXJzRm9yTWFzaykge1xuICAgICAgICAgICAgICAgIGJ1Y2tldHNJbmRleFtpbmRleEluQnVja2V0c0luZGV4KytdID0gdG9rZW47XG4gICAgICAgICAgICAgICAgYnVja2V0c0luZGV4W2luZGV4SW5CdWNrZXRzSW5kZXgrK10gPSBmaWx0ZXJJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgaW50ZXJuYWxzXG4gICAgICAgIGJ1ZmZlci5zZWVrWmVybygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUludGVybmFscyh7XG4gICAgICAgICAgICBidWNrZXRzSW5kZXgsXG4gICAgICAgICAgICBmaWx0ZXJzSW5kZXhTdGFydCxcbiAgICAgICAgICAgIG51bWJlck9mRmlsdGVyczogZmlsdGVyc1Rva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICB0b2tlbnNMb29rdXBJbmRleCxcbiAgICAgICAgICAgIHZpZXc6IGJ1ZmZlcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZUludGVybmFscyh7IGJ1Y2tldHNJbmRleCwgZmlsdGVyc0luZGV4U3RhcnQsIG51bWJlck9mRmlsdGVycywgdG9rZW5zTG9va3VwSW5kZXgsIHZpZXcsIH0pIHtcbiAgICAgICAgdGhpcy5idWNrZXRzSW5kZXggPSBidWNrZXRzSW5kZXg7XG4gICAgICAgIHRoaXMuZmlsdGVyc0luZGV4U3RhcnQgPSBmaWx0ZXJzSW5kZXhTdGFydDtcbiAgICAgICAgdGhpcy5udW1iZXJPZkZpbHRlcnMgPSBudW1iZXJPZkZpbHRlcnM7XG4gICAgICAgIHRoaXMudG9rZW5zTG9va3VwSW5kZXggPSB0b2tlbnNMb29rdXBJbmRleDtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdmlldy5zZWVrWmVybygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgYSBidWNrZXQgZXhpc3RzIGZvciB0aGUgZ2l2ZW4gdG9rZW4sIGNhbGwgdGhlIGNhbGxiYWNrIG9uIGVhY2ggZmlsdGVyXG4gICAgICogZm91bmQgaW5zaWRlLiBBbiBlYXJseSB0ZXJtaW5hdGlvbiBtZWNoYW5pc20gaXMgYnVpbHQtaW4sIHRvIHN0b3AgaXRlcmF0aW5nXG4gICAgICogYXMgc29vbiBhcyBgZmFsc2VgIGlzIHJldHVybmVkIGZyb20gdGhlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGl0ZXJCdWNrZXQodG9rZW4sIHJlcXVlc3RJZCwgY2IpIHtcbiAgICAgICAgbGV0IGJ1Y2tldCA9IHRoaXMuY29uZmlnLmVuYWJsZUluTWVtb3J5Q2FjaGUgPT09IHRydWUgPyB0aGlzLmNhY2hlLmdldCh0b2tlbikgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIExhemlseSBjcmVhdGUgYnVja2V0IGlmIGl0IGRvZXMgbm90IHlldCBleGlzdCBpbiBtZW1vcnkuIExvb2t1cCB0aGVcbiAgICAgICAgLy8gY29tcGFjdCBidWNrZXQgcmVwcmVzZW50YXRpb24gYW5kIGZpbmQgYWxsIGZpbHRlcnMgYmVpbmcgYXNzb2NpYXRlZCB3aXRoXG4gICAgICAgIC8vIGB0b2tlbmAuIENyZWF0ZSBhIGBCdWNrZXRgIG91dCBvZiB0aGVtIGFuZCBzdG9yZSB0aGVtIGluIGNhY2hlLlxuICAgICAgICBpZiAoYnVja2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRva2VuICYgKHRoaXMudG9rZW5zTG9va3VwSW5kZXgubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBjb25zdCBzdGFydE9mQnVja2V0ID0gdGhpcy50b2tlbnNMb29rdXBJbmRleFtvZmZzZXRdO1xuICAgICAgICAgICAgLy8gV2UgZG8gbm90IGhhdmUgYW55IGZpbHRlcnMgZm9yIHRoaXMgdG9rZW5cbiAgICAgICAgICAgIGlmIChzdGFydE9mQnVja2V0ID09PSBFTVBUWV9CVUNLRVQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGRvIG5vdCBzdG9yZSBleHBsaWNpdGx5IHRoZSBudW1iZXIgb2YgZmlsdGVycyBpbiBlYWNoXG4gICAgICAgICAgICAvLyBcImJ1Y2tldFwiLCB3ZSBjaGVjayB0aGUgaW5kZXggb2YgdGhlIG5leHQgb25lIGFuZCB1c2UgaXQgdG8gaW5mZXIgdGhlXG4gICAgICAgICAgICAvLyBudW1iZXIgb2YgZmlsdGVycyAoZWFjaCBmaWx0ZXIgYmVpbmcgc3RvcmVkIGFzIGEgdG9rZW4gKyBpbmRleCB0byB0aGVcbiAgICAgICAgICAgIC8vIFwiZmlsdGVycyBzdG9yZVwiKVxuICAgICAgICAgICAgY29uc3QgZW5kT2ZCdWNrZXQgPSBvZmZzZXQgPT09IHRoaXMudG9rZW5zTG9va3VwSW5kZXgubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgID8gdGhpcy5idWNrZXRzSW5kZXgubGVuZ3RoXG4gICAgICAgICAgICAgICAgOiB0aGlzLnRva2Vuc0xvb2t1cEluZGV4W29mZnNldCArIDFdO1xuICAgICAgICAgICAgLy8gR2V0IGluZGljZXMgb2YgZmlsdGVycyBpbmRleGVkIHdpdGggYHRva2VuYCwgaWYgYW55LlxuICAgICAgICAgICAgY29uc3QgZmlsdGVyc0luZGljZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydE9mQnVja2V0OyBpIDwgZW5kT2ZCdWNrZXQ7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUb2tlbiA9IHRoaXMuYnVja2V0c0luZGV4W2ldO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VG9rZW4gPT09IHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcnNJbmRpY2VzLnB1c2godGhpcy5idWNrZXRzSW5kZXhbaSArIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBmaWx0ZXIgaW5kZXhlZCB3aXRoIGB0b2tlbmAuXG4gICAgICAgICAgICBpZiAoZmlsdGVyc0luZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIGNvbnRpbnVlIGxvb2tpbmcgZm9yIGEgbWF0Y2hcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgZmlsdGVycyBmb3IgYHRva2VuYCB0aGVuIGRlc2VyaWFsaXplIGZpbHRlcnMgaW4gbWVtb3J5IGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgYEJ1Y2tldGAgaW5zdGFuY2UgdG8gaG9sZCB0aGVtIGZvciBmdXR1cmUgYWNjZXNzLlxuICAgICAgICAgICAgY29uc3QgZmlsdGVycyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IHRoaXMudmlldztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyc0luZGljZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFBvcyhmaWx0ZXJzSW5kaWNlc1tpXSk7XG4gICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKHRoaXMuZGVzZXJpYWxpemVGaWx0ZXIodmlldykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyBidWNrZXQgd2l0aCBmb3VuZCBmaWx0ZXJzIChvbmx5IG9wdGltaXplIGlmIHdlIGhhdmUgbW9yZVxuICAgICAgICAgICAgLy8gdGhhbiBvbmUgZmlsdGVyKS5cbiAgICAgICAgICAgIGJ1Y2tldCA9IHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzLmxlbmd0aCA+IDEgPyB0aGlzLm9wdGltaXplKGZpbHRlcnMpIDogZmlsdGVycyxcbiAgICAgICAgICAgICAgICBsYXN0UmVxdWVzdFNlZW46IC0xLCAvLyBzYWZlIGJlY2F1c2UgYWxsIGlkcyBhcmUgcG9zaXRpdmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlSW5NZW1vcnlDYWNoZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KHRva2VuLCBidWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExvb2sgZm9yIG1hdGNoaW5nIGZpbHRlciBpbiB0aGlzIGJ1Y2tldFxuICAgICAgICBpZiAoYnVja2V0Lmxhc3RSZXF1ZXN0U2VlbiAhPT0gcmVxdWVzdElkKSB7XG4gICAgICAgICAgICBidWNrZXQubGFzdFJlcXVlc3RTZWVuID0gcmVxdWVzdElkO1xuICAgICAgICAgICAgY29uc3QgZmlsdGVycyA9IGJ1Y2tldC5maWx0ZXJzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gQnJlYWsgdGhlIGxvb3AgaWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgICAgIGlmIChjYihmaWx0ZXJzW2ldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbmV2ZXIgd2UgZ2V0IGEgbWF0Y2ggZnJvbSBhIGZpbHRlciwgd2UgYWxzbyBzd2FwIGl0IG9uZVxuICAgICAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbiB1cCBpbiB0aGUgbGlzdC4gVGhpcyB3YXksIG92ZXIgdGltZSwgcG9wdWxhciBmaWx0ZXJzIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgLy8gYmUgZmlyc3QgYW5kIG1pZ2h0IG1hdGNoIGVhcmxpZXIuIFRoaXMgc2hvdWxkIGRlY3JlYXNlIHRoZSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWRlZCB0byBnZXQgYSBtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyc1tpXSA9IGZpbHRlcnNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyc1tpIC0gMV0gPSBmaWx0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXZlcnNlLWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/reverse-index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/events.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/events.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter)\n/* harmony export */ });\n/* harmony import */ var _queue_microtask_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./queue-microtask.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/queue-microtask.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n/**\n * Add `callback` listener for `event` in `listeners` Map.\n */\nfunction registerCallback(event, callback, listeners) {\n    let listenersForEvent = listeners.get(event);\n    if (listenersForEvent === undefined) {\n        listenersForEvent = [];\n        listeners.set(event, listenersForEvent);\n    }\n    listenersForEvent.push(callback);\n}\n/**\n * Remove `callback` listener for `event` from `listeners` Map.\n */\nfunction unregisterCallback(event, callback, listeners) {\n    const listenersForEvent = listeners.get(event);\n    if (listenersForEvent !== undefined) {\n        const indexOfCallback = listenersForEvent.indexOf(callback);\n        if (indexOfCallback !== -1) {\n            listenersForEvent.splice(indexOfCallback, 1);\n        }\n    }\n}\n/**\n * Call all registered listeners for `event` with `args` as arguments. Return\n * `true` if at least one callback was registered and `false` otherwise.\n */\nfunction triggerCallback(event, args, listeners) {\n    // Fast-path for cases where no listener is registered\n    if (listeners.size === 0) {\n        return false;\n    }\n    const listenersForEvent = listeners.get(event);\n    if (listenersForEvent !== undefined) {\n        (0,_queue_microtask_js__WEBPACK_IMPORTED_MODULE_0__.queueMicrotask)(() => {\n            for (const listener of listenersForEvent) {\n                listener(...args);\n            }\n        });\n        return true;\n    }\n    return false;\n}\n/**\n * Simple and efficient `EventEmitter` abstraction (following conventions from\n * Node.js) allowing partially typed event emitting. The set of event names is\n * specified as a type parameter while instantiating the event emitter.\n */\nclass EventEmitter {\n    constructor() {\n        this.onceListeners = new Map();\n        this.onListeners = new Map();\n    }\n    /**\n     * Register an event listener for `event`.\n     */\n    on(event, callback) {\n        registerCallback(event, callback, this.onListeners);\n    }\n    /**\n     * Register an event listener for `event`; but only listen to first instance\n     * of this event. The listener is automatically deleted afterwards.\n     */\n    once(event, callback) {\n        registerCallback(event, callback, this.onceListeners);\n    }\n    /**\n     * Remove `callback` from list of listeners for `event`.\n     */\n    unsubscribe(event, callback) {\n        unregisterCallback(event, callback, this.onListeners);\n        unregisterCallback(event, callback, this.onceListeners);\n    }\n    /**\n     * Emit an event. Call all registered listeners to this event.\n     */\n    emit(event, ...args) {\n        triggerCallback(event, args, this.onListeners);\n        if (triggerCallback(event, args, this.onceListeners) === true) {\n            this.onceListeners.delete(event);\n        }\n    }\n}\n//# sourceMappingURL=events.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9ldmVudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUVBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9ldmVudHMuanM/NTgwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50IEdob3N0ZXJ5IEdtYkguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmltcG9ydCB7IHF1ZXVlTWljcm90YXNrIH0gZnJvbSAnLi9xdWV1ZS1taWNyb3Rhc2suanMnO1xuLyoqXG4gKiBBZGQgYGNhbGxiYWNrYCBsaXN0ZW5lciBmb3IgYGV2ZW50YCBpbiBgbGlzdGVuZXJzYCBNYXAuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyQ2FsbGJhY2soZXZlbnQsIGNhbGxiYWNrLCBsaXN0ZW5lcnMpIHtcbiAgICBsZXQgbGlzdGVuZXJzRm9yRXZlbnQgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50KTtcbiAgICBpZiAobGlzdGVuZXJzRm9yRXZlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaXN0ZW5lcnNGb3JFdmVudCA9IFtdO1xuICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50LCBsaXN0ZW5lcnNGb3JFdmVudCk7XG4gICAgfVxuICAgIGxpc3RlbmVyc0ZvckV2ZW50LnB1c2goY2FsbGJhY2spO1xufVxuLyoqXG4gKiBSZW1vdmUgYGNhbGxiYWNrYCBsaXN0ZW5lciBmb3IgYGV2ZW50YCBmcm9tIGBsaXN0ZW5lcnNgIE1hcC5cbiAqL1xuZnVuY3Rpb24gdW5yZWdpc3RlckNhbGxiYWNrKGV2ZW50LCBjYWxsYmFjaywgbGlzdGVuZXJzKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzRm9yRXZlbnQgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50KTtcbiAgICBpZiAobGlzdGVuZXJzRm9yRXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBpbmRleE9mQ2FsbGJhY2sgPSBsaXN0ZW5lcnNGb3JFdmVudC5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGluZGV4T2ZDYWxsYmFjayAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc0ZvckV2ZW50LnNwbGljZShpbmRleE9mQ2FsbGJhY2ssIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDYWxsIGFsbCByZWdpc3RlcmVkIGxpc3RlbmVycyBmb3IgYGV2ZW50YCB3aXRoIGBhcmdzYCBhcyBhcmd1bWVudHMuIFJldHVyblxuICogYHRydWVgIGlmIGF0IGxlYXN0IG9uZSBjYWxsYmFjayB3YXMgcmVnaXN0ZXJlZCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJDYWxsYmFjayhldmVudCwgYXJncywgbGlzdGVuZXJzKSB7XG4gICAgLy8gRmFzdC1wYXRoIGZvciBjYXNlcyB3aGVyZSBubyBsaXN0ZW5lciBpcyByZWdpc3RlcmVkXG4gICAgaWYgKGxpc3RlbmVycy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzRm9yRXZlbnQgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50KTtcbiAgICBpZiAobGlzdGVuZXJzRm9yRXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVyc0ZvckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBTaW1wbGUgYW5kIGVmZmljaWVudCBgRXZlbnRFbWl0dGVyYCBhYnN0cmFjdGlvbiAoZm9sbG93aW5nIGNvbnZlbnRpb25zIGZyb21cbiAqIE5vZGUuanMpIGFsbG93aW5nIHBhcnRpYWxseSB0eXBlZCBldmVudCBlbWl0dGluZy4gVGhlIHNldCBvZiBldmVudCBuYW1lcyBpc1xuICogc3BlY2lmaWVkIGFzIGEgdHlwZSBwYXJhbWV0ZXIgd2hpbGUgaW5zdGFudGlhdGluZyB0aGUgZXZlbnQgZW1pdHRlci5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub25jZUxpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5vbkxpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGBldmVudGAuXG4gICAgICovXG4gICAgb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJlZ2lzdGVyQ2FsbGJhY2soZXZlbnQsIGNhbGxiYWNrLCB0aGlzLm9uTGlzdGVuZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGBldmVudGA7IGJ1dCBvbmx5IGxpc3RlbiB0byBmaXJzdCBpbnN0YW5jZVxuICAgICAqIG9mIHRoaXMgZXZlbnQuIFRoZSBsaXN0ZW5lciBpcyBhdXRvbWF0aWNhbGx5IGRlbGV0ZWQgYWZ0ZXJ3YXJkcy5cbiAgICAgKi9cbiAgICBvbmNlKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICByZWdpc3RlckNhbGxiYWNrKGV2ZW50LCBjYWxsYmFjaywgdGhpcy5vbmNlTGlzdGVuZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGBjYWxsYmFja2AgZnJvbSBsaXN0IG9mIGxpc3RlbmVycyBmb3IgYGV2ZW50YC5cbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZShldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgdW5yZWdpc3RlckNhbGxiYWNrKGV2ZW50LCBjYWxsYmFjaywgdGhpcy5vbkxpc3RlbmVycyk7XG4gICAgICAgIHVucmVnaXN0ZXJDYWxsYmFjayhldmVudCwgY2FsbGJhY2ssIHRoaXMub25jZUxpc3RlbmVycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXQgYW4gZXZlbnQuIENhbGwgYWxsIHJlZ2lzdGVyZWQgbGlzdGVuZXJzIHRvIHRoaXMgZXZlbnQuXG4gICAgICovXG4gICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICB0cmlnZ2VyQ2FsbGJhY2soZXZlbnQsIGFyZ3MsIHRoaXMub25MaXN0ZW5lcnMpO1xuICAgICAgICBpZiAodHJpZ2dlckNhbGxiYWNrKGV2ZW50LCBhcmdzLCB0aGlzLm9uY2VMaXN0ZW5lcnMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLm9uY2VMaXN0ZW5lcnMuZGVsZXRlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/events.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/fetch.js":
/*!************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/fetch.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adsAndTrackingLists: () => (/* binding */ adsAndTrackingLists),\n/* harmony export */   adsLists: () => (/* binding */ adsLists),\n/* harmony export */   fetchLists: () => (/* binding */ fetchLists),\n/* harmony export */   fetchResources: () => (/* binding */ fetchResources),\n/* harmony export */   fetchWithRetry: () => (/* binding */ fetchWithRetry),\n/* harmony export */   fullLists: () => (/* binding */ fullLists)\n/* harmony export */ });\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/**\n * Built-in fetch helpers can be used to initialize the adblocker from\n * pre-built presets or raw lists (fetched from multiple sources). In case of\n * failure (e.g. timeout), the whole process of initialization fails. Timeouts\n * are not so uncommon, and retrying to fetch usually succeeds.\n */\nfunction fetchWithRetry(fetch, url) {\n    let retry = 3;\n    // Wrap `fetch` into a lightweight retry function which makes sure that if\n    // fetching fails, it can be retried up to three times. Failure can happen if\n    // the remote server times-out, but retrying fetching of the same URL will\n    // usually succeed.\n    const fetchWrapper = () => {\n        return fetch(url).catch((ex) => {\n            if (retry > 0) {\n                retry -= 1;\n                return new Promise((resolve, reject) => {\n                    setTimeout(() => {\n                        fetchWrapper().then(resolve).catch(reject);\n                    }, 500);\n                });\n            }\n            throw ex;\n        });\n    };\n    return fetchWrapper();\n}\nfunction fetchResource(fetch, url) {\n    return fetchWithRetry(fetch, url).then((response) => response.text());\n}\nconst PREFIX = 'https://raw.githubusercontent.com/ghostery/adblocker/master/packages/adblocker/assets';\nconst adsLists = [\n    `${PREFIX}/easylist/easylist.txt`,\n    `${PREFIX}/peter-lowe/serverlist.txt`,\n    `${PREFIX}/ublock-origin/badware.txt`,\n    `${PREFIX}/ublock-origin/filters-2020.txt`,\n    `${PREFIX}/ublock-origin/filters-2021.txt`,\n    `${PREFIX}/ublock-origin/filters-2022.txt`,\n    `${PREFIX}/ublock-origin/filters-2023.txt`,\n    `${PREFIX}/ublock-origin/filters-2024.txt`,\n    `${PREFIX}/ublock-origin/filters.txt`,\n    `${PREFIX}/ublock-origin/quick-fixes.txt`,\n    `${PREFIX}/ublock-origin/resource-abuse.txt`,\n    `${PREFIX}/ublock-origin/unbreak.txt`,\n];\nconst adsAndTrackingLists = [\n    ...adsLists,\n    `${PREFIX}/easylist/easyprivacy.txt`,\n    `${PREFIX}/ublock-origin/privacy.txt`,\n];\nconst fullLists = [\n    ...adsAndTrackingLists,\n    `${PREFIX}/easylist/easylist-cookie.txt`,\n    `${PREFIX}/ublock-origin/annoyances-others.txt`,\n    `${PREFIX}/ublock-origin/annoyances-cookies.txt`,\n];\n/**\n * Fetch latest version of enabledByDefault blocking lists.\n */\nfunction fetchLists(fetch, urls) {\n    return Promise.all(urls.map((url) => fetchResource(fetch, url)));\n}\n/**\n * Fetch latest version of uBlock Origin's resources, used to inject scripts in\n * the page or redirect request to data URLs.\n */\nfunction fetchResources(fetch) {\n    return fetchResource(fetch, `${PREFIX}/ublock-origin/resources.json`);\n}\n//# sourceMappingURL=fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZDtBQUNPO0FBQ1A7QUFDQSxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZDtBQUNPO0FBQ1A7QUFDQSxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZCxPQUFPLE9BQU87QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtQ0FBbUMsT0FBTztBQUMxQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9mZXRjaC5qcz8wZjYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQgR2hvc3RlcnkgR21iSC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuLyoqXG4gKiBCdWlsdC1pbiBmZXRjaCBoZWxwZXJzIGNhbiBiZSB1c2VkIHRvIGluaXRpYWxpemUgdGhlIGFkYmxvY2tlciBmcm9tXG4gKiBwcmUtYnVpbHQgcHJlc2V0cyBvciByYXcgbGlzdHMgKGZldGNoZWQgZnJvbSBtdWx0aXBsZSBzb3VyY2VzKS4gSW4gY2FzZSBvZlxuICogZmFpbHVyZSAoZS5nLiB0aW1lb3V0KSwgdGhlIHdob2xlIHByb2Nlc3Mgb2YgaW5pdGlhbGl6YXRpb24gZmFpbHMuIFRpbWVvdXRzXG4gKiBhcmUgbm90IHNvIHVuY29tbW9uLCBhbmQgcmV0cnlpbmcgdG8gZmV0Y2ggdXN1YWxseSBzdWNjZWVkcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZldGNoV2l0aFJldHJ5KGZldGNoLCB1cmwpIHtcbiAgICBsZXQgcmV0cnkgPSAzO1xuICAgIC8vIFdyYXAgYGZldGNoYCBpbnRvIGEgbGlnaHR3ZWlnaHQgcmV0cnkgZnVuY3Rpb24gd2hpY2ggbWFrZXMgc3VyZSB0aGF0IGlmXG4gICAgLy8gZmV0Y2hpbmcgZmFpbHMsIGl0IGNhbiBiZSByZXRyaWVkIHVwIHRvIHRocmVlIHRpbWVzLiBGYWlsdXJlIGNhbiBoYXBwZW4gaWZcbiAgICAvLyB0aGUgcmVtb3RlIHNlcnZlciB0aW1lcy1vdXQsIGJ1dCByZXRyeWluZyBmZXRjaGluZyBvZiB0aGUgc2FtZSBVUkwgd2lsbFxuICAgIC8vIHVzdWFsbHkgc3VjY2VlZC5cbiAgICBjb25zdCBmZXRjaFdyYXBwZXIgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBmZXRjaCh1cmwpLmNhdGNoKChleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJldHJ5ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHJ5IC09IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFdyYXBwZXIoKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gZmV0Y2hXcmFwcGVyKCk7XG59XG5mdW5jdGlvbiBmZXRjaFJlc291cmNlKGZldGNoLCB1cmwpIHtcbiAgICByZXR1cm4gZmV0Y2hXaXRoUmV0cnkoZmV0Y2gsIHVybCkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLnRleHQoKSk7XG59XG5jb25zdCBQUkVGSVggPSAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2dob3N0ZXJ5L2FkYmxvY2tlci9tYXN0ZXIvcGFja2FnZXMvYWRibG9ja2VyL2Fzc2V0cyc7XG5leHBvcnQgY29uc3QgYWRzTGlzdHMgPSBbXG4gICAgYCR7UFJFRklYfS9lYXN5bGlzdC9lYXN5bGlzdC50eHRgLFxuICAgIGAke1BSRUZJWH0vcGV0ZXItbG93ZS9zZXJ2ZXJsaXN0LnR4dGAsXG4gICAgYCR7UFJFRklYfS91YmxvY2stb3JpZ2luL2JhZHdhcmUudHh0YCxcbiAgICBgJHtQUkVGSVh9L3VibG9jay1vcmlnaW4vZmlsdGVycy0yMDIwLnR4dGAsXG4gICAgYCR7UFJFRklYfS91YmxvY2stb3JpZ2luL2ZpbHRlcnMtMjAyMS50eHRgLFxuICAgIGAke1BSRUZJWH0vdWJsb2NrLW9yaWdpbi9maWx0ZXJzLTIwMjIudHh0YCxcbiAgICBgJHtQUkVGSVh9L3VibG9jay1vcmlnaW4vZmlsdGVycy0yMDIzLnR4dGAsXG4gICAgYCR7UFJFRklYfS91YmxvY2stb3JpZ2luL2ZpbHRlcnMtMjAyNC50eHRgLFxuICAgIGAke1BSRUZJWH0vdWJsb2NrLW9yaWdpbi9maWx0ZXJzLnR4dGAsXG4gICAgYCR7UFJFRklYfS91YmxvY2stb3JpZ2luL3F1aWNrLWZpeGVzLnR4dGAsXG4gICAgYCR7UFJFRklYfS91YmxvY2stb3JpZ2luL3Jlc291cmNlLWFidXNlLnR4dGAsXG4gICAgYCR7UFJFRklYfS91YmxvY2stb3JpZ2luL3VuYnJlYWsudHh0YCxcbl07XG5leHBvcnQgY29uc3QgYWRzQW5kVHJhY2tpbmdMaXN0cyA9IFtcbiAgICAuLi5hZHNMaXN0cyxcbiAgICBgJHtQUkVGSVh9L2Vhc3lsaXN0L2Vhc3lwcml2YWN5LnR4dGAsXG4gICAgYCR7UFJFRklYfS91YmxvY2stb3JpZ2luL3ByaXZhY3kudHh0YCxcbl07XG5leHBvcnQgY29uc3QgZnVsbExpc3RzID0gW1xuICAgIC4uLmFkc0FuZFRyYWNraW5nTGlzdHMsXG4gICAgYCR7UFJFRklYfS9lYXN5bGlzdC9lYXN5bGlzdC1jb29raWUudHh0YCxcbiAgICBgJHtQUkVGSVh9L3VibG9jay1vcmlnaW4vYW5ub3lhbmNlcy1vdGhlcnMudHh0YCxcbiAgICBgJHtQUkVGSVh9L3VibG9jay1vcmlnaW4vYW5ub3lhbmNlcy1jb29raWVzLnR4dGAsXG5dO1xuLyoqXG4gKiBGZXRjaCBsYXRlc3QgdmVyc2lvbiBvZiBlbmFibGVkQnlEZWZhdWx0IGJsb2NraW5nIGxpc3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hMaXN0cyhmZXRjaCwgdXJscykge1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh1cmxzLm1hcCgodXJsKSA9PiBmZXRjaFJlc291cmNlKGZldGNoLCB1cmwpKSk7XG59XG4vKipcbiAqIEZldGNoIGxhdGVzdCB2ZXJzaW9uIG9mIHVCbG9jayBPcmlnaW4ncyByZXNvdXJjZXMsIHVzZWQgdG8gaW5qZWN0IHNjcmlwdHMgaW5cbiAqIHRoZSBwYWdlIG9yIHJlZGlyZWN0IHJlcXVlc3QgdG8gZGF0YSBVUkxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hSZXNvdXJjZXMoZmV0Y2gpIHtcbiAgICByZXR1cm4gZmV0Y2hSZXNvdXJjZShmZXRjaCwgYCR7UFJFRklYfS91YmxvY2stb3JpZ2luL3Jlc291cmNlcy5qc29uYCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/fetch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/cosmetic.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/filters/cosmetic.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_HIDING_STYLE: () => (/* binding */ DEFAULT_HIDING_STYLE),\n/* harmony export */   \"default\": () => (/* binding */ CosmeticFilter),\n/* harmony export */   normalizeSelector: () => (/* binding */ normalizeSelector)\n/* harmony export */ });\n/* harmony import */ var _ghostery_adblocker_extended_selectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ghostery/adblocker-extended-selectors */ \"(rsc)/./node_modules/@ghostery/adblocker-extended-selectors/dist/esm/index.js\");\n/* harmony import */ var _engine_domains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../engine/domains.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/domains.js\");\n/* harmony import */ var _data_view_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data-view.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/data-view.js\");\n/* harmony import */ var _request_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../request.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/request.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/utils.js\");\n/* harmony import */ var _html_filtering_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../html-filtering.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/html-filtering.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n\nconst EMPTY_TOKENS = [_data_view_js__WEBPACK_IMPORTED_MODULE_2__.EMPTY_UINT32_ARRAY];\nconst DEFAULT_HIDING_STYLE = 'display: none !important;';\nconst REGEXP_UNICODE_COMMA = new RegExp(/\\\\u002C/, 'g');\nconst REGEXP_UNICODE_BACKSLASH = new RegExp(/\\\\u005C/, 'g');\nconst REGEXP_ESCAPED_COMMA = new RegExp(/\\\\,/, 'g');\nconst REGEXP_ESCAPED_SINGLE_QUOTE = new RegExp(/\\\\'/, 'g');\nconst REGEXP_ESCAPED_DOUBLE_QUOTE = new RegExp(/\\\\\"/, 'g');\nconst REGEXP_ESCAPED_BACKTICK = new RegExp(/\\\\`/, 'g');\n/**\n * Given a `selector` starting with either '#' or '.' check if what follows is\n * a simple CSS selector: /^-?[_a-zA-Z]+[_a-zA-Z0-9-]*$/\n */\nfunction isSimpleSelector(selector) {\n    for (let i = 1; i < selector.length; i += 1) {\n        const code = selector.charCodeAt(i);\n        if (!(code === 45 /* '-' */ ||\n            code === 95 /* '_' */ ||\n            (code >= 48 && code <= 57) /* [0-9] */ ||\n            (code >= 65 && code <= 90) /* [A-Z] */ ||\n            (code >= 97 && code <= 122)) /* [a-z] */) {\n            if (i < selector.length - 1) {\n                // Check if what follows is a ' >' or ' ~' or ' +', in which case we\n                // also consider it a simple selector and the token this filter can be\n                // indexed with is the first selector.\n                const nextCode = selector.charCodeAt(i + 1);\n                if (code === 91 /* '[' */ ||\n                    code === 46 /* '.' */ ||\n                    code === 58 /* ':' */ ||\n                    (code === 32 /* ' ' */ &&\n                        (nextCode === 62 /* '>' */ ||\n                            nextCode === 43 /* '+' */ ||\n                            nextCode === 126 /* '~' */ ||\n                            nextCode === 46 /* '.' */ ||\n                            nextCode === 35)) /* '#' */) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Given a `selector` starting with either 'a[' or '[', check if what follows\n * is a simple href attribute selector of the form: 'href^=' or 'href*='.\n */\nfunction isSimpleHrefSelector(selector, start) {\n    return (selector.startsWith('href^=\"', start) ||\n        selector.startsWith('href*=\"', start) ||\n        selector.startsWith('href=\"', start));\n}\n/**\n * Validate CSS selector. There is a fast path for simple selectors (e.g.: #foo\n * or .bar) which are the most common case. For complex ones, we rely on\n * `Element.matches` (if available).\n */\nconst isValidCss = (() => {\n    const div = typeof document !== 'undefined'\n        ? document.createElement('div')\n        : {\n            matches: () => {\n                /* noop */\n            },\n        };\n    const matches = (selector) => div.matches(selector);\n    const validSelectorRe = /^[#.]?[\\w-.]+$/;\n    return function isValidCssImpl(selector) {\n        if (validSelectorRe.test(selector)) {\n            return true;\n        }\n        try {\n            matches(selector);\n        }\n        catch (ex) {\n            return false;\n        }\n        return true;\n    };\n})();\n/**\n * Masks used to store options of cosmetic filters in a bitmask.\n */\nvar COSMETICS_MASK;\n(function (COSMETICS_MASK) {\n    COSMETICS_MASK[COSMETICS_MASK[\"unhide\"] = 1] = \"unhide\";\n    COSMETICS_MASK[COSMETICS_MASK[\"scriptInject\"] = 2] = \"scriptInject\";\n    COSMETICS_MASK[COSMETICS_MASK[\"isUnicode\"] = 4] = \"isUnicode\";\n    COSMETICS_MASK[COSMETICS_MASK[\"isClassSelector\"] = 8] = \"isClassSelector\";\n    COSMETICS_MASK[COSMETICS_MASK[\"isIdSelector\"] = 16] = \"isIdSelector\";\n    COSMETICS_MASK[COSMETICS_MASK[\"isHrefSelector\"] = 32] = \"isHrefSelector\";\n    COSMETICS_MASK[COSMETICS_MASK[\"remove\"] = 64] = \"remove\";\n    COSMETICS_MASK[COSMETICS_MASK[\"extended\"] = 128] = \"extended\";\n})(COSMETICS_MASK || (COSMETICS_MASK = {}));\nconst HASH_DOMAINS_MARKER_LOW = 1;\nconst HASH_DOMAINS_MARKER_HIGH = 253;\nfunction computeFilterId(mask, selector, domains, parentDomains, style) {\n    let hash = (_utils_js__WEBPACK_IMPORTED_MODULE_4__.HASH_SEED * _utils_js__WEBPACK_IMPORTED_MODULE_4__.HASH_INTERNAL_MULT) ^ mask;\n    if (selector !== undefined) {\n        for (let i = 0; i < selector.length; i += 1) {\n            hash = (hash * _utils_js__WEBPACK_IMPORTED_MODULE_4__.HASH_INTERNAL_MULT) ^ selector.charCodeAt(i);\n        }\n    }\n    if (domains !== undefined) {\n        hash = (hash * _utils_js__WEBPACK_IMPORTED_MODULE_4__.HASH_INTERNAL_MULT) ^ HASH_DOMAINS_MARKER_LOW;\n        hash = domains.updateId(hash);\n    }\n    if (parentDomains !== undefined) {\n        hash = (hash * _utils_js__WEBPACK_IMPORTED_MODULE_4__.HASH_INTERNAL_MULT) ^ HASH_DOMAINS_MARKER_HIGH;\n        hash = parentDomains.updateId(hash);\n    }\n    if (style !== undefined) {\n        for (let i = 0; i < style.length; i += 1) {\n            hash = (hash * _utils_js__WEBPACK_IMPORTED_MODULE_4__.HASH_INTERNAL_MULT) ^ style.charCodeAt(i);\n        }\n    }\n    return hash >>> 0;\n}\nfunction normalizeSelector(filter, getScriptletCanonicalName) {\n    let selector = filter.getSelector();\n    if (filter.style !== undefined) {\n        selector += filter.style;\n    }\n    if (filter.isScriptInject() === false) {\n        return selector;\n    }\n    const parsed = filter.parseScript();\n    if (parsed === undefined) {\n        return selector;\n    }\n    const canonicalName = getScriptletCanonicalName(parsed.name);\n    if (canonicalName === undefined) {\n        return selector;\n    }\n    return selector.replace(parsed.name, canonicalName);\n}\n/***************************************************************************\n *  Cosmetic filters parsing\n * ************************************************************************ */\nclass CosmeticFilter {\n    /**\n     * Given a line that we know contains a cosmetic filter, create a CosmeticFiler\n     * instance out of it. This function should be *very* efficient, as it will be\n     * used to parse tens of thousands of lines.\n     */\n    static parse(line, debug = false) {\n        const rawLine = line;\n        // Mask to store attributes. Each flag (unhide, scriptInject, etc.) takes\n        // only 1 bit at a specific offset defined in COSMETICS_MASK.\n        // cf: COSMETICS_MASK for the offset of each property\n        let mask = 0;\n        let selector;\n        let domains;\n        let parentDomains;\n        let style;\n        const sharpIndex = line.indexOf('#');\n        // Start parsing the line\n        const afterSharpIndex = sharpIndex + 1;\n        let suffixStartIndex = afterSharpIndex + 1;\n        // hostname1,hostname2#?#.selector\n        // hostname1,hostname2#@#.selector\n        //                    ^^ ^\n        //                    || |\n        //                    || suffixStartIndex\n        //                    |afterSharpIndex\n        //                    sharpIndex\n        // Check if unhide\n        if (line.length > afterSharpIndex) {\n            if (line[afterSharpIndex] === '@') {\n                mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBit)(mask, COSMETICS_MASK.unhide);\n                suffixStartIndex += 1;\n            }\n            else if (line[afterSharpIndex] === '?') {\n                suffixStartIndex += 1;\n            }\n        }\n        if (suffixStartIndex >= line.length) {\n            return null;\n        }\n        // Parse hostnames and entitites as well as their negations.\n        //\n        // - ~hostname##.selector\n        // - hostname##.selector\n        // - hostname>>##.selector\n        // - entity.*##.selector\n        // - ~entity.*##.selector\n        // - entity>>##.selector\n        //\n        // Each kind will have its own Uint32Array containing hashes, sorted by\n        // number of labels considered. This allows a compact representation of\n        // hostnames and fast matching without any string copy.\n        //\n        // `>>` suffix is responsible for targeting subframe of the given domain.\n        // It is the part of each domain entry and domains can have a mix of\n        // hostnames and subframe targeting hostnames (also entries).\n        if (sharpIndex > 0) {\n            const domainEntries = [];\n            const parentDomainEntries = [];\n            for (const entry of line.slice(0, sharpIndex).split(',')) {\n                // each domain entry can have `>>` suffix.\n                if (entry.endsWith('>>')) {\n                    parentDomainEntries.push(entry.slice(0, -2));\n                }\n                else {\n                    domainEntries.push(entry);\n                }\n            }\n            if (domainEntries.length !== 0) {\n                domains = _engine_domains_js__WEBPACK_IMPORTED_MODULE_1__.Domains.parse(domainEntries.join(','), {\n                    debug,\n                });\n            }\n            if (parentDomainEntries.length !== 0) {\n                parentDomains = _engine_domains_js__WEBPACK_IMPORTED_MODULE_1__.Domains.parse(parentDomainEntries.join(','), {\n                    debug,\n                });\n            }\n        }\n        if (line.endsWith(':remove()')) {\n            // ##selector:remove()\n            mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBit)(mask, COSMETICS_MASK.remove);\n            mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBit)(mask, COSMETICS_MASK.extended);\n            line = line.slice(0, -9);\n        }\n        else if (line.length - suffixStartIndex >= 8 &&\n            line.endsWith(')') &&\n            line.indexOf(':style(', suffixStartIndex) !== -1) {\n            // ##selector:style(...)\n            const indexOfStyle = line.indexOf(':style(', suffixStartIndex);\n            style = line.slice(indexOfStyle + 7, -1);\n            line = line.slice(0, indexOfStyle);\n        }\n        // Deal with HTML filters\n        if (line.charCodeAt(suffixStartIndex) === 94 /* '^' */) {\n            if (line.startsWith('script:has-text(', suffixStartIndex + 1) === false ||\n                line.charCodeAt(line.length - 1) !== 41 /* ')' */) {\n                return null;\n            }\n            // NOTE: currently only ^script:has-text(...) is supported.\n            //\n            //   ^script:has-text(selector)\n            //   ^                         ^\n            //   |                         |\n            //   |                         |\n            //   |                         line.length\n            //   |\n            //   suffixStartIndex\n            //\n            selector = line.slice(suffixStartIndex, line.length);\n            if ((0,_html_filtering_js__WEBPACK_IMPORTED_MODULE_5__.extractHTMLSelectorFromRule)(selector) === undefined) {\n                return null;\n            }\n        }\n        else if (line.length - suffixStartIndex > 4 &&\n            line.charCodeAt(suffixStartIndex) === 43 /* '+' */ &&\n            line.startsWith('+js(', suffixStartIndex)) {\n            // Generic scriptlets are invalid, unless they are un-hide\n            if ((domains === undefined ||\n                (domains.hostnames === undefined && domains.entities === undefined)) &&\n                (parentDomains === undefined ||\n                    (parentDomains.hostnames === undefined && parentDomains.entities === undefined)) &&\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(mask, COSMETICS_MASK.unhide) === false) {\n                return null;\n            }\n            mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBit)(mask, COSMETICS_MASK.scriptInject);\n            selector = line.slice(suffixStartIndex + 4, line.length - 1);\n            // An empty scriptlet (i.e. '+js()') can be specified to cancel injections\n            // on a specific domain or globally. It does not make sense though to have\n            // an empty scriptlet without an exception (i.e. '#@#' is mandatory).\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(mask, COSMETICS_MASK.unhide) === false && selector.length === 0) {\n                return null;\n            }\n        }\n        else {\n            selector = line.slice(suffixStartIndex);\n            const selectorType = (0,_ghostery_adblocker_extended_selectors__WEBPACK_IMPORTED_MODULE_0__.classifySelector)(selector);\n            if (selectorType === _ghostery_adblocker_extended_selectors__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Extended) {\n                mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBit)(mask, COSMETICS_MASK.extended);\n            }\n            else if (selectorType === _ghostery_adblocker_extended_selectors__WEBPACK_IMPORTED_MODULE_0__.SelectorType.Invalid || !isValidCss(selector)) {\n                // console.error('Invalid', line);\n                // TODO - maybe perform `isValidCss` from the other module.\n                return null;\n            }\n        }\n        // Subframe target is only available to scriptlets.\n        if (parentDomains !== undefined && (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(mask, COSMETICS_MASK.scriptInject) === false) {\n            return null;\n        }\n        // Extended selectors should always be specific to some domain.\n        if (domains === undefined && (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(mask, COSMETICS_MASK.extended) === true) {\n            return null;\n        }\n        if (selector !== undefined) {\n            // Check if unicode appears in selector\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.hasUnicode)(selector)) {\n                mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBit)(mask, COSMETICS_MASK.isUnicode);\n            }\n            // Classify selector\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(mask, COSMETICS_MASK.scriptInject) === false &&\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(mask, COSMETICS_MASK.remove) === false &&\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(mask, COSMETICS_MASK.extended) === false &&\n                selector.startsWith('^') === false) {\n                const c0 = selector.charCodeAt(0);\n                const c1 = selector.charCodeAt(1);\n                const c2 = selector.charCodeAt(2);\n                // Check if we have a specific case of simple selector (id, class or\n                // href) These are the most common filters and will benefit greatly from\n                // a custom dispatch mechanism.\n                if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(mask, COSMETICS_MASK.scriptInject) === false) {\n                    if (c0 === 46 /* '.' */ && isSimpleSelector(selector)) {\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBit)(mask, COSMETICS_MASK.isClassSelector);\n                    }\n                    else if (c0 === 35 /* '#' */ && isSimpleSelector(selector)) {\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBit)(mask, COSMETICS_MASK.isIdSelector);\n                    }\n                    else if (c0 === 97 /* a */ &&\n                        c1 === 91 /* '[' */ &&\n                        c2 === 104 /* 'h' */ &&\n                        isSimpleHrefSelector(selector, 2)) {\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBit)(mask, COSMETICS_MASK.isHrefSelector);\n                    }\n                    else if (c0 === 91 /* '[' */ &&\n                        c1 === 104 /* 'h' */ &&\n                        isSimpleHrefSelector(selector, 1)) {\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.setBit)(mask, COSMETICS_MASK.isHrefSelector);\n                    }\n                }\n            }\n        }\n        return new CosmeticFilter({\n            mask,\n            rawLine: debug === true ? rawLine : undefined,\n            selector,\n            style,\n            domains,\n            parentDomains,\n        });\n    }\n    /**\n     * Deserialize cosmetic filters. The code accessing the buffer should be\n     * symetrical to the one in `serializeCosmeticFilter`.\n     */\n    static deserialize(buffer) {\n        const mask = buffer.getUint16();\n        const isUnicode = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(mask, COSMETICS_MASK.isUnicode);\n        const optionalParts = buffer.getUint8();\n        const selector = isUnicode ? buffer.getUTF8() : buffer.getCosmeticSelector();\n        // The order of these fields should be the same as when we serialize them.\n        return new CosmeticFilter({\n            // Mandatory fields\n            mask,\n            selector,\n            // Optional fields\n            domains: (optionalParts & 1) === 1 ? _engine_domains_js__WEBPACK_IMPORTED_MODULE_1__.Domains.deserialize(buffer) : undefined,\n            rawLine: (optionalParts & 2) === 2 ? buffer.getRawCosmetic() : undefined,\n            style: (optionalParts & 4) === 4 ? buffer.getASCII() : undefined,\n            parentDomains: (optionalParts & 8) === 8 ? _engine_domains_js__WEBPACK_IMPORTED_MODULE_1__.Domains.deserialize(buffer) : undefined,\n        });\n    }\n    constructor({ mask, selector, domains, rawLine, style, parentDomains, }) {\n        this.mask = mask;\n        this.selector = selector;\n        this.domains = domains;\n        this.parentDomains = parentDomains;\n        this.style = style;\n        this.id = undefined;\n        this.rawLine = rawLine;\n        this.scriptletDetails = undefined;\n    }\n    isCosmeticFilter() {\n        return true;\n    }\n    isNetworkFilter() {\n        return false;\n    }\n    /**\n     * The format of a cosmetic filter is:\n     *\n     * | mask | selector length | selector... | hostnames length | hostnames...\n     *   32     16                              16\n     *\n     * The header (mask) is 32 bits, then we have a total of 32 bits to store the\n     * length of `selector` and `hostnames` (16 bits each).\n     *\n     * Improvements similar to the onces mentioned in `serializeNetworkFilters`\n     * could be applied here, to get a more compact representation.\n     */\n    serialize(buffer) {\n        // Mandatory fields\n        buffer.pushUint16(this.mask);\n        const index = buffer.getPos();\n        buffer.pushUint8(0);\n        if (this.isUnicode()) {\n            buffer.pushUTF8(this.selector);\n        }\n        else {\n            buffer.pushCosmeticSelector(this.selector);\n        }\n        // This bit-mask indicates which optional parts of the filter were serialized.\n        let optionalParts = 0;\n        if (this.domains !== undefined) {\n            optionalParts |= 1;\n            this.domains.serialize(buffer);\n        }\n        if (this.rawLine !== undefined) {\n            optionalParts |= 2;\n            buffer.pushRawCosmetic(this.rawLine);\n        }\n        if (this.style !== undefined) {\n            optionalParts |= 4;\n            buffer.pushASCII(this.style);\n        }\n        if (this.parentDomains !== undefined) {\n            optionalParts |= 8;\n            this.parentDomains.serialize(buffer);\n        }\n        buffer.setByte(index, optionalParts);\n    }\n    /**\n     * Return an estimation of the size (in bytes) needed to persist this filter\n     * in a DataView. This does not need to be 100% accurate but should be an\n     * upper-bound. It should also be as fast as possible.\n     */\n    getSerializedSize(compression) {\n        let estimate = 2 + 1; // mask (2 byte) + optional parts (1 byte)\n        if (this.isUnicode()) {\n            estimate += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_2__.sizeOfUTF8)(this.selector);\n        }\n        else {\n            estimate += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_2__.sizeOfCosmeticSelector)(this.selector, compression);\n        }\n        if (this.domains !== undefined) {\n            estimate += this.domains.getSerializedSize();\n        }\n        if (this.parentDomains !== undefined) {\n            estimate += this.parentDomains.getSerializedSize();\n        }\n        if (this.rawLine !== undefined) {\n            estimate += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_2__.sizeOfRawCosmetic)(this.rawLine, compression);\n        }\n        if (this.style !== undefined) {\n            estimate += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_2__.sizeOfASCII)(this.style);\n        }\n        return estimate;\n    }\n    /**\n     * Create a more human-readable version of this filter. It is mainly used for\n     * debugging purpose, as it will expand the values stored in the bit mask.\n     */\n    toString() {\n        if (this.rawLine !== undefined) {\n            return this.rawLine;\n        }\n        let filter = '';\n        if (this.domains !== undefined) {\n            if (this.domains.parts !== undefined) {\n                filter += this.domains.parts;\n            }\n            else {\n                filter += '<hostnames>';\n            }\n        }\n        if (this.parentDomains !== undefined) {\n            if (this.domains !== undefined) {\n                filter += ',';\n            }\n            if (this.parentDomains.parts !== undefined) {\n                filter += this.parentDomains.parts\n                    .split(',')\n                    .map((part) => part + '>>')\n                    .join(',');\n            }\n            else {\n                filter += '<hostnames>>>';\n            }\n        }\n        if (this.isUnhide()) {\n            filter += '#@#';\n        }\n        else {\n            filter += '##';\n        }\n        if (this.isScriptInject()) {\n            filter += '+js(';\n            filter += this.selector;\n            filter += ')';\n        }\n        else {\n            filter += this.selector;\n        }\n        if (this.hasCustomStyle()) {\n            filter += ':style(' + this.getStyle() + ')';\n        }\n        return filter;\n    }\n    match(hostname, domain, ancestors) {\n        // Not constraint on hostname, match is true\n        if (this.hasHostnameConstraint() === false) {\n            return true;\n        }\n        // No `hostname` available but this filter has some constraints on hostname.\n        if (!hostname) {\n            return false;\n        }\n        if (this.domains !== undefined &&\n            // TODO - this hashing could be re-used between cosmetics by using an\n            // abstraction like `Request` (similar to network filters matching).\n            // Maybe could we reuse `Request` directly without any change?\n            this.domains.match((0,_request_js__WEBPACK_IMPORTED_MODULE_3__.getHostnameHashesFromLabelsBackward)(hostname, domain), (0,_request_js__WEBPACK_IMPORTED_MODULE_3__.getEntityHashesFromLabelsBackward)(hostname, domain))) {\n            return true;\n        }\n        if (ancestors !== undefined && this.parentDomains !== undefined) {\n            for (const { hostname, domain } of ancestors) {\n                if (this.parentDomains.match(hostname.length === 0\n                    ? _data_view_js__WEBPACK_IMPORTED_MODULE_2__.EMPTY_UINT32_ARRAY\n                    : (0,_request_js__WEBPACK_IMPORTED_MODULE_3__.getHostnameHashesFromLabelsBackward)(hostname, domain), hostname.length === 0\n                    ? _data_view_js__WEBPACK_IMPORTED_MODULE_2__.EMPTY_UINT32_ARRAY\n                    : (0,_request_js__WEBPACK_IMPORTED_MODULE_3__.getEntityHashesFromLabelsBackward)(hostname, domain))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Get tokens for this filter. It can be indexed multiple times if multiple\n     * hostnames are specified (e.g.: host1,host2##.selector).\n     */\n    getTokens() {\n        const tokens = [];\n        // Note, we do not need to use negated domains or entities as tokens here\n        // since they will by definition not match on their own, unless accompanied\n        // by a domain or entity. Instead, they are handled in\n        // `CosmeticFilterBucket.getCosmeticsFilters(...)`.\n        if (this.domains !== undefined) {\n            const { hostnames, entities } = this.domains;\n            if (hostnames !== undefined) {\n                for (const hostname of hostnames) {\n                    tokens.push(new Uint32Array([hostname]));\n                }\n            }\n            if (entities !== undefined) {\n                for (const entity of entities) {\n                    tokens.push(new Uint32Array([entity]));\n                }\n            }\n        }\n        if (this.parentDomains !== undefined) {\n            const { hostnames, entities } = this.parentDomains;\n            if (hostnames !== undefined) {\n                for (const hostname of hostnames) {\n                    tokens.push(new Uint32Array([hostname]));\n                }\n            }\n            if (entities !== undefined) {\n                for (const entity of entities) {\n                    tokens.push(new Uint32Array([entity]));\n                }\n            }\n        }\n        // Here we only take selector into account if the filter is not unHide.\n        if (tokens.length === 0 && this.isUnhide() === false) {\n            if (this.isIdSelector() || this.isClassSelector()) {\n                // Here we try to identify the end of selector si that we can extract a\n                // valid token out of it. In all these examples, 'selector' is our\n                // token:\n                //\n                //   .selector[...]\n                //   #selector[...]\n                //   #selector ~ foo\n                //   .selector:not(...)\n                //   .selector.foo\n                //\n                // We now try to identify the first valid end of selector which will\n                // also be the end of our token: space, bracket, colon, dot.\n                let endOfSelector = 1;\n                const selector = this.selector;\n                for (; endOfSelector < selector.length; endOfSelector += 1) {\n                    const code = selector.charCodeAt(endOfSelector);\n                    if (code === 32 /* ' ' */ ||\n                        code === 46 /* '.' */ ||\n                        code === 58 /* ':' */ ||\n                        code === 91 /* '[' */) {\n                        break;\n                    }\n                }\n                const arr = new Uint32Array(1);\n                arr[0] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHashBetween)(selector, 1, endOfSelector);\n                tokens.push(arr);\n            }\n            else if (this.isHrefSelector() === true) {\n                const selector = this.getSelector();\n                // Locate 'href' in selector\n                let hrefIndex = selector.indexOf('href');\n                if (hrefIndex === -1) {\n                    return EMPTY_TOKENS;\n                }\n                hrefIndex += 4;\n                // Tokenize optimally depending on the kind of selector: 'href=',\n                // 'href*=', 'href^='.\n                let skipFirstToken = false;\n                let skipLastToken = true;\n                if (selector.charCodeAt(hrefIndex) === 42 /* '*' */) {\n                    // skip: '*'\n                    skipFirstToken = true;\n                    hrefIndex += 1;\n                }\n                else if (selector.charCodeAt(hrefIndex) === 94 /* '^' */) {\n                    // skip: '^'\n                    hrefIndex += 1;\n                }\n                else {\n                    skipLastToken = false;\n                }\n                hrefIndex += 2; // skip:  '=\"'\n                // Locate end of href\n                const hrefEnd = selector.indexOf('\"', hrefIndex);\n                if (hrefEnd === -1) {\n                    // That cannot happen unless the filter is not well-formed. In this\n                    // case, we just return no tokens, which will result in this filter\n                    // ending up in the \"wildcard\" bucket of the index.\n                    return EMPTY_TOKENS;\n                }\n                tokens.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.tokenize)(this.selector.slice(hrefIndex, hrefEnd), skipFirstToken, skipLastToken));\n            }\n        }\n        if (tokens.length === 0) {\n            return EMPTY_TOKENS;\n        }\n        return tokens;\n    }\n    parseScript() {\n        if (this.scriptletDetails !== undefined) {\n            return this.scriptletDetails;\n        }\n        const selector = this.getSelector();\n        if (selector.length === 0) {\n            return undefined;\n        }\n        const parts = [];\n        let index = 0;\n        let lastComaIndex = -1;\n        let inDoubleQuotes = false;\n        let inSingleQuotes = false;\n        let inBackticks = false;\n        let inRegexp = false;\n        let objectNesting = 0;\n        let lastCharIsBackslash = false;\n        let inArgument = false;\n        for (; index < selector.length; index += 1) {\n            const char = selector[index];\n            if (lastCharIsBackslash === false) {\n                if (inDoubleQuotes === true) {\n                    if (char === '\"') {\n                        inDoubleQuotes = false;\n                    }\n                }\n                else if (inSingleQuotes === true) {\n                    if (char === \"'\") {\n                        inSingleQuotes = false;\n                    }\n                }\n                else if (inBackticks === true) {\n                    if (char === '`') {\n                        inBackticks = false;\n                    }\n                }\n                else if (objectNesting !== 0) {\n                    if (char === '{') {\n                        objectNesting += 1;\n                    }\n                    else if (char === '}') {\n                        objectNesting -= 1;\n                    }\n                    else if (char === '\"') {\n                        inDoubleQuotes = true;\n                    }\n                    else if (char === \"'\") {\n                        inSingleQuotes = true;\n                    }\n                    else if (char === '`') {\n                        inBackticks = true;\n                    }\n                }\n                else if (inRegexp === true) {\n                    if (char === '/') {\n                        inRegexp = false;\n                    }\n                }\n                else {\n                    if (inArgument === false) {\n                        if (char === ' ') {\n                            // ignore\n                        }\n                        else if (char === '\"' && selector.indexOf('\"', index + 1) > 0) {\n                            inDoubleQuotes = true;\n                        }\n                        else if (char === \"'\" && selector.indexOf(\"'\", index + 1) > 0) {\n                            inSingleQuotes = true;\n                        }\n                        else if (char === '`' && selector.indexOf('`', index + 1) > 0) {\n                            inBackticks = true;\n                        }\n                        else if (char === '{' && selector.indexOf('}', index + 1) > 0) {\n                            objectNesting += 1;\n                        }\n                        else if (char === '/' && selector.indexOf('/', index + 1) > 0) {\n                            inRegexp = true;\n                        }\n                        else {\n                            inArgument = true;\n                        }\n                    }\n                }\n            }\n            // Split on comma only if not inside quotes, regexp, and not escaped\n            if (lastCharIsBackslash === false &&\n                char === ',' &&\n                inDoubleQuotes === false &&\n                inSingleQuotes === false &&\n                inBackticks === false &&\n                inRegexp === false) {\n                parts.push(selector.slice(lastComaIndex + 1, index).trim());\n                lastComaIndex = index;\n                inArgument = false;\n            }\n            lastCharIsBackslash = char === '\\\\' && !lastCharIsBackslash;\n        }\n        parts.push(selector.slice(lastComaIndex + 1).trim());\n        const args = parts\n            .slice(1)\n            .map((part) => {\n            const openingCode = part.charCodeAt(0);\n            if (!(openingCode === 39 /* `'` */ && part.endsWith(`'`)) &&\n                !(openingCode === 34 /* `\"` */ && part.endsWith(`\"`)) &&\n                !(openingCode === 96 /* '`' */ && part.endsWith('`'))) {\n                return part;\n            }\n            // Passthrough `part` if it ends with escaped quote\n            if (part.charCodeAt(part.length - 2) === 92 /* '\\\\' */) {\n                return part;\n            }\n            // Passthrough `part` if it contains unescaped quote\n            if (part.length > 2) {\n                for (let i = 1; i < part.length - 1; i++) {\n                    if (part.charCodeAt(i) === openingCode && part.charCodeAt(i - 1) !== 92 /* '\\\\' */) {\n                        return part;\n                    }\n                }\n            }\n            const escaped = part.substring(1, part.length - 1);\n            if (openingCode === 39 /* `'` */) {\n                return escaped.replace(REGEXP_ESCAPED_SINGLE_QUOTE, \"'\");\n            }\n            else if (openingCode === 34 /* '\"' */) {\n                return escaped.replace(REGEXP_ESCAPED_DOUBLE_QUOTE, '\"');\n            }\n            return escaped.replace(REGEXP_ESCAPED_BACKTICK, '`');\n        })\n            .map((part) => {\n            const isObjectLiteral = part.startsWith('{');\n            let result = part\n                .replace(REGEXP_UNICODE_COMMA, ',')\n                .replace(REGEXP_UNICODE_BACKSLASH, '\\\\');\n            if (!isObjectLiteral) {\n                result = result.replace(REGEXP_ESCAPED_COMMA, ',');\n            }\n            return result;\n        });\n        this.scriptletDetails = { name: parts[0], args };\n        return this.scriptletDetails;\n    }\n    getScript(getScriptlet) {\n        const parsed = this.parseScript();\n        if (parsed === undefined) {\n            return undefined;\n        }\n        const { name, args } = parsed;\n        let script = getScriptlet(name);\n        if (script !== undefined) {\n            for (let i = 0; i < args.length; i += 1) {\n                // escape some characters so they wont get evaluated with escape characters during script injection\n                const arg = args[i].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n                script = script.replace(`{{${i + 1}}}`, arg);\n            }\n            return script;\n        } // TODO - else throw an exception?\n        return undefined;\n    }\n    hasHostnameConstraint() {\n        return this.domains !== undefined || this.parentDomains !== undefined;\n    }\n    // `hasSubframeConstraint` is only `true` when the filter is scriptlet.\n    // Other cosmetic filters with subframe constraint will be rejected in the parse time.\n    hasSubframeConstraint() {\n        return this.parentDomains !== undefined;\n    }\n    getId() {\n        if (this.id === undefined) {\n            this.id = computeFilterId(this.mask, this.selector, this.domains, this.parentDomains, this.style);\n        }\n        return this.id;\n    }\n    hasCustomStyle() {\n        return this.style !== undefined;\n    }\n    getStyle(defaultStyle = DEFAULT_HIDING_STYLE) {\n        return this.style || defaultStyle;\n    }\n    getStyleAttributeHash() {\n        return `s${(0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)(this.getStyle())}`;\n    }\n    getSelector() {\n        return this.selector;\n    }\n    getSelectorAST() {\n        return (0,_ghostery_adblocker_extended_selectors__WEBPACK_IMPORTED_MODULE_0__.parse)(this.getSelector());\n    }\n    getExtendedSelector() {\n        return (0,_html_filtering_js__WEBPACK_IMPORTED_MODULE_5__.extractHTMLSelectorFromRule)(this.selector);\n    }\n    isExtended() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(this.mask, COSMETICS_MASK.extended);\n    }\n    isRemove() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(this.mask, COSMETICS_MASK.remove);\n    }\n    isUnhide() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(this.mask, COSMETICS_MASK.unhide);\n    }\n    isScriptInject() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(this.mask, COSMETICS_MASK.scriptInject);\n    }\n    isCSS() {\n        return this.isScriptInject() === false;\n    }\n    isIdSelector() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(this.mask, COSMETICS_MASK.isIdSelector);\n    }\n    isClassSelector() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(this.mask, COSMETICS_MASK.isClassSelector);\n    }\n    isHrefSelector() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(this.mask, COSMETICS_MASK.isHrefSelector);\n    }\n    isUnicode() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.getBit)(this.mask, COSMETICS_MASK.isUnicode);\n    }\n    isHtmlFiltering() {\n        return this.getSelector().startsWith('^');\n    }\n    // A generic hide cosmetic filter is one that:\n    //\n    // * Do not have a domain specified. \"Hide this element on all domains\"\n    // * Have only domain exceptions specified. \"Hide this element on all domains except example.com\"\n    //\n    // For example: ~example.com##.ad  is a generic filter as well!\n    isGenericHide() {\n        var _a, _b, _c, _d;\n        return (((_a = this === null || this === void 0 ? void 0 : this.domains) === null || _a === void 0 ? void 0 : _a.hostnames) === undefined &&\n            ((_b = this === null || this === void 0 ? void 0 : this.domains) === null || _b === void 0 ? void 0 : _b.entities) === undefined &&\n            ((_c = this === null || this === void 0 ? void 0 : this.parentDomains) === null || _c === void 0 ? void 0 : _c.hostnames) === undefined &&\n            ((_d = this === null || this === void 0 ? void 0 : this.parentDomains) === null || _d === void 0 ? void 0 : _d.entities) === undefined);\n    }\n}\n//# sourceMappingURL=cosmetic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9maWx0ZXJzL2Nvc21ldGljLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29IO0FBQ3JFO0FBQzJFO0FBQ2xCO0FBQ3NCO0FBQzNEO0FBQ25FLHNCQUFzQiw2REFBa0I7QUFDakMsdURBQXVEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQVMsR0FBRyx5REFBa0I7QUFDOUM7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDLDJCQUEyQix5REFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUMsMkJBQTJCLHlEQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVEQUFPO0FBQ2pDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxnQ0FBZ0MsdURBQU87QUFDdkM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQU07QUFDekIsbUJBQW1CLGlEQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrRUFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBTTtBQUN0QjtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0ZBQWdCO0FBQ2pELGlDQUFpQyxnRkFBWTtBQUM3Qyx1QkFBdUIsaURBQU07QUFDN0I7QUFDQSxzQ0FBc0MsZ0ZBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlEQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpREFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBVTtBQUMxQix1QkFBdUIsaURBQU07QUFDN0I7QUFDQTtBQUNBLGdCQUFnQixpREFBTTtBQUN0QixnQkFBZ0IsaURBQU07QUFDdEIsZ0JBQWdCLGlEQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlEQUFNO0FBQzFCO0FBQ0EsK0JBQStCLGlEQUFNO0FBQ3JDO0FBQ0E7QUFDQSwrQkFBK0IsaURBQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpREFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpREFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlEQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsdURBQU87QUFDeEQ7QUFDQTtBQUNBLHVEQUF1RCx1REFBTztBQUM5RCxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IseURBQXlEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0Esd0JBQXdCLHlEQUFVO0FBQ2xDO0FBQ0E7QUFDQSx3QkFBd0IscUVBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0VBQWlCO0FBQ3pDO0FBQ0E7QUFDQSx3QkFBd0IsMERBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdGQUFtQyxvQkFBb0IsOEVBQWlDO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQSxzQkFBc0IsNkRBQWtCO0FBQ3hDLHNCQUFzQixnRkFBbUM7QUFDekQsc0JBQXNCLDZEQUFrQjtBQUN4QyxzQkFBc0IsOEVBQWlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwREFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbURBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3QkFBd0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0Esc0RBQXNEO0FBQ3RELDJDQUEyQyxFQUFFLFFBQVE7QUFDckQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1EQUFRLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2RUFBZ0I7QUFDL0I7QUFDQTtBQUNBLGVBQWUsK0VBQTJCO0FBQzFDO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9maWx0ZXJzL2Nvc21ldGljLmpzPzQ5ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCBHaG9zdGVyeSBHbWJILiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgeyBjbGFzc2lmeVNlbGVjdG9yLCBTZWxlY3RvclR5cGUsIHBhcnNlIGFzIHBhcnNlQ3NzU2VsZWN0b3IsIH0gZnJvbSAnQGdob3N0ZXJ5L2FkYmxvY2tlci1leHRlbmRlZC1zZWxlY3RvcnMnO1xuaW1wb3J0IHsgRG9tYWlucyB9IGZyb20gJy4uL2VuZ2luZS9kb21haW5zLmpzJztcbmltcG9ydCB7IEVNUFRZX1VJTlQzMl9BUlJBWSwgc2l6ZU9mQVNDSUksIHNpemVPZkNvc21ldGljU2VsZWN0b3IsIHNpemVPZlVURjgsIHNpemVPZlJhd0Nvc21ldGljLCB9IGZyb20gJy4uL2RhdGEtdmlldy5qcyc7XG5pbXBvcnQgeyBnZXRIb3N0bmFtZUhhc2hlc0Zyb21MYWJlbHNCYWNrd2FyZCwgZ2V0RW50aXR5SGFzaGVzRnJvbUxhYmVsc0JhY2t3YXJkLCB9IGZyb20gJy4uL3JlcXVlc3QuanMnO1xuaW1wb3J0IHsgZmFzdEhhc2gsIGZhc3RIYXNoQmV0d2VlbiwgZ2V0Qml0LCBoYXNVbmljb2RlLCBzZXRCaXQsIHRva2VuaXplLCBIQVNIX1NFRUQsIEhBU0hfSU5URVJOQUxfTVVMVCwgfSBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgeyBleHRyYWN0SFRNTFNlbGVjdG9yRnJvbVJ1bGUgfSBmcm9tICcuLi9odG1sLWZpbHRlcmluZy5qcyc7XG5jb25zdCBFTVBUWV9UT0tFTlMgPSBbRU1QVFlfVUlOVDMyX0FSUkFZXTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX0hJRElOR19TVFlMRSA9ICdkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7JztcbmNvbnN0IFJFR0VYUF9VTklDT0RFX0NPTU1BID0gbmV3IFJlZ0V4cCgvXFxcXHUwMDJDLywgJ2cnKTtcbmNvbnN0IFJFR0VYUF9VTklDT0RFX0JBQ0tTTEFTSCA9IG5ldyBSZWdFeHAoL1xcXFx1MDA1Qy8sICdnJyk7XG5jb25zdCBSRUdFWFBfRVNDQVBFRF9DT01NQSA9IG5ldyBSZWdFeHAoL1xcXFwsLywgJ2cnKTtcbmNvbnN0IFJFR0VYUF9FU0NBUEVEX1NJTkdMRV9RVU9URSA9IG5ldyBSZWdFeHAoL1xcXFwnLywgJ2cnKTtcbmNvbnN0IFJFR0VYUF9FU0NBUEVEX0RPVUJMRV9RVU9URSA9IG5ldyBSZWdFeHAoL1xcXFxcIi8sICdnJyk7XG5jb25zdCBSRUdFWFBfRVNDQVBFRF9CQUNLVElDSyA9IG5ldyBSZWdFeHAoL1xcXFxgLywgJ2cnKTtcbi8qKlxuICogR2l2ZW4gYSBgc2VsZWN0b3JgIHN0YXJ0aW5nIHdpdGggZWl0aGVyICcjJyBvciAnLicgY2hlY2sgaWYgd2hhdCBmb2xsb3dzIGlzXG4gKiBhIHNpbXBsZSBDU1Mgc2VsZWN0b3I6IC9eLT9bX2EtekEtWl0rW19hLXpBLVowLTktXSokL1xuICovXG5mdW5jdGlvbiBpc1NpbXBsZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzZWxlY3Rvci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBjb2RlID0gc2VsZWN0b3IuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKCEoY29kZSA9PT0gNDUgLyogJy0nICovIHx8XG4gICAgICAgICAgICBjb2RlID09PSA5NSAvKiAnXycgKi8gfHxcbiAgICAgICAgICAgIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIC8qIFswLTldICovIHx8XG4gICAgICAgICAgICAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSAvKiBbQS1aXSAqLyB8fFxuICAgICAgICAgICAgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpKSAvKiBbYS16XSAqLykge1xuICAgICAgICAgICAgaWYgKGkgPCBzZWxlY3Rvci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2hhdCBmb2xsb3dzIGlzIGEgJyA+JyBvciAnIH4nIG9yICcgKycsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICAgICAgICAgICAgICAvLyBhbHNvIGNvbnNpZGVyIGl0IGEgc2ltcGxlIHNlbGVjdG9yIGFuZCB0aGUgdG9rZW4gdGhpcyBmaWx0ZXIgY2FuIGJlXG4gICAgICAgICAgICAgICAgLy8gaW5kZXhlZCB3aXRoIGlzIHRoZSBmaXJzdCBzZWxlY3Rvci5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q29kZSA9IHNlbGVjdG9yLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSA5MSAvKiAnWycgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9PT0gNDYgLyogJy4nICovIHx8XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPT09IDU4IC8qICc6JyAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAoY29kZSA9PT0gMzIgLyogJyAnICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAobmV4dENvZGUgPT09IDYyIC8qICc+JyAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDb2RlID09PSA0MyAvKiAnKycgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29kZSA9PT0gMTI2IC8qICd+JyAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDb2RlID09PSA0NiAvKiAnLicgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29kZSA9PT0gMzUpKSAvKiAnIycgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBHaXZlbiBhIGBzZWxlY3RvcmAgc3RhcnRpbmcgd2l0aCBlaXRoZXIgJ2FbJyBvciAnWycsIGNoZWNrIGlmIHdoYXQgZm9sbG93c1xuICogaXMgYSBzaW1wbGUgaHJlZiBhdHRyaWJ1dGUgc2VsZWN0b3Igb2YgdGhlIGZvcm06ICdocmVmXj0nIG9yICdocmVmKj0nLlxuICovXG5mdW5jdGlvbiBpc1NpbXBsZUhyZWZTZWxlY3RvcihzZWxlY3Rvciwgc3RhcnQpIHtcbiAgICByZXR1cm4gKHNlbGVjdG9yLnN0YXJ0c1dpdGgoJ2hyZWZePVwiJywgc3RhcnQpIHx8XG4gICAgICAgIHNlbGVjdG9yLnN0YXJ0c1dpdGgoJ2hyZWYqPVwiJywgc3RhcnQpIHx8XG4gICAgICAgIHNlbGVjdG9yLnN0YXJ0c1dpdGgoJ2hyZWY9XCInLCBzdGFydCkpO1xufVxuLyoqXG4gKiBWYWxpZGF0ZSBDU1Mgc2VsZWN0b3IuIFRoZXJlIGlzIGEgZmFzdCBwYXRoIGZvciBzaW1wbGUgc2VsZWN0b3JzIChlLmcuOiAjZm9vXG4gKiBvciAuYmFyKSB3aGljaCBhcmUgdGhlIG1vc3QgY29tbW9uIGNhc2UuIEZvciBjb21wbGV4IG9uZXMsIHdlIHJlbHkgb25cbiAqIGBFbGVtZW50Lm1hdGNoZXNgIChpZiBhdmFpbGFibGUpLlxuICovXG5jb25zdCBpc1ZhbGlkQ3NzID0gKCgpID0+IHtcbiAgICBjb25zdCBkaXYgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgOiB7XG4gICAgICAgICAgICBtYXRjaGVzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLyogbm9vcCAqL1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICBjb25zdCBtYXRjaGVzID0gKHNlbGVjdG9yKSA9PiBkaXYubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgY29uc3QgdmFsaWRTZWxlY3RvclJlID0gL15bIy5dP1tcXHctLl0rJC87XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVmFsaWRDc3NJbXBsKHNlbGVjdG9yKSB7XG4gICAgICAgIGlmICh2YWxpZFNlbGVjdG9yUmUudGVzdChzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYXRjaGVzKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufSkoKTtcbi8qKlxuICogTWFza3MgdXNlZCB0byBzdG9yZSBvcHRpb25zIG9mIGNvc21ldGljIGZpbHRlcnMgaW4gYSBiaXRtYXNrLlxuICovXG52YXIgQ09TTUVUSUNTX01BU0s7XG4oZnVuY3Rpb24gKENPU01FVElDU19NQVNLKSB7XG4gICAgQ09TTUVUSUNTX01BU0tbQ09TTUVUSUNTX01BU0tbXCJ1bmhpZGVcIl0gPSAxXSA9IFwidW5oaWRlXCI7XG4gICAgQ09TTUVUSUNTX01BU0tbQ09TTUVUSUNTX01BU0tbXCJzY3JpcHRJbmplY3RcIl0gPSAyXSA9IFwic2NyaXB0SW5qZWN0XCI7XG4gICAgQ09TTUVUSUNTX01BU0tbQ09TTUVUSUNTX01BU0tbXCJpc1VuaWNvZGVcIl0gPSA0XSA9IFwiaXNVbmljb2RlXCI7XG4gICAgQ09TTUVUSUNTX01BU0tbQ09TTUVUSUNTX01BU0tbXCJpc0NsYXNzU2VsZWN0b3JcIl0gPSA4XSA9IFwiaXNDbGFzc1NlbGVjdG9yXCI7XG4gICAgQ09TTUVUSUNTX01BU0tbQ09TTUVUSUNTX01BU0tbXCJpc0lkU2VsZWN0b3JcIl0gPSAxNl0gPSBcImlzSWRTZWxlY3RvclwiO1xuICAgIENPU01FVElDU19NQVNLW0NPU01FVElDU19NQVNLW1wiaXNIcmVmU2VsZWN0b3JcIl0gPSAzMl0gPSBcImlzSHJlZlNlbGVjdG9yXCI7XG4gICAgQ09TTUVUSUNTX01BU0tbQ09TTUVUSUNTX01BU0tbXCJyZW1vdmVcIl0gPSA2NF0gPSBcInJlbW92ZVwiO1xuICAgIENPU01FVElDU19NQVNLW0NPU01FVElDU19NQVNLW1wiZXh0ZW5kZWRcIl0gPSAxMjhdID0gXCJleHRlbmRlZFwiO1xufSkoQ09TTUVUSUNTX01BU0sgfHwgKENPU01FVElDU19NQVNLID0ge30pKTtcbmNvbnN0IEhBU0hfRE9NQUlOU19NQVJLRVJfTE9XID0gMTtcbmNvbnN0IEhBU0hfRE9NQUlOU19NQVJLRVJfSElHSCA9IDI1MztcbmZ1bmN0aW9uIGNvbXB1dGVGaWx0ZXJJZChtYXNrLCBzZWxlY3RvciwgZG9tYWlucywgcGFyZW50RG9tYWlucywgc3R5bGUpIHtcbiAgICBsZXQgaGFzaCA9IChIQVNIX1NFRUQgKiBIQVNIX0lOVEVSTkFMX01VTFQpIF4gbWFzaztcbiAgICBpZiAoc2VsZWN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdG9yLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBoYXNoID0gKGhhc2ggKiBIQVNIX0lOVEVSTkFMX01VTFQpIF4gc2VsZWN0b3IuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZG9tYWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhhc2ggPSAoaGFzaCAqIEhBU0hfSU5URVJOQUxfTVVMVCkgXiBIQVNIX0RPTUFJTlNfTUFSS0VSX0xPVztcbiAgICAgICAgaGFzaCA9IGRvbWFpbnMudXBkYXRlSWQoaGFzaCk7XG4gICAgfVxuICAgIGlmIChwYXJlbnREb21haW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGFzaCA9IChoYXNoICogSEFTSF9JTlRFUk5BTF9NVUxUKSBeIEhBU0hfRE9NQUlOU19NQVJLRVJfSElHSDtcbiAgICAgICAgaGFzaCA9IHBhcmVudERvbWFpbnMudXBkYXRlSWQoaGFzaCk7XG4gICAgfVxuICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3R5bGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGhhc2ggPSAoaGFzaCAqIEhBU0hfSU5URVJOQUxfTVVMVCkgXiBzdHlsZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNoID4+PiAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdG9yKGZpbHRlciwgZ2V0U2NyaXB0bGV0Q2Fub25pY2FsTmFtZSkge1xuICAgIGxldCBzZWxlY3RvciA9IGZpbHRlci5nZXRTZWxlY3RvcigpO1xuICAgIGlmIChmaWx0ZXIuc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxlY3RvciArPSBmaWx0ZXIuc3R5bGU7XG4gICAgfVxuICAgIGlmIChmaWx0ZXIuaXNTY3JpcHRJbmplY3QoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWQgPSBmaWx0ZXIucGFyc2VTY3JpcHQoKTtcbiAgICBpZiAocGFyc2VkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgIH1cbiAgICBjb25zdCBjYW5vbmljYWxOYW1lID0gZ2V0U2NyaXB0bGV0Q2Fub25pY2FsTmFtZShwYXJzZWQubmFtZSk7XG4gICAgaWYgKGNhbm9uaWNhbE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKHBhcnNlZC5uYW1lLCBjYW5vbmljYWxOYW1lKTtcbn1cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3NtZXRpYyBmaWx0ZXJzIHBhcnNpbmdcbiAqICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29zbWV0aWNGaWx0ZXIge1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgbGluZSB0aGF0IHdlIGtub3cgY29udGFpbnMgYSBjb3NtZXRpYyBmaWx0ZXIsIGNyZWF0ZSBhIENvc21ldGljRmlsZXJcbiAgICAgKiBpbnN0YW5jZSBvdXQgb2YgaXQuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlICp2ZXJ5KiBlZmZpY2llbnQsIGFzIGl0IHdpbGwgYmVcbiAgICAgKiB1c2VkIHRvIHBhcnNlIHRlbnMgb2YgdGhvdXNhbmRzIG9mIGxpbmVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZShsaW5lLCBkZWJ1ZyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHJhd0xpbmUgPSBsaW5lO1xuICAgICAgICAvLyBNYXNrIHRvIHN0b3JlIGF0dHJpYnV0ZXMuIEVhY2ggZmxhZyAodW5oaWRlLCBzY3JpcHRJbmplY3QsIGV0Yy4pIHRha2VzXG4gICAgICAgIC8vIG9ubHkgMSBiaXQgYXQgYSBzcGVjaWZpYyBvZmZzZXQgZGVmaW5lZCBpbiBDT1NNRVRJQ1NfTUFTSy5cbiAgICAgICAgLy8gY2Y6IENPU01FVElDU19NQVNLIGZvciB0aGUgb2Zmc2V0IG9mIGVhY2ggcHJvcGVydHlcbiAgICAgICAgbGV0IG1hc2sgPSAwO1xuICAgICAgICBsZXQgc2VsZWN0b3I7XG4gICAgICAgIGxldCBkb21haW5zO1xuICAgICAgICBsZXQgcGFyZW50RG9tYWlucztcbiAgICAgICAgbGV0IHN0eWxlO1xuICAgICAgICBjb25zdCBzaGFycEluZGV4ID0gbGluZS5pbmRleE9mKCcjJyk7XG4gICAgICAgIC8vIFN0YXJ0IHBhcnNpbmcgdGhlIGxpbmVcbiAgICAgICAgY29uc3QgYWZ0ZXJTaGFycEluZGV4ID0gc2hhcnBJbmRleCArIDE7XG4gICAgICAgIGxldCBzdWZmaXhTdGFydEluZGV4ID0gYWZ0ZXJTaGFycEluZGV4ICsgMTtcbiAgICAgICAgLy8gaG9zdG5hbWUxLGhvc3RuYW1lMiM/Iy5zZWxlY3RvclxuICAgICAgICAvLyBob3N0bmFtZTEsaG9zdG5hbWUyI0AjLnNlbGVjdG9yXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBeXiBeXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICB8fCB8XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICB8fCBzdWZmaXhTdGFydEluZGV4XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICB8YWZ0ZXJTaGFycEluZGV4XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBzaGFycEluZGV4XG4gICAgICAgIC8vIENoZWNrIGlmIHVuaGlkZVxuICAgICAgICBpZiAobGluZS5sZW5ndGggPiBhZnRlclNoYXJwSW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChsaW5lW2FmdGVyU2hhcnBJbmRleF0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgIG1hc2sgPSBzZXRCaXQobWFzaywgQ09TTUVUSUNTX01BU0sudW5oaWRlKTtcbiAgICAgICAgICAgICAgICBzdWZmaXhTdGFydEluZGV4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsaW5lW2FmdGVyU2hhcnBJbmRleF0gPT09ICc/Jykge1xuICAgICAgICAgICAgICAgIHN1ZmZpeFN0YXJ0SW5kZXggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VmZml4U3RhcnRJbmRleCA+PSBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2UgaG9zdG5hbWVzIGFuZCBlbnRpdGl0ZXMgYXMgd2VsbCBhcyB0aGVpciBuZWdhdGlvbnMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIC0gfmhvc3RuYW1lIyMuc2VsZWN0b3JcbiAgICAgICAgLy8gLSBob3N0bmFtZSMjLnNlbGVjdG9yXG4gICAgICAgIC8vIC0gaG9zdG5hbWU+PiMjLnNlbGVjdG9yXG4gICAgICAgIC8vIC0gZW50aXR5LiojIy5zZWxlY3RvclxuICAgICAgICAvLyAtIH5lbnRpdHkuKiMjLnNlbGVjdG9yXG4gICAgICAgIC8vIC0gZW50aXR5Pj4jIy5zZWxlY3RvclxuICAgICAgICAvL1xuICAgICAgICAvLyBFYWNoIGtpbmQgd2lsbCBoYXZlIGl0cyBvd24gVWludDMyQXJyYXkgY29udGFpbmluZyBoYXNoZXMsIHNvcnRlZCBieVxuICAgICAgICAvLyBudW1iZXIgb2YgbGFiZWxzIGNvbnNpZGVyZWQuIFRoaXMgYWxsb3dzIGEgY29tcGFjdCByZXByZXNlbnRhdGlvbiBvZlxuICAgICAgICAvLyBob3N0bmFtZXMgYW5kIGZhc3QgbWF0Y2hpbmcgd2l0aG91dCBhbnkgc3RyaW5nIGNvcHkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGA+PmAgc3VmZml4IGlzIHJlc3BvbnNpYmxlIGZvciB0YXJnZXRpbmcgc3ViZnJhbWUgb2YgdGhlIGdpdmVuIGRvbWFpbi5cbiAgICAgICAgLy8gSXQgaXMgdGhlIHBhcnQgb2YgZWFjaCBkb21haW4gZW50cnkgYW5kIGRvbWFpbnMgY2FuIGhhdmUgYSBtaXggb2ZcbiAgICAgICAgLy8gaG9zdG5hbWVzIGFuZCBzdWJmcmFtZSB0YXJnZXRpbmcgaG9zdG5hbWVzIChhbHNvIGVudHJpZXMpLlxuICAgICAgICBpZiAoc2hhcnBJbmRleCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGRvbWFpbkVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudERvbWFpbkVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgbGluZS5zbGljZSgwLCBzaGFycEluZGV4KS5zcGxpdCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gZWFjaCBkb21haW4gZW50cnkgY2FuIGhhdmUgYD4+YCBzdWZmaXguXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmVuZHNXaXRoKCc+PicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudERvbWFpbkVudHJpZXMucHVzaChlbnRyeS5zbGljZSgwLCAtMikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluRW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9tYWluRW50cmllcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBkb21haW5zID0gRG9tYWlucy5wYXJzZShkb21haW5FbnRyaWVzLmpvaW4oJywnKSwge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnREb21haW5FbnRyaWVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHBhcmVudERvbWFpbnMgPSBEb21haW5zLnBhcnNlKHBhcmVudERvbWFpbkVudHJpZXMuam9pbignLCcpLCB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lLmVuZHNXaXRoKCc6cmVtb3ZlKCknKSkge1xuICAgICAgICAgICAgLy8gIyNzZWxlY3RvcjpyZW1vdmUoKVxuICAgICAgICAgICAgbWFzayA9IHNldEJpdChtYXNrLCBDT1NNRVRJQ1NfTUFTSy5yZW1vdmUpO1xuICAgICAgICAgICAgbWFzayA9IHNldEJpdChtYXNrLCBDT1NNRVRJQ1NfTUFTSy5leHRlbmRlZCk7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCAtOSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGluZS5sZW5ndGggLSBzdWZmaXhTdGFydEluZGV4ID49IDggJiZcbiAgICAgICAgICAgIGxpbmUuZW5kc1dpdGgoJyknKSAmJlxuICAgICAgICAgICAgbGluZS5pbmRleE9mKCc6c3R5bGUoJywgc3VmZml4U3RhcnRJbmRleCkgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyAjI3NlbGVjdG9yOnN0eWxlKC4uLilcbiAgICAgICAgICAgIGNvbnN0IGluZGV4T2ZTdHlsZSA9IGxpbmUuaW5kZXhPZignOnN0eWxlKCcsIHN1ZmZpeFN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgc3R5bGUgPSBsaW5lLnNsaWNlKGluZGV4T2ZTdHlsZSArIDcsIC0xKTtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIGluZGV4T2ZTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVhbCB3aXRoIEhUTUwgZmlsdGVyc1xuICAgICAgICBpZiAobGluZS5jaGFyQ29kZUF0KHN1ZmZpeFN0YXJ0SW5kZXgpID09PSA5NCAvKiAnXicgKi8pIHtcbiAgICAgICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ3NjcmlwdDpoYXMtdGV4dCgnLCBzdWZmaXhTdGFydEluZGV4ICsgMSkgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgbGluZS5jaGFyQ29kZUF0KGxpbmUubGVuZ3RoIC0gMSkgIT09IDQxIC8qICcpJyAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URTogY3VycmVudGx5IG9ubHkgXnNjcmlwdDpoYXMtdGV4dCguLi4pIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgIF5zY3JpcHQ6aGFzLXRleHQoc2VsZWN0b3IpXG4gICAgICAgICAgICAvLyAgIF4gICAgICAgICAgICAgICAgICAgICAgICAgXlxuICAgICAgICAgICAgLy8gICB8ICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgIC8vICAgfCAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAvLyAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgbGluZS5sZW5ndGhcbiAgICAgICAgICAgIC8vICAgfFxuICAgICAgICAgICAgLy8gICBzdWZmaXhTdGFydEluZGV4XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBsaW5lLnNsaWNlKHN1ZmZpeFN0YXJ0SW5kZXgsIGxpbmUubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChleHRyYWN0SFRNTFNlbGVjdG9yRnJvbVJ1bGUoc2VsZWN0b3IpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaW5lLmxlbmd0aCAtIHN1ZmZpeFN0YXJ0SW5kZXggPiA0ICYmXG4gICAgICAgICAgICBsaW5lLmNoYXJDb2RlQXQoc3VmZml4U3RhcnRJbmRleCkgPT09IDQzIC8qICcrJyAqLyAmJlxuICAgICAgICAgICAgbGluZS5zdGFydHNXaXRoKCcranMoJywgc3VmZml4U3RhcnRJbmRleCkpIHtcbiAgICAgICAgICAgIC8vIEdlbmVyaWMgc2NyaXB0bGV0cyBhcmUgaW52YWxpZCwgdW5sZXNzIHRoZXkgYXJlIHVuLWhpZGVcbiAgICAgICAgICAgIGlmICgoZG9tYWlucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgKGRvbWFpbnMuaG9zdG5hbWVzID09PSB1bmRlZmluZWQgJiYgZG9tYWlucy5lbnRpdGllcyA9PT0gdW5kZWZpbmVkKSkgJiZcbiAgICAgICAgICAgICAgICAocGFyZW50RG9tYWlucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIChwYXJlbnREb21haW5zLmhvc3RuYW1lcyA9PT0gdW5kZWZpbmVkICYmIHBhcmVudERvbWFpbnMuZW50aXRpZXMgPT09IHVuZGVmaW5lZCkpICYmXG4gICAgICAgICAgICAgICAgZ2V0Qml0KG1hc2ssIENPU01FVElDU19NQVNLLnVuaGlkZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXNrID0gc2V0Qml0KG1hc2ssIENPU01FVElDU19NQVNLLnNjcmlwdEluamVjdCk7XG4gICAgICAgICAgICBzZWxlY3RvciA9IGxpbmUuc2xpY2Uoc3VmZml4U3RhcnRJbmRleCArIDQsIGxpbmUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAvLyBBbiBlbXB0eSBzY3JpcHRsZXQgKGkuZS4gJytqcygpJykgY2FuIGJlIHNwZWNpZmllZCB0byBjYW5jZWwgaW5qZWN0aW9uc1xuICAgICAgICAgICAgLy8gb24gYSBzcGVjaWZpYyBkb21haW4gb3IgZ2xvYmFsbHkuIEl0IGRvZXMgbm90IG1ha2Ugc2Vuc2UgdGhvdWdoIHRvIGhhdmVcbiAgICAgICAgICAgIC8vIGFuIGVtcHR5IHNjcmlwdGxldCB3aXRob3V0IGFuIGV4Y2VwdGlvbiAoaS5lLiAnI0AjJyBpcyBtYW5kYXRvcnkpLlxuICAgICAgICAgICAgaWYgKGdldEJpdChtYXNrLCBDT1NNRVRJQ1NfTUFTSy51bmhpZGUpID09PSBmYWxzZSAmJiBzZWxlY3Rvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gbGluZS5zbGljZShzdWZmaXhTdGFydEluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yVHlwZSA9IGNsYXNzaWZ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yVHlwZSA9PT0gU2VsZWN0b3JUeXBlLkV4dGVuZGVkKSB7XG4gICAgICAgICAgICAgICAgbWFzayA9IHNldEJpdChtYXNrLCBDT1NNRVRJQ1NfTUFTSy5leHRlbmRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3RvclR5cGUgPT09IFNlbGVjdG9yVHlwZS5JbnZhbGlkIHx8ICFpc1ZhbGlkQ3NzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQnLCBsaW5lKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIC0gbWF5YmUgcGVyZm9ybSBgaXNWYWxpZENzc2AgZnJvbSB0aGUgb3RoZXIgbW9kdWxlLlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN1YmZyYW1lIHRhcmdldCBpcyBvbmx5IGF2YWlsYWJsZSB0byBzY3JpcHRsZXRzLlxuICAgICAgICBpZiAocGFyZW50RG9tYWlucyAhPT0gdW5kZWZpbmVkICYmIGdldEJpdChtYXNrLCBDT1NNRVRJQ1NfTUFTSy5zY3JpcHRJbmplY3QpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXh0ZW5kZWQgc2VsZWN0b3JzIHNob3VsZCBhbHdheXMgYmUgc3BlY2lmaWMgdG8gc29tZSBkb21haW4uXG4gICAgICAgIGlmIChkb21haW5zID09PSB1bmRlZmluZWQgJiYgZ2V0Qml0KG1hc2ssIENPU01FVElDU19NQVNLLmV4dGVuZGVkKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHVuaWNvZGUgYXBwZWFycyBpbiBzZWxlY3RvclxuICAgICAgICAgICAgaWYgKGhhc1VuaWNvZGUoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgbWFzayA9IHNldEJpdChtYXNrLCBDT1NNRVRJQ1NfTUFTSy5pc1VuaWNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xhc3NpZnkgc2VsZWN0b3JcbiAgICAgICAgICAgIGlmIChnZXRCaXQobWFzaywgQ09TTUVUSUNTX01BU0suc2NyaXB0SW5qZWN0KSA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICBnZXRCaXQobWFzaywgQ09TTUVUSUNTX01BU0sucmVtb3ZlKSA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICBnZXRCaXQobWFzaywgQ09TTUVUSUNTX01BU0suZXh0ZW5kZWQpID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgIHNlbGVjdG9yLnN0YXJ0c1dpdGgoJ14nKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjMCA9IHNlbGVjdG9yLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYzEgPSBzZWxlY3Rvci5jaGFyQ29kZUF0KDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGMyID0gc2VsZWN0b3IuY2hhckNvZGVBdCgyKTtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgc3BlY2lmaWMgY2FzZSBvZiBzaW1wbGUgc2VsZWN0b3IgKGlkLCBjbGFzcyBvclxuICAgICAgICAgICAgICAgIC8vIGhyZWYpIFRoZXNlIGFyZSB0aGUgbW9zdCBjb21tb24gZmlsdGVycyBhbmQgd2lsbCBiZW5lZml0IGdyZWF0bHkgZnJvbVxuICAgICAgICAgICAgICAgIC8vIGEgY3VzdG9tIGRpc3BhdGNoIG1lY2hhbmlzbS5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0Qml0KG1hc2ssIENPU01FVElDU19NQVNLLnNjcmlwdEluamVjdCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjMCA9PT0gNDYgLyogJy4nICovICYmIGlzU2ltcGxlU2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrID0gc2V0Qml0KG1hc2ssIENPU01FVElDU19NQVNLLmlzQ2xhc3NTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYzAgPT09IDM1IC8qICcjJyAqLyAmJiBpc1NpbXBsZVNlbGVjdG9yKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzayA9IHNldEJpdChtYXNrLCBDT1NNRVRJQ1NfTUFTSy5pc0lkU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMwID09PSA5NyAvKiBhICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjMSA9PT0gOTEgLyogJ1snICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjMiA9PT0gMTA0IC8qICdoJyAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTaW1wbGVIcmVmU2VsZWN0b3Ioc2VsZWN0b3IsIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrID0gc2V0Qml0KG1hc2ssIENPU01FVElDU19NQVNLLmlzSHJlZlNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjMCA9PT0gOTEgLyogJ1snICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjMSA9PT0gMTA0IC8qICdoJyAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTaW1wbGVIcmVmU2VsZWN0b3Ioc2VsZWN0b3IsIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrID0gc2V0Qml0KG1hc2ssIENPU01FVElDU19NQVNLLmlzSHJlZlNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvc21ldGljRmlsdGVyKHtcbiAgICAgICAgICAgIG1hc2ssXG4gICAgICAgICAgICByYXdMaW5lOiBkZWJ1ZyA9PT0gdHJ1ZSA/IHJhd0xpbmUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWxlY3RvcixcbiAgICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgICAgZG9tYWlucyxcbiAgICAgICAgICAgIHBhcmVudERvbWFpbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXNlcmlhbGl6ZSBjb3NtZXRpYyBmaWx0ZXJzLiBUaGUgY29kZSBhY2Nlc3NpbmcgdGhlIGJ1ZmZlciBzaG91bGQgYmVcbiAgICAgKiBzeW1ldHJpY2FsIHRvIHRoZSBvbmUgaW4gYHNlcmlhbGl6ZUNvc21ldGljRmlsdGVyYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IG1hc2sgPSBidWZmZXIuZ2V0VWludDE2KCk7XG4gICAgICAgIGNvbnN0IGlzVW5pY29kZSA9IGdldEJpdChtYXNrLCBDT1NNRVRJQ1NfTUFTSy5pc1VuaWNvZGUpO1xuICAgICAgICBjb25zdCBvcHRpb25hbFBhcnRzID0gYnVmZmVyLmdldFVpbnQ4KCk7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gaXNVbmljb2RlID8gYnVmZmVyLmdldFVURjgoKSA6IGJ1ZmZlci5nZXRDb3NtZXRpY1NlbGVjdG9yKCk7XG4gICAgICAgIC8vIFRoZSBvcmRlciBvZiB0aGVzZSBmaWVsZHMgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIHdoZW4gd2Ugc2VyaWFsaXplIHRoZW0uXG4gICAgICAgIHJldHVybiBuZXcgQ29zbWV0aWNGaWx0ZXIoe1xuICAgICAgICAgICAgLy8gTWFuZGF0b3J5IGZpZWxkc1xuICAgICAgICAgICAgbWFzayxcbiAgICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgICAgLy8gT3B0aW9uYWwgZmllbGRzXG4gICAgICAgICAgICBkb21haW5zOiAob3B0aW9uYWxQYXJ0cyAmIDEpID09PSAxID8gRG9tYWlucy5kZXNlcmlhbGl6ZShidWZmZXIpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmF3TGluZTogKG9wdGlvbmFsUGFydHMgJiAyKSA9PT0gMiA/IGJ1ZmZlci5nZXRSYXdDb3NtZXRpYygpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3R5bGU6IChvcHRpb25hbFBhcnRzICYgNCkgPT09IDQgPyBidWZmZXIuZ2V0QVNDSUkoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBhcmVudERvbWFpbnM6IChvcHRpb25hbFBhcnRzICYgOCkgPT09IDggPyBEb21haW5zLmRlc2VyaWFsaXplKGJ1ZmZlcikgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IG1hc2ssIHNlbGVjdG9yLCBkb21haW5zLCByYXdMaW5lLCBzdHlsZSwgcGFyZW50RG9tYWlucywgfSkge1xuICAgICAgICB0aGlzLm1hc2sgPSBtYXNrO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZG9tYWlucyA9IGRvbWFpbnM7XG4gICAgICAgIHRoaXMucGFyZW50RG9tYWlucyA9IHBhcmVudERvbWFpbnM7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgdGhpcy5pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yYXdMaW5lID0gcmF3TGluZTtcbiAgICAgICAgdGhpcy5zY3JpcHRsZXREZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpc0Nvc21ldGljRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaXNOZXR3b3JrRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmb3JtYXQgb2YgYSBjb3NtZXRpYyBmaWx0ZXIgaXM6XG4gICAgICpcbiAgICAgKiB8IG1hc2sgfCBzZWxlY3RvciBsZW5ndGggfCBzZWxlY3Rvci4uLiB8IGhvc3RuYW1lcyBsZW5ndGggfCBob3N0bmFtZXMuLi5cbiAgICAgKiAgIDMyICAgICAxNiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE2XG4gICAgICpcbiAgICAgKiBUaGUgaGVhZGVyIChtYXNrKSBpcyAzMiBiaXRzLCB0aGVuIHdlIGhhdmUgYSB0b3RhbCBvZiAzMiBiaXRzIHRvIHN0b3JlIHRoZVxuICAgICAqIGxlbmd0aCBvZiBgc2VsZWN0b3JgIGFuZCBgaG9zdG5hbWVzYCAoMTYgYml0cyBlYWNoKS5cbiAgICAgKlxuICAgICAqIEltcHJvdmVtZW50cyBzaW1pbGFyIHRvIHRoZSBvbmNlcyBtZW50aW9uZWQgaW4gYHNlcmlhbGl6ZU5ldHdvcmtGaWx0ZXJzYFxuICAgICAqIGNvdWxkIGJlIGFwcGxpZWQgaGVyZSwgdG8gZ2V0IGEgbW9yZSBjb21wYWN0IHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZShidWZmZXIpIHtcbiAgICAgICAgLy8gTWFuZGF0b3J5IGZpZWxkc1xuICAgICAgICBidWZmZXIucHVzaFVpbnQxNih0aGlzLm1hc2spO1xuICAgICAgICBjb25zdCBpbmRleCA9IGJ1ZmZlci5nZXRQb3MoKTtcbiAgICAgICAgYnVmZmVyLnB1c2hVaW50OCgwKTtcbiAgICAgICAgaWYgKHRoaXMuaXNVbmljb2RlKCkpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoVVRGOCh0aGlzLnNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoQ29zbWV0aWNTZWxlY3Rvcih0aGlzLnNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGJpdC1tYXNrIGluZGljYXRlcyB3aGljaCBvcHRpb25hbCBwYXJ0cyBvZiB0aGUgZmlsdGVyIHdlcmUgc2VyaWFsaXplZC5cbiAgICAgICAgbGV0IG9wdGlvbmFsUGFydHMgPSAwO1xuICAgICAgICBpZiAodGhpcy5kb21haW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbmFsUGFydHMgfD0gMTtcbiAgICAgICAgICAgIHRoaXMuZG9tYWlucy5zZXJpYWxpemUoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yYXdMaW5lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbmFsUGFydHMgfD0gMjtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoUmF3Q29zbWV0aWModGhpcy5yYXdMaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25hbFBhcnRzIHw9IDQ7XG4gICAgICAgICAgICBidWZmZXIucHVzaEFTQ0lJKHRoaXMuc3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudERvbWFpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9uYWxQYXJ0cyB8PSA4O1xuICAgICAgICAgICAgdGhpcy5wYXJlbnREb21haW5zLnNlcmlhbGl6ZShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5zZXRCeXRlKGluZGV4LCBvcHRpb25hbFBhcnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGVzdGltYXRpb24gb2YgdGhlIHNpemUgKGluIGJ5dGVzKSBuZWVkZWQgdG8gcGVyc2lzdCB0aGlzIGZpbHRlclxuICAgICAqIGluIGEgRGF0YVZpZXcuIFRoaXMgZG9lcyBub3QgbmVlZCB0byBiZSAxMDAlIGFjY3VyYXRlIGJ1dCBzaG91bGQgYmUgYW5cbiAgICAgKiB1cHBlci1ib3VuZC4gSXQgc2hvdWxkIGFsc28gYmUgYXMgZmFzdCBhcyBwb3NzaWJsZS5cbiAgICAgKi9cbiAgICBnZXRTZXJpYWxpemVkU2l6ZShjb21wcmVzc2lvbikge1xuICAgICAgICBsZXQgZXN0aW1hdGUgPSAyICsgMTsgLy8gbWFzayAoMiBieXRlKSArIG9wdGlvbmFsIHBhcnRzICgxIGJ5dGUpXG4gICAgICAgIGlmICh0aGlzLmlzVW5pY29kZSgpKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZSArPSBzaXplT2ZVVEY4KHRoaXMuc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXN0aW1hdGUgKz0gc2l6ZU9mQ29zbWV0aWNTZWxlY3Rvcih0aGlzLnNlbGVjdG9yLCBjb21wcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZG9tYWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZSArPSB0aGlzLmRvbWFpbnMuZ2V0U2VyaWFsaXplZFNpemUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJlbnREb21haW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVzdGltYXRlICs9IHRoaXMucGFyZW50RG9tYWlucy5nZXRTZXJpYWxpemVkU2l6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJhd0xpbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXN0aW1hdGUgKz0gc2l6ZU9mUmF3Q29zbWV0aWModGhpcy5yYXdMaW5lLCBjb21wcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXN0aW1hdGUgKz0gc2l6ZU9mQVNDSUkodGhpcy5zdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVzdGltYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBtb3JlIGh1bWFuLXJlYWRhYmxlIHZlcnNpb24gb2YgdGhpcyBmaWx0ZXIuIEl0IGlzIG1haW5seSB1c2VkIGZvclxuICAgICAqIGRlYnVnZ2luZyBwdXJwb3NlLCBhcyBpdCB3aWxsIGV4cGFuZCB0aGUgdmFsdWVzIHN0b3JlZCBpbiB0aGUgYml0IG1hc2suXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnJhd0xpbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3TGluZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmlsdGVyID0gJyc7XG4gICAgICAgIGlmICh0aGlzLmRvbWFpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tYWlucy5wYXJ0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyICs9IHRoaXMuZG9tYWlucy5wYXJ0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbHRlciArPSAnPGhvc3RuYW1lcz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudERvbWFpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tYWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyICs9ICcsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudERvbWFpbnMucGFydHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZpbHRlciArPSB0aGlzLnBhcmVudERvbWFpbnMucGFydHNcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KCcsJylcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgocGFydCkgPT4gcGFydCArICc+PicpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIgKz0gJzxob3N0bmFtZXM+Pj4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVW5oaWRlKCkpIHtcbiAgICAgICAgICAgIGZpbHRlciArPSAnI0AjJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbHRlciArPSAnIyMnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU2NyaXB0SW5qZWN0KCkpIHtcbiAgICAgICAgICAgIGZpbHRlciArPSAnK2pzKCc7XG4gICAgICAgICAgICBmaWx0ZXIgKz0gdGhpcy5zZWxlY3RvcjtcbiAgICAgICAgICAgIGZpbHRlciArPSAnKSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWx0ZXIgKz0gdGhpcy5zZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNDdXN0b21TdHlsZSgpKSB7XG4gICAgICAgICAgICBmaWx0ZXIgKz0gJzpzdHlsZSgnICsgdGhpcy5nZXRTdHlsZSgpICsgJyknO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfVxuICAgIG1hdGNoKGhvc3RuYW1lLCBkb21haW4sIGFuY2VzdG9ycykge1xuICAgICAgICAvLyBOb3QgY29uc3RyYWludCBvbiBob3N0bmFtZSwgbWF0Y2ggaXMgdHJ1ZVxuICAgICAgICBpZiAodGhpcy5oYXNIb3N0bmFtZUNvbnN0cmFpbnQoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIGBob3N0bmFtZWAgYXZhaWxhYmxlIGJ1dCB0aGlzIGZpbHRlciBoYXMgc29tZSBjb25zdHJhaW50cyBvbiBob3N0bmFtZS5cbiAgICAgICAgaWYgKCFob3N0bmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRvbWFpbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgLy8gVE9ETyAtIHRoaXMgaGFzaGluZyBjb3VsZCBiZSByZS11c2VkIGJldHdlZW4gY29zbWV0aWNzIGJ5IHVzaW5nIGFuXG4gICAgICAgICAgICAvLyBhYnN0cmFjdGlvbiBsaWtlIGBSZXF1ZXN0YCAoc2ltaWxhciB0byBuZXR3b3JrIGZpbHRlcnMgbWF0Y2hpbmcpLlxuICAgICAgICAgICAgLy8gTWF5YmUgY291bGQgd2UgcmV1c2UgYFJlcXVlc3RgIGRpcmVjdGx5IHdpdGhvdXQgYW55IGNoYW5nZT9cbiAgICAgICAgICAgIHRoaXMuZG9tYWlucy5tYXRjaChnZXRIb3N0bmFtZUhhc2hlc0Zyb21MYWJlbHNCYWNrd2FyZChob3N0bmFtZSwgZG9tYWluKSwgZ2V0RW50aXR5SGFzaGVzRnJvbUxhYmVsc0JhY2t3YXJkKGhvc3RuYW1lLCBkb21haW4pKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuY2VzdG9ycyAhPT0gdW5kZWZpbmVkICYmIHRoaXMucGFyZW50RG9tYWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgaG9zdG5hbWUsIGRvbWFpbiB9IG9mIGFuY2VzdG9ycykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudERvbWFpbnMubWF0Y2goaG9zdG5hbWUubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgICAgID8gRU1QVFlfVUlOVDMyX0FSUkFZXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0SG9zdG5hbWVIYXNoZXNGcm9tTGFiZWxzQmFja3dhcmQoaG9zdG5hbWUsIGRvbWFpbiksIGhvc3RuYW1lLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICA/IEVNUFRZX1VJTlQzMl9BUlJBWVxuICAgICAgICAgICAgICAgICAgICA6IGdldEVudGl0eUhhc2hlc0Zyb21MYWJlbHNCYWNrd2FyZChob3N0bmFtZSwgZG9tYWluKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRva2VucyBmb3IgdGhpcyBmaWx0ZXIuIEl0IGNhbiBiZSBpbmRleGVkIG11bHRpcGxlIHRpbWVzIGlmIG11bHRpcGxlXG4gICAgICogaG9zdG5hbWVzIGFyZSBzcGVjaWZpZWQgKGUuZy46IGhvc3QxLGhvc3QyIyMuc2VsZWN0b3IpLlxuICAgICAqL1xuICAgIGdldFRva2VucygpIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICAgIC8vIE5vdGUsIHdlIGRvIG5vdCBuZWVkIHRvIHVzZSBuZWdhdGVkIGRvbWFpbnMgb3IgZW50aXRpZXMgYXMgdG9rZW5zIGhlcmVcbiAgICAgICAgLy8gc2luY2UgdGhleSB3aWxsIGJ5IGRlZmluaXRpb24gbm90IG1hdGNoIG9uIHRoZWlyIG93biwgdW5sZXNzIGFjY29tcGFuaWVkXG4gICAgICAgIC8vIGJ5IGEgZG9tYWluIG9yIGVudGl0eS4gSW5zdGVhZCwgdGhleSBhcmUgaGFuZGxlZCBpblxuICAgICAgICAvLyBgQ29zbWV0aWNGaWx0ZXJCdWNrZXQuZ2V0Q29zbWV0aWNzRmlsdGVycyguLi4pYC5cbiAgICAgICAgaWYgKHRoaXMuZG9tYWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IGhvc3RuYW1lcywgZW50aXRpZXMgfSA9IHRoaXMuZG9tYWlucztcbiAgICAgICAgICAgIGlmIChob3N0bmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaG9zdG5hbWUgb2YgaG9zdG5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKG5ldyBVaW50MzJBcnJheShbaG9zdG5hbWVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaChuZXcgVWludDMyQXJyYXkoW2VudGl0eV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50RG9tYWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IGhvc3RuYW1lcywgZW50aXRpZXMgfSA9IHRoaXMucGFyZW50RG9tYWlucztcbiAgICAgICAgICAgIGlmIChob3N0bmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaG9zdG5hbWUgb2YgaG9zdG5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKG5ldyBVaW50MzJBcnJheShbaG9zdG5hbWVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGl0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaChuZXcgVWludDMyQXJyYXkoW2VudGl0eV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGVyZSB3ZSBvbmx5IHRha2Ugc2VsZWN0b3IgaW50byBhY2NvdW50IGlmIHRoZSBmaWx0ZXIgaXMgbm90IHVuSGlkZS5cbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgJiYgdGhpcy5pc1VuaGlkZSgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJZFNlbGVjdG9yKCkgfHwgdGhpcy5pc0NsYXNzU2VsZWN0b3IoKSkge1xuICAgICAgICAgICAgICAgIC8vIEhlcmUgd2UgdHJ5IHRvIGlkZW50aWZ5IHRoZSBlbmQgb2Ygc2VsZWN0b3Igc2kgdGhhdCB3ZSBjYW4gZXh0cmFjdCBhXG4gICAgICAgICAgICAgICAgLy8gdmFsaWQgdG9rZW4gb3V0IG9mIGl0LiBJbiBhbGwgdGhlc2UgZXhhbXBsZXMsICdzZWxlY3RvcicgaXMgb3VyXG4gICAgICAgICAgICAgICAgLy8gdG9rZW46XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgIC5zZWxlY3RvclsuLi5dXG4gICAgICAgICAgICAgICAgLy8gICAjc2VsZWN0b3JbLi4uXVxuICAgICAgICAgICAgICAgIC8vICAgI3NlbGVjdG9yIH4gZm9vXG4gICAgICAgICAgICAgICAgLy8gICAuc2VsZWN0b3I6bm90KC4uLilcbiAgICAgICAgICAgICAgICAvLyAgIC5zZWxlY3Rvci5mb29cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFdlIG5vdyB0cnkgdG8gaWRlbnRpZnkgdGhlIGZpcnN0IHZhbGlkIGVuZCBvZiBzZWxlY3RvciB3aGljaCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gYWxzbyBiZSB0aGUgZW5kIG9mIG91ciB0b2tlbjogc3BhY2UsIGJyYWNrZXQsIGNvbG9uLCBkb3QuXG4gICAgICAgICAgICAgICAgbGV0IGVuZE9mU2VsZWN0b3IgPSAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcbiAgICAgICAgICAgICAgICBmb3IgKDsgZW5kT2ZTZWxlY3RvciA8IHNlbGVjdG9yLmxlbmd0aDsgZW5kT2ZTZWxlY3RvciArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBzZWxlY3Rvci5jaGFyQ29kZUF0KGVuZE9mU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gMzIgLyogJyAnICovIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID09PSA0NiAvKiAnLicgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPT09IDU4IC8qICc6JyAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9PT0gOTEgLyogJ1snICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDMyQXJyYXkoMSk7XG4gICAgICAgICAgICAgICAgYXJyWzBdID0gZmFzdEhhc2hCZXR3ZWVuKHNlbGVjdG9yLCAxLCBlbmRPZlNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaChhcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0hyZWZTZWxlY3RvcigpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSB0aGlzLmdldFNlbGVjdG9yKCk7XG4gICAgICAgICAgICAgICAgLy8gTG9jYXRlICdocmVmJyBpbiBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGxldCBocmVmSW5kZXggPSBzZWxlY3Rvci5pbmRleE9mKCdocmVmJyk7XG4gICAgICAgICAgICAgICAgaWYgKGhyZWZJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVNUFRZX1RPS0VOUztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaHJlZkluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgLy8gVG9rZW5pemUgb3B0aW1hbGx5IGRlcGVuZGluZyBvbiB0aGUga2luZCBvZiBzZWxlY3RvcjogJ2hyZWY9JyxcbiAgICAgICAgICAgICAgICAvLyAnaHJlZio9JywgJ2hyZWZePScuXG4gICAgICAgICAgICAgICAgbGV0IHNraXBGaXJzdFRva2VuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IHNraXBMYXN0VG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvci5jaGFyQ29kZUF0KGhyZWZJbmRleCkgPT09IDQyIC8qICcqJyAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwOiAnKidcbiAgICAgICAgICAgICAgICAgICAgc2tpcEZpcnN0VG9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBocmVmSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsZWN0b3IuY2hhckNvZGVBdChocmVmSW5kZXgpID09PSA5NCAvKiAnXicgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcDogJ14nXG4gICAgICAgICAgICAgICAgICAgIGhyZWZJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcExhc3RUb2tlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBocmVmSW5kZXggKz0gMjsgLy8gc2tpcDogICc9XCInXG4gICAgICAgICAgICAgICAgLy8gTG9jYXRlIGVuZCBvZiBocmVmXG4gICAgICAgICAgICAgICAgY29uc3QgaHJlZkVuZCA9IHNlbGVjdG9yLmluZGV4T2YoJ1wiJywgaHJlZkluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoaHJlZkVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhhdCBjYW5ub3QgaGFwcGVuIHVubGVzcyB0aGUgZmlsdGVyIGlzIG5vdCB3ZWxsLWZvcm1lZC4gSW4gdGhpc1xuICAgICAgICAgICAgICAgICAgICAvLyBjYXNlLCB3ZSBqdXN0IHJldHVybiBubyB0b2tlbnMsIHdoaWNoIHdpbGwgcmVzdWx0IGluIHRoaXMgZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVuZGluZyB1cCBpbiB0aGUgXCJ3aWxkY2FyZFwiIGJ1Y2tldCBvZiB0aGUgaW5kZXguXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFTVBUWV9UT0tFTlM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuaXplKHRoaXMuc2VsZWN0b3Iuc2xpY2UoaHJlZkluZGV4LCBocmVmRW5kKSwgc2tpcEZpcnN0VG9rZW4sIHNraXBMYXN0VG9rZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX1RPS0VOUztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICBwYXJzZVNjcmlwdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NyaXB0bGV0RGV0YWlscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY3JpcHRsZXREZXRhaWxzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gdGhpcy5nZXRTZWxlY3RvcigpO1xuICAgICAgICBpZiAoc2VsZWN0b3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGxldCBsYXN0Q29tYUluZGV4ID0gLTE7XG4gICAgICAgIGxldCBpbkRvdWJsZVF1b3RlcyA9IGZhbHNlO1xuICAgICAgICBsZXQgaW5TaW5nbGVRdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgbGV0IGluQmFja3RpY2tzID0gZmFsc2U7XG4gICAgICAgIGxldCBpblJlZ2V4cCA9IGZhbHNlO1xuICAgICAgICBsZXQgb2JqZWN0TmVzdGluZyA9IDA7XG4gICAgICAgIGxldCBsYXN0Q2hhcklzQmFja3NsYXNoID0gZmFsc2U7XG4gICAgICAgIGxldCBpbkFyZ3VtZW50ID0gZmFsc2U7XG4gICAgICAgIGZvciAoOyBpbmRleCA8IHNlbGVjdG9yLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IHNlbGVjdG9yW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChsYXN0Q2hhcklzQmFja3NsYXNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbkRvdWJsZVF1b3RlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5Eb3VibGVRdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpblNpbmdsZVF1b3RlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluU2luZ2xlUXVvdGVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5CYWNrdGlja3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdgJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5CYWNrdGlja3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3ROZXN0aW5nICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdE5lc3RpbmcgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdE5lc3RpbmcgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkRvdWJsZVF1b3RlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluU2luZ2xlUXVvdGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnYCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQmFja3RpY2tzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpblJlZ2V4cCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpblJlZ2V4cCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5Bcmd1bWVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09ICdcIicgJiYgc2VsZWN0b3IuaW5kZXhPZignXCInLCBpbmRleCArIDEpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluRG91YmxlUXVvdGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IFwiJ1wiICYmIHNlbGVjdG9yLmluZGV4T2YoXCInXCIsIGluZGV4ICsgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5TaW5nbGVRdW90ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gJ2AnICYmIHNlbGVjdG9yLmluZGV4T2YoJ2AnLCBpbmRleCArIDEpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluQmFja3RpY2tzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09ICd7JyAmJiBzZWxlY3Rvci5pbmRleE9mKCd9JywgaW5kZXggKyAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3ROZXN0aW5nICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnLycgJiYgc2VsZWN0b3IuaW5kZXhPZignLycsIGluZGV4ICsgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5SZWdleHAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5Bcmd1bWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTcGxpdCBvbiBjb21tYSBvbmx5IGlmIG5vdCBpbnNpZGUgcXVvdGVzLCByZWdleHAsIGFuZCBub3QgZXNjYXBlZFxuICAgICAgICAgICAgaWYgKGxhc3RDaGFySXNCYWNrc2xhc2ggPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgY2hhciA9PT0gJywnICYmXG4gICAgICAgICAgICAgICAgaW5Eb3VibGVRdW90ZXMgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgaW5TaW5nbGVRdW90ZXMgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgaW5CYWNrdGlja3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgaW5SZWdleHAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChzZWxlY3Rvci5zbGljZShsYXN0Q29tYUluZGV4ICsgMSwgaW5kZXgpLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgbGFzdENvbWFJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGluQXJndW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RDaGFySXNCYWNrc2xhc2ggPSBjaGFyID09PSAnXFxcXCcgJiYgIWxhc3RDaGFySXNCYWNrc2xhc2g7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChzZWxlY3Rvci5zbGljZShsYXN0Q29tYUluZGV4ICsgMSkudHJpbSgpKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHBhcnRzXG4gICAgICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgICAgIC5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5pbmdDb2RlID0gcGFydC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgaWYgKCEob3BlbmluZ0NvZGUgPT09IDM5IC8qIGAnYCAqLyAmJiBwYXJ0LmVuZHNXaXRoKGAnYCkpICYmXG4gICAgICAgICAgICAgICAgIShvcGVuaW5nQ29kZSA9PT0gMzQgLyogYFwiYCAqLyAmJiBwYXJ0LmVuZHNXaXRoKGBcImApKSAmJlxuICAgICAgICAgICAgICAgICEob3BlbmluZ0NvZGUgPT09IDk2IC8qICdgJyAqLyAmJiBwYXJ0LmVuZHNXaXRoKCdgJykpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXNzdGhyb3VnaCBgcGFydGAgaWYgaXQgZW5kcyB3aXRoIGVzY2FwZWQgcXVvdGVcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQocGFydC5sZW5ndGggLSAyKSA9PT0gOTIgLyogJ1xcXFwnICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXNzdGhyb3VnaCBgcGFydGAgaWYgaXQgY29udGFpbnMgdW5lc2NhcGVkIHF1b3RlXG4gICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGkpID09PSBvcGVuaW5nQ29kZSAmJiBwYXJ0LmNoYXJDb2RlQXQoaSAtIDEpICE9PSA5MiAvKiAnXFxcXCcgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXNjYXBlZCA9IHBhcnQuc3Vic3RyaW5nKDEsIHBhcnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBpZiAob3BlbmluZ0NvZGUgPT09IDM5IC8qIGAnYCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVkLnJlcGxhY2UoUkVHRVhQX0VTQ0FQRURfU0lOR0xFX1FVT1RFLCBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcGVuaW5nQ29kZSA9PT0gMzQgLyogJ1wiJyAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVkLnJlcGxhY2UoUkVHRVhQX0VTQ0FQRURfRE9VQkxFX1FVT1RFLCAnXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlc2NhcGVkLnJlcGxhY2UoUkVHRVhQX0VTQ0FQRURfQkFDS1RJQ0ssICdgJyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc09iamVjdExpdGVyYWwgPSBwYXJ0LnN0YXJ0c1dpdGgoJ3snKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJ0XG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoUkVHRVhQX1VOSUNPREVfQ09NTUEsICcsJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZShSRUdFWFBfVU5JQ09ERV9CQUNLU0xBU0gsICdcXFxcJyk7XG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0TGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKFJFR0VYUF9FU0NBUEVEX0NPTU1BLCAnLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2NyaXB0bGV0RGV0YWlscyA9IHsgbmFtZTogcGFydHNbMF0sIGFyZ3MgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyaXB0bGV0RGV0YWlscztcbiAgICB9XG4gICAgZ2V0U2NyaXB0KGdldFNjcmlwdGxldCkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlU2NyaXB0KCk7XG4gICAgICAgIGlmIChwYXJzZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG5hbWUsIGFyZ3MgfSA9IHBhcnNlZDtcbiAgICAgICAgbGV0IHNjcmlwdCA9IGdldFNjcmlwdGxldChuYW1lKTtcbiAgICAgICAgaWYgKHNjcmlwdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc29tZSBjaGFyYWN0ZXJzIHNvIHRoZXkgd29udCBnZXQgZXZhbHVhdGVkIHdpdGggZXNjYXBlIGNoYXJhY3RlcnMgZHVyaW5nIHNjcmlwdCBpbmplY3Rpb25cbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2ldLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gc2NyaXB0LnJlcGxhY2UoYHt7JHtpICsgMX19fWAsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0O1xuICAgICAgICB9IC8vIFRPRE8gLSBlbHNlIHRocm93IGFuIGV4Y2VwdGlvbj9cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaGFzSG9zdG5hbWVDb25zdHJhaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb21haW5zICE9PSB1bmRlZmluZWQgfHwgdGhpcy5wYXJlbnREb21haW5zICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIGBoYXNTdWJmcmFtZUNvbnN0cmFpbnRgIGlzIG9ubHkgYHRydWVgIHdoZW4gdGhlIGZpbHRlciBpcyBzY3JpcHRsZXQuXG4gICAgLy8gT3RoZXIgY29zbWV0aWMgZmlsdGVycyB3aXRoIHN1YmZyYW1lIGNvbnN0cmFpbnQgd2lsbCBiZSByZWplY3RlZCBpbiB0aGUgcGFyc2UgdGltZS5cbiAgICBoYXNTdWJmcmFtZUNvbnN0cmFpbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudERvbWFpbnMgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0SWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBjb21wdXRlRmlsdGVySWQodGhpcy5tYXNrLCB0aGlzLnNlbGVjdG9yLCB0aGlzLmRvbWFpbnMsIHRoaXMucGFyZW50RG9tYWlucywgdGhpcy5zdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfVxuICAgIGhhc0N1c3RvbVN0eWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXRTdHlsZShkZWZhdWx0U3R5bGUgPSBERUZBVUxUX0hJRElOR19TVFlMRSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSB8fCBkZWZhdWx0U3R5bGU7XG4gICAgfVxuICAgIGdldFN0eWxlQXR0cmlidXRlSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIGBzJHtmYXN0SGFzaCh0aGlzLmdldFN0eWxlKCkpfWA7XG4gICAgfVxuICAgIGdldFNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RvcjtcbiAgICB9XG4gICAgZ2V0U2VsZWN0b3JBU1QoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUNzc1NlbGVjdG9yKHRoaXMuZ2V0U2VsZWN0b3IoKSk7XG4gICAgfVxuICAgIGdldEV4dGVuZGVkU2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBleHRyYWN0SFRNTFNlbGVjdG9yRnJvbVJ1bGUodGhpcy5zZWxlY3Rvcik7XG4gICAgfVxuICAgIGlzRXh0ZW5kZWQoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaXQodGhpcy5tYXNrLCBDT1NNRVRJQ1NfTUFTSy5leHRlbmRlZCk7XG4gICAgfVxuICAgIGlzUmVtb3ZlKCkge1xuICAgICAgICByZXR1cm4gZ2V0Qml0KHRoaXMubWFzaywgQ09TTUVUSUNTX01BU0sucmVtb3ZlKTtcbiAgICB9XG4gICAgaXNVbmhpZGUoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaXQodGhpcy5tYXNrLCBDT1NNRVRJQ1NfTUFTSy51bmhpZGUpO1xuICAgIH1cbiAgICBpc1NjcmlwdEluamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldEJpdCh0aGlzLm1hc2ssIENPU01FVElDU19NQVNLLnNjcmlwdEluamVjdCk7XG4gICAgfVxuICAgIGlzQ1NTKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NjcmlwdEluamVjdCgpID09PSBmYWxzZTtcbiAgICB9XG4gICAgaXNJZFNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gZ2V0Qml0KHRoaXMubWFzaywgQ09TTUVUSUNTX01BU0suaXNJZFNlbGVjdG9yKTtcbiAgICB9XG4gICAgaXNDbGFzc1NlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gZ2V0Qml0KHRoaXMubWFzaywgQ09TTUVUSUNTX01BU0suaXNDbGFzc1NlbGVjdG9yKTtcbiAgICB9XG4gICAgaXNIcmVmU2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaXQodGhpcy5tYXNrLCBDT1NNRVRJQ1NfTUFTSy5pc0hyZWZTZWxlY3Rvcik7XG4gICAgfVxuICAgIGlzVW5pY29kZSgpIHtcbiAgICAgICAgcmV0dXJuIGdldEJpdCh0aGlzLm1hc2ssIENPU01FVElDU19NQVNLLmlzVW5pY29kZSk7XG4gICAgfVxuICAgIGlzSHRtbEZpbHRlcmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0b3IoKS5zdGFydHNXaXRoKCdeJyk7XG4gICAgfVxuICAgIC8vIEEgZ2VuZXJpYyBoaWRlIGNvc21ldGljIGZpbHRlciBpcyBvbmUgdGhhdDpcbiAgICAvL1xuICAgIC8vICogRG8gbm90IGhhdmUgYSBkb21haW4gc3BlY2lmaWVkLiBcIkhpZGUgdGhpcyBlbGVtZW50IG9uIGFsbCBkb21haW5zXCJcbiAgICAvLyAqIEhhdmUgb25seSBkb21haW4gZXhjZXB0aW9ucyBzcGVjaWZpZWQuIFwiSGlkZSB0aGlzIGVsZW1lbnQgb24gYWxsIGRvbWFpbnMgZXhjZXB0IGV4YW1wbGUuY29tXCJcbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlOiB+ZXhhbXBsZS5jb20jIy5hZCAgaXMgYSBnZW5lcmljIGZpbHRlciBhcyB3ZWxsIVxuICAgIGlzR2VuZXJpY0hpZGUoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgcmV0dXJuICgoKF9hID0gdGhpcyA9PT0gbnVsbCB8fCB0aGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aGlzLmRvbWFpbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ob3N0bmFtZXMpID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICgoX2IgPSB0aGlzID09PSBudWxsIHx8IHRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRoaXMuZG9tYWlucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVudGl0aWVzKSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoKF9jID0gdGhpcyA9PT0gbnVsbCB8fCB0aGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aGlzLnBhcmVudERvbWFpbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5ob3N0bmFtZXMpID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICgoX2QgPSB0aGlzID09PSBudWxsIHx8IHRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRoaXMucGFyZW50RG9tYWlucykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmVudGl0aWVzKSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3NtZXRpYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/cosmetic.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/dsl.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/filters/dsl.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   block: () => (/* binding */ block),\n/* harmony export */   hide: () => (/* binding */ hide)\n/* harmony export */ });\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nclass HidingBuilder {\n}\nclass NetworkBuilder {\n    constructor() {\n        this.options = new Set();\n        this.prefix = undefined;\n        this.infix = undefined;\n        this.suffix = undefined;\n        this.redirect = undefined;\n    }\n    blockRequestsWithType(t) {\n        if (this.options.has(t)) {\n            throw new Error(`Already blocking type ${t}`);\n        }\n        this.options.add(t);\n        return this;\n    }\n    images() {\n        return this.blockRequestsWithType('image');\n    }\n    scripts() {\n        return this.blockRequestsWithType('script');\n    }\n    frames() {\n        return this.blockRequestsWithType('frame');\n    }\n    fonts() {\n        return this.blockRequestsWithType('font');\n    }\n    medias() {\n        return this.blockRequestsWithType('media');\n    }\n    styles() {\n        return this.blockRequestsWithType('css');\n    }\n    redirectTo(redirect) {\n        if (this.redirect !== undefined) {\n            throw new Error(`Already redirecting: ${this.redirect}`);\n        }\n        this.redirect = `redirect=${redirect}`;\n        return this;\n    }\n    urlContains(infix) {\n        if (this.infix !== undefined) {\n            throw new Error(`Already matching pattern: ${this.infix}`);\n        }\n        this.infix = infix;\n        return this;\n    }\n    urlStartsWith(prefix) {\n        if (this.prefix !== undefined) {\n            throw new Error(`Already matching prefix: ${this.prefix}`);\n        }\n        this.prefix = `|${prefix}`;\n        return this;\n    }\n    urlEndsWith(suffix) {\n        if (this.suffix !== undefined) {\n            throw new Error(`Already matching suffix: ${this.suffix}`);\n        }\n        this.suffix = `${suffix}|`;\n        return this;\n    }\n    withHostname(hostname) {\n        if (this.prefix !== undefined) {\n            throw new Error(`Cannot match hostname if filter already has prefix: ${this.prefix}`);\n        }\n        this.prefix = `||${hostname}^`;\n        return this;\n    }\n    toString() {\n        const parts = [];\n        if (this.prefix !== undefined) {\n            parts.push(this.prefix);\n        }\n        if (this.infix !== undefined) {\n            parts.push(this.infix);\n        }\n        if (this.suffix !== undefined) {\n            parts.push(this.suffix);\n        }\n        const options = ['important'];\n        if (this.options.size !== 0) {\n            for (const option of this.options) {\n                options.push(option);\n            }\n        }\n        if (this.redirect !== undefined) {\n            options.push(this.redirect);\n        }\n        return `${parts.length === 0 ? '*' : parts.join('*')}$${options.join(',')}`;\n    }\n}\nfunction block() {\n    return new NetworkBuilder();\n}\nfunction hide() {\n    return new HidingBuilder();\n}\n//# sourceMappingURL=dsl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9maWx0ZXJzL2RzbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEVBQUU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxXQUFXO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsWUFBWTtBQUNwRTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFlBQVk7QUFDL0Y7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkMsR0FBRyxrQkFBa0I7QUFDbEY7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9maWx0ZXJzL2RzbC5qcz9hZDViIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQgR2hvc3RlcnkgR21iSC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuY2xhc3MgSGlkaW5nQnVpbGRlciB7XG59XG5jbGFzcyBOZXR3b3JrQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaW5maXggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3VmZml4ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlZGlyZWN0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBibG9ja1JlcXVlc3RzV2l0aFR5cGUodCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhhcyh0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbHJlYWR5IGJsb2NraW5nIHR5cGUgJHt0fWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy5hZGQodCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpbWFnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NrUmVxdWVzdHNXaXRoVHlwZSgnaW1hZ2UnKTtcbiAgICB9XG4gICAgc2NyaXB0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tSZXF1ZXN0c1dpdGhUeXBlKCdzY3JpcHQnKTtcbiAgICB9XG4gICAgZnJhbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9ja1JlcXVlc3RzV2l0aFR5cGUoJ2ZyYW1lJyk7XG4gICAgfVxuICAgIGZvbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9ja1JlcXVlc3RzV2l0aFR5cGUoJ2ZvbnQnKTtcbiAgICB9XG4gICAgbWVkaWFzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9ja1JlcXVlc3RzV2l0aFR5cGUoJ21lZGlhJyk7XG4gICAgfVxuICAgIHN0eWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tSZXF1ZXN0c1dpdGhUeXBlKCdjc3MnKTtcbiAgICB9XG4gICAgcmVkaXJlY3RUbyhyZWRpcmVjdCkge1xuICAgICAgICBpZiAodGhpcy5yZWRpcmVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFscmVhZHkgcmVkaXJlY3Rpbmc6ICR7dGhpcy5yZWRpcmVjdH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZGlyZWN0ID0gYHJlZGlyZWN0PSR7cmVkaXJlY3R9YDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVybENvbnRhaW5zKGluZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmluZml4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQWxyZWFkeSBtYXRjaGluZyBwYXR0ZXJuOiAke3RoaXMuaW5maXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmZpeCA9IGluZml4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdXJsU3RhcnRzV2l0aChwcmVmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJlZml4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQWxyZWFkeSBtYXRjaGluZyBwcmVmaXg6ICR7dGhpcy5wcmVmaXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVmaXggPSBgfCR7cHJlZml4fWA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1cmxFbmRzV2l0aChzdWZmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3VmZml4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQWxyZWFkeSBtYXRjaGluZyBzdWZmaXg6ICR7dGhpcy5zdWZmaXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWZmaXggPSBgJHtzdWZmaXh9fGA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoSG9zdG5hbWUoaG9zdG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMucHJlZml4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG1hdGNoIGhvc3RuYW1lIGlmIGZpbHRlciBhbHJlYWR5IGhhcyBwcmVmaXg6ICR7dGhpcy5wcmVmaXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVmaXggPSBgfHwke2hvc3RuYW1lfV5gO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIGlmICh0aGlzLnByZWZpeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMucHJlZml4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmZpeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuaW5maXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN1ZmZpeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuc3VmZml4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gWydpbXBvcnRhbnQnXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaXplICE9PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2gob3B0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWRpcmVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2godGhpcy5yZWRpcmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3BhcnRzLmxlbmd0aCA9PT0gMCA/ICcqJyA6IHBhcnRzLmpvaW4oJyonKX0kJHtvcHRpb25zLmpvaW4oJywnKX1gO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBibG9jaygpIHtcbiAgICByZXR1cm4gbmV3IE5ldHdvcmtCdWlsZGVyKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGlkZSgpIHtcbiAgICByZXR1cm4gbmV3IEhpZGluZ0J1aWxkZXIoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRzbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/dsl.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/network.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/filters/network.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NETWORK_FILTER_MASK: () => (/* binding */ NETWORK_FILTER_MASK),\n/* harmony export */   \"default\": () => (/* binding */ NetworkFilter),\n/* harmony export */   isAnchoredByHostname: () => (/* binding */ isAnchoredByHostname),\n/* harmony export */   normalizeRawFilterOptions: () => (/* binding */ normalizeRawFilterOptions),\n/* harmony export */   replaceOptionValueToRegexp: () => (/* binding */ replaceOptionValueToRegexp)\n/* harmony export */ });\n/* harmony import */ var _engine_domains_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../engine/domains.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/domains.js\");\n/* harmony import */ var _data_view_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data-view.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/data-view.js\");\n/* harmony import */ var _punycode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../punycode.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/punycode.js\");\n/* harmony import */ var _request_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../request.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/request.js\");\n/* harmony import */ var _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tokens-buffer.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/tokens-buffer.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/utils.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n\nconst HTTP_HASH = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.fastHash)('http');\nconst HTTPS_HASH = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.fastHash)('https');\nfunction isAllowedHostname(ch) {\n    return ((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isDigit)(ch) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.isAlpha)(ch) || ch === 95 /* '_' */ || ch === 45 /* '-' */ || ch === 46 /* '.' */);\n}\nconst NORMALIZE_OPTIONS = {\n    'document': 'doc',\n    'first-party': '1p',\n    'generichide': 'ghide',\n    'object-subrequest': 'object',\n    'stylesheet': 'css',\n    'subdocument': 'frame',\n    'third-party': '3p',\n    'xmlhttprequest': 'xhr',\n    '~first-party': '3p',\n    '~third-party': '1p',\n    'all': '',\n};\n/**\n * Normalize a raw filter by replacing options with their canonical forms. For\n * example `||foo.com$stylesheet,first-party,xhr` would be normalized to\n * `||foo.com$css,1p,xhr`.\n */\nconst REGEX = /all|~third-party|~first-party|third-party|first-party|object-subrequest|stylesheet|subdocument|xmlhttprequest|document|generichide/g;\nfunction normalizeRawFilterOptions(rawFilter) {\n    rawFilter = rawFilter.toLowerCase();\n    let indexOfOptions = rawFilter.lastIndexOf('$');\n    if (indexOfOptions === -1) {\n        return rawFilter;\n    }\n    // Remove trailing '*' if possible\n    if (indexOfOptions !== 0 && rawFilter[indexOfOptions - 1] === '*') {\n        rawFilter = rawFilter.slice(0, indexOfOptions - 1) + rawFilter.slice(indexOfOptions);\n        indexOfOptions -= 1;\n    }\n    // Normalize options\n    const options = rawFilter.slice(indexOfOptions + 1);\n    const normalizedOptions = options\n        .replace(REGEX, (option) => {\n        const normalized = NORMALIZE_OPTIONS[option];\n        if (normalized === undefined) {\n            return option;\n        }\n        return normalized;\n    })\n        .split(',')\n        .sort()\n        .join(',');\n    if (options === normalizedOptions) {\n        return rawFilter;\n    }\n    if (normalizedOptions === '') {\n        return rawFilter.slice(0, indexOfOptions);\n    }\n    return `${rawFilter.slice(0, indexOfOptions)}$${normalizedOptions}`;\n}\n/**\n * Masks used to store options of network filters in a bitmask.\n */\nvar NETWORK_FILTER_MASK;\n(function (NETWORK_FILTER_MASK) {\n    // Request Type\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"fromDocument\"] = 1] = \"fromDocument\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"fromFont\"] = 2] = \"fromFont\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"fromHttp\"] = 4] = \"fromHttp\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"fromHttps\"] = 8] = \"fromHttps\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"fromImage\"] = 16] = \"fromImage\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"fromMedia\"] = 32] = \"fromMedia\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"fromObject\"] = 64] = \"fromObject\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"fromOther\"] = 128] = \"fromOther\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"fromPing\"] = 256] = \"fromPing\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"fromScript\"] = 512] = \"fromScript\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"fromStylesheet\"] = 1024] = \"fromStylesheet\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"fromSubdocument\"] = 2048] = \"fromSubdocument\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"fromWebsocket\"] = 4096] = \"fromWebsocket\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"fromXmlHttpRequest\"] = 8192] = \"fromXmlHttpRequest\";\n    // Partiness\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"firstParty\"] = 16384] = \"firstParty\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"thirdParty\"] = 32768] = \"thirdParty\";\n    // Options\n    // isReplace does not fit to the options, but is here from a lack of empty MASK slots\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"isReplace\"] = 65536] = \"isReplace\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"isBadFilter\"] = 131072] = \"isBadFilter\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"isCSP\"] = 262144] = \"isCSP\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"isGenericHide\"] = 524288] = \"isGenericHide\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"isImportant\"] = 1048576] = \"isImportant\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"isSpecificHide\"] = 2097152] = \"isSpecificHide\";\n    // Kind of patterns\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"isFullRegex\"] = 4194304] = \"isFullRegex\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"isRegex\"] = 8388608] = \"isRegex\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"isUnicode\"] = 16777216] = \"isUnicode\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"isLeftAnchor\"] = 33554432] = \"isLeftAnchor\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"isRightAnchor\"] = 67108864] = \"isRightAnchor\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"isException\"] = 134217728] = \"isException\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"isHostnameAnchor\"] = 268435456] = \"isHostnameAnchor\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"isRedirectRule\"] = 536870912] = \"isRedirectRule\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"isRedirect\"] = 1073741824] = \"isRedirect\";\n    NETWORK_FILTER_MASK[NETWORK_FILTER_MASK[\"isRemoveParam\"] = -2147483648] = \"isRemoveParam\";\n    // IMPORTANT: the mask is now full, no more options can be added\n    // Consider creating a separate fitler type for isReplace if a new\n    // network filter option is needed.\n})(NETWORK_FILTER_MASK || (NETWORK_FILTER_MASK = {}));\n/**\n * Mask used when a network filter can be applied on any content type.\n */\nconst FROM_ANY = NETWORK_FILTER_MASK.fromDocument |\n    NETWORK_FILTER_MASK.fromFont |\n    NETWORK_FILTER_MASK.fromImage |\n    NETWORK_FILTER_MASK.fromMedia |\n    NETWORK_FILTER_MASK.fromObject |\n    NETWORK_FILTER_MASK.fromOther |\n    NETWORK_FILTER_MASK.fromPing |\n    NETWORK_FILTER_MASK.fromScript |\n    NETWORK_FILTER_MASK.fromStylesheet |\n    NETWORK_FILTER_MASK.fromSubdocument |\n    NETWORK_FILTER_MASK.fromWebsocket |\n    NETWORK_FILTER_MASK.fromXmlHttpRequest;\n/**\n * Map content type value to mask the corresponding mask.\n * ref: https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIContentPolicy\n */\nconst REQUEST_TYPE_TO_MASK = {\n    beacon: NETWORK_FILTER_MASK.fromPing, // fromOther?\n    document: NETWORK_FILTER_MASK.fromDocument,\n    cspviolationreport: NETWORK_FILTER_MASK.fromOther,\n    // https://developer.mozilla.org/en-US/docs/Web/API/FedCM_API/IDP_integration#provide_a_config_file_and_endpoints\n    // FedCM configuration file is resolved as a JSON module, which is interpreted as a \"script\".\n    // Some of FedCM related requests are resolved as \"xhr/fetch\" but we use \"script\" to add weight to the meaning of \"standardised\" module behavior in browser-side.\n    fedcm: NETWORK_FILTER_MASK.fromScript,\n    fetch: NETWORK_FILTER_MASK.fromXmlHttpRequest,\n    font: NETWORK_FILTER_MASK.fromFont,\n    image: NETWORK_FILTER_MASK.fromImage,\n    imageset: NETWORK_FILTER_MASK.fromImage,\n    // https://searchfox.org/mozilla-central/rev/fcfb558f8946f3648d962576125af46bf6e2910a/toolkit/components/extensions/schemas/web_request.json\n    // This is for JSON modules from import statements.\n    // Our `NETWORK_FILTER_MASK` is already full and we can treat this as a script request.\n    json: NETWORK_FILTER_MASK.fromScript,\n    mainFrame: NETWORK_FILTER_MASK.fromDocument,\n    main_frame: NETWORK_FILTER_MASK.fromDocument,\n    media: NETWORK_FILTER_MASK.fromMedia,\n    object: NETWORK_FILTER_MASK.fromObject,\n    object_subrequest: NETWORK_FILTER_MASK.fromObject,\n    ping: NETWORK_FILTER_MASK.fromPing, // fromOther?\n    script: NETWORK_FILTER_MASK.fromScript,\n    stylesheet: NETWORK_FILTER_MASK.fromStylesheet,\n    subFrame: NETWORK_FILTER_MASK.fromSubdocument,\n    sub_frame: NETWORK_FILTER_MASK.fromSubdocument,\n    webSocket: NETWORK_FILTER_MASK.fromWebsocket,\n    websocket: NETWORK_FILTER_MASK.fromWebsocket,\n    xhr: NETWORK_FILTER_MASK.fromXmlHttpRequest,\n    xmlhttprequest: NETWORK_FILTER_MASK.fromXmlHttpRequest,\n    // Other\n    cspReport: NETWORK_FILTER_MASK.fromOther,\n    csp_report: NETWORK_FILTER_MASK.fromOther,\n    eventsource: NETWORK_FILTER_MASK.fromOther,\n    manifest: NETWORK_FILTER_MASK.fromOther,\n    other: NETWORK_FILTER_MASK.fromOther,\n    prefetch: NETWORK_FILTER_MASK.fromOther,\n    preflight: NETWORK_FILTER_MASK.fromOther,\n    signedexchange: NETWORK_FILTER_MASK.fromOther,\n    speculative: NETWORK_FILTER_MASK.fromOther,\n    texttrack: NETWORK_FILTER_MASK.fromOther,\n    web_manifest: NETWORK_FILTER_MASK.fromOther,\n    xml_dtd: NETWORK_FILTER_MASK.fromOther,\n    xslt: NETWORK_FILTER_MASK.fromOther,\n};\nfunction getListOfRequestTypesNegated(filter) {\n    const types = [];\n    if (filter.fromDocument() === false) {\n        types.push('document');\n    }\n    if (filter.fromImage() === false) {\n        types.push('image');\n    }\n    if (filter.fromMedia() === false) {\n        types.push('media');\n    }\n    if (filter.fromObject() === false) {\n        types.push('object');\n    }\n    if (filter.fromOther() === false) {\n        types.push('other');\n    }\n    if (filter.fromPing() === false) {\n        types.push('ping');\n    }\n    if (filter.fromScript() === false) {\n        types.push('script');\n    }\n    if (filter.fromStylesheet() === false) {\n        types.push('stylesheet');\n    }\n    if (filter.fromSubdocument() === false) {\n        types.push('sub_frame');\n    }\n    if (filter.fromWebsocket() === false) {\n        types.push('websocket');\n    }\n    if (filter.fromXmlHttpRequest() === false) {\n        types.push('xhr');\n    }\n    if (filter.fromFont() === false) {\n        types.push('font');\n    }\n    return types;\n}\nfunction getListOfRequestTypes(filter) {\n    const types = [];\n    if (filter.fromDocument()) {\n        types.push('document');\n    }\n    if (filter.fromImage()) {\n        types.push('image');\n    }\n    if (filter.fromMedia()) {\n        types.push('media');\n    }\n    if (filter.fromObject()) {\n        types.push('object');\n    }\n    if (filter.fromOther()) {\n        types.push('other');\n    }\n    if (filter.fromPing()) {\n        types.push('ping');\n    }\n    if (filter.fromScript()) {\n        types.push('script');\n    }\n    if (filter.fromStylesheet()) {\n        types.push('stylesheet');\n    }\n    if (filter.fromSubdocument()) {\n        types.push('sub_frame');\n    }\n    if (filter.fromWebsocket()) {\n        types.push('websocket');\n    }\n    if (filter.fromXmlHttpRequest()) {\n        types.push('xhr');\n    }\n    if (filter.fromFont()) {\n        types.push('font');\n    }\n    return types;\n}\nfunction computeFilterId(mask, filter, hostname, domains, denyallow, optionValue) {\n    let hash = (_utils_js__WEBPACK_IMPORTED_MODULE_5__.HASH_SEED * _utils_js__WEBPACK_IMPORTED_MODULE_5__.HASH_INTERNAL_MULT) ^ mask;\n    if (domains !== undefined) {\n        hash = domains.updateId(hash);\n    }\n    if (denyallow !== undefined) {\n        hash = denyallow.updateId(hash);\n    }\n    if (filter !== undefined) {\n        for (let i = 0; i < filter.length; i += 1) {\n            hash = (hash * _utils_js__WEBPACK_IMPORTED_MODULE_5__.HASH_INTERNAL_MULT) ^ filter.charCodeAt(i);\n        }\n    }\n    if (hostname !== undefined) {\n        for (let i = 0; i < hostname.length; i += 1) {\n            hash = (hash * _utils_js__WEBPACK_IMPORTED_MODULE_5__.HASH_INTERNAL_MULT) ^ hostname.charCodeAt(i);\n        }\n    }\n    if (optionValue !== undefined) {\n        for (let i = 0; i < optionValue.length; i += 1) {\n            hash = (hash * _utils_js__WEBPACK_IMPORTED_MODULE_5__.HASH_INTERNAL_MULT) ^ optionValue.charCodeAt(i);\n        }\n    }\n    return hash >>> 0;\n}\n/**\n * Compiles a filter pattern to a regex. This is only performed *lazily* for\n * filters containing at least a * or ^ symbol. Because Regexes are expansive,\n * we try to convert some patterns to plain filters.\n */\nfunction compileRegex(filter, isLeftAnchor, isRightAnchor, isFullRegex) {\n    if (isFullRegex === true) {\n        return new RegExp(filter.slice(1, filter.length - 1), 'i');\n    }\n    // Escape special regex characters: |.$+?{}()[]\\\n    filter = filter.replace(/([|.$+?{}()[\\]\\\\])/g, '\\\\$1');\n    // * can match anything\n    filter = filter.replace(/\\*/g, '.*');\n    // ^ can match any separator or the end of the pattern\n    filter = filter.replace(/\\^/g, '(?:[^\\\\w\\\\d_.%-]|$)');\n    // Should match end of url\n    if (isRightAnchor) {\n        filter = `${filter}$`;\n    }\n    if (isLeftAnchor) {\n        filter = `^${filter}`;\n    }\n    return new RegExp(filter);\n}\n/**\n * Collects a filter option key until the function sees the special character.\n * This function will stop iterating over the given string if it sees equal sign or comma sign.\n * If there's an equal sign, it means that we'll see the value.\n * Otherwise, if there's a comma sign, it means that the option doesn't have any values.\n */\nfunction getFilterOptionName(line, pos, end) {\n    const start = pos;\n    for (; pos < end; pos++) {\n        const code = line.charCodeAt(pos);\n        if (code === 61 /* '=' */ || code === 44 /* ',' */) {\n            end = pos;\n            break;\n        }\n    }\n    return [pos, line.slice(start, end)];\n}\n/**\n * Collects a filter option value until the function sees the special character.\n * This function respects the escaping characters, so we can safely collect the full value\n * including the special characters which are not allowed normally.\n * This function will stop if it sees a comma sign.\n */\nfunction getFilterOptionValue(line, pos, end) {\n    let start = pos;\n    let value = '';\n    for (; pos < end; pos++) {\n        const code = line.charCodeAt(pos);\n        if (code === 92 /* '\\\\' */) {\n            value += line.slice(start, pos);\n            start = ++pos;\n        }\n        else if (code === 44 /* ',' */) {\n            break;\n        }\n    }\n    if (start - pos !== 0) {\n        value += line.slice(start, pos);\n    }\n    return [pos, value];\n}\nconst REGEXP_CHARACTER_ESCAPES = new Set([\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Character_escape\n    102, // f\n    110, // n\n    114, // r\n    116, // t\n    118, // v\n    48, // 0\n    94, // ^\n    36, // $\n    92, // \\\n    46, // .\n    42, // *\n    43, // +\n    63, // ?\n    40, // (\n    41, // )\n    91, // [\n    93, // ]\n    123, // {\n    125, // }\n    124, // |\n    47, // /\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Character_class_escape\n    100, // d\n    68, // D\n    119, // s\n    87, // S\n    115, // w\n    83, // W\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Word_boundary_assertion\n    98, // b\n    66, // B\n]);\nfunction isHexLiteral(code) {\n    return ((code >= 48 && code <= 57) || // 0-9\n        (code <= 65 && code <= 70) || // A-F\n        (code >= 97 && code <= 102) // a-f\n    );\n}\n/**\n * Checks if the character(s) after the escape character should be preserved.\n * @returns The end index of search range and boolean indicating whether the character escape was found or not.\n */\nfunction isCharacterEscapeInRegExp(line, pos, _end) {\n    const code = line.charCodeAt(pos + 1);\n    if (code === 44 /* ',' */ || REGEXP_CHARACTER_ESCAPES.has(code)) {\n        return [pos + 1, true];\n    }\n    // \\cA, \\cB, , \\cz\n    if (code === 99 /* 'c' */) {\n        const next = line.charCodeAt(pos + 2);\n        if ((next >= 65 && next <= 90) || (next >= 97 && next <= 122)) {\n            return [pos + 2, true];\n        }\n    }\n    // \\xHH\n    if (code === 120 /* 'x' */ &&\n        isHexLiteral(line.charCodeAt(pos + 2)) &&\n        isHexLiteral(line.charCodeAt(pos + 3))) {\n        return [pos + 3, true];\n    }\n    if (code === 117 /* 'u' */) {\n        // \\u{HHH}\n        if (line.charCodeAt(pos + 2) === 123 /* '{' */) {\n            const close = line.indexOf('}', pos + 3);\n            const hexLiteralLength = close - pos + 3;\n            if (hexLiteralLength >= 1 && hexLiteralLength <= 6) {\n                return [close, true];\n            }\n        }\n        else if (\n        // \\uHHHH\n        isHexLiteral(line.charCodeAt(pos + 2)) &&\n            isHexLiteral(line.charCodeAt(pos + 3)) &&\n            isHexLiteral(line.charCodeAt(pos + 4)) &&\n            isHexLiteral(line.charCodeAt(pos + 5))) {\n            return [pos + 5, true];\n        }\n    }\n    return [pos + 1, false];\n}\n/**\n * Comma and slash are expected to come with escape character by the spec.\n * https://adguard.com/kb/general/ad-filtering/create-own-filters/#replace-modifier\n */\nfunction isCharacterEscapeInReplace(line, pos, end) {\n    const code = line.charCodeAt(pos + 1);\n    if (code === 44 /* ',' */ || code === 47 /* '/' */) {\n        return [pos + 1, false];\n    }\n    return isCharacterEscapeInRegExp(line, pos, end);\n}\n/**\n * Collects a filter option value of the replace modifier.\n * This function respects the escaping character with the allowed characters of the replace modifier.\n * In the replace modifier, it can include the any sign allowed in the regular expression.\n * Therefore, a comma sign can interfere the `getFilterOptionValue` function.\n * This function will not stop unless it collects all the parts of the replace modifier option value.\n */\nfunction getFilterReplaceOptionValue(line, pos, end) {\n    // Try to fast exit if the first character is an unexpected character.\n    if (line.charCodeAt(pos++) !== 47 /* '/' */) {\n        return [end, undefined];\n    }\n    const parts = ['', '', ''];\n    let start = pos;\n    let slashes = 0;\n    for (; pos < end; pos++) {\n        const code = line.charCodeAt(pos);\n        if (code === 92 /* '\\\\' */) {\n            parts[slashes] += line.slice(start, pos);\n            const [posAfterCharacterEscape, isCharacterEscape] = isCharacterEscapeInReplace(line, pos, end);\n            if (isCharacterEscape === false) {\n                // Remove escaping character ('\\\\') by adding an offset to next `start` assignment.\n                ++pos;\n            }\n            start = pos;\n            pos = posAfterCharacterEscape;\n        }\n        else if (code === 47 /* '/' */) {\n            if (pos - start !== 0) {\n                parts[slashes] += line.slice(start, pos);\n            }\n            start = pos + 1;\n            if (++slashes === 2) {\n                // Since we saw 3 slashes in total, it means that the option value should be closed here.\n                // Note that we already saw the first slash before the loop.\n                break;\n            }\n        }\n    }\n    const valueEnd = line.indexOf(',', pos);\n    if (valueEnd !== -1) {\n        end = valueEnd;\n    }\n    parts[2] = line.slice(start, end);\n    pos = end;\n    return [pos, parts];\n}\n/**\n * Collects an array of filter options from the given index.\n * This function leverages `getFilterOptionKey`, `getFilterOptionValue`, and every extension functions.\n * Depending on the filter option key, the function to collect filter option value can vary.\n * For the generic filter option value, it'll use `getFilterOptionValue` function to get the value.\n */\nfunction getFilterOptions(line, pos, end) {\n    const options = [];\n    let name;\n    let value;\n    for (; pos < end; pos++) {\n        [pos, name] = getFilterOptionName(line, pos, end);\n        if (name !== undefined) {\n            if (line.charCodeAt(pos) === 61 /* '=' */) {\n                pos++;\n            }\n            if (name === 'replace') {\n                const result = getFilterReplaceOptionValue(line, pos, end);\n                if (result[1] === undefined) {\n                    value = '';\n                }\n                else {\n                    value = line.slice(pos, result[0]);\n                }\n                pos = result[0];\n            }\n            else {\n                [pos, value] = getFilterOptionValue(line, pos, end);\n            }\n            options.push([name, value]);\n        }\n    }\n    return options;\n}\n/**\n * Transforms the replace modifier option value into the regular expression with its replacement.\n * This function takes a fixed length array from `getFilterReplaceOptionValue`\n * then try to build the regular expression.\n * This function will return `null` if the array format or the given regular expression components are not valid.\n */\nfunction replaceOptionValueToRegexp(value) {\n    const [, values] = getFilterReplaceOptionValue(value, 0, value.length);\n    if (values === undefined) {\n        return null;\n    }\n    // RegExp constructor can throw an error\n    try {\n        // We expect `/regexp/replacement/flags` to be [regexp, replacement, flags]\n        // The first slash should be removed in the early steps\n        return [new RegExp(values[0], values[2]), values[1]];\n    }\n    catch (error) {\n        return null;\n    }\n}\nconst MATCH_ALL = new RegExp('');\nclass NetworkFilter {\n    static parse(line, debug = false) {\n        // Represent options as a bitmask\n        let mask = NETWORK_FILTER_MASK.thirdParty |\n            NETWORK_FILTER_MASK.firstParty |\n            NETWORK_FILTER_MASK.fromHttps |\n            NETWORK_FILTER_MASK.fromHttp;\n        // Temporary masks for positive (e.g.: $script) and negative (e.g.: $~script)\n        // content type options.\n        let cptMaskPositive = 0;\n        let cptMaskNegative = FROM_ANY;\n        let hostname;\n        let domains;\n        let denyallow;\n        let optionValue;\n        // Start parsing\n        let filterIndexStart = 0;\n        let filterIndexEnd = line.length;\n        // @@filter == Exception\n        if (line.charCodeAt(0) === 64 /* '@' */ && line.charCodeAt(1) === 64 /* '@' */) {\n            filterIndexStart += 2;\n            mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isException);\n        }\n        // filter$options == Options\n        // ^     ^\n        // |     |\n        // |     optionsIndex\n        // filterIndexStart\n        const optionsIndex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.findLastIndexOfUnescapedCharacter)(line, '$');\n        if (optionsIndex !== -1 && line.charCodeAt(optionsIndex + 1) !== 47 /* '/' */) {\n            // Parse options and set flags\n            filterIndexEnd = optionsIndex;\n            // --------------------------------------------------------------------- //\n            // parseOptions\n            // --------------------------------------------------------------------- //\n            let domainsList;\n            let denyallowList;\n            for (const rawOption of getFilterOptions(line, optionsIndex + 1, line.length)) {\n                const negation = rawOption[0].charCodeAt(0) === 126; /* '~' */\n                const option = negation === true ? rawOption[0].slice(1) : rawOption[0];\n                const value = rawOption[1];\n                switch (option) {\n                    case 'to': {\n                        domainsList !== null && domainsList !== void 0 ? domainsList : (domainsList = new Set());\n                        denyallowList !== null && denyallowList !== void 0 ? denyallowList : (denyallowList = new Set());\n                        for (const hostname of value.split('|')) {\n                            if (hostname.startsWith('~')) {\n                                denyallowList.add(hostname.slice(1));\n                            }\n                            else {\n                                domainsList.add(hostname);\n                            }\n                        }\n                        break;\n                    }\n                    case 'denyallow': {\n                        denyallowList !== null && denyallowList !== void 0 ? denyallowList : (denyallowList = new Set());\n                        for (const domain of value.split('|')) {\n                            denyallowList.add(domain);\n                        }\n                        break;\n                    }\n                    case 'domain':\n                    case 'from': {\n                        domainsList !== null && domainsList !== void 0 ? domainsList : (domainsList = new Set());\n                        for (const domain of value.split('|')) {\n                            domainsList.add(domain);\n                        }\n                        break;\n                    }\n                    case 'badfilter':\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isBadFilter);\n                        break;\n                    case 'important':\n                        // Note: `negation` should always be `false` here.\n                        if (negation) {\n                            return null;\n                        }\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isImportant);\n                        break;\n                    case 'match-case':\n                        // Note: `negation` should always be `false` here.\n                        if (negation) {\n                            return null;\n                        }\n                        // We currently consider all filters to be case-insensitive.\n                        break;\n                    case '3p':\n                    case 'third-party':\n                        if (negation) {\n                            // ~third-party means we should clear the flag\n                            mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.clearBit)(mask, NETWORK_FILTER_MASK.thirdParty);\n                        }\n                        else {\n                            // third-party means ~first-party\n                            mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.clearBit)(mask, NETWORK_FILTER_MASK.firstParty);\n                        }\n                        break;\n                    case '1p':\n                    case 'first-party':\n                        if (negation) {\n                            // ~first-party means we should clear the flag\n                            mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.clearBit)(mask, NETWORK_FILTER_MASK.firstParty);\n                        }\n                        else {\n                            // first-party means ~third-party\n                            mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.clearBit)(mask, NETWORK_FILTER_MASK.thirdParty);\n                        }\n                        break;\n                    case 'redirect-rule':\n                    case 'redirect': {\n                        // Negation of redirection doesn't make sense\n                        if (negation) {\n                            return null;\n                        }\n                        // Ignore this filter if no redirection resource is specified\n                        if (value.length === 0) {\n                            return null;\n                        }\n                        // Ignore this filter if wrong priority is given\n                        const priorityIndex = value.lastIndexOf(':');\n                        if (priorityIndex === 0) {\n                            return null;\n                        }\n                        else if (priorityIndex !== -1 &&\n                            (isNaN(Number(value.slice(priorityIndex + 1))) === true ||\n                                priorityIndex + 1 === value.length)) {\n                            return null;\n                        }\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isRedirect);\n                        if (option === 'redirect-rule') {\n                            mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isRedirectRule);\n                        }\n                        if (optionValue !== undefined) {\n                            return null;\n                        }\n                        optionValue = value;\n                        break;\n                    }\n                    case 'csp':\n                        if (negation) {\n                            return null;\n                        }\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isCSP);\n                        if (value.length > 0) {\n                            if (optionValue !== undefined) {\n                                return null;\n                            }\n                            optionValue = value;\n                        }\n                        break;\n                    case 'ehide':\n                    case 'elemhide':\n                        if (negation) {\n                            return null;\n                        }\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isGenericHide);\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isSpecificHide);\n                        break;\n                    case 'shide':\n                    case 'specifichide':\n                        if (negation) {\n                            return null;\n                        }\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isSpecificHide);\n                        break;\n                    case 'ghide':\n                    case 'generichide':\n                        if (negation) {\n                            return null;\n                        }\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isGenericHide);\n                        break;\n                    case 'inline-script':\n                        if (negation || optionValue !== undefined) {\n                            return null;\n                        }\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isCSP);\n                        optionValue =\n                            \"script-src 'self' 'unsafe-eval' http: https: data: blob: mediastream: filesystem:\";\n                        break;\n                    case 'inline-font':\n                        if (negation || optionValue !== undefined) {\n                            return null;\n                        }\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isCSP);\n                        optionValue =\n                            \"font-src 'self' 'unsafe-eval' http: https: data: blob: mediastream: filesystem:\";\n                        break;\n                    case 'replace':\n                    case 'content':\n                        if (negation ||\n                            (value.length === 0\n                                ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(mask, NETWORK_FILTER_MASK.isException) === false\n                                : replaceOptionValueToRegexp(value) === null) ||\n                            optionValue !== undefined) {\n                            return null;\n                        }\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isReplace);\n                        optionValue = value;\n                        break;\n                    case 'removeparam':\n                        // TODO: Support regex\n                        if (negation || value.startsWith('/') || optionValue !== undefined) {\n                            return null;\n                        }\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isRemoveParam);\n                        optionValue = value;\n                        break;\n                    default: {\n                        // Handle content type options separatly\n                        let optionMask = 0;\n                        switch (option) {\n                            case 'all':\n                                if (negation) {\n                                    return null;\n                                }\n                                // NOTE: Currently a filter cannot be both blocking and CSP, so\n                                // we will have to create multiple filters to keep the semantics\n                                // of 'all'.\n                                // mask = setBit(mask, NETWORK_FILTER_MASK.isCSP);\n                                // csp = [\n                                //   \"script-src 'self' 'unsafe-eval' http: https: data: blob: mediastream: filesystem:\",\n                                //   \"font-src 'self' 'unsafe-eval' http: https: data: blob: mediastream: filesystem:\",\n                                // ].join('; ');\n                                break;\n                            case 'image':\n                                optionMask = NETWORK_FILTER_MASK.fromImage;\n                                break;\n                            case 'media':\n                                optionMask = NETWORK_FILTER_MASK.fromMedia;\n                                break;\n                            case 'object':\n                            case 'object-subrequest':\n                                optionMask = NETWORK_FILTER_MASK.fromObject;\n                                break;\n                            case 'other':\n                                optionMask = NETWORK_FILTER_MASK.fromOther;\n                                break;\n                            case 'ping':\n                            case 'beacon':\n                                optionMask = NETWORK_FILTER_MASK.fromPing;\n                                break;\n                            case 'script':\n                                optionMask = NETWORK_FILTER_MASK.fromScript;\n                                break;\n                            case 'css':\n                            case 'stylesheet':\n                                optionMask = NETWORK_FILTER_MASK.fromStylesheet;\n                                break;\n                            case 'frame':\n                            case 'subdocument':\n                                optionMask = NETWORK_FILTER_MASK.fromSubdocument;\n                                break;\n                            case 'xhr':\n                            case 'xmlhttprequest':\n                                optionMask = NETWORK_FILTER_MASK.fromXmlHttpRequest;\n                                break;\n                            case 'websocket':\n                                optionMask = NETWORK_FILTER_MASK.fromWebsocket;\n                                break;\n                            case 'font':\n                                optionMask = NETWORK_FILTER_MASK.fromFont;\n                                break;\n                            case 'doc':\n                            case 'document':\n                                optionMask = NETWORK_FILTER_MASK.fromDocument;\n                                break;\n                            default:\n                                // Disable this filter if we don't support all the options\n                                return null;\n                        }\n                        // We got a valid cpt option, update mask\n                        if (negation) {\n                            cptMaskNegative = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.clearBit)(cptMaskNegative, optionMask);\n                        }\n                        else {\n                            cptMaskPositive = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(cptMaskPositive, optionMask);\n                        }\n                        break;\n                    }\n                }\n            }\n            if (domainsList !== undefined && domainsList.size !== 0) {\n                domains = _engine_domains_js__WEBPACK_IMPORTED_MODULE_0__.Domains.parse(domainsList, {\n                    delimiter: '|',\n                    debug,\n                });\n                if (domains === undefined) {\n                    return null;\n                }\n            }\n            if (denyallowList !== undefined && denyallowList.size !== 0) {\n                // $denyallow requires $domain\n                if (domainsList === undefined || domainsList.size === 0) {\n                    return null;\n                }\n                denyallow = _engine_domains_js__WEBPACK_IMPORTED_MODULE_0__.Domains.parse(denyallowList, {\n                    delimiter: '|',\n                    debug,\n                });\n                if (denyallow === undefined) {\n                    return null;\n                }\n            }\n            // End of option parsing\n            // --------------------------------------------------------------------- //\n        }\n        if (cptMaskPositive === 0) {\n            mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, cptMaskNegative);\n        }\n        else if (cptMaskNegative === FROM_ANY) {\n            mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, cptMaskPositive);\n        }\n        else {\n            mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, cptMaskPositive & cptMaskNegative);\n        }\n        // Identify kind of pattern\n        let filter;\n        // Detect Regexps (i.e.: /pattern/)\n        if (filterIndexEnd - filterIndexStart >= 2 &&\n            line.charCodeAt(filterIndexStart) === 47 /* '/' */ &&\n            line.charCodeAt(filterIndexEnd - 1) === 47 /* '/' */) {\n            // Some extra ideas which could be applied to RegExp filters:\n            // * convert rules without any special RegExp syntax to plain patterns\n            // * remove extra `isFullRegex` flag since `isRegex` might be enough\n            // * apply some optimizations on the fly: /^https?:\\\\/\\\\/rest => isHttp + isHttps + rest\n            filter = line.slice(filterIndexStart, filterIndexEnd);\n            // Validate RegExp to make sure this rule is fine\n            try {\n                compileRegex(filter, false /* isLeftAnchor */, false /* isRightAnchor */, true /* isFullRegex */);\n            }\n            catch (ex) {\n                return null; // invalid RegExp\n            }\n            mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isFullRegex);\n        }\n        else {\n            // Deal with hostname pattern\n            if (filterIndexEnd > 0 && line.charCodeAt(filterIndexEnd - 1) === 124 /* '|' */) {\n                mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isRightAnchor);\n                filterIndexEnd -= 1;\n            }\n            if (filterIndexStart < filterIndexEnd &&\n                line.charCodeAt(filterIndexStart) === 124 /* '|' */) {\n                if (filterIndexStart < filterIndexEnd - 1 &&\n                    line.charCodeAt(filterIndexStart + 1) === 124 /* '|' */) {\n                    mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isHostnameAnchor);\n                    filterIndexStart += 2;\n                }\n                else {\n                    mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isLeftAnchor);\n                    filterIndexStart += 1;\n                }\n            }\n            // const isRegex = checkIsRegex(line, filterIndexStart, filterIndexEnd);\n            // mask = setNetworkMask(mask, NETWORK_FILTER_MASK.isRegex, isRegex);\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(mask, NETWORK_FILTER_MASK.isHostnameAnchor)) {\n                // Split at the first character which is not allowed in a hostname\n                let firstSeparator = filterIndexStart;\n                while (firstSeparator < filterIndexEnd &&\n                    isAllowedHostname(line.charCodeAt(firstSeparator)) === true) {\n                    firstSeparator += 1;\n                }\n                // No separator found so hostname has full length\n                if (firstSeparator === filterIndexEnd) {\n                    hostname = line.slice(filterIndexStart, filterIndexEnd);\n                    filterIndexStart = filterIndexEnd;\n                    // mask = setBit(mask, NETWORK_FILTER_MASK.isLeftAnchor);\n                }\n                else {\n                    // Found a separator\n                    hostname = line.slice(filterIndexStart, firstSeparator);\n                    filterIndexStart = firstSeparator;\n                    const separatorCode = line.charCodeAt(firstSeparator);\n                    if (separatorCode === 94 /* '^' */) {\n                        // If the only symbol remaining for the selector is '^' then ignore it\n                        // but set the filter as right anchored since there should not be any\n                        // other label on the right\n                        if (filterIndexEnd - filterIndexStart === 1) {\n                            filterIndexStart = filterIndexEnd;\n                            mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isRightAnchor);\n                        }\n                        else {\n                            mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isRegex);\n                            mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isLeftAnchor);\n                        }\n                    }\n                    else if (separatorCode === 42 /* '*' */) {\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isRegex);\n                        // mask = setBit(mask, NETWORK_FILTER_MASK.isLeftAnchor);\n                    }\n                    else {\n                        mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.isLeftAnchor);\n                    }\n                }\n            }\n            // Remove trailing '*'\n            if (filterIndexEnd - filterIndexStart > 0 &&\n                line.charCodeAt(filterIndexEnd - 1) === 42 /* '*' */) {\n                filterIndexEnd -= 1;\n            }\n            // Remove leading '*' if the filter is not hostname anchored.\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(mask, NETWORK_FILTER_MASK.isHostnameAnchor) === false &&\n                filterIndexEnd - filterIndexStart > 0 &&\n                line.charCodeAt(filterIndexStart) === 42 /* '*' */) {\n                mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.clearBit)(mask, NETWORK_FILTER_MASK.isLeftAnchor);\n                filterIndexStart += 1;\n            }\n            // Transform filters on protocol (http, https, ws)\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(mask, NETWORK_FILTER_MASK.isLeftAnchor)) {\n                if (filterIndexEnd - filterIndexStart === 5 &&\n                    line.startsWith('ws://', filterIndexStart)) {\n                    mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.fromWebsocket);\n                    mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.clearBit)(mask, NETWORK_FILTER_MASK.isLeftAnchor);\n                    mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.clearBit)(mask, NETWORK_FILTER_MASK.fromHttp);\n                    mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.clearBit)(mask, NETWORK_FILTER_MASK.fromHttps);\n                    filterIndexStart = filterIndexEnd;\n                }\n                else if (filterIndexEnd - filterIndexStart === 7 &&\n                    line.startsWith('http://', filterIndexStart)) {\n                    mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.fromHttp);\n                    mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.clearBit)(mask, NETWORK_FILTER_MASK.fromHttps);\n                    mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.clearBit)(mask, NETWORK_FILTER_MASK.isLeftAnchor);\n                    filterIndexStart = filterIndexEnd;\n                }\n                else if (filterIndexEnd - filterIndexStart === 8 &&\n                    line.startsWith('https://', filterIndexStart)) {\n                    mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.fromHttps);\n                    mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.clearBit)(mask, NETWORK_FILTER_MASK.fromHttp);\n                    mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.clearBit)(mask, NETWORK_FILTER_MASK.isLeftAnchor);\n                    filterIndexStart = filterIndexEnd;\n                }\n                else if (filterIndexEnd - filterIndexStart === 8 &&\n                    line.startsWith('http*://', filterIndexStart)) {\n                    mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.fromHttps);\n                    mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, NETWORK_FILTER_MASK.fromHttp);\n                    mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.clearBit)(mask, NETWORK_FILTER_MASK.isLeftAnchor);\n                    filterIndexStart = filterIndexEnd;\n                }\n            }\n            if (filterIndexEnd - filterIndexStart > 0) {\n                filter = line.slice(filterIndexStart, filterIndexEnd).toLowerCase();\n                mask = setNetworkMask(mask, NETWORK_FILTER_MASK.isUnicode, (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.hasUnicode)(filter));\n                if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(mask, NETWORK_FILTER_MASK.isRegex) === false) {\n                    mask = setNetworkMask(mask, NETWORK_FILTER_MASK.isRegex, checkIsRegex(filter, 0, filter.length));\n                }\n            }\n            // TODO\n            // - ignore hostname anchor is not hostname provided\n            if (hostname !== undefined) {\n                hostname = hostname.toLowerCase();\n                if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.hasUnicode)(hostname)) {\n                    mask = setNetworkMask(mask, NETWORK_FILTER_MASK.isUnicode, true);\n                    hostname = (0,_punycode_js__WEBPACK_IMPORTED_MODULE_2__.toASCII)(hostname);\n                }\n            }\n        }\n        return new NetworkFilter({\n            filter,\n            hostname,\n            mask,\n            domains,\n            denyallow,\n            optionValue,\n            rawLine: debug === true ? line : undefined,\n            regex: undefined,\n        });\n    }\n    /**\n     * Deserialize network filters. The code accessing the buffer should be\n     * symetrical to the one in `serializeNetworkFilter`.\n     */\n    static deserialize(buffer) {\n        const mask = buffer.getUint32();\n        const optionalParts = buffer.getUint8();\n        const isUnicode = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(mask, NETWORK_FILTER_MASK.isUnicode);\n        // The order of these statements is important. Since `buffer.getX()` will\n        // internally increment the position of next byte to read, they need to be\n        // retrieved in the exact same order they were serialized (check\n        // `serializeNetworkFilter`).\n        return new NetworkFilter({\n            // Mandatory field\n            mask,\n            // Optional parts\n            filter: (optionalParts & 1) === 1\n                ? isUnicode\n                    ? buffer.getUTF8()\n                    : buffer.getNetworkFilter()\n                : undefined,\n            hostname: (optionalParts & 2) === 2 ? buffer.getNetworkHostname() : undefined,\n            domains: (optionalParts & 4) === 4 ? _engine_domains_js__WEBPACK_IMPORTED_MODULE_0__.Domains.deserialize(buffer) : undefined,\n            rawLine: (optionalParts & 8) === 8 ? buffer.getRawNetwork() : undefined,\n            denyallow: (optionalParts & 16) === 16 ? _engine_domains_js__WEBPACK_IMPORTED_MODULE_0__.Domains.deserialize(buffer) : undefined,\n            optionValue: (optionalParts & 32) === 32\n                ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(mask, NETWORK_FILTER_MASK.isCSP)\n                    ? buffer.getNetworkCSP()\n                    : (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(mask, NETWORK_FILTER_MASK.isRedirect)\n                        ? buffer.getNetworkRedirect()\n                        : buffer.getUTF8()\n                : undefined,\n            regex: undefined,\n        });\n    }\n    constructor({ filter, hostname, mask, domains, denyallow, optionValue, rawLine, regex, }) {\n        this.filter = filter;\n        this.hostname = hostname;\n        this.mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, 0);\n        this.domains = domains;\n        this.denyallow = denyallow;\n        this.optionValue = optionValue;\n        this.rawLine = rawLine;\n        this.id = undefined;\n        this.regex = regex;\n    }\n    get csp() {\n        if (!this.isCSP()) {\n            return undefined;\n        }\n        return this.optionValue;\n    }\n    get redirect() {\n        if (!this.isRedirect()) {\n            return undefined;\n        }\n        return this.optionValue;\n    }\n    get removeparam() {\n        if (!this.isRemoveParam()) {\n            return undefined;\n        }\n        return this.optionValue;\n    }\n    isCosmeticFilter() {\n        return false;\n    }\n    isNetworkFilter() {\n        return true;\n    }\n    match(request) {\n        return checkOptions(this, request) && checkPattern(this, request);\n    }\n    /**\n     * To allow for a more compact representation of network filters, the\n     * representation is composed of a mandatory header, and some optional\n     *\n     * Header:\n     * =======\n     *\n     *  | opt | mask\n     *     8     32\n     *\n     * For an empty filter having no pattern, hostname, the minimum size is: 42 bits.\n     *\n     * Then for each optional part (filter, hostname optDomains, optNotDomains,\n     * redirect), it takes 16 bits for the length of the string + the length of the\n     * string in bytes.\n     *\n     * The optional parts are written in order of there number of occurrence in the\n     * filter list used by the adblocker. The most common being `hostname`, then\n     * `filter`, `optDomains`, `optNotDomains`, `redirect`.\n     *\n     * Example:\n     * ========\n     *\n     * @@||cliqz.com would result in a serialized version:\n     *\n     * | 1 | mask | 9 | c | l | i | q | z | . | c | o | m  (16 bytes)\n     *\n     * In this case, the serialized version is actually bigger than the original\n     * filter, but faster to deserialize. In the future, we could optimize the\n     * representation to compact small filters better.\n     *\n     * Ideas:\n     *  * variable length encoding for the mask (if not option, take max 1 byte).\n     *  * first byte could contain the mask as well if small enough.\n     *  * when packing ascii string, store several of them in each byte.\n     */\n    serialize(buffer) {\n        buffer.pushUint32(this.mask);\n        const index = buffer.getPos();\n        buffer.pushUint8(0);\n        // This bit-mask indicates which optional parts of the filter were serialized.\n        let optionalParts = 0;\n        if (this.filter !== undefined) {\n            optionalParts |= 1;\n            if (this.isUnicode()) {\n                buffer.pushUTF8(this.filter);\n            }\n            else {\n                buffer.pushNetworkFilter(this.filter);\n            }\n        }\n        if (this.hostname !== undefined) {\n            optionalParts |= 2;\n            buffer.pushNetworkHostname(this.hostname);\n        }\n        if (this.domains !== undefined) {\n            optionalParts |= 4;\n            this.domains.serialize(buffer);\n        }\n        if (this.rawLine !== undefined) {\n            optionalParts |= 8;\n            buffer.pushRawNetwork(this.rawLine);\n        }\n        if (this.denyallow !== undefined) {\n            optionalParts |= 16;\n            this.denyallow.serialize(buffer);\n        }\n        if (this.optionValue !== undefined) {\n            optionalParts |= 32;\n            if (this.isCSP()) {\n                buffer.pushNetworkCSP(this.optionValue);\n            }\n            else if (this.isRedirect()) {\n                buffer.pushNetworkRedirect(this.optionValue);\n            }\n            else {\n                buffer.pushUTF8(this.optionValue);\n            }\n        }\n        buffer.setByte(index, optionalParts);\n    }\n    getSerializedSize(compression) {\n        let estimate = 4 + 1; // mask = 4 bytes // optional parts = 1 byte\n        if (this.filter !== undefined) {\n            if (this.isUnicode() === true) {\n                estimate += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(this.filter);\n            }\n            else {\n                estimate += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfNetworkFilter)(this.filter, compression);\n            }\n        }\n        if (this.hostname !== undefined) {\n            estimate += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfNetworkHostname)(this.hostname, compression);\n        }\n        if (this.domains !== undefined) {\n            estimate += this.domains.getSerializedSize();\n        }\n        if (this.rawLine !== undefined) {\n            estimate += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfRawNetwork)(this.rawLine, compression);\n        }\n        if (this.denyallow !== undefined) {\n            estimate += this.denyallow.getSerializedSize();\n        }\n        if (this.optionValue !== undefined) {\n            if (this.isCSP()) {\n                estimate += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfNetworkCSP)(this.optionValue, compression);\n            }\n            else if (this.isRedirect()) {\n                estimate += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfNetworkRedirect)(this.optionValue, compression);\n            }\n            else {\n                estimate += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(this.optionValue);\n            }\n        }\n        return estimate;\n    }\n    /**\n     * Tries to recreate the original representation of the filter (adblock\n     * syntax) from the internal representation. If `rawLine` is set (when filters\n     * are parsed in `debug` mode for example), then it is returned directly.\n     * Otherwise, we try to stick as closely as possible to the original form;\n     * there are things which cannot be recovered though, like domains options\n     * of which only hashes are stored.\n     */\n    toString(modifierReplacer) {\n        if (this.rawLine !== undefined) {\n            return this.rawLine;\n        }\n        let filter = '';\n        if (this.isException()) {\n            filter += '@@';\n        }\n        if (this.isHostnameAnchor()) {\n            filter += '||';\n        }\n        else if (this.fromHttp() !== this.fromHttps()) {\n            if (this.fromHttp()) {\n                filter += '|http://';\n            }\n            else {\n                filter += '|https://';\n            }\n        }\n        else if (this.isLeftAnchor()) {\n            filter += '|';\n        }\n        if (this.hasHostname()) {\n            filter += this.getHostname();\n            filter += '^';\n        }\n        if (this.isFullRegex()) {\n            filter += `/${this.getRegex().source}/`;\n        }\n        else if (this.isRegex()) {\n            filter += this.getRegex().source;\n        }\n        else {\n            filter += this.getFilter();\n        }\n        if (this.isRightAnchor() && filter[filter.length - 1] !== '^') {\n            filter += '|';\n        }\n        // Options\n        const options = [];\n        if (this.fromAny() === false) {\n            const numberOfCptOptions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.bitCount)(this.getCptMask());\n            const numberOfNegatedOptions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.bitCount)(FROM_ANY) - numberOfCptOptions;\n            if (numberOfNegatedOptions < numberOfCptOptions) {\n                for (const type of getListOfRequestTypesNegated(this)) {\n                    options.push(`~${type}`);\n                }\n            }\n            else {\n                for (const type of getListOfRequestTypes(this)) {\n                    options.push(type);\n                }\n            }\n        }\n        if (this.isImportant()) {\n            options.push('important');\n        }\n        if (this.isRedirectRule()) {\n            if (this.optionValue === '') {\n                options.push('redirect-rule');\n            }\n            else {\n                options.push(`redirect-rule=${this.optionValue}`);\n            }\n        }\n        else if (this.isRedirect()) {\n            if (this.optionValue === '') {\n                options.push('redirect');\n            }\n            else {\n                options.push(`redirect=${this.optionValue}`);\n            }\n        }\n        if (this.isCSP()) {\n            options.push(`csp=${this.optionValue}`);\n        }\n        if (this.isElemHide()) {\n            options.push('elemhide');\n        }\n        if (this.isSpecificHide()) {\n            options.push('specifichide');\n        }\n        if (this.isGenericHide()) {\n            options.push('generichide');\n        }\n        if (this.firstParty() !== this.thirdParty()) {\n            if (this.firstParty()) {\n                options.push('1p');\n            }\n            if (this.thirdParty()) {\n                options.push('3p');\n            }\n        }\n        if (this.domains !== undefined) {\n            if (this.domains.parts !== undefined) {\n                options.push(`domain=${this.domains.parts}`);\n            }\n            else {\n                options.push('domain=<hashed>');\n            }\n        }\n        if (this.denyallow !== undefined) {\n            if (this.denyallow.parts !== undefined) {\n                options.push(`denyallow=${this.denyallow.parts}`);\n            }\n            else {\n                options.push('denyallow=<hashed>');\n            }\n        }\n        if (this.isBadFilter()) {\n            options.push('badfilter');\n        }\n        const removeparam = this.removeparam;\n        if (removeparam !== undefined) {\n            if (removeparam.length > 0) {\n                options.push(`removeparam=${removeparam}`);\n            }\n            else {\n                options.push('removeparam');\n            }\n        }\n        if (options.length > 0) {\n            if (typeof modifierReplacer === 'function') {\n                filter += `$${options.map(modifierReplacer).join(',')}`;\n            }\n            else {\n                filter += `$${options.join(',')}`;\n            }\n        }\n        return filter;\n    }\n    // Public API (Read-Only)\n    getIdWithoutBadFilter() {\n        // This method computes the id ignoring the $badfilter option (which will\n        // correspond to the ID of filters being discarded). This allows us to\n        // eliminate bad filters by comparing IDs, which is more robust and faster\n        // than string comparison.\n        return computeFilterId(this.mask & ~NETWORK_FILTER_MASK.isBadFilter, this.filter, this.hostname, this.domains, this.denyallow, this.optionValue);\n    }\n    getId() {\n        if (this.id === undefined) {\n            this.id = computeFilterId(this.mask, this.filter, this.hostname, this.domains, this.denyallow, this.optionValue);\n        }\n        return this.id;\n    }\n    hasFilter() {\n        return this.filter !== undefined;\n    }\n    hasDomains() {\n        return this.domains !== undefined;\n    }\n    getMask() {\n        return this.mask;\n    }\n    getCptMask() {\n        return this.getMask() & FROM_ANY;\n    }\n    isRedirect() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.getMask(), NETWORK_FILTER_MASK.isRedirect);\n    }\n    isRedirectRule() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.isRedirectRule);\n    }\n    getRedirect() {\n        var _a;\n        return (_a = this.optionValue) !== null && _a !== void 0 ? _a : '';\n    }\n    isReplace() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.getMask(), NETWORK_FILTER_MASK.isReplace);\n    }\n    isRemoveParam() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.getMask(), NETWORK_FILTER_MASK.isRemoveParam);\n    }\n    // Expected to be called only with `$replace` modifiers\n    getHtmlModifier() {\n        var _a;\n        // Empty `$replace` modifier is to disable all replace modifiers on exception\n        // This is checked on the parse time\n        if (((_a = this.optionValue) === null || _a === void 0 ? void 0 : _a.length) === 0) {\n            return null;\n        }\n        return replaceOptionValueToRegexp(this.optionValue);\n    }\n    isHtmlFilteringRule() {\n        return this.isReplace();\n    }\n    getRedirectResource() {\n        const redirect = this.getRedirect();\n        const priorityIndex = redirect.lastIndexOf(':');\n        if (priorityIndex === -1) {\n            return redirect;\n        }\n        return redirect.slice(0, priorityIndex);\n    }\n    getRedirectPriority() {\n        const redirect = this.getRedirect();\n        const priorityIndex = redirect.lastIndexOf(':');\n        if (priorityIndex === -1) {\n            return 0;\n        }\n        return Number(redirect.slice(priorityIndex + 1));\n    }\n    hasHostname() {\n        return this.hostname !== undefined;\n    }\n    getHostname() {\n        return this.hostname || '';\n    }\n    getFilter() {\n        return this.filter || '';\n    }\n    getRegex() {\n        if (this.regex === undefined) {\n            this.regex =\n                this.filter !== undefined && this.isRegex()\n                    ? compileRegex(this.filter, this.isLeftAnchor(), this.isRightAnchor(), this.isFullRegex())\n                    : MATCH_ALL;\n        }\n        return this.regex;\n    }\n    getTokens() {\n        _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_4__.TOKENS_BUFFER.reset();\n        // If there is only one domain and no domain negation, we also use this\n        // domain as a token.\n        if (this.domains !== undefined &&\n            this.domains.hostnames !== undefined &&\n            this.domains.entities === undefined &&\n            this.domains.notHostnames === undefined &&\n            this.domains.notEntities === undefined &&\n            this.domains.hostnames.length === 1) {\n            _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_4__.TOKENS_BUFFER.push(this.domains.hostnames[0]);\n        }\n        // Get tokens from filter\n        if (this.isFullRegex() === false) {\n            if (this.filter !== undefined) {\n                const skipLastToken = !this.isRightAnchor();\n                const skipFirstToken = !this.isLeftAnchor();\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.tokenizeWithWildcardsInPlace)(this.filter, skipFirstToken, skipLastToken, _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_4__.TOKENS_BUFFER);\n            }\n            // Append tokens from hostname, if any\n            if (this.hostname !== undefined) {\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.tokenizeInPlace)(this.hostname, false, this.filter !== undefined && this.filter.charCodeAt(0) === 42 /* '*' */, _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_4__.TOKENS_BUFFER);\n            }\n        }\n        else if (this.filter !== undefined) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.tokenizeRegexInPlace)(this.filter, _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_4__.TOKENS_BUFFER);\n        }\n        // If we got no tokens for the filter/hostname part, then we will dispatch\n        // this filter in multiple buckets based on the domains option.\n        if (_tokens_buffer_js__WEBPACK_IMPORTED_MODULE_4__.TOKENS_BUFFER.empty() === true &&\n            this.domains !== undefined &&\n            this.domains.hostnames !== undefined &&\n            this.domains.entities === undefined &&\n            this.domains.notHostnames === undefined &&\n            this.domains.notEntities === undefined) {\n            const result = [];\n            for (const hostname of this.domains.hostnames) {\n                const arr = new Uint32Array(1);\n                arr[0] = hostname;\n                result.push(arr);\n            }\n            return result;\n        }\n        // Add optional token for types\n        if (_tokens_buffer_js__WEBPACK_IMPORTED_MODULE_4__.TOKENS_BUFFER.empty() === true && this.fromAny() === false) {\n            const types = getListOfRequestTypes(this);\n            if (types.length !== 0) {\n                const result = [];\n                for (const type of types) {\n                    const arr = new Uint32Array(1);\n                    arr[0] = _request_js__WEBPACK_IMPORTED_MODULE_3__.NORMALIZED_TYPE_TOKEN[type];\n                    result.push(arr);\n                }\n                return result;\n            }\n        }\n        // Add optional token for protocol\n        if (this.fromHttp() === true && this.fromHttps() === false) {\n            _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_4__.TOKENS_BUFFER.push(HTTP_HASH);\n        }\n        else if (this.fromHttps() === true && this.fromHttp() === false) {\n            _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_4__.TOKENS_BUFFER.push(HTTPS_HASH);\n        }\n        return [_tokens_buffer_js__WEBPACK_IMPORTED_MODULE_4__.TOKENS_BUFFER.slice()];\n    }\n    /**\n     * Check if this filter should apply to a request with this content type.\n     */\n    isCptAllowed(cpt) {\n        const mask = REQUEST_TYPE_TO_MASK[cpt];\n        if (mask !== undefined) {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, mask);\n        }\n        // If content type is not supported (or not specified), we return `true`\n        // only if the filter does not specify any resource type.\n        return this.fromAny();\n    }\n    isException() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.isException);\n    }\n    isHostnameAnchor() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.isHostnameAnchor);\n    }\n    isRightAnchor() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.isRightAnchor);\n    }\n    isLeftAnchor() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.isLeftAnchor);\n    }\n    isImportant() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.isImportant);\n    }\n    isFullRegex() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.isFullRegex);\n    }\n    isRegex() {\n        return ((0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.isRegex) ||\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.isFullRegex));\n    }\n    isPlain() {\n        return !this.isRegex();\n    }\n    isCSP() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.isCSP);\n    }\n    isElemHide() {\n        return this.isSpecificHide() && this.isGenericHide();\n    }\n    isSpecificHide() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.isSpecificHide);\n    }\n    isGenericHide() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.isGenericHide);\n    }\n    isBadFilter() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.isBadFilter);\n    }\n    isUnicode() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.isUnicode);\n    }\n    fromAny() {\n        return this.getCptMask() === FROM_ANY;\n    }\n    thirdParty() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.thirdParty);\n    }\n    firstParty() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.firstParty);\n    }\n    fromImage() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.fromImage);\n    }\n    fromMedia() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.fromMedia);\n    }\n    fromObject() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.fromObject);\n    }\n    fromOther() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.fromOther);\n    }\n    fromPing() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.fromPing);\n    }\n    fromScript() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.fromScript);\n    }\n    fromStylesheet() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.fromStylesheet);\n    }\n    fromDocument() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.fromDocument);\n    }\n    fromSubdocument() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.fromSubdocument);\n    }\n    fromWebsocket() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.fromWebsocket);\n    }\n    fromHttp() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.fromHttp);\n    }\n    fromHttps() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.fromHttps);\n    }\n    fromXmlHttpRequest() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.fromXmlHttpRequest);\n    }\n    fromFont() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.getBit)(this.mask, NETWORK_FILTER_MASK.fromFont);\n    }\n}\n// ---------------------------------------------------------------------------\n// Filter parsing\n// ---------------------------------------------------------------------------\nfunction setNetworkMask(mask, m, value) {\n    if (value === true) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.setBit)(mask, m);\n    }\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.clearBit)(mask, m);\n}\n/**\n * Check if the sub-string contained between the indices start and end is a\n * regex filter (it contains a '*' or '^' char).\n */\nfunction checkIsRegex(filter, start, end) {\n    const indexOfSeparator = filter.indexOf('^', start);\n    if (indexOfSeparator !== -1 && indexOfSeparator < end) {\n        return true;\n    }\n    const indexOfWildcard = filter.indexOf('*', start);\n    return indexOfWildcard !== -1 && indexOfWildcard < end;\n}\n/**\n * Handle hostname anchored filters, given 'hostname' from ||hostname and\n * request's hostname, check if there is a match. This is tricky because\n * filters authors rely and different assumptions. We can have prefix of suffix\n * matches of anchor.\n */\nfunction isAnchoredByHostname(filterHostname, hostname, isFollowedByWildcard) {\n    // Corner-case, if `filterHostname` is empty, then it's a match\n    if (filterHostname.length === 0) {\n        return true;\n    }\n    // `filterHostname` cannot be longer than actual hostname\n    if (filterHostname.length > hostname.length) {\n        return false;\n    }\n    // If they have the same length, they should be equal\n    if (filterHostname.length === hostname.length) {\n        return filterHostname === hostname;\n    }\n    // Check if `filterHostname` appears anywhere in `hostname`\n    const matchIndex = hostname.indexOf(filterHostname);\n    // No match\n    if (matchIndex === -1) {\n        return false;\n    }\n    // `filterHostname` is a prefix of `hostname` and needs to match full a label.\n    //\n    // Examples (filterHostname, hostname):\n    //   * (foo, foo.com)\n    //   * (sub.foo, sub.foo.com)\n    if (matchIndex === 0) {\n        return (isFollowedByWildcard === true ||\n            hostname.charCodeAt(filterHostname.length) === 46 /* '.' */ ||\n            filterHostname.charCodeAt(filterHostname.length - 1) === 46 /* '.' */);\n    }\n    // `filterHostname` is a suffix of `hostname`.\n    //\n    // Examples (filterHostname, hostname):\n    //    * (foo.com, sub.foo.com)\n    //    * (com, foo.com)\n    if (hostname.length === matchIndex + filterHostname.length) {\n        return (hostname.charCodeAt(matchIndex - 1) === 46 /* '.' */ ||\n            filterHostname.charCodeAt(0) === 46 /* '.' */);\n    }\n    // `filterHostname` is infix of `hostname` and needs match full labels\n    return ((isFollowedByWildcard === true ||\n        hostname.charCodeAt(filterHostname.length) === 46 /* '.' */ ||\n        filterHostname.charCodeAt(filterHostname.length - 1) === 46) /* '.' */ &&\n        (hostname.charCodeAt(matchIndex - 1) === 46 || filterHostname.charCodeAt(0) === 46));\n}\n/**\n * Specialize a network filter depending on its type. It allows for more\n * efficient matching function.\n */\nfunction checkPattern(filter, request) {\n    const pattern = filter.getFilter();\n    const url = request.normalizedUrl;\n    if (filter.isHostnameAnchor() === true) {\n        // Make sure request is anchored by hostname before proceeding to matching\n        const filterHostname = filter.getHostname();\n        if (isAnchoredByHostname(filterHostname, request.hostname, filter.filter !== undefined && filter.filter.charCodeAt(0) === 42 /* '*' */) === false) {\n            return false;\n        }\n        // At this point we know request is hostname anchored so we match the rest of the filter.\n        if (filter.isRegex()) {\n            // ||pattern*^\n            return filter\n                .getRegex()\n                .test(url.slice(url.indexOf(filterHostname) + filterHostname.length));\n        }\n        else if (filter.isRightAnchor() && filter.isLeftAnchor()) {\n            // |||pattern|\n            // Since this is not a regex, the filter pattern must follow the hostname\n            // with nothing in between. So we extract the part of the URL following\n            // after hostname and will perform the matching on it.\n            const urlAfterHostname = url.slice(url.indexOf(filterHostname) + filterHostname.length);\n            // Since it must follow immediatly after the hostname and be a suffix of\n            // the URL, we conclude that filter must be equal to the part of the\n            // url following the hostname.\n            return pattern === urlAfterHostname;\n        }\n        else if (filter.isRightAnchor()) {\n            // ||pattern|\n            const requestHostname = request.hostname;\n            if (filter.hasFilter() === false) {\n                // In this specific case it means that the specified hostname should match\n                // at the end of the hostname of the request. This allows to prevent false\n                // positive like ||foo.bar which would match https://foo.bar.baz where\n                // ||foo.bar^ would not.\n                return (filterHostname.length === requestHostname.length ||\n                    requestHostname.endsWith(filterHostname));\n            }\n            else {\n                // pattern|\n                return url.endsWith(pattern);\n            }\n        }\n        else if (filter.isLeftAnchor()) {\n            // ||pattern + left-anchor => This means that a plain pattern needs to appear\n            // exactly after the hostname, with nothing in between.\n            // Since this is not a regex, the filter pattern must follow the hostname\n            // with nothing in between. So we extract the part of the URL following\n            // after hostname and will perform the matching on it.\n            return url.startsWith(pattern, url.indexOf(filterHostname) + filterHostname.length);\n        }\n        if (filter.hasFilter() === false) {\n            return true;\n        }\n        // We consider this a match if the plain patter (i.e.: filter) appears anywhere.\n        return url.indexOf(pattern, url.indexOf(filterHostname) + filterHostname.length) !== -1;\n    }\n    else if (filter.isRegex()) {\n        // pattern*^\n        return filter.getRegex().test(url);\n    }\n    else if (filter.isLeftAnchor() && filter.isRightAnchor()) {\n        // |pattern|\n        return url === pattern;\n    }\n    else if (filter.isLeftAnchor()) {\n        // |pattern\n        return url.startsWith(pattern);\n    }\n    else if (filter.isRightAnchor()) {\n        // pattern|\n        return url.endsWith(pattern);\n    }\n    // pattern\n    if (filter.hasFilter() === false) {\n        return true;\n    }\n    return url.indexOf(pattern) !== -1;\n}\nfunction checkOptions(filter, request) {\n    // We first discard requests based on type, protocol and party. This is really\n    // cheap and should be done first.\n    if (filter.isCptAllowed(request.type) === false ||\n        (request.isHttps === true && filter.fromHttps() === false) ||\n        (request.isHttp === true && filter.fromHttp() === false) ||\n        (filter.firstParty() === false && request.isFirstParty === true) ||\n        (filter.thirdParty() === false && request.isThirdParty === true)) {\n        return false;\n    }\n    // If `sourceHostname` is *not* matched by `domain` then the request should be allowed.\n    if (filter.domains !== undefined &&\n        filter.domains.match(request.sourceHostnameHashes, request.sourceEntityHashes) === false) {\n        return false;\n    }\n    // If `hostname` is matched by `denyallow` then the request should be allowed.\n    if (filter.denyallow !== undefined &&\n        filter.denyallow.match(request.getHostnameHashes(), request.getEntityHashes()) === true) {\n        return false;\n    }\n    return true;\n}\n//# sourceMappingURL=network.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9maWx0ZXJzL25ldHdvcmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQztBQUNzRztBQUM1RztBQUNhO0FBQ0Y7QUFDNkw7QUFDalAsa0JBQWtCLG1EQUFRO0FBQzFCLG1CQUFtQixtREFBUTtBQUMzQjtBQUNBLFlBQVksa0RBQU8sUUFBUSxrREFBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1DQUFtQyxHQUFHLGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFTLEdBQUcseURBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQywyQkFBMkIseURBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0MsMkJBQTJCLHlEQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hELDJCQUEyQix5REFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0Msc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrREFBa0Q7QUFDbEQseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEVBQWlDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpREFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbURBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1EQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtREFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbURBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaURBQU07QUFDckM7QUFDQSxtQ0FBbUMsaURBQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpREFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaURBQU07QUFDckMsK0JBQStCLGlEQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpREFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaURBQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpREFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpREFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpREFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpREFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpREFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1EQUFRO0FBQ3REO0FBQ0E7QUFDQSw4Q0FBOEMsaURBQU07QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVEQUFPO0FBQ2pDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVEQUFPO0FBQ25DO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBTTtBQUN6QjtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFNO0FBQ3pCO0FBQ0E7QUFDQSxtQkFBbUIsaURBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLG1CQUFtQixpREFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaURBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlEQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpREFBTTtBQUN6QztBQUNBO0FBQ0EsbUNBQW1DLGlEQUFNO0FBQ3pDLG1DQUFtQyxpREFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaURBQU07QUFDckM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBTTtBQUN0QjtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBTTtBQUN0QjtBQUNBO0FBQ0EsMkJBQTJCLGlEQUFNO0FBQ2pDLDJCQUEyQixtREFBUTtBQUNuQywyQkFBMkIsbURBQVE7QUFDbkMsMkJBQTJCLG1EQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlEQUFNO0FBQ2pDLDJCQUEyQixtREFBUTtBQUNuQywyQkFBMkIsbURBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaURBQU07QUFDakMsMkJBQTJCLG1EQUFRO0FBQ25DLDJCQUEyQixtREFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpREFBTTtBQUNqQywyQkFBMkIsaURBQU07QUFDakMsMkJBQTJCLG1EQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUscURBQVU7QUFDckYsb0JBQW9CLGlEQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFVO0FBQzlCO0FBQ0EsK0JBQStCLHFEQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlEQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsdURBQU87QUFDeEQ7QUFDQSxxREFBcUQsdURBQU87QUFDNUQ7QUFDQSxrQkFBa0IsaURBQU07QUFDeEI7QUFDQSxzQkFBc0IsaURBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsMEVBQTBFO0FBQzVGO0FBQ0E7QUFDQSxvQkFBb0IsaURBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsNEJBQTRCLHlEQUFVO0FBQ3RDO0FBQ0E7QUFDQSw0QkFBNEIsa0VBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvRUFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrREFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUFnQjtBQUM1QztBQUNBO0FBQ0EsNEJBQTRCLG9FQUFxQjtBQUNqRDtBQUNBO0FBQ0EsNEJBQTRCLHlEQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbURBQVE7QUFDL0MsMkNBQTJDLG1EQUFRO0FBQ25EO0FBQ0E7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxpQkFBaUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUJBQWlCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3Q0FBd0M7QUFDdEU7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQU07QUFDckI7QUFDQTtBQUNBLGVBQWUsaURBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1RUFBNEIsNkNBQTZDLDREQUFhO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwREFBZSxnR0FBZ0csNERBQWE7QUFDNUk7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBb0IsY0FBYyw0REFBYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOERBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0REFBYTtBQUN6QjtBQUNBO0FBQ0EsWUFBWSw0REFBYTtBQUN6QjtBQUNBLGdCQUFnQiw0REFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLGlEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQU07QUFDdEIsWUFBWSxpREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxpREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQU07QUFDckI7QUFDQSxXQUFXLG1EQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9maWx0ZXJzL25ldHdvcmsuanM/N2Y4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50IEdob3N0ZXJ5IEdtYkguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmltcG9ydCB7IERvbWFpbnMgfSBmcm9tICcuLi9lbmdpbmUvZG9tYWlucy5qcyc7XG5pbXBvcnQgeyBzaXplT2ZOZXR3b3JrRmlsdGVyLCBzaXplT2ZOZXR3b3JrSG9zdG5hbWUsIHNpemVPZlVURjgsIHNpemVPZlJhd05ldHdvcmssIHNpemVPZk5ldHdvcmtDU1AsIHNpemVPZk5ldHdvcmtSZWRpcmVjdCwgfSBmcm9tICcuLi9kYXRhLXZpZXcuanMnO1xuaW1wb3J0IHsgdG9BU0NJSSB9IGZyb20gJy4uL3B1bnljb2RlLmpzJztcbmltcG9ydCB7IE5PUk1BTElaRURfVFlQRV9UT0tFTiB9IGZyb20gJy4uL3JlcXVlc3QuanMnO1xuaW1wb3J0IHsgVE9LRU5TX0JVRkZFUiB9IGZyb20gJy4uL3Rva2Vucy1idWZmZXIuanMnO1xuaW1wb3J0IHsgYml0Q291bnQsIGNsZWFyQml0LCBmYXN0SGFzaCwgZ2V0Qml0LCBoYXNVbmljb2RlLCBpc0FscGhhLCBpc0RpZ2l0LCBzZXRCaXQsIHRva2VuaXplSW5QbGFjZSwgdG9rZW5pemVSZWdleEluUGxhY2UsIHRva2VuaXplV2l0aFdpbGRjYXJkc0luUGxhY2UsIEhBU0hfU0VFRCwgSEFTSF9JTlRFUk5BTF9NVUxULCBmaW5kTGFzdEluZGV4T2ZVbmVzY2FwZWRDaGFyYWN0ZXIsIH0gZnJvbSAnLi4vdXRpbHMuanMnO1xuY29uc3QgSFRUUF9IQVNIID0gZmFzdEhhc2goJ2h0dHAnKTtcbmNvbnN0IEhUVFBTX0hBU0ggPSBmYXN0SGFzaCgnaHR0cHMnKTtcbmZ1bmN0aW9uIGlzQWxsb3dlZEhvc3RuYW1lKGNoKSB7XG4gICAgcmV0dXJuIChpc0RpZ2l0KGNoKSB8fCBpc0FscGhhKGNoKSB8fCBjaCA9PT0gOTUgLyogJ18nICovIHx8IGNoID09PSA0NSAvKiAnLScgKi8gfHwgY2ggPT09IDQ2IC8qICcuJyAqLyk7XG59XG5jb25zdCBOT1JNQUxJWkVfT1BUSU9OUyA9IHtcbiAgICAnZG9jdW1lbnQnOiAnZG9jJyxcbiAgICAnZmlyc3QtcGFydHknOiAnMXAnLFxuICAgICdnZW5lcmljaGlkZSc6ICdnaGlkZScsXG4gICAgJ29iamVjdC1zdWJyZXF1ZXN0JzogJ29iamVjdCcsXG4gICAgJ3N0eWxlc2hlZXQnOiAnY3NzJyxcbiAgICAnc3ViZG9jdW1lbnQnOiAnZnJhbWUnLFxuICAgICd0aGlyZC1wYXJ0eSc6ICczcCcsXG4gICAgJ3htbGh0dHByZXF1ZXN0JzogJ3hocicsXG4gICAgJ35maXJzdC1wYXJ0eSc6ICczcCcsXG4gICAgJ350aGlyZC1wYXJ0eSc6ICcxcCcsXG4gICAgJ2FsbCc6ICcnLFxufTtcbi8qKlxuICogTm9ybWFsaXplIGEgcmF3IGZpbHRlciBieSByZXBsYWNpbmcgb3B0aW9ucyB3aXRoIHRoZWlyIGNhbm9uaWNhbCBmb3Jtcy4gRm9yXG4gKiBleGFtcGxlIGB8fGZvby5jb20kc3R5bGVzaGVldCxmaXJzdC1wYXJ0eSx4aHJgIHdvdWxkIGJlIG5vcm1hbGl6ZWQgdG9cbiAqIGB8fGZvby5jb20kY3NzLDFwLHhocmAuXG4gKi9cbmNvbnN0IFJFR0VYID0gL2FsbHx+dGhpcmQtcGFydHl8fmZpcnN0LXBhcnR5fHRoaXJkLXBhcnR5fGZpcnN0LXBhcnR5fG9iamVjdC1zdWJyZXF1ZXN0fHN0eWxlc2hlZXR8c3ViZG9jdW1lbnR8eG1saHR0cHJlcXVlc3R8ZG9jdW1lbnR8Z2VuZXJpY2hpZGUvZztcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVSYXdGaWx0ZXJPcHRpb25zKHJhd0ZpbHRlcikge1xuICAgIHJhd0ZpbHRlciA9IHJhd0ZpbHRlci50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCBpbmRleE9mT3B0aW9ucyA9IHJhd0ZpbHRlci5sYXN0SW5kZXhPZignJCcpO1xuICAgIGlmIChpbmRleE9mT3B0aW9ucyA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHJhd0ZpbHRlcjtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRyYWlsaW5nICcqJyBpZiBwb3NzaWJsZVxuICAgIGlmIChpbmRleE9mT3B0aW9ucyAhPT0gMCAmJiByYXdGaWx0ZXJbaW5kZXhPZk9wdGlvbnMgLSAxXSA9PT0gJyonKSB7XG4gICAgICAgIHJhd0ZpbHRlciA9IHJhd0ZpbHRlci5zbGljZSgwLCBpbmRleE9mT3B0aW9ucyAtIDEpICsgcmF3RmlsdGVyLnNsaWNlKGluZGV4T2ZPcHRpb25zKTtcbiAgICAgICAgaW5kZXhPZk9wdGlvbnMgLT0gMTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIG9wdGlvbnNcbiAgICBjb25zdCBvcHRpb25zID0gcmF3RmlsdGVyLnNsaWNlKGluZGV4T2ZPcHRpb25zICsgMSk7XG4gICAgY29uc3Qgbm9ybWFsaXplZE9wdGlvbnMgPSBvcHRpb25zXG4gICAgICAgIC5yZXBsYWNlKFJFR0VYLCAob3B0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBOT1JNQUxJWkVfT1BUSU9OU1tvcHRpb25dO1xuICAgICAgICBpZiAobm9ybWFsaXplZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH0pXG4gICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLmpvaW4oJywnKTtcbiAgICBpZiAob3B0aW9ucyA9PT0gbm9ybWFsaXplZE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHJhd0ZpbHRlcjtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWRPcHRpb25zID09PSAnJykge1xuICAgICAgICByZXR1cm4gcmF3RmlsdGVyLnNsaWNlKDAsIGluZGV4T2ZPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3Jhd0ZpbHRlci5zbGljZSgwLCBpbmRleE9mT3B0aW9ucyl9JCR7bm9ybWFsaXplZE9wdGlvbnN9YDtcbn1cbi8qKlxuICogTWFza3MgdXNlZCB0byBzdG9yZSBvcHRpb25zIG9mIG5ldHdvcmsgZmlsdGVycyBpbiBhIGJpdG1hc2suXG4gKi9cbmV4cG9ydCB2YXIgTkVUV09SS19GSUxURVJfTUFTSztcbihmdW5jdGlvbiAoTkVUV09SS19GSUxURVJfTUFTSykge1xuICAgIC8vIFJlcXVlc3QgVHlwZVxuICAgIE5FVFdPUktfRklMVEVSX01BU0tbTkVUV09SS19GSUxURVJfTUFTS1tcImZyb21Eb2N1bWVudFwiXSA9IDFdID0gXCJmcm9tRG9jdW1lbnRcIjtcbiAgICBORVRXT1JLX0ZJTFRFUl9NQVNLW05FVFdPUktfRklMVEVSX01BU0tbXCJmcm9tRm9udFwiXSA9IDJdID0gXCJmcm9tRm9udFwiO1xuICAgIE5FVFdPUktfRklMVEVSX01BU0tbTkVUV09SS19GSUxURVJfTUFTS1tcImZyb21IdHRwXCJdID0gNF0gPSBcImZyb21IdHRwXCI7XG4gICAgTkVUV09SS19GSUxURVJfTUFTS1tORVRXT1JLX0ZJTFRFUl9NQVNLW1wiZnJvbUh0dHBzXCJdID0gOF0gPSBcImZyb21IdHRwc1wiO1xuICAgIE5FVFdPUktfRklMVEVSX01BU0tbTkVUV09SS19GSUxURVJfTUFTS1tcImZyb21JbWFnZVwiXSA9IDE2XSA9IFwiZnJvbUltYWdlXCI7XG4gICAgTkVUV09SS19GSUxURVJfTUFTS1tORVRXT1JLX0ZJTFRFUl9NQVNLW1wiZnJvbU1lZGlhXCJdID0gMzJdID0gXCJmcm9tTWVkaWFcIjtcbiAgICBORVRXT1JLX0ZJTFRFUl9NQVNLW05FVFdPUktfRklMVEVSX01BU0tbXCJmcm9tT2JqZWN0XCJdID0gNjRdID0gXCJmcm9tT2JqZWN0XCI7XG4gICAgTkVUV09SS19GSUxURVJfTUFTS1tORVRXT1JLX0ZJTFRFUl9NQVNLW1wiZnJvbU90aGVyXCJdID0gMTI4XSA9IFwiZnJvbU90aGVyXCI7XG4gICAgTkVUV09SS19GSUxURVJfTUFTS1tORVRXT1JLX0ZJTFRFUl9NQVNLW1wiZnJvbVBpbmdcIl0gPSAyNTZdID0gXCJmcm9tUGluZ1wiO1xuICAgIE5FVFdPUktfRklMVEVSX01BU0tbTkVUV09SS19GSUxURVJfTUFTS1tcImZyb21TY3JpcHRcIl0gPSA1MTJdID0gXCJmcm9tU2NyaXB0XCI7XG4gICAgTkVUV09SS19GSUxURVJfTUFTS1tORVRXT1JLX0ZJTFRFUl9NQVNLW1wiZnJvbVN0eWxlc2hlZXRcIl0gPSAxMDI0XSA9IFwiZnJvbVN0eWxlc2hlZXRcIjtcbiAgICBORVRXT1JLX0ZJTFRFUl9NQVNLW05FVFdPUktfRklMVEVSX01BU0tbXCJmcm9tU3ViZG9jdW1lbnRcIl0gPSAyMDQ4XSA9IFwiZnJvbVN1YmRvY3VtZW50XCI7XG4gICAgTkVUV09SS19GSUxURVJfTUFTS1tORVRXT1JLX0ZJTFRFUl9NQVNLW1wiZnJvbVdlYnNvY2tldFwiXSA9IDQwOTZdID0gXCJmcm9tV2Vic29ja2V0XCI7XG4gICAgTkVUV09SS19GSUxURVJfTUFTS1tORVRXT1JLX0ZJTFRFUl9NQVNLW1wiZnJvbVhtbEh0dHBSZXF1ZXN0XCJdID0gODE5Ml0gPSBcImZyb21YbWxIdHRwUmVxdWVzdFwiO1xuICAgIC8vIFBhcnRpbmVzc1xuICAgIE5FVFdPUktfRklMVEVSX01BU0tbTkVUV09SS19GSUxURVJfTUFTS1tcImZpcnN0UGFydHlcIl0gPSAxNjM4NF0gPSBcImZpcnN0UGFydHlcIjtcbiAgICBORVRXT1JLX0ZJTFRFUl9NQVNLW05FVFdPUktfRklMVEVSX01BU0tbXCJ0aGlyZFBhcnR5XCJdID0gMzI3NjhdID0gXCJ0aGlyZFBhcnR5XCI7XG4gICAgLy8gT3B0aW9uc1xuICAgIC8vIGlzUmVwbGFjZSBkb2VzIG5vdCBmaXQgdG8gdGhlIG9wdGlvbnMsIGJ1dCBpcyBoZXJlIGZyb20gYSBsYWNrIG9mIGVtcHR5IE1BU0sgc2xvdHNcbiAgICBORVRXT1JLX0ZJTFRFUl9NQVNLW05FVFdPUktfRklMVEVSX01BU0tbXCJpc1JlcGxhY2VcIl0gPSA2NTUzNl0gPSBcImlzUmVwbGFjZVwiO1xuICAgIE5FVFdPUktfRklMVEVSX01BU0tbTkVUV09SS19GSUxURVJfTUFTS1tcImlzQmFkRmlsdGVyXCJdID0gMTMxMDcyXSA9IFwiaXNCYWRGaWx0ZXJcIjtcbiAgICBORVRXT1JLX0ZJTFRFUl9NQVNLW05FVFdPUktfRklMVEVSX01BU0tbXCJpc0NTUFwiXSA9IDI2MjE0NF0gPSBcImlzQ1NQXCI7XG4gICAgTkVUV09SS19GSUxURVJfTUFTS1tORVRXT1JLX0ZJTFRFUl9NQVNLW1wiaXNHZW5lcmljSGlkZVwiXSA9IDUyNDI4OF0gPSBcImlzR2VuZXJpY0hpZGVcIjtcbiAgICBORVRXT1JLX0ZJTFRFUl9NQVNLW05FVFdPUktfRklMVEVSX01BU0tbXCJpc0ltcG9ydGFudFwiXSA9IDEwNDg1NzZdID0gXCJpc0ltcG9ydGFudFwiO1xuICAgIE5FVFdPUktfRklMVEVSX01BU0tbTkVUV09SS19GSUxURVJfTUFTS1tcImlzU3BlY2lmaWNIaWRlXCJdID0gMjA5NzE1Ml0gPSBcImlzU3BlY2lmaWNIaWRlXCI7XG4gICAgLy8gS2luZCBvZiBwYXR0ZXJuc1xuICAgIE5FVFdPUktfRklMVEVSX01BU0tbTkVUV09SS19GSUxURVJfTUFTS1tcImlzRnVsbFJlZ2V4XCJdID0gNDE5NDMwNF0gPSBcImlzRnVsbFJlZ2V4XCI7XG4gICAgTkVUV09SS19GSUxURVJfTUFTS1tORVRXT1JLX0ZJTFRFUl9NQVNLW1wiaXNSZWdleFwiXSA9IDgzODg2MDhdID0gXCJpc1JlZ2V4XCI7XG4gICAgTkVUV09SS19GSUxURVJfTUFTS1tORVRXT1JLX0ZJTFRFUl9NQVNLW1wiaXNVbmljb2RlXCJdID0gMTY3NzcyMTZdID0gXCJpc1VuaWNvZGVcIjtcbiAgICBORVRXT1JLX0ZJTFRFUl9NQVNLW05FVFdPUktfRklMVEVSX01BU0tbXCJpc0xlZnRBbmNob3JcIl0gPSAzMzU1NDQzMl0gPSBcImlzTGVmdEFuY2hvclwiO1xuICAgIE5FVFdPUktfRklMVEVSX01BU0tbTkVUV09SS19GSUxURVJfTUFTS1tcImlzUmlnaHRBbmNob3JcIl0gPSA2NzEwODg2NF0gPSBcImlzUmlnaHRBbmNob3JcIjtcbiAgICBORVRXT1JLX0ZJTFRFUl9NQVNLW05FVFdPUktfRklMVEVSX01BU0tbXCJpc0V4Y2VwdGlvblwiXSA9IDEzNDIxNzcyOF0gPSBcImlzRXhjZXB0aW9uXCI7XG4gICAgTkVUV09SS19GSUxURVJfTUFTS1tORVRXT1JLX0ZJTFRFUl9NQVNLW1wiaXNIb3N0bmFtZUFuY2hvclwiXSA9IDI2ODQzNTQ1Nl0gPSBcImlzSG9zdG5hbWVBbmNob3JcIjtcbiAgICBORVRXT1JLX0ZJTFRFUl9NQVNLW05FVFdPUktfRklMVEVSX01BU0tbXCJpc1JlZGlyZWN0UnVsZVwiXSA9IDUzNjg3MDkxMl0gPSBcImlzUmVkaXJlY3RSdWxlXCI7XG4gICAgTkVUV09SS19GSUxURVJfTUFTS1tORVRXT1JLX0ZJTFRFUl9NQVNLW1wiaXNSZWRpcmVjdFwiXSA9IDEwNzM3NDE4MjRdID0gXCJpc1JlZGlyZWN0XCI7XG4gICAgTkVUV09SS19GSUxURVJfTUFTS1tORVRXT1JLX0ZJTFRFUl9NQVNLW1wiaXNSZW1vdmVQYXJhbVwiXSA9IC0yMTQ3NDgzNjQ4XSA9IFwiaXNSZW1vdmVQYXJhbVwiO1xuICAgIC8vIElNUE9SVEFOVDogdGhlIG1hc2sgaXMgbm93IGZ1bGwsIG5vIG1vcmUgb3B0aW9ucyBjYW4gYmUgYWRkZWRcbiAgICAvLyBDb25zaWRlciBjcmVhdGluZyBhIHNlcGFyYXRlIGZpdGxlciB0eXBlIGZvciBpc1JlcGxhY2UgaWYgYSBuZXdcbiAgICAvLyBuZXR3b3JrIGZpbHRlciBvcHRpb24gaXMgbmVlZGVkLlxufSkoTkVUV09SS19GSUxURVJfTUFTSyB8fCAoTkVUV09SS19GSUxURVJfTUFTSyA9IHt9KSk7XG4vKipcbiAqIE1hc2sgdXNlZCB3aGVuIGEgbmV0d29yayBmaWx0ZXIgY2FuIGJlIGFwcGxpZWQgb24gYW55IGNvbnRlbnQgdHlwZS5cbiAqL1xuY29uc3QgRlJPTV9BTlkgPSBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21Eb2N1bWVudCB8XG4gICAgTkVUV09SS19GSUxURVJfTUFTSy5mcm9tRm9udCB8XG4gICAgTkVUV09SS19GSUxURVJfTUFTSy5mcm9tSW1hZ2UgfFxuICAgIE5FVFdPUktfRklMVEVSX01BU0suZnJvbU1lZGlhIHxcbiAgICBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21PYmplY3QgfFxuICAgIE5FVFdPUktfRklMVEVSX01BU0suZnJvbU90aGVyIHxcbiAgICBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21QaW5nIHxcbiAgICBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21TY3JpcHQgfFxuICAgIE5FVFdPUktfRklMVEVSX01BU0suZnJvbVN0eWxlc2hlZXQgfFxuICAgIE5FVFdPUktfRklMVEVSX01BU0suZnJvbVN1YmRvY3VtZW50IHxcbiAgICBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21XZWJzb2NrZXQgfFxuICAgIE5FVFdPUktfRklMVEVSX01BU0suZnJvbVhtbEh0dHBSZXF1ZXN0O1xuLyoqXG4gKiBNYXAgY29udGVudCB0eXBlIHZhbHVlIHRvIG1hc2sgdGhlIGNvcnJlc3BvbmRpbmcgbWFzay5cbiAqIHJlZjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Nb3ppbGxhL1RlY2gvWFBDT00vUmVmZXJlbmNlL0ludGVyZmFjZS9uc0lDb250ZW50UG9saWN5XG4gKi9cbmNvbnN0IFJFUVVFU1RfVFlQRV9UT19NQVNLID0ge1xuICAgIGJlYWNvbjogTkVUV09SS19GSUxURVJfTUFTSy5mcm9tUGluZywgLy8gZnJvbU90aGVyP1xuICAgIGRvY3VtZW50OiBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21Eb2N1bWVudCxcbiAgICBjc3B2aW9sYXRpb25yZXBvcnQ6IE5FVFdPUktfRklMVEVSX01BU0suZnJvbU90aGVyLFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZWRDTV9BUEkvSURQX2ludGVncmF0aW9uI3Byb3ZpZGVfYV9jb25maWdfZmlsZV9hbmRfZW5kcG9pbnRzXG4gICAgLy8gRmVkQ00gY29uZmlndXJhdGlvbiBmaWxlIGlzIHJlc29sdmVkIGFzIGEgSlNPTiBtb2R1bGUsIHdoaWNoIGlzIGludGVycHJldGVkIGFzIGEgXCJzY3JpcHRcIi5cbiAgICAvLyBTb21lIG9mIEZlZENNIHJlbGF0ZWQgcmVxdWVzdHMgYXJlIHJlc29sdmVkIGFzIFwieGhyL2ZldGNoXCIgYnV0IHdlIHVzZSBcInNjcmlwdFwiIHRvIGFkZCB3ZWlnaHQgdG8gdGhlIG1lYW5pbmcgb2YgXCJzdGFuZGFyZGlzZWRcIiBtb2R1bGUgYmVoYXZpb3IgaW4gYnJvd3Nlci1zaWRlLlxuICAgIGZlZGNtOiBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21TY3JpcHQsXG4gICAgZmV0Y2g6IE5FVFdPUktfRklMVEVSX01BU0suZnJvbVhtbEh0dHBSZXF1ZXN0LFxuICAgIGZvbnQ6IE5FVFdPUktfRklMVEVSX01BU0suZnJvbUZvbnQsXG4gICAgaW1hZ2U6IE5FVFdPUktfRklMVEVSX01BU0suZnJvbUltYWdlLFxuICAgIGltYWdlc2V0OiBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21JbWFnZSxcbiAgICAvLyBodHRwczovL3NlYXJjaGZveC5vcmcvbW96aWxsYS1jZW50cmFsL3Jldi9mY2ZiNTU4Zjg5NDZmMzY0OGQ5NjI1NzYxMjVhZjQ2YmY2ZTI5MTBhL3Rvb2xraXQvY29tcG9uZW50cy9leHRlbnNpb25zL3NjaGVtYXMvd2ViX3JlcXVlc3QuanNvblxuICAgIC8vIFRoaXMgaXMgZm9yIEpTT04gbW9kdWxlcyBmcm9tIGltcG9ydCBzdGF0ZW1lbnRzLlxuICAgIC8vIE91ciBgTkVUV09SS19GSUxURVJfTUFTS2AgaXMgYWxyZWFkeSBmdWxsIGFuZCB3ZSBjYW4gdHJlYXQgdGhpcyBhcyBhIHNjcmlwdCByZXF1ZXN0LlxuICAgIGpzb246IE5FVFdPUktfRklMVEVSX01BU0suZnJvbVNjcmlwdCxcbiAgICBtYWluRnJhbWU6IE5FVFdPUktfRklMVEVSX01BU0suZnJvbURvY3VtZW50LFxuICAgIG1haW5fZnJhbWU6IE5FVFdPUktfRklMVEVSX01BU0suZnJvbURvY3VtZW50LFxuICAgIG1lZGlhOiBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21NZWRpYSxcbiAgICBvYmplY3Q6IE5FVFdPUktfRklMVEVSX01BU0suZnJvbU9iamVjdCxcbiAgICBvYmplY3Rfc3VicmVxdWVzdDogTkVUV09SS19GSUxURVJfTUFTSy5mcm9tT2JqZWN0LFxuICAgIHBpbmc6IE5FVFdPUktfRklMVEVSX01BU0suZnJvbVBpbmcsIC8vIGZyb21PdGhlcj9cbiAgICBzY3JpcHQ6IE5FVFdPUktfRklMVEVSX01BU0suZnJvbVNjcmlwdCxcbiAgICBzdHlsZXNoZWV0OiBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21TdHlsZXNoZWV0LFxuICAgIHN1YkZyYW1lOiBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21TdWJkb2N1bWVudCxcbiAgICBzdWJfZnJhbWU6IE5FVFdPUktfRklMVEVSX01BU0suZnJvbVN1YmRvY3VtZW50LFxuICAgIHdlYlNvY2tldDogTkVUV09SS19GSUxURVJfTUFTSy5mcm9tV2Vic29ja2V0LFxuICAgIHdlYnNvY2tldDogTkVUV09SS19GSUxURVJfTUFTSy5mcm9tV2Vic29ja2V0LFxuICAgIHhocjogTkVUV09SS19GSUxURVJfTUFTSy5mcm9tWG1sSHR0cFJlcXVlc3QsXG4gICAgeG1saHR0cHJlcXVlc3Q6IE5FVFdPUktfRklMVEVSX01BU0suZnJvbVhtbEh0dHBSZXF1ZXN0LFxuICAgIC8vIE90aGVyXG4gICAgY3NwUmVwb3J0OiBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21PdGhlcixcbiAgICBjc3BfcmVwb3J0OiBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21PdGhlcixcbiAgICBldmVudHNvdXJjZTogTkVUV09SS19GSUxURVJfTUFTSy5mcm9tT3RoZXIsXG4gICAgbWFuaWZlc3Q6IE5FVFdPUktfRklMVEVSX01BU0suZnJvbU90aGVyLFxuICAgIG90aGVyOiBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21PdGhlcixcbiAgICBwcmVmZXRjaDogTkVUV09SS19GSUxURVJfTUFTSy5mcm9tT3RoZXIsXG4gICAgcHJlZmxpZ2h0OiBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21PdGhlcixcbiAgICBzaWduZWRleGNoYW5nZTogTkVUV09SS19GSUxURVJfTUFTSy5mcm9tT3RoZXIsXG4gICAgc3BlY3VsYXRpdmU6IE5FVFdPUktfRklMVEVSX01BU0suZnJvbU90aGVyLFxuICAgIHRleHR0cmFjazogTkVUV09SS19GSUxURVJfTUFTSy5mcm9tT3RoZXIsXG4gICAgd2ViX21hbmlmZXN0OiBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21PdGhlcixcbiAgICB4bWxfZHRkOiBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21PdGhlcixcbiAgICB4c2x0OiBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21PdGhlcixcbn07XG5mdW5jdGlvbiBnZXRMaXN0T2ZSZXF1ZXN0VHlwZXNOZWdhdGVkKGZpbHRlcikge1xuICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgaWYgKGZpbHRlci5mcm9tRG9jdW1lbnQoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdHlwZXMucHVzaCgnZG9jdW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlci5mcm9tSW1hZ2UoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdHlwZXMucHVzaCgnaW1hZ2UnKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlci5mcm9tTWVkaWEoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdHlwZXMucHVzaCgnbWVkaWEnKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlci5mcm9tT2JqZWN0KCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHR5cGVzLnB1c2goJ29iamVjdCcpO1xuICAgIH1cbiAgICBpZiAoZmlsdGVyLmZyb21PdGhlcigpID09PSBmYWxzZSkge1xuICAgICAgICB0eXBlcy5wdXNoKCdvdGhlcicpO1xuICAgIH1cbiAgICBpZiAoZmlsdGVyLmZyb21QaW5nKCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHR5cGVzLnB1c2goJ3BpbmcnKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlci5mcm9tU2NyaXB0KCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHR5cGVzLnB1c2goJ3NjcmlwdCcpO1xuICAgIH1cbiAgICBpZiAoZmlsdGVyLmZyb21TdHlsZXNoZWV0KCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHR5cGVzLnB1c2goJ3N0eWxlc2hlZXQnKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlci5mcm9tU3ViZG9jdW1lbnQoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdHlwZXMucHVzaCgnc3ViX2ZyYW1lJyk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXIuZnJvbVdlYnNvY2tldCgpID09PSBmYWxzZSkge1xuICAgICAgICB0eXBlcy5wdXNoKCd3ZWJzb2NrZXQnKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlci5mcm9tWG1sSHR0cFJlcXVlc3QoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdHlwZXMucHVzaCgneGhyJyk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXIuZnJvbUZvbnQoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdHlwZXMucHVzaCgnZm9udCcpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZXM7XG59XG5mdW5jdGlvbiBnZXRMaXN0T2ZSZXF1ZXN0VHlwZXMoZmlsdGVyKSB7XG4gICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICBpZiAoZmlsdGVyLmZyb21Eb2N1bWVudCgpKSB7XG4gICAgICAgIHR5cGVzLnB1c2goJ2RvY3VtZW50Jyk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXIuZnJvbUltYWdlKCkpIHtcbiAgICAgICAgdHlwZXMucHVzaCgnaW1hZ2UnKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlci5mcm9tTWVkaWEoKSkge1xuICAgICAgICB0eXBlcy5wdXNoKCdtZWRpYScpO1xuICAgIH1cbiAgICBpZiAoZmlsdGVyLmZyb21PYmplY3QoKSkge1xuICAgICAgICB0eXBlcy5wdXNoKCdvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlci5mcm9tT3RoZXIoKSkge1xuICAgICAgICB0eXBlcy5wdXNoKCdvdGhlcicpO1xuICAgIH1cbiAgICBpZiAoZmlsdGVyLmZyb21QaW5nKCkpIHtcbiAgICAgICAgdHlwZXMucHVzaCgncGluZycpO1xuICAgIH1cbiAgICBpZiAoZmlsdGVyLmZyb21TY3JpcHQoKSkge1xuICAgICAgICB0eXBlcy5wdXNoKCdzY3JpcHQnKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlci5mcm9tU3R5bGVzaGVldCgpKSB7XG4gICAgICAgIHR5cGVzLnB1c2goJ3N0eWxlc2hlZXQnKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlci5mcm9tU3ViZG9jdW1lbnQoKSkge1xuICAgICAgICB0eXBlcy5wdXNoKCdzdWJfZnJhbWUnKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlci5mcm9tV2Vic29ja2V0KCkpIHtcbiAgICAgICAgdHlwZXMucHVzaCgnd2Vic29ja2V0Jyk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXIuZnJvbVhtbEh0dHBSZXF1ZXN0KCkpIHtcbiAgICAgICAgdHlwZXMucHVzaCgneGhyJyk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXIuZnJvbUZvbnQoKSkge1xuICAgICAgICB0eXBlcy5wdXNoKCdmb250Jyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGaWx0ZXJJZChtYXNrLCBmaWx0ZXIsIGhvc3RuYW1lLCBkb21haW5zLCBkZW55YWxsb3csIG9wdGlvblZhbHVlKSB7XG4gICAgbGV0IGhhc2ggPSAoSEFTSF9TRUVEICogSEFTSF9JTlRFUk5BTF9NVUxUKSBeIG1hc2s7XG4gICAgaWYgKGRvbWFpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoYXNoID0gZG9tYWlucy51cGRhdGVJZChoYXNoKTtcbiAgICB9XG4gICAgaWYgKGRlbnlhbGxvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhhc2ggPSBkZW55YWxsb3cudXBkYXRlSWQoaGFzaCk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaGFzaCA9IChoYXNoICogSEFTSF9JTlRFUk5BTF9NVUxUKSBeIGZpbHRlci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChob3N0bmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9zdG5hbWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGhhc2ggPSAoaGFzaCAqIEhBU0hfSU5URVJOQUxfTVVMVCkgXiBob3N0bmFtZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9uVmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGhhc2ggPSAoaGFzaCAqIEhBU0hfSU5URVJOQUxfTVVMVCkgXiBvcHRpb25WYWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNoID4+PiAwO1xufVxuLyoqXG4gKiBDb21waWxlcyBhIGZpbHRlciBwYXR0ZXJuIHRvIGEgcmVnZXguIFRoaXMgaXMgb25seSBwZXJmb3JtZWQgKmxhemlseSogZm9yXG4gKiBmaWx0ZXJzIGNvbnRhaW5pbmcgYXQgbGVhc3QgYSAqIG9yIF4gc3ltYm9sLiBCZWNhdXNlIFJlZ2V4ZXMgYXJlIGV4cGFuc2l2ZSxcbiAqIHdlIHRyeSB0byBjb252ZXJ0IHNvbWUgcGF0dGVybnMgdG8gcGxhaW4gZmlsdGVycy5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZVJlZ2V4KGZpbHRlciwgaXNMZWZ0QW5jaG9yLCBpc1JpZ2h0QW5jaG9yLCBpc0Z1bGxSZWdleCkge1xuICAgIGlmIChpc0Z1bGxSZWdleCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChmaWx0ZXIuc2xpY2UoMSwgZmlsdGVyLmxlbmd0aCAtIDEpLCAnaScpO1xuICAgIH1cbiAgICAvLyBFc2NhcGUgc3BlY2lhbCByZWdleCBjaGFyYWN0ZXJzOiB8LiQrP3t9KClbXVxcXG4gICAgZmlsdGVyID0gZmlsdGVyLnJlcGxhY2UoLyhbfC4kKz97fSgpW1xcXVxcXFxdKS9nLCAnXFxcXCQxJyk7XG4gICAgLy8gKiBjYW4gbWF0Y2ggYW55dGhpbmdcbiAgICBmaWx0ZXIgPSBmaWx0ZXIucmVwbGFjZSgvXFwqL2csICcuKicpO1xuICAgIC8vIF4gY2FuIG1hdGNoIGFueSBzZXBhcmF0b3Igb3IgdGhlIGVuZCBvZiB0aGUgcGF0dGVyblxuICAgIGZpbHRlciA9IGZpbHRlci5yZXBsYWNlKC9cXF4vZywgJyg/OlteXFxcXHdcXFxcZF8uJS1dfCQpJyk7XG4gICAgLy8gU2hvdWxkIG1hdGNoIGVuZCBvZiB1cmxcbiAgICBpZiAoaXNSaWdodEFuY2hvcikge1xuICAgICAgICBmaWx0ZXIgPSBgJHtmaWx0ZXJ9JGA7XG4gICAgfVxuICAgIGlmIChpc0xlZnRBbmNob3IpIHtcbiAgICAgICAgZmlsdGVyID0gYF4ke2ZpbHRlcn1gO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZ0V4cChmaWx0ZXIpO1xufVxuLyoqXG4gKiBDb2xsZWN0cyBhIGZpbHRlciBvcHRpb24ga2V5IHVudGlsIHRoZSBmdW5jdGlvbiBzZWVzIHRoZSBzcGVjaWFsIGNoYXJhY3Rlci5cbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBzdG9wIGl0ZXJhdGluZyBvdmVyIHRoZSBnaXZlbiBzdHJpbmcgaWYgaXQgc2VlcyBlcXVhbCBzaWduIG9yIGNvbW1hIHNpZ24uXG4gKiBJZiB0aGVyZSdzIGFuIGVxdWFsIHNpZ24sIGl0IG1lYW5zIHRoYXQgd2UnbGwgc2VlIHRoZSB2YWx1ZS5cbiAqIE90aGVyd2lzZSwgaWYgdGhlcmUncyBhIGNvbW1hIHNpZ24sIGl0IG1lYW5zIHRoYXQgdGhlIG9wdGlvbiBkb2Vzbid0IGhhdmUgYW55IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RmlsdGVyT3B0aW9uTmFtZShsaW5lLCBwb3MsIGVuZCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gcG9zO1xuICAgIGZvciAoOyBwb3MgPCBlbmQ7IHBvcysrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBsaW5lLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDYxIC8qICc9JyAqLyB8fCBjb2RlID09PSA0NCAvKiAnLCcgKi8pIHtcbiAgICAgICAgICAgIGVuZCA9IHBvcztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbcG9zLCBsaW5lLnNsaWNlKHN0YXJ0LCBlbmQpXTtcbn1cbi8qKlxuICogQ29sbGVjdHMgYSBmaWx0ZXIgb3B0aW9uIHZhbHVlIHVudGlsIHRoZSBmdW5jdGlvbiBzZWVzIHRoZSBzcGVjaWFsIGNoYXJhY3Rlci5cbiAqIFRoaXMgZnVuY3Rpb24gcmVzcGVjdHMgdGhlIGVzY2FwaW5nIGNoYXJhY3RlcnMsIHNvIHdlIGNhbiBzYWZlbHkgY29sbGVjdCB0aGUgZnVsbCB2YWx1ZVxuICogaW5jbHVkaW5nIHRoZSBzcGVjaWFsIGNoYXJhY3RlcnMgd2hpY2ggYXJlIG5vdCBhbGxvd2VkIG5vcm1hbGx5LlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHN0b3AgaWYgaXQgc2VlcyBhIGNvbW1hIHNpZ24uXG4gKi9cbmZ1bmN0aW9uIGdldEZpbHRlck9wdGlvblZhbHVlKGxpbmUsIHBvcywgZW5kKSB7XG4gICAgbGV0IHN0YXJ0ID0gcG9zO1xuICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgIGZvciAoOyBwb3MgPCBlbmQ7IHBvcysrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBsaW5lLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDkyIC8qICdcXFxcJyAqLykge1xuICAgICAgICAgICAgdmFsdWUgKz0gbGluZS5zbGljZShzdGFydCwgcG9zKTtcbiAgICAgICAgICAgIHN0YXJ0ID0gKytwb3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29kZSA9PT0gNDQgLyogJywnICovKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhcnQgLSBwb3MgIT09IDApIHtcbiAgICAgICAgdmFsdWUgKz0gbGluZS5zbGljZShzdGFydCwgcG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIFtwb3MsIHZhbHVlXTtcbn1cbmNvbnN0IFJFR0VYUF9DSEFSQUNURVJfRVNDQVBFUyA9IG5ldyBTZXQoW1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL1JlZ3VsYXJfZXhwcmVzc2lvbnMvQ2hhcmFjdGVyX2VzY2FwZVxuICAgIDEwMiwgLy8gZlxuICAgIDExMCwgLy8gblxuICAgIDExNCwgLy8gclxuICAgIDExNiwgLy8gdFxuICAgIDExOCwgLy8gdlxuICAgIDQ4LCAvLyAwXG4gICAgOTQsIC8vIF5cbiAgICAzNiwgLy8gJFxuICAgIDkyLCAvLyBcXFxuICAgIDQ2LCAvLyAuXG4gICAgNDIsIC8vICpcbiAgICA0MywgLy8gK1xuICAgIDYzLCAvLyA/XG4gICAgNDAsIC8vIChcbiAgICA0MSwgLy8gKVxuICAgIDkxLCAvLyBbXG4gICAgOTMsIC8vIF1cbiAgICAxMjMsIC8vIHtcbiAgICAxMjUsIC8vIH1cbiAgICAxMjQsIC8vIHxcbiAgICA0NywgLy8gL1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL1JlZ3VsYXJfZXhwcmVzc2lvbnMvQ2hhcmFjdGVyX2NsYXNzX2VzY2FwZVxuICAgIDEwMCwgLy8gZFxuICAgIDY4LCAvLyBEXG4gICAgMTE5LCAvLyBzXG4gICAgODcsIC8vIFNcbiAgICAxMTUsIC8vIHdcbiAgICA4MywgLy8gV1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL1JlZ3VsYXJfZXhwcmVzc2lvbnMvV29yZF9ib3VuZGFyeV9hc3NlcnRpb25cbiAgICA5OCwgLy8gYlxuICAgIDY2LCAvLyBCXG5dKTtcbmZ1bmN0aW9uIGlzSGV4TGl0ZXJhbChjb2RlKSB7XG4gICAgcmV0dXJuICgoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB8fCAvLyAwLTlcbiAgICAgICAgKGNvZGUgPD0gNjUgJiYgY29kZSA8PSA3MCkgfHwgLy8gQS1GXG4gICAgICAgIChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTAyKSAvLyBhLWZcbiAgICApO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGNoYXJhY3RlcihzKSBhZnRlciB0aGUgZXNjYXBlIGNoYXJhY3RlciBzaG91bGQgYmUgcHJlc2VydmVkLlxuICogQHJldHVybnMgVGhlIGVuZCBpbmRleCBvZiBzZWFyY2ggcmFuZ2UgYW5kIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjaGFyYWN0ZXIgZXNjYXBlIHdhcyBmb3VuZCBvciBub3QuXG4gKi9cbmZ1bmN0aW9uIGlzQ2hhcmFjdGVyRXNjYXBlSW5SZWdFeHAobGluZSwgcG9zLCBfZW5kKSB7XG4gICAgY29uc3QgY29kZSA9IGxpbmUuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICBpZiAoY29kZSA9PT0gNDQgLyogJywnICovIHx8IFJFR0VYUF9DSEFSQUNURVJfRVNDQVBFUy5oYXMoY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIFtwb3MgKyAxLCB0cnVlXTtcbiAgICB9XG4gICAgLy8gXFxjQSwgXFxjQiwg4oCmLCBcXGN6XG4gICAgaWYgKGNvZGUgPT09IDk5IC8qICdjJyAqLykge1xuICAgICAgICBjb25zdCBuZXh0ID0gbGluZS5jaGFyQ29kZUF0KHBvcyArIDIpO1xuICAgICAgICBpZiAoKG5leHQgPj0gNjUgJiYgbmV4dCA8PSA5MCkgfHwgKG5leHQgPj0gOTcgJiYgbmV4dCA8PSAxMjIpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3BvcyArIDIsIHRydWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFxceEhIXG4gICAgaWYgKGNvZGUgPT09IDEyMCAvKiAneCcgKi8gJiZcbiAgICAgICAgaXNIZXhMaXRlcmFsKGxpbmUuY2hhckNvZGVBdChwb3MgKyAyKSkgJiZcbiAgICAgICAgaXNIZXhMaXRlcmFsKGxpbmUuY2hhckNvZGVBdChwb3MgKyAzKSkpIHtcbiAgICAgICAgcmV0dXJuIFtwb3MgKyAzLCB0cnVlXTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDExNyAvKiAndScgKi8pIHtcbiAgICAgICAgLy8gXFx1e0hISH1cbiAgICAgICAgaWYgKGxpbmUuY2hhckNvZGVBdChwb3MgKyAyKSA9PT0gMTIzIC8qICd7JyAqLykge1xuICAgICAgICAgICAgY29uc3QgY2xvc2UgPSBsaW5lLmluZGV4T2YoJ30nLCBwb3MgKyAzKTtcbiAgICAgICAgICAgIGNvbnN0IGhleExpdGVyYWxMZW5ndGggPSBjbG9zZSAtIHBvcyArIDM7XG4gICAgICAgICAgICBpZiAoaGV4TGl0ZXJhbExlbmd0aCA+PSAxICYmIGhleExpdGVyYWxMZW5ndGggPD0gNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbY2xvc2UsIHRydWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAvLyBcXHVISEhIXG4gICAgICAgIGlzSGV4TGl0ZXJhbChsaW5lLmNoYXJDb2RlQXQocG9zICsgMikpICYmXG4gICAgICAgICAgICBpc0hleExpdGVyYWwobGluZS5jaGFyQ29kZUF0KHBvcyArIDMpKSAmJlxuICAgICAgICAgICAgaXNIZXhMaXRlcmFsKGxpbmUuY2hhckNvZGVBdChwb3MgKyA0KSkgJiZcbiAgICAgICAgICAgIGlzSGV4TGl0ZXJhbChsaW5lLmNoYXJDb2RlQXQocG9zICsgNSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3BvcyArIDUsIHRydWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbcG9zICsgMSwgZmFsc2VdO1xufVxuLyoqXG4gKiBDb21tYSBhbmQgc2xhc2ggYXJlIGV4cGVjdGVkIHRvIGNvbWUgd2l0aCBlc2NhcGUgY2hhcmFjdGVyIGJ5IHRoZSBzcGVjLlxuICogaHR0cHM6Ly9hZGd1YXJkLmNvbS9rYi9nZW5lcmFsL2FkLWZpbHRlcmluZy9jcmVhdGUtb3duLWZpbHRlcnMvI3JlcGxhY2UtbW9kaWZpZXJcbiAqL1xuZnVuY3Rpb24gaXNDaGFyYWN0ZXJFc2NhcGVJblJlcGxhY2UobGluZSwgcG9zLCBlbmQpIHtcbiAgICBjb25zdCBjb2RlID0gbGluZS5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgIGlmIChjb2RlID09PSA0NCAvKiAnLCcgKi8gfHwgY29kZSA9PT0gNDcgLyogJy8nICovKSB7XG4gICAgICAgIHJldHVybiBbcG9zICsgMSwgZmFsc2VdO1xuICAgIH1cbiAgICByZXR1cm4gaXNDaGFyYWN0ZXJFc2NhcGVJblJlZ0V4cChsaW5lLCBwb3MsIGVuZCk7XG59XG4vKipcbiAqIENvbGxlY3RzIGEgZmlsdGVyIG9wdGlvbiB2YWx1ZSBvZiB0aGUgcmVwbGFjZSBtb2RpZmllci5cbiAqIFRoaXMgZnVuY3Rpb24gcmVzcGVjdHMgdGhlIGVzY2FwaW5nIGNoYXJhY3RlciB3aXRoIHRoZSBhbGxvd2VkIGNoYXJhY3RlcnMgb2YgdGhlIHJlcGxhY2UgbW9kaWZpZXIuXG4gKiBJbiB0aGUgcmVwbGFjZSBtb2RpZmllciwgaXQgY2FuIGluY2x1ZGUgdGhlIGFueSBzaWduIGFsbG93ZWQgaW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqIFRoZXJlZm9yZSwgYSBjb21tYSBzaWduIGNhbiBpbnRlcmZlcmUgdGhlIGBnZXRGaWx0ZXJPcHRpb25WYWx1ZWAgZnVuY3Rpb24uXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgbm90IHN0b3AgdW5sZXNzIGl0IGNvbGxlY3RzIGFsbCB0aGUgcGFydHMgb2YgdGhlIHJlcGxhY2UgbW9kaWZpZXIgb3B0aW9uIHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRGaWx0ZXJSZXBsYWNlT3B0aW9uVmFsdWUobGluZSwgcG9zLCBlbmQpIHtcbiAgICAvLyBUcnkgdG8gZmFzdCBleGl0IGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgYW4gdW5leHBlY3RlZCBjaGFyYWN0ZXIuXG4gICAgaWYgKGxpbmUuY2hhckNvZGVBdChwb3MrKykgIT09IDQ3IC8qICcvJyAqLykge1xuICAgICAgICByZXR1cm4gW2VuZCwgdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBbJycsICcnLCAnJ107XG4gICAgbGV0IHN0YXJ0ID0gcG9zO1xuICAgIGxldCBzbGFzaGVzID0gMDtcbiAgICBmb3IgKDsgcG9zIDwgZW5kOyBwb3MrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gbGluZS5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmIChjb2RlID09PSA5MiAvKiAnXFxcXCcgKi8pIHtcbiAgICAgICAgICAgIHBhcnRzW3NsYXNoZXNdICs9IGxpbmUuc2xpY2Uoc3RhcnQsIHBvcyk7XG4gICAgICAgICAgICBjb25zdCBbcG9zQWZ0ZXJDaGFyYWN0ZXJFc2NhcGUsIGlzQ2hhcmFjdGVyRXNjYXBlXSA9IGlzQ2hhcmFjdGVyRXNjYXBlSW5SZXBsYWNlKGxpbmUsIHBvcywgZW5kKTtcbiAgICAgICAgICAgIGlmIChpc0NoYXJhY3RlckVzY2FwZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZXNjYXBpbmcgY2hhcmFjdGVyICgnXFxcXCcpIGJ5IGFkZGluZyBhbiBvZmZzZXQgdG8gbmV4dCBgc3RhcnRgIGFzc2lnbm1lbnQuXG4gICAgICAgICAgICAgICAgKytwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IHBvcztcbiAgICAgICAgICAgIHBvcyA9IHBvc0FmdGVyQ2hhcmFjdGVyRXNjYXBlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGUgPT09IDQ3IC8qICcvJyAqLykge1xuICAgICAgICAgICAgaWYgKHBvcyAtIHN0YXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcGFydHNbc2xhc2hlc10gKz0gbGluZS5zbGljZShzdGFydCwgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgICAgICAgIGlmICgrK3NsYXNoZXMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSBzYXcgMyBzbGFzaGVzIGluIHRvdGFsLCBpdCBtZWFucyB0aGF0IHRoZSBvcHRpb24gdmFsdWUgc2hvdWxkIGJlIGNsb3NlZCBoZXJlLlxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBhbHJlYWR5IHNhdyB0aGUgZmlyc3Qgc2xhc2ggYmVmb3JlIHRoZSBsb29wLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlRW5kID0gbGluZS5pbmRleE9mKCcsJywgcG9zKTtcbiAgICBpZiAodmFsdWVFbmQgIT09IC0xKSB7XG4gICAgICAgIGVuZCA9IHZhbHVlRW5kO1xuICAgIH1cbiAgICBwYXJ0c1syXSA9IGxpbmUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgcG9zID0gZW5kO1xuICAgIHJldHVybiBbcG9zLCBwYXJ0c107XG59XG4vKipcbiAqIENvbGxlY3RzIGFuIGFycmF5IG9mIGZpbHRlciBvcHRpb25zIGZyb20gdGhlIGdpdmVuIGluZGV4LlxuICogVGhpcyBmdW5jdGlvbiBsZXZlcmFnZXMgYGdldEZpbHRlck9wdGlvbktleWAsIGBnZXRGaWx0ZXJPcHRpb25WYWx1ZWAsIGFuZCBldmVyeSBleHRlbnNpb24gZnVuY3Rpb25zLlxuICogRGVwZW5kaW5nIG9uIHRoZSBmaWx0ZXIgb3B0aW9uIGtleSwgdGhlIGZ1bmN0aW9uIHRvIGNvbGxlY3QgZmlsdGVyIG9wdGlvbiB2YWx1ZSBjYW4gdmFyeS5cbiAqIEZvciB0aGUgZ2VuZXJpYyBmaWx0ZXIgb3B0aW9uIHZhbHVlLCBpdCdsbCB1c2UgYGdldEZpbHRlck9wdGlvblZhbHVlYCBmdW5jdGlvbiB0byBnZXQgdGhlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRGaWx0ZXJPcHRpb25zKGxpbmUsIHBvcywgZW5kKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IFtdO1xuICAgIGxldCBuYW1lO1xuICAgIGxldCB2YWx1ZTtcbiAgICBmb3IgKDsgcG9zIDwgZW5kOyBwb3MrKykge1xuICAgICAgICBbcG9zLCBuYW1lXSA9IGdldEZpbHRlck9wdGlvbk5hbWUobGluZSwgcG9zLCBlbmQpO1xuICAgICAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAobGluZS5jaGFyQ29kZUF0KHBvcykgPT09IDYxIC8qICc9JyAqLykge1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdyZXBsYWNlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldEZpbHRlclJlcGxhY2VPcHRpb25WYWx1ZShsaW5lLCBwb3MsIGVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdFsxXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxpbmUuc2xpY2UocG9zLCByZXN1bHRbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgPSByZXN1bHRbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBbcG9zLCB2YWx1ZV0gPSBnZXRGaWx0ZXJPcHRpb25WYWx1ZShsaW5lLCBwb3MsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHJlcGxhY2UgbW9kaWZpZXIgb3B0aW9uIHZhbHVlIGludG8gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB3aXRoIGl0cyByZXBsYWNlbWVudC5cbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBmaXhlZCBsZW5ndGggYXJyYXkgZnJvbSBgZ2V0RmlsdGVyUmVwbGFjZU9wdGlvblZhbHVlYFxuICogdGhlbiB0cnkgdG8gYnVpbGQgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYG51bGxgIGlmIHRoZSBhcnJheSBmb3JtYXQgb3IgdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBjb21wb25lbnRzIGFyZSBub3QgdmFsaWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlT3B0aW9uVmFsdWVUb1JlZ2V4cCh2YWx1ZSkge1xuICAgIGNvbnN0IFssIHZhbHVlc10gPSBnZXRGaWx0ZXJSZXBsYWNlT3B0aW9uVmFsdWUodmFsdWUsIDAsIHZhbHVlLmxlbmd0aCk7XG4gICAgaWYgKHZhbHVlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBSZWdFeHAgY29uc3RydWN0b3IgY2FuIHRocm93IGFuIGVycm9yXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGAvcmVnZXhwL3JlcGxhY2VtZW50L2ZsYWdzYCB0byBiZSBbcmVnZXhwLCByZXBsYWNlbWVudCwgZmxhZ3NdXG4gICAgICAgIC8vIFRoZSBmaXJzdCBzbGFzaCBzaG91bGQgYmUgcmVtb3ZlZCBpbiB0aGUgZWFybHkgc3RlcHNcbiAgICAgICAgcmV0dXJuIFtuZXcgUmVnRXhwKHZhbHVlc1swXSwgdmFsdWVzWzJdKSwgdmFsdWVzWzFdXTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNvbnN0IE1BVENIX0FMTCA9IG5ldyBSZWdFeHAoJycpO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmV0d29ya0ZpbHRlciB7XG4gICAgc3RhdGljIHBhcnNlKGxpbmUsIGRlYnVnID0gZmFsc2UpIHtcbiAgICAgICAgLy8gUmVwcmVzZW50IG9wdGlvbnMgYXMgYSBiaXRtYXNrXG4gICAgICAgIGxldCBtYXNrID0gTkVUV09SS19GSUxURVJfTUFTSy50aGlyZFBhcnR5IHxcbiAgICAgICAgICAgIE5FVFdPUktfRklMVEVSX01BU0suZmlyc3RQYXJ0eSB8XG4gICAgICAgICAgICBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21IdHRwcyB8XG4gICAgICAgICAgICBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21IdHRwO1xuICAgICAgICAvLyBUZW1wb3JhcnkgbWFza3MgZm9yIHBvc2l0aXZlIChlLmcuOiAkc2NyaXB0KSBhbmQgbmVnYXRpdmUgKGUuZy46ICR+c2NyaXB0KVxuICAgICAgICAvLyBjb250ZW50IHR5cGUgb3B0aW9ucy5cbiAgICAgICAgbGV0IGNwdE1hc2tQb3NpdGl2ZSA9IDA7XG4gICAgICAgIGxldCBjcHRNYXNrTmVnYXRpdmUgPSBGUk9NX0FOWTtcbiAgICAgICAgbGV0IGhvc3RuYW1lO1xuICAgICAgICBsZXQgZG9tYWlucztcbiAgICAgICAgbGV0IGRlbnlhbGxvdztcbiAgICAgICAgbGV0IG9wdGlvblZhbHVlO1xuICAgICAgICAvLyBTdGFydCBwYXJzaW5nXG4gICAgICAgIGxldCBmaWx0ZXJJbmRleFN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IGZpbHRlckluZGV4RW5kID0gbGluZS5sZW5ndGg7XG4gICAgICAgIC8vIEBAZmlsdGVyID09IEV4Y2VwdGlvblxuICAgICAgICBpZiAobGluZS5jaGFyQ29kZUF0KDApID09PSA2NCAvKiAnQCcgKi8gJiYgbGluZS5jaGFyQ29kZUF0KDEpID09PSA2NCAvKiAnQCcgKi8pIHtcbiAgICAgICAgICAgIGZpbHRlckluZGV4U3RhcnQgKz0gMjtcbiAgICAgICAgICAgIG1hc2sgPSBzZXRCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc0V4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlsdGVyJG9wdGlvbnMgPT0gT3B0aW9uc1xuICAgICAgICAvLyBeICAgICBeXG4gICAgICAgIC8vIHwgICAgIHxcbiAgICAgICAgLy8gfCAgICAgb3B0aW9uc0luZGV4XG4gICAgICAgIC8vIGZpbHRlckluZGV4U3RhcnRcbiAgICAgICAgY29uc3Qgb3B0aW9uc0luZGV4ID0gZmluZExhc3RJbmRleE9mVW5lc2NhcGVkQ2hhcmFjdGVyKGxpbmUsICckJyk7XG4gICAgICAgIGlmIChvcHRpb25zSW5kZXggIT09IC0xICYmIGxpbmUuY2hhckNvZGVBdChvcHRpb25zSW5kZXggKyAxKSAhPT0gNDcgLyogJy8nICovKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBvcHRpb25zIGFuZCBzZXQgZmxhZ3NcbiAgICAgICAgICAgIGZpbHRlckluZGV4RW5kID0gb3B0aW9uc0luZGV4O1xuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gICAgICAgICAgICAvLyBwYXJzZU9wdGlvbnNcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICAgICAgICAgICAgbGV0IGRvbWFpbnNMaXN0O1xuICAgICAgICAgICAgbGV0IGRlbnlhbGxvd0xpc3Q7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJhd09wdGlvbiBvZiBnZXRGaWx0ZXJPcHRpb25zKGxpbmUsIG9wdGlvbnNJbmRleCArIDEsIGxpbmUubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5lZ2F0aW9uID0gcmF3T3B0aW9uWzBdLmNoYXJDb2RlQXQoMCkgPT09IDEyNjsgLyogJ34nICovXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gbmVnYXRpb24gPT09IHRydWUgPyByYXdPcHRpb25bMF0uc2xpY2UoMSkgOiByYXdPcHRpb25bMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByYXdPcHRpb25bMV07XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndG8nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW5zTGlzdCAhPT0gbnVsbCAmJiBkb21haW5zTGlzdCAhPT0gdm9pZCAwID8gZG9tYWluc0xpc3QgOiAoZG9tYWluc0xpc3QgPSBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVueWFsbG93TGlzdCAhPT0gbnVsbCAmJiBkZW55YWxsb3dMaXN0ICE9PSB2b2lkIDAgPyBkZW55YWxsb3dMaXN0IDogKGRlbnlhbGxvd0xpc3QgPSBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBob3N0bmFtZSBvZiB2YWx1ZS5zcGxpdCgnfCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3RuYW1lLnN0YXJ0c1dpdGgoJ34nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW55YWxsb3dMaXN0LmFkZChob3N0bmFtZS5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW5zTGlzdC5hZGQoaG9zdG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlbnlhbGxvdyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbnlhbGxvd0xpc3QgIT09IG51bGwgJiYgZGVueWFsbG93TGlzdCAhPT0gdm9pZCAwID8gZGVueWFsbG93TGlzdCA6IChkZW55YWxsb3dMaXN0ID0gbmV3IFNldCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZG9tYWluIG9mIHZhbHVlLnNwbGl0KCd8JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW55YWxsb3dMaXN0LmFkZChkb21haW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZG9tYWluJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZnJvbSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbnNMaXN0ICE9PSBudWxsICYmIGRvbWFpbnNMaXN0ICE9PSB2b2lkIDAgPyBkb21haW5zTGlzdCA6IChkb21haW5zTGlzdCA9IG5ldyBTZXQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRvbWFpbiBvZiB2YWx1ZS5zcGxpdCgnfCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluc0xpc3QuYWRkKGRvbWFpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdiYWRmaWx0ZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWFzayA9IHNldEJpdChtYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzQmFkRmlsdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbXBvcnRhbnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogYG5lZ2F0aW9uYCBzaG91bGQgYWx3YXlzIGJlIGBmYWxzZWAgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWdhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFzayA9IHNldEJpdChtYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzSW1wb3J0YW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXRjaC1jYXNlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IGBuZWdhdGlvbmAgc2hvdWxkIGFsd2F5cyBiZSBgZmFsc2VgIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVnYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGN1cnJlbnRseSBjb25zaWRlciBhbGwgZmlsdGVycyB0byBiZSBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzNwJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGhpcmQtcGFydHknOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfnRoaXJkLXBhcnR5IG1lYW5zIHdlIHNob3VsZCBjbGVhciB0aGUgZmxhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2sgPSBjbGVhckJpdChtYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLnRoaXJkUGFydHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcmQtcGFydHkgbWVhbnMgfmZpcnN0LXBhcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFzayA9IGNsZWFyQml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suZmlyc3RQYXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnMXAnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdmaXJzdC1wYXJ0eSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVnYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB+Zmlyc3QtcGFydHkgbWVhbnMgd2Ugc2hvdWxkIGNsZWFyIHRoZSBmbGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFzayA9IGNsZWFyQml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suZmlyc3RQYXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdC1wYXJ0eSBtZWFucyB+dGhpcmQtcGFydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrID0gY2xlYXJCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy50aGlyZFBhcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyZWRpcmVjdC1ydWxlJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVkaXJlY3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWdhdGlvbiBvZiByZWRpcmVjdGlvbiBkb2Vzbid0IG1ha2Ugc2Vuc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWdhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRoaXMgZmlsdGVyIGlmIG5vIHJlZGlyZWN0aW9uIHJlc291cmNlIGlzIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRoaXMgZmlsdGVyIGlmIHdyb25nIHByaW9yaXR5IGlzIGdpdmVuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmlvcml0eUluZGV4ID0gdmFsdWUubGFzdEluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmlvcml0eUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmlvcml0eUluZGV4ICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpc05hTihOdW1iZXIodmFsdWUuc2xpY2UocHJpb3JpdHlJbmRleCArIDEpKSkgPT09IHRydWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHlJbmRleCArIDEgPT09IHZhbHVlLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2sgPSBzZXRCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc1JlZGlyZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb24gPT09ICdyZWRpcmVjdC1ydWxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2sgPSBzZXRCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc1JlZGlyZWN0UnVsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NzcCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVnYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2sgPSBzZXRCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc0NTUCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25WYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VoaWRlJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZWxlbWhpZGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrID0gc2V0Qml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNHZW5lcmljSGlkZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrID0gc2V0Qml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNTcGVjaWZpY0hpZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NoaWRlJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3BlY2lmaWNoaWRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWdhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFzayA9IHNldEJpdChtYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzU3BlY2lmaWNIaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnaGlkZSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dlbmVyaWNoaWRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWdhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFzayA9IHNldEJpdChtYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzR2VuZXJpY0hpZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lubGluZS1zY3JpcHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZ2F0aW9uIHx8IG9wdGlvblZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2sgPSBzZXRCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc0NTUCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25WYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzY3JpcHQtc3JjICdzZWxmJyAndW5zYWZlLWV2YWwnIGh0dHA6IGh0dHBzOiBkYXRhOiBibG9iOiBtZWRpYXN0cmVhbTogZmlsZXN5c3RlbTpcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbmxpbmUtZm9udCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVnYXRpb24gfHwgb3B0aW9uVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFzayA9IHNldEJpdChtYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzQ1NQKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvblZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvbnQtc3JjICdzZWxmJyAndW5zYWZlLWV2YWwnIGh0dHA6IGh0dHBzOiBkYXRhOiBibG9iOiBtZWRpYXN0cmVhbTogZmlsZXN5c3RlbTpcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyZXBsYWNlJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29udGVudCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVnYXRpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodmFsdWUubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZ2V0Qml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNFeGNlcHRpb24pID09PSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlcGxhY2VPcHRpb25WYWx1ZVRvUmVnZXhwKHZhbHVlKSA9PT0gbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrID0gc2V0Qml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNSZXBsYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvblZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVtb3ZlcGFyYW0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogU3VwcG9ydCByZWdleFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZ2F0aW9uIHx8IHZhbHVlLnN0YXJ0c1dpdGgoJy8nKSB8fCBvcHRpb25WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrID0gc2V0Qml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNSZW1vdmVQYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25WYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjb250ZW50IHR5cGUgb3B0aW9ucyBzZXBhcmF0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvcHRpb25NYXNrID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWxsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBDdXJyZW50bHkgYSBmaWx0ZXIgY2Fubm90IGJlIGJvdGggYmxvY2tpbmcgYW5kIENTUCwgc29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2lsbCBoYXZlIHRvIGNyZWF0ZSBtdWx0aXBsZSBmaWx0ZXJzIHRvIGtlZXAgdGhlIHNlbWFudGljc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiAnYWxsJy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFzayA9IHNldEJpdChtYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzQ1NQKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3NwID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIFwic2NyaXB0LXNyYyAnc2VsZicgJ3Vuc2FmZS1ldmFsJyBodHRwOiBodHRwczogZGF0YTogYmxvYjogbWVkaWFzdHJlYW06IGZpbGVzeXN0ZW06XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgXCJmb250LXNyYyAnc2VsZicgJ3Vuc2FmZS1ldmFsJyBodHRwOiBodHRwczogZGF0YTogYmxvYjogbWVkaWFzdHJlYW06IGZpbGVzeXN0ZW06XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIF0uam9pbignOyAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25NYXNrID0gTkVUV09SS19GSUxURVJfTUFTSy5mcm9tSW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21lZGlhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uTWFzayA9IE5FVFdPUktfRklMVEVSX01BU0suZnJvbU1lZGlhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdC1zdWJyZXF1ZXN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uTWFzayA9IE5FVFdPUktfRklMVEVSX01BU0suZnJvbU9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnb3RoZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25NYXNrID0gTkVUV09SS19GSUxURVJfTUFTSy5mcm9tT3RoZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3BpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JlYWNvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbk1hc2sgPSBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21QaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzY3JpcHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25NYXNrID0gTkVUV09SS19GSUxURVJfTUFTSy5mcm9tU2NyaXB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjc3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0eWxlc2hlZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25NYXNrID0gTkVUV09SS19GSUxURVJfTUFTSy5mcm9tU3R5bGVzaGVldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N1YmRvY3VtZW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uTWFzayA9IE5FVFdPUktfRklMVEVSX01BU0suZnJvbVN1YmRvY3VtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd4aHInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3htbGh0dHByZXF1ZXN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uTWFzayA9IE5FVFdPUktfRklMVEVSX01BU0suZnJvbVhtbEh0dHBSZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd3ZWJzb2NrZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25NYXNrID0gTkVUV09SS19GSUxURVJfTUFTSy5mcm9tV2Vic29ja2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmb250JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uTWFzayA9IE5FVFdPUktfRklMVEVSX01BU0suZnJvbUZvbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RvYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25NYXNrID0gTkVUV09SS19GSUxURVJfTUFTSy5mcm9tRG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2FibGUgdGhpcyBmaWx0ZXIgaWYgd2UgZG9uJ3Qgc3VwcG9ydCBhbGwgdGhlIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBnb3QgYSB2YWxpZCBjcHQgb3B0aW9uLCB1cGRhdGUgbWFza1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3B0TWFza05lZ2F0aXZlID0gY2xlYXJCaXQoY3B0TWFza05lZ2F0aXZlLCBvcHRpb25NYXNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwdE1hc2tQb3NpdGl2ZSA9IHNldEJpdChjcHRNYXNrUG9zaXRpdmUsIG9wdGlvbk1hc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9tYWluc0xpc3QgIT09IHVuZGVmaW5lZCAmJiBkb21haW5zTGlzdC5zaXplICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZG9tYWlucyA9IERvbWFpbnMucGFyc2UoZG9tYWluc0xpc3QsIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyOiAnfCcsXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChkb21haW5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbnlhbGxvd0xpc3QgIT09IHVuZGVmaW5lZCAmJiBkZW55YWxsb3dMaXN0LnNpemUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyAkZGVueWFsbG93IHJlcXVpcmVzICRkb21haW5cbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluc0xpc3QgPT09IHVuZGVmaW5lZCB8fCBkb21haW5zTGlzdC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZW55YWxsb3cgPSBEb21haW5zLnBhcnNlKGRlbnlhbGxvd0xpc3QsIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyOiAnfCcsXG4gICAgICAgICAgICAgICAgICAgIGRlYnVnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChkZW55YWxsb3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbmQgb2Ygb3B0aW9uIHBhcnNpbmdcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICAgICAgICB9XG4gICAgICAgIGlmIChjcHRNYXNrUG9zaXRpdmUgPT09IDApIHtcbiAgICAgICAgICAgIG1hc2sgPSBzZXRCaXQobWFzaywgY3B0TWFza05lZ2F0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcHRNYXNrTmVnYXRpdmUgPT09IEZST01fQU5ZKSB7XG4gICAgICAgICAgICBtYXNrID0gc2V0Qml0KG1hc2ssIGNwdE1hc2tQb3NpdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXNrID0gc2V0Qml0KG1hc2ssIGNwdE1hc2tQb3NpdGl2ZSAmIGNwdE1hc2tOZWdhdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWRlbnRpZnkga2luZCBvZiBwYXR0ZXJuXG4gICAgICAgIGxldCBmaWx0ZXI7XG4gICAgICAgIC8vIERldGVjdCBSZWdleHBzIChpLmUuOiAvcGF0dGVybi8pXG4gICAgICAgIGlmIChmaWx0ZXJJbmRleEVuZCAtIGZpbHRlckluZGV4U3RhcnQgPj0gMiAmJlxuICAgICAgICAgICAgbGluZS5jaGFyQ29kZUF0KGZpbHRlckluZGV4U3RhcnQpID09PSA0NyAvKiAnLycgKi8gJiZcbiAgICAgICAgICAgIGxpbmUuY2hhckNvZGVBdChmaWx0ZXJJbmRleEVuZCAtIDEpID09PSA0NyAvKiAnLycgKi8pIHtcbiAgICAgICAgICAgIC8vIFNvbWUgZXh0cmEgaWRlYXMgd2hpY2ggY291bGQgYmUgYXBwbGllZCB0byBSZWdFeHAgZmlsdGVyczpcbiAgICAgICAgICAgIC8vICogY29udmVydCBydWxlcyB3aXRob3V0IGFueSBzcGVjaWFsIFJlZ0V4cCBzeW50YXggdG8gcGxhaW4gcGF0dGVybnNcbiAgICAgICAgICAgIC8vICogcmVtb3ZlIGV4dHJhIGBpc0Z1bGxSZWdleGAgZmxhZyBzaW5jZSBgaXNSZWdleGAgbWlnaHQgYmUgZW5vdWdoXG4gICAgICAgICAgICAvLyAqIGFwcGx5IHNvbWUgb3B0aW1pemF0aW9ucyBvbiB0aGUgZmx5OiAvXmh0dHBzPzpcXFxcL1xcXFwvcmVzdCA9PiBpc0h0dHAgKyBpc0h0dHBzICsgcmVzdFxuICAgICAgICAgICAgZmlsdGVyID0gbGluZS5zbGljZShmaWx0ZXJJbmRleFN0YXJ0LCBmaWx0ZXJJbmRleEVuZCk7XG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSBSZWdFeHAgdG8gbWFrZSBzdXJlIHRoaXMgcnVsZSBpcyBmaW5lXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbXBpbGVSZWdleChmaWx0ZXIsIGZhbHNlIC8qIGlzTGVmdEFuY2hvciAqLywgZmFsc2UgLyogaXNSaWdodEFuY2hvciAqLywgdHJ1ZSAvKiBpc0Z1bGxSZWdleCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gaW52YWxpZCBSZWdFeHBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hc2sgPSBzZXRCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc0Z1bGxSZWdleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWFsIHdpdGggaG9zdG5hbWUgcGF0dGVyblxuICAgICAgICAgICAgaWYgKGZpbHRlckluZGV4RW5kID4gMCAmJiBsaW5lLmNoYXJDb2RlQXQoZmlsdGVySW5kZXhFbmQgLSAxKSA9PT0gMTI0IC8qICd8JyAqLykge1xuICAgICAgICAgICAgICAgIG1hc2sgPSBzZXRCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc1JpZ2h0QW5jaG9yKTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJJbmRleEVuZCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlckluZGV4U3RhcnQgPCBmaWx0ZXJJbmRleEVuZCAmJlxuICAgICAgICAgICAgICAgIGxpbmUuY2hhckNvZGVBdChmaWx0ZXJJbmRleFN0YXJ0KSA9PT0gMTI0IC8qICd8JyAqLykge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJJbmRleFN0YXJ0IDwgZmlsdGVySW5kZXhFbmQgLSAxICYmXG4gICAgICAgICAgICAgICAgICAgIGxpbmUuY2hhckNvZGVBdChmaWx0ZXJJbmRleFN0YXJ0ICsgMSkgPT09IDEyNCAvKiAnfCcgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbWFzayA9IHNldEJpdChtYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzSG9zdG5hbWVBbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbmRleFN0YXJ0ICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXNrID0gc2V0Qml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNMZWZ0QW5jaG9yKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVySW5kZXhTdGFydCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnN0IGlzUmVnZXggPSBjaGVja0lzUmVnZXgobGluZSwgZmlsdGVySW5kZXhTdGFydCwgZmlsdGVySW5kZXhFbmQpO1xuICAgICAgICAgICAgLy8gbWFzayA9IHNldE5ldHdvcmtNYXNrKG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNSZWdleCwgaXNSZWdleCk7XG4gICAgICAgICAgICBpZiAoZ2V0Qml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNIb3N0bmFtZUFuY2hvcikpIHtcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBhdCB0aGUgZmlyc3QgY2hhcmFjdGVyIHdoaWNoIGlzIG5vdCBhbGxvd2VkIGluIGEgaG9zdG5hbWVcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3RTZXBhcmF0b3IgPSBmaWx0ZXJJbmRleFN0YXJ0O1xuICAgICAgICAgICAgICAgIHdoaWxlIChmaXJzdFNlcGFyYXRvciA8IGZpbHRlckluZGV4RW5kICYmXG4gICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZEhvc3RuYW1lKGxpbmUuY2hhckNvZGVBdChmaXJzdFNlcGFyYXRvcikpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0U2VwYXJhdG9yICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vIHNlcGFyYXRvciBmb3VuZCBzbyBob3N0bmFtZSBoYXMgZnVsbCBsZW5ndGhcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RTZXBhcmF0b3IgPT09IGZpbHRlckluZGV4RW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RuYW1lID0gbGluZS5zbGljZShmaWx0ZXJJbmRleFN0YXJ0LCBmaWx0ZXJJbmRleEVuZCk7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckluZGV4U3RhcnQgPSBmaWx0ZXJJbmRleEVuZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFzayA9IHNldEJpdChtYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzTGVmdEFuY2hvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIHNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICBob3N0bmFtZSA9IGxpbmUuc2xpY2UoZmlsdGVySW5kZXhTdGFydCwgZmlyc3RTZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbmRleFN0YXJ0ID0gZmlyc3RTZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvckNvZGUgPSBsaW5lLmNoYXJDb2RlQXQoZmlyc3RTZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yQ29kZSA9PT0gOTQgLyogJ14nICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb25seSBzeW1ib2wgcmVtYWluaW5nIGZvciB0aGUgc2VsZWN0b3IgaXMgJ14nIHRoZW4gaWdub3JlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgc2V0IHRoZSBmaWx0ZXIgYXMgcmlnaHQgYW5jaG9yZWQgc2luY2UgdGhlcmUgc2hvdWxkIG5vdCBiZSBhbnlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyIGxhYmVsIG9uIHRoZSByaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlckluZGV4RW5kIC0gZmlsdGVySW5kZXhTdGFydCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckluZGV4U3RhcnQgPSBmaWx0ZXJJbmRleEVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrID0gc2V0Qml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNSaWdodEFuY2hvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrID0gc2V0Qml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNSZWdleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFzayA9IHNldEJpdChtYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzTGVmdEFuY2hvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VwYXJhdG9yQ29kZSA9PT0gNDIgLyogJyonICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrID0gc2V0Qml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNSZWdleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXNrID0gc2V0Qml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNMZWZ0QW5jaG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2sgPSBzZXRCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc0xlZnRBbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nICcqJ1xuICAgICAgICAgICAgaWYgKGZpbHRlckluZGV4RW5kIC0gZmlsdGVySW5kZXhTdGFydCA+IDAgJiZcbiAgICAgICAgICAgICAgICBsaW5lLmNoYXJDb2RlQXQoZmlsdGVySW5kZXhFbmQgLSAxKSA9PT0gNDIgLyogJyonICovKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVySW5kZXhFbmQgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nICcqJyBpZiB0aGUgZmlsdGVyIGlzIG5vdCBob3N0bmFtZSBhbmNob3JlZC5cbiAgICAgICAgICAgIGlmIChnZXRCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc0hvc3RuYW1lQW5jaG9yKSA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICBmaWx0ZXJJbmRleEVuZCAtIGZpbHRlckluZGV4U3RhcnQgPiAwICYmXG4gICAgICAgICAgICAgICAgbGluZS5jaGFyQ29kZUF0KGZpbHRlckluZGV4U3RhcnQpID09PSA0MiAvKiAnKicgKi8pIHtcbiAgICAgICAgICAgICAgICBtYXNrID0gY2xlYXJCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc0xlZnRBbmNob3IpO1xuICAgICAgICAgICAgICAgIGZpbHRlckluZGV4U3RhcnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBmaWx0ZXJzIG9uIHByb3RvY29sIChodHRwLCBodHRwcywgd3MpXG4gICAgICAgICAgICBpZiAoZ2V0Qml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNMZWZ0QW5jaG9yKSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJJbmRleEVuZCAtIGZpbHRlckluZGV4U3RhcnQgPT09IDUgJiZcbiAgICAgICAgICAgICAgICAgICAgbGluZS5zdGFydHNXaXRoKCd3czovLycsIGZpbHRlckluZGV4U3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hc2sgPSBzZXRCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5mcm9tV2Vic29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbWFzayA9IGNsZWFyQml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNMZWZ0QW5jaG9yKTtcbiAgICAgICAgICAgICAgICAgICAgbWFzayA9IGNsZWFyQml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suZnJvbUh0dHApO1xuICAgICAgICAgICAgICAgICAgICBtYXNrID0gY2xlYXJCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5mcm9tSHR0cHMpO1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbmRleFN0YXJ0ID0gZmlsdGVySW5kZXhFbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlckluZGV4RW5kIC0gZmlsdGVySW5kZXhTdGFydCA9PT0gNyAmJlxuICAgICAgICAgICAgICAgICAgICBsaW5lLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nLCBmaWx0ZXJJbmRleFN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICBtYXNrID0gc2V0Qml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suZnJvbUh0dHApO1xuICAgICAgICAgICAgICAgICAgICBtYXNrID0gY2xlYXJCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5mcm9tSHR0cHMpO1xuICAgICAgICAgICAgICAgICAgICBtYXNrID0gY2xlYXJCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc0xlZnRBbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbmRleFN0YXJ0ID0gZmlsdGVySW5kZXhFbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlckluZGV4RW5kIC0gZmlsdGVySW5kZXhTdGFydCA9PT0gOCAmJlxuICAgICAgICAgICAgICAgICAgICBsaW5lLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJywgZmlsdGVySW5kZXhTdGFydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFzayA9IHNldEJpdChtYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21IdHRwcyk7XG4gICAgICAgICAgICAgICAgICAgIG1hc2sgPSBjbGVhckJpdChtYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21IdHRwKTtcbiAgICAgICAgICAgICAgICAgICAgbWFzayA9IGNsZWFyQml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNMZWZ0QW5jaG9yKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVySW5kZXhTdGFydCA9IGZpbHRlckluZGV4RW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWx0ZXJJbmRleEVuZCAtIGZpbHRlckluZGV4U3RhcnQgPT09IDggJiZcbiAgICAgICAgICAgICAgICAgICAgbGluZS5zdGFydHNXaXRoKCdodHRwKjovLycsIGZpbHRlckluZGV4U3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hc2sgPSBzZXRCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5mcm9tSHR0cHMpO1xuICAgICAgICAgICAgICAgICAgICBtYXNrID0gc2V0Qml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suZnJvbUh0dHApO1xuICAgICAgICAgICAgICAgICAgICBtYXNrID0gY2xlYXJCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc0xlZnRBbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbmRleFN0YXJ0ID0gZmlsdGVySW5kZXhFbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlckluZGV4RW5kIC0gZmlsdGVySW5kZXhTdGFydCA+IDApIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSBsaW5lLnNsaWNlKGZpbHRlckluZGV4U3RhcnQsIGZpbHRlckluZGV4RW5kKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIG1hc2sgPSBzZXROZXR3b3JrTWFzayhtYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzVW5pY29kZSwgaGFzVW5pY29kZShmaWx0ZXIpKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Qml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNSZWdleCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hc2sgPSBzZXROZXR3b3JrTWFzayhtYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzUmVnZXgsIGNoZWNrSXNSZWdleChmaWx0ZXIsIDAsIGZpbHRlci5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvLyAtIGlnbm9yZSBob3N0bmFtZSBhbmNob3IgaXMgbm90IGhvc3RuYW1lIHByb3ZpZGVkXG4gICAgICAgICAgICBpZiAoaG9zdG5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGhvc3RuYW1lID0gaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVW5pY29kZShob3N0bmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFzayA9IHNldE5ldHdvcmtNYXNrKG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNVbmljb2RlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaG9zdG5hbWUgPSB0b0FTQ0lJKGhvc3RuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOZXR3b3JrRmlsdGVyKHtcbiAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgIGhvc3RuYW1lLFxuICAgICAgICAgICAgbWFzayxcbiAgICAgICAgICAgIGRvbWFpbnMsXG4gICAgICAgICAgICBkZW55YWxsb3csXG4gICAgICAgICAgICBvcHRpb25WYWx1ZSxcbiAgICAgICAgICAgIHJhd0xpbmU6IGRlYnVnID09PSB0cnVlID8gbGluZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlZ2V4OiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXNlcmlhbGl6ZSBuZXR3b3JrIGZpbHRlcnMuIFRoZSBjb2RlIGFjY2Vzc2luZyB0aGUgYnVmZmVyIHNob3VsZCBiZVxuICAgICAqIHN5bWV0cmljYWwgdG8gdGhlIG9uZSBpbiBgc2VyaWFsaXplTmV0d29ya0ZpbHRlcmAuXG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBtYXNrID0gYnVmZmVyLmdldFVpbnQzMigpO1xuICAgICAgICBjb25zdCBvcHRpb25hbFBhcnRzID0gYnVmZmVyLmdldFVpbnQ4KCk7XG4gICAgICAgIGNvbnN0IGlzVW5pY29kZSA9IGdldEJpdChtYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzVW5pY29kZSk7XG4gICAgICAgIC8vIFRoZSBvcmRlciBvZiB0aGVzZSBzdGF0ZW1lbnRzIGlzIGltcG9ydGFudC4gU2luY2UgYGJ1ZmZlci5nZXRYKClgIHdpbGxcbiAgICAgICAgLy8gaW50ZXJuYWxseSBpbmNyZW1lbnQgdGhlIHBvc2l0aW9uIG9mIG5leHQgYnl0ZSB0byByZWFkLCB0aGV5IG5lZWQgdG8gYmVcbiAgICAgICAgLy8gcmV0cmlldmVkIGluIHRoZSBleGFjdCBzYW1lIG9yZGVyIHRoZXkgd2VyZSBzZXJpYWxpemVkIChjaGVja1xuICAgICAgICAvLyBgc2VyaWFsaXplTmV0d29ya0ZpbHRlcmApLlxuICAgICAgICByZXR1cm4gbmV3IE5ldHdvcmtGaWx0ZXIoe1xuICAgICAgICAgICAgLy8gTWFuZGF0b3J5IGZpZWxkXG4gICAgICAgICAgICBtYXNrLFxuICAgICAgICAgICAgLy8gT3B0aW9uYWwgcGFydHNcbiAgICAgICAgICAgIGZpbHRlcjogKG9wdGlvbmFsUGFydHMgJiAxKSA9PT0gMVxuICAgICAgICAgICAgICAgID8gaXNVbmljb2RlXG4gICAgICAgICAgICAgICAgICAgID8gYnVmZmVyLmdldFVURjgoKVxuICAgICAgICAgICAgICAgICAgICA6IGJ1ZmZlci5nZXROZXR3b3JrRmlsdGVyKClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhvc3RuYW1lOiAob3B0aW9uYWxQYXJ0cyAmIDIpID09PSAyID8gYnVmZmVyLmdldE5ldHdvcmtIb3N0bmFtZSgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZG9tYWluczogKG9wdGlvbmFsUGFydHMgJiA0KSA9PT0gNCA/IERvbWFpbnMuZGVzZXJpYWxpemUoYnVmZmVyKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJhd0xpbmU6IChvcHRpb25hbFBhcnRzICYgOCkgPT09IDggPyBidWZmZXIuZ2V0UmF3TmV0d29yaygpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGVueWFsbG93OiAob3B0aW9uYWxQYXJ0cyAmIDE2KSA9PT0gMTYgPyBEb21haW5zLmRlc2VyaWFsaXplKGJ1ZmZlcikgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvcHRpb25WYWx1ZTogKG9wdGlvbmFsUGFydHMgJiAzMikgPT09IDMyXG4gICAgICAgICAgICAgICAgPyBnZXRCaXQobWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc0NTUClcbiAgICAgICAgICAgICAgICAgICAgPyBidWZmZXIuZ2V0TmV0d29ya0NTUCgpXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0Qml0KG1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNSZWRpcmVjdClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYnVmZmVyLmdldE5ldHdvcmtSZWRpcmVjdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGJ1ZmZlci5nZXRVVEY4KClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlZ2V4OiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IGZpbHRlciwgaG9zdG5hbWUsIG1hc2ssIGRvbWFpbnMsIGRlbnlhbGxvdywgb3B0aW9uVmFsdWUsIHJhd0xpbmUsIHJlZ2V4LCB9KSB7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICB0aGlzLmhvc3RuYW1lID0gaG9zdG5hbWU7XG4gICAgICAgIHRoaXMubWFzayA9IHNldEJpdChtYXNrLCAwKTtcbiAgICAgICAgdGhpcy5kb21haW5zID0gZG9tYWlucztcbiAgICAgICAgdGhpcy5kZW55YWxsb3cgPSBkZW55YWxsb3c7XG4gICAgICAgIHRoaXMub3B0aW9uVmFsdWUgPSBvcHRpb25WYWx1ZTtcbiAgICAgICAgdGhpcy5yYXdMaW5lID0gcmF3TGluZTtcbiAgICAgICAgdGhpcy5pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZWdleCA9IHJlZ2V4O1xuICAgIH1cbiAgICBnZXQgY3NwKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDU1AoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25WYWx1ZTtcbiAgICB9XG4gICAgZ2V0IHJlZGlyZWN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSZWRpcmVjdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvblZhbHVlO1xuICAgIH1cbiAgICBnZXQgcmVtb3ZlcGFyYW0oKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1JlbW92ZVBhcmFtKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uVmFsdWU7XG4gICAgfVxuICAgIGlzQ29zbWV0aWNGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNOZXR3b3JrRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbWF0Y2gocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gY2hlY2tPcHRpb25zKHRoaXMsIHJlcXVlc3QpICYmIGNoZWNrUGF0dGVybih0aGlzLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gYWxsb3cgZm9yIGEgbW9yZSBjb21wYWN0IHJlcHJlc2VudGF0aW9uIG9mIG5ldHdvcmsgZmlsdGVycywgdGhlXG4gICAgICogcmVwcmVzZW50YXRpb24gaXMgY29tcG9zZWQgb2YgYSBtYW5kYXRvcnkgaGVhZGVyLCBhbmQgc29tZSBvcHRpb25hbFxuICAgICAqXG4gICAgICogSGVhZGVyOlxuICAgICAqID09PT09PT1cbiAgICAgKlxuICAgICAqICB8IG9wdCB8IG1hc2tcbiAgICAgKiAgICAgOCAgICAgMzJcbiAgICAgKlxuICAgICAqIEZvciBhbiBlbXB0eSBmaWx0ZXIgaGF2aW5nIG5vIHBhdHRlcm4sIGhvc3RuYW1lLCB0aGUgbWluaW11bSBzaXplIGlzOiA0MiBiaXRzLlxuICAgICAqXG4gICAgICogVGhlbiBmb3IgZWFjaCBvcHRpb25hbCBwYXJ0IChmaWx0ZXIsIGhvc3RuYW1lIG9wdERvbWFpbnMsIG9wdE5vdERvbWFpbnMsXG4gICAgICogcmVkaXJlY3QpLCBpdCB0YWtlcyAxNiBiaXRzIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgKyB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgICAqIHN0cmluZyBpbiBieXRlcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcHRpb25hbCBwYXJ0cyBhcmUgd3JpdHRlbiBpbiBvcmRlciBvZiB0aGVyZSBudW1iZXIgb2Ygb2NjdXJyZW5jZSBpbiB0aGVcbiAgICAgKiBmaWx0ZXIgbGlzdCB1c2VkIGJ5IHRoZSBhZGJsb2NrZXIuIFRoZSBtb3N0IGNvbW1vbiBiZWluZyBgaG9zdG5hbWVgLCB0aGVuXG4gICAgICogYGZpbHRlcmAsIGBvcHREb21haW5zYCwgYG9wdE5vdERvbWFpbnNgLCBgcmVkaXJlY3RgLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiA9PT09PT09PVxuICAgICAqXG4gICAgICogQEB8fGNsaXF6LmNvbSB3b3VsZCByZXN1bHQgaW4gYSBzZXJpYWxpemVkIHZlcnNpb246XG4gICAgICpcbiAgICAgKiB8IDEgfCBtYXNrIHwgOSB8IGMgfCBsIHwgaSB8IHEgfCB6IHwgLiB8IGMgfCBvIHwgbSAgKDE2IGJ5dGVzKVxuICAgICAqXG4gICAgICogSW4gdGhpcyBjYXNlLCB0aGUgc2VyaWFsaXplZCB2ZXJzaW9uIGlzIGFjdHVhbGx5IGJpZ2dlciB0aGFuIHRoZSBvcmlnaW5hbFxuICAgICAqIGZpbHRlciwgYnV0IGZhc3RlciB0byBkZXNlcmlhbGl6ZS4gSW4gdGhlIGZ1dHVyZSwgd2UgY291bGQgb3B0aW1pemUgdGhlXG4gICAgICogcmVwcmVzZW50YXRpb24gdG8gY29tcGFjdCBzbWFsbCBmaWx0ZXJzIGJldHRlci5cbiAgICAgKlxuICAgICAqIElkZWFzOlxuICAgICAqICAqIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZyBmb3IgdGhlIG1hc2sgKGlmIG5vdCBvcHRpb24sIHRha2UgbWF4IDEgYnl0ZSkuXG4gICAgICogICogZmlyc3QgYnl0ZSBjb3VsZCBjb250YWluIHRoZSBtYXNrIGFzIHdlbGwgaWYgc21hbGwgZW5vdWdoLlxuICAgICAqICAqIHdoZW4gcGFja2luZyBhc2NpaSBzdHJpbmcsIHN0b3JlIHNldmVyYWwgb2YgdGhlbSBpbiBlYWNoIGJ5dGUuXG4gICAgICovXG4gICAgc2VyaWFsaXplKGJ1ZmZlcikge1xuICAgICAgICBidWZmZXIucHVzaFVpbnQzMih0aGlzLm1hc2spO1xuICAgICAgICBjb25zdCBpbmRleCA9IGJ1ZmZlci5nZXRQb3MoKTtcbiAgICAgICAgYnVmZmVyLnB1c2hVaW50OCgwKTtcbiAgICAgICAgLy8gVGhpcyBiaXQtbWFzayBpbmRpY2F0ZXMgd2hpY2ggb3B0aW9uYWwgcGFydHMgb2YgdGhlIGZpbHRlciB3ZXJlIHNlcmlhbGl6ZWQuXG4gICAgICAgIGxldCBvcHRpb25hbFBhcnRzID0gMDtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbmFsUGFydHMgfD0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVW5pY29kZSgpKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnB1c2hVVEY4KHRoaXMuZmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoTmV0d29ya0ZpbHRlcih0aGlzLmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaG9zdG5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9uYWxQYXJ0cyB8PSAyO1xuICAgICAgICAgICAgYnVmZmVyLnB1c2hOZXR3b3JrSG9zdG5hbWUodGhpcy5ob3N0bmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZG9tYWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25hbFBhcnRzIHw9IDQ7XG4gICAgICAgICAgICB0aGlzLmRvbWFpbnMuc2VyaWFsaXplKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmF3TGluZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25hbFBhcnRzIHw9IDg7XG4gICAgICAgICAgICBidWZmZXIucHVzaFJhd05ldHdvcmsodGhpcy5yYXdMaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZW55YWxsb3cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9uYWxQYXJ0cyB8PSAxNjtcbiAgICAgICAgICAgIHRoaXMuZGVueWFsbG93LnNlcmlhbGl6ZShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvblZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbmFsUGFydHMgfD0gMzI7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0NTUCgpKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnB1c2hOZXR3b3JrQ1NQKHRoaXMub3B0aW9uVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc1JlZGlyZWN0KCkpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaE5ldHdvcmtSZWRpcmVjdCh0aGlzLm9wdGlvblZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoVVRGOCh0aGlzLm9wdGlvblZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidWZmZXIuc2V0Qnl0ZShpbmRleCwgb3B0aW9uYWxQYXJ0cyk7XG4gICAgfVxuICAgIGdldFNlcmlhbGl6ZWRTaXplKGNvbXByZXNzaW9uKSB7XG4gICAgICAgIGxldCBlc3RpbWF0ZSA9IDQgKyAxOyAvLyBtYXNrID0gNCBieXRlcyAvLyBvcHRpb25hbCBwYXJ0cyA9IDEgYnl0ZVxuICAgICAgICBpZiAodGhpcy5maWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNVbmljb2RlKCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZSArPSBzaXplT2ZVVEY4KHRoaXMuZmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVzdGltYXRlICs9IHNpemVPZk5ldHdvcmtGaWx0ZXIodGhpcy5maWx0ZXIsIGNvbXByZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ob3N0bmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZSArPSBzaXplT2ZOZXR3b3JrSG9zdG5hbWUodGhpcy5ob3N0bmFtZSwgY29tcHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRvbWFpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXN0aW1hdGUgKz0gdGhpcy5kb21haW5zLmdldFNlcmlhbGl6ZWRTaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmF3TGluZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZSArPSBzaXplT2ZSYXdOZXR3b3JrKHRoaXMucmF3TGluZSwgY29tcHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlbnlhbGxvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZSArPSB0aGlzLmRlbnlhbGxvdy5nZXRTZXJpYWxpemVkU2l6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvblZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ1NQKCkpIHtcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZSArPSBzaXplT2ZOZXR3b3JrQ1NQKHRoaXMub3B0aW9uVmFsdWUsIGNvbXByZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNSZWRpcmVjdCgpKSB7XG4gICAgICAgICAgICAgICAgZXN0aW1hdGUgKz0gc2l6ZU9mTmV0d29ya1JlZGlyZWN0KHRoaXMub3B0aW9uVmFsdWUsIGNvbXByZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVzdGltYXRlICs9IHNpemVPZlVURjgodGhpcy5vcHRpb25WYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVzdGltYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmllcyB0byByZWNyZWF0ZSB0aGUgb3JpZ2luYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGZpbHRlciAoYWRibG9ja1xuICAgICAqIHN5bnRheCkgZnJvbSB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24uIElmIGByYXdMaW5lYCBpcyBzZXQgKHdoZW4gZmlsdGVyc1xuICAgICAqIGFyZSBwYXJzZWQgaW4gYGRlYnVnYCBtb2RlIGZvciBleGFtcGxlKSwgdGhlbiBpdCBpcyByZXR1cm5lZCBkaXJlY3RseS5cbiAgICAgKiBPdGhlcndpc2UsIHdlIHRyeSB0byBzdGljayBhcyBjbG9zZWx5IGFzIHBvc3NpYmxlIHRvIHRoZSBvcmlnaW5hbCBmb3JtO1xuICAgICAqIHRoZXJlIGFyZSB0aGluZ3Mgd2hpY2ggY2Fubm90IGJlIHJlY292ZXJlZCB0aG91Z2gsIGxpa2UgZG9tYWlucyBvcHRpb25zXG4gICAgICogb2Ygd2hpY2ggb25seSBoYXNoZXMgYXJlIHN0b3JlZC5cbiAgICAgKi9cbiAgICB0b1N0cmluZyhtb2RpZmllclJlcGxhY2VyKSB7XG4gICAgICAgIGlmICh0aGlzLnJhd0xpbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3TGluZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmlsdGVyID0gJyc7XG4gICAgICAgIGlmICh0aGlzLmlzRXhjZXB0aW9uKCkpIHtcbiAgICAgICAgICAgIGZpbHRlciArPSAnQEAnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzSG9zdG5hbWVBbmNob3IoKSkge1xuICAgICAgICAgICAgZmlsdGVyICs9ICd8fCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5mcm9tSHR0cCgpICE9PSB0aGlzLmZyb21IdHRwcygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mcm9tSHR0cCgpKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyICs9ICd8aHR0cDovLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXIgKz0gJ3xodHRwczovLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc0xlZnRBbmNob3IoKSkge1xuICAgICAgICAgICAgZmlsdGVyICs9ICd8JztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNIb3N0bmFtZSgpKSB7XG4gICAgICAgICAgICBmaWx0ZXIgKz0gdGhpcy5nZXRIb3N0bmFtZSgpO1xuICAgICAgICAgICAgZmlsdGVyICs9ICdeJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0Z1bGxSZWdleCgpKSB7XG4gICAgICAgICAgICBmaWx0ZXIgKz0gYC8ke3RoaXMuZ2V0UmVnZXgoKS5zb3VyY2V9L2A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1JlZ2V4KCkpIHtcbiAgICAgICAgICAgIGZpbHRlciArPSB0aGlzLmdldFJlZ2V4KCkuc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmlsdGVyICs9IHRoaXMuZ2V0RmlsdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNSaWdodEFuY2hvcigpICYmIGZpbHRlcltmaWx0ZXIubGVuZ3RoIC0gMV0gIT09ICdeJykge1xuICAgICAgICAgICAgZmlsdGVyICs9ICd8JztcbiAgICAgICAgfVxuICAgICAgICAvLyBPcHRpb25zXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbUFueSgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZDcHRPcHRpb25zID0gYml0Q291bnQodGhpcy5nZXRDcHRNYXNrKCkpO1xuICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZOZWdhdGVkT3B0aW9ucyA9IGJpdENvdW50KEZST01fQU5ZKSAtIG51bWJlck9mQ3B0T3B0aW9ucztcbiAgICAgICAgICAgIGlmIChudW1iZXJPZk5lZ2F0ZWRPcHRpb25zIDwgbnVtYmVyT2ZDcHRPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGdldExpc3RPZlJlcXVlc3RUeXBlc05lZ2F0ZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKGB+JHt0eXBlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBnZXRMaXN0T2ZSZXF1ZXN0VHlwZXModGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0ltcG9ydGFudCgpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goJ2ltcG9ydGFudCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzUmVkaXJlY3RSdWxlKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvblZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaCgncmVkaXJlY3QtcnVsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKGByZWRpcmVjdC1ydWxlPSR7dGhpcy5vcHRpb25WYWx1ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzUmVkaXJlY3QoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uVmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKCdyZWRpcmVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKGByZWRpcmVjdD0ke3RoaXMub3B0aW9uVmFsdWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNDU1AoKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKGBjc3A9JHt0aGlzLm9wdGlvblZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzRWxlbUhpZGUoKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKCdlbGVtaGlkZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU3BlY2lmaWNIaWRlKCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaCgnc3BlY2lmaWNoaWRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNHZW5lcmljSGlkZSgpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goJ2dlbmVyaWNoaWRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmlyc3RQYXJ0eSgpICE9PSB0aGlzLnRoaXJkUGFydHkoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RQYXJ0eSgpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKCcxcCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudGhpcmRQYXJ0eSgpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKCczcCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRvbWFpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tYWlucy5wYXJ0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wdXNoKGBkb21haW49JHt0aGlzLmRvbWFpbnMucGFydHN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2goJ2RvbWFpbj08aGFzaGVkPicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlbnlhbGxvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZW55YWxsb3cucGFydHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaChgZGVueWFsbG93PSR7dGhpcy5kZW55YWxsb3cucGFydHN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2goJ2RlbnlhbGxvdz08aGFzaGVkPicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQmFkRmlsdGVyKCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaCgnYmFkZmlsdGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVtb3ZlcGFyYW0gPSB0aGlzLnJlbW92ZXBhcmFtO1xuICAgICAgICBpZiAocmVtb3ZlcGFyYW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHJlbW92ZXBhcmFtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2goYHJlbW92ZXBhcmFtPSR7cmVtb3ZlcGFyYW19YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2goJ3JlbW92ZXBhcmFtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllclJlcGxhY2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyICs9IGAkJHtvcHRpb25zLm1hcChtb2RpZmllclJlcGxhY2VyKS5qb2luKCcsJyl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbHRlciArPSBgJCR7b3B0aW9ucy5qb2luKCcsJyl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgIH1cbiAgICAvLyBQdWJsaWMgQVBJIChSZWFkLU9ubHkpXG4gICAgZ2V0SWRXaXRob3V0QmFkRmlsdGVyKCkge1xuICAgICAgICAvLyBUaGlzIG1ldGhvZCBjb21wdXRlcyB0aGUgaWQgaWdub3JpbmcgdGhlICRiYWRmaWx0ZXIgb3B0aW9uICh3aGljaCB3aWxsXG4gICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIElEIG9mIGZpbHRlcnMgYmVpbmcgZGlzY2FyZGVkKS4gVGhpcyBhbGxvd3MgdXMgdG9cbiAgICAgICAgLy8gZWxpbWluYXRlIGJhZCBmaWx0ZXJzIGJ5IGNvbXBhcmluZyBJRHMsIHdoaWNoIGlzIG1vcmUgcm9idXN0IGFuZCBmYXN0ZXJcbiAgICAgICAgLy8gdGhhbiBzdHJpbmcgY29tcGFyaXNvbi5cbiAgICAgICAgcmV0dXJuIGNvbXB1dGVGaWx0ZXJJZCh0aGlzLm1hc2sgJiB+TkVUV09SS19GSUxURVJfTUFTSy5pc0JhZEZpbHRlciwgdGhpcy5maWx0ZXIsIHRoaXMuaG9zdG5hbWUsIHRoaXMuZG9tYWlucywgdGhpcy5kZW55YWxsb3csIHRoaXMub3B0aW9uVmFsdWUpO1xuICAgIH1cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IGNvbXB1dGVGaWx0ZXJJZCh0aGlzLm1hc2ssIHRoaXMuZmlsdGVyLCB0aGlzLmhvc3RuYW1lLCB0aGlzLmRvbWFpbnMsIHRoaXMuZGVueWFsbG93LCB0aGlzLm9wdGlvblZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICB9XG4gICAgaGFzRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaGFzRG9tYWlucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tYWlucyAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXRNYXNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXNrO1xuICAgIH1cbiAgICBnZXRDcHRNYXNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXNrKCkgJiBGUk9NX0FOWTtcbiAgICB9XG4gICAgaXNSZWRpcmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldEJpdCh0aGlzLmdldE1hc2soKSwgTkVUV09SS19GSUxURVJfTUFTSy5pc1JlZGlyZWN0KTtcbiAgICB9XG4gICAgaXNSZWRpcmVjdFJ1bGUoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaXQodGhpcy5tYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzUmVkaXJlY3RSdWxlKTtcbiAgICB9XG4gICAgZ2V0UmVkaXJlY3QoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMub3B0aW9uVmFsdWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgIH1cbiAgICBpc1JlcGxhY2UoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaXQodGhpcy5nZXRNYXNrKCksIE5FVFdPUktfRklMVEVSX01BU0suaXNSZXBsYWNlKTtcbiAgICB9XG4gICAgaXNSZW1vdmVQYXJhbSgpIHtcbiAgICAgICAgcmV0dXJuIGdldEJpdCh0aGlzLmdldE1hc2soKSwgTkVUV09SS19GSUxURVJfTUFTSy5pc1JlbW92ZVBhcmFtKTtcbiAgICB9XG4gICAgLy8gRXhwZWN0ZWQgdG8gYmUgY2FsbGVkIG9ubHkgd2l0aCBgJHJlcGxhY2VgIG1vZGlmaWVyc1xuICAgIGdldEh0bWxNb2RpZmllcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBFbXB0eSBgJHJlcGxhY2VgIG1vZGlmaWVyIGlzIHRvIGRpc2FibGUgYWxsIHJlcGxhY2UgbW9kaWZpZXJzIG9uIGV4Y2VwdGlvblxuICAgICAgICAvLyBUaGlzIGlzIGNoZWNrZWQgb24gdGhlIHBhcnNlIHRpbWVcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLm9wdGlvblZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGxhY2VPcHRpb25WYWx1ZVRvUmVnZXhwKHRoaXMub3B0aW9uVmFsdWUpO1xuICAgIH1cbiAgICBpc0h0bWxGaWx0ZXJpbmdSdWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1JlcGxhY2UoKTtcbiAgICB9XG4gICAgZ2V0UmVkaXJlY3RSZXNvdXJjZSgpIHtcbiAgICAgICAgY29uc3QgcmVkaXJlY3QgPSB0aGlzLmdldFJlZGlyZWN0KCk7XG4gICAgICAgIGNvbnN0IHByaW9yaXR5SW5kZXggPSByZWRpcmVjdC5sYXN0SW5kZXhPZignOicpO1xuICAgICAgICBpZiAocHJpb3JpdHlJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiByZWRpcmVjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVkaXJlY3Quc2xpY2UoMCwgcHJpb3JpdHlJbmRleCk7XG4gICAgfVxuICAgIGdldFJlZGlyZWN0UHJpb3JpdHkoKSB7XG4gICAgICAgIGNvbnN0IHJlZGlyZWN0ID0gdGhpcy5nZXRSZWRpcmVjdCgpO1xuICAgICAgICBjb25zdCBwcmlvcml0eUluZGV4ID0gcmVkaXJlY3QubGFzdEluZGV4T2YoJzonKTtcbiAgICAgICAgaWYgKHByaW9yaXR5SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTnVtYmVyKHJlZGlyZWN0LnNsaWNlKHByaW9yaXR5SW5kZXggKyAxKSk7XG4gICAgfVxuICAgIGhhc0hvc3RuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0bmFtZSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXRIb3N0bmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgfVxuICAgIGdldEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyIHx8ICcnO1xuICAgIH1cbiAgICBnZXRSZWdleCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVnZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yZWdleCA9XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXIgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmlzUmVnZXgoKVxuICAgICAgICAgICAgICAgICAgICA/IGNvbXBpbGVSZWdleCh0aGlzLmZpbHRlciwgdGhpcy5pc0xlZnRBbmNob3IoKSwgdGhpcy5pc1JpZ2h0QW5jaG9yKCksIHRoaXMuaXNGdWxsUmVnZXgoKSlcbiAgICAgICAgICAgICAgICAgICAgOiBNQVRDSF9BTEw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVnZXg7XG4gICAgfVxuICAgIGdldFRva2VucygpIHtcbiAgICAgICAgVE9LRU5TX0JVRkZFUi5yZXNldCgpO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSBkb21haW4gYW5kIG5vIGRvbWFpbiBuZWdhdGlvbiwgd2UgYWxzbyB1c2UgdGhpc1xuICAgICAgICAvLyBkb21haW4gYXMgYSB0b2tlbi5cbiAgICAgICAgaWYgKHRoaXMuZG9tYWlucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmRvbWFpbnMuaG9zdG5hbWVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuZG9tYWlucy5lbnRpdGllcyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmRvbWFpbnMubm90SG9zdG5hbWVzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuZG9tYWlucy5ub3RFbnRpdGllcyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmRvbWFpbnMuaG9zdG5hbWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgVE9LRU5TX0JVRkZFUi5wdXNoKHRoaXMuZG9tYWlucy5ob3N0bmFtZXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0b2tlbnMgZnJvbSBmaWx0ZXJcbiAgICAgICAgaWYgKHRoaXMuaXNGdWxsUmVnZXgoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2tpcExhc3RUb2tlbiA9ICF0aGlzLmlzUmlnaHRBbmNob3IoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBza2lwRmlyc3RUb2tlbiA9ICF0aGlzLmlzTGVmdEFuY2hvcigpO1xuICAgICAgICAgICAgICAgIHRva2VuaXplV2l0aFdpbGRjYXJkc0luUGxhY2UodGhpcy5maWx0ZXIsIHNraXBGaXJzdFRva2VuLCBza2lwTGFzdFRva2VuLCBUT0tFTlNfQlVGRkVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFwcGVuZCB0b2tlbnMgZnJvbSBob3N0bmFtZSwgaWYgYW55XG4gICAgICAgICAgICBpZiAodGhpcy5ob3N0bmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5pemVJblBsYWNlKHRoaXMuaG9zdG5hbWUsIGZhbHNlLCB0aGlzLmZpbHRlciAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZmlsdGVyLmNoYXJDb2RlQXQoMCkgPT09IDQyIC8qICcqJyAqLywgVE9LRU5TX0JVRkZFUik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5maWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9rZW5pemVSZWdleEluUGxhY2UodGhpcy5maWx0ZXIsIFRPS0VOU19CVUZGRVIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGdvdCBubyB0b2tlbnMgZm9yIHRoZSBmaWx0ZXIvaG9zdG5hbWUgcGFydCwgdGhlbiB3ZSB3aWxsIGRpc3BhdGNoXG4gICAgICAgIC8vIHRoaXMgZmlsdGVyIGluIG11bHRpcGxlIGJ1Y2tldHMgYmFzZWQgb24gdGhlIGRvbWFpbnMgb3B0aW9uLlxuICAgICAgICBpZiAoVE9LRU5TX0JVRkZFUi5lbXB0eSgpID09PSB0cnVlICYmXG4gICAgICAgICAgICB0aGlzLmRvbWFpbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5kb21haW5zLmhvc3RuYW1lcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmRvbWFpbnMuZW50aXRpZXMgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5kb21haW5zLm5vdEhvc3RuYW1lcyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmRvbWFpbnMubm90RW50aXRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhvc3RuYW1lIG9mIHRoaXMuZG9tYWlucy5ob3N0bmFtZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDMyQXJyYXkoMSk7XG4gICAgICAgICAgICAgICAgYXJyWzBdID0gaG9zdG5hbWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIG9wdGlvbmFsIHRva2VuIGZvciB0eXBlc1xuICAgICAgICBpZiAoVE9LRU5TX0JVRkZFUi5lbXB0eSgpID09PSB0cnVlICYmIHRoaXMuZnJvbUFueSgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgdHlwZXMgPSBnZXRMaXN0T2ZSZXF1ZXN0VHlwZXModGhpcyk7XG4gICAgICAgICAgICBpZiAodHlwZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyciA9IG5ldyBVaW50MzJBcnJheSgxKTtcbiAgICAgICAgICAgICAgICAgICAgYXJyWzBdID0gTk9STUFMSVpFRF9UWVBFX1RPS0VOW3R5cGVdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBvcHRpb25hbCB0b2tlbiBmb3IgcHJvdG9jb2xcbiAgICAgICAgaWYgKHRoaXMuZnJvbUh0dHAoKSA9PT0gdHJ1ZSAmJiB0aGlzLmZyb21IdHRwcygpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgVE9LRU5TX0JVRkZFUi5wdXNoKEhUVFBfSEFTSCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5mcm9tSHR0cHMoKSA9PT0gdHJ1ZSAmJiB0aGlzLmZyb21IdHRwKCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBUT0tFTlNfQlVGRkVSLnB1c2goSFRUUFNfSEFTSCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtUT0tFTlNfQlVGRkVSLnNsaWNlKCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIGZpbHRlciBzaG91bGQgYXBwbHkgdG8gYSByZXF1ZXN0IHdpdGggdGhpcyBjb250ZW50IHR5cGUuXG4gICAgICovXG4gICAgaXNDcHRBbGxvd2VkKGNwdCkge1xuICAgICAgICBjb25zdCBtYXNrID0gUkVRVUVTVF9UWVBFX1RPX01BU0tbY3B0XTtcbiAgICAgICAgaWYgKG1hc2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJpdCh0aGlzLm1hc2ssIG1hc2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGNvbnRlbnQgdHlwZSBpcyBub3Qgc3VwcG9ydGVkIChvciBub3Qgc3BlY2lmaWVkKSwgd2UgcmV0dXJuIGB0cnVlYFxuICAgICAgICAvLyBvbmx5IGlmIHRoZSBmaWx0ZXIgZG9lcyBub3Qgc3BlY2lmeSBhbnkgcmVzb3VyY2UgdHlwZS5cbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUFueSgpO1xuICAgIH1cbiAgICBpc0V4Y2VwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldEJpdCh0aGlzLm1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNFeGNlcHRpb24pO1xuICAgIH1cbiAgICBpc0hvc3RuYW1lQW5jaG9yKCkge1xuICAgICAgICByZXR1cm4gZ2V0Qml0KHRoaXMubWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc0hvc3RuYW1lQW5jaG9yKTtcbiAgICB9XG4gICAgaXNSaWdodEFuY2hvcigpIHtcbiAgICAgICAgcmV0dXJuIGdldEJpdCh0aGlzLm1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNSaWdodEFuY2hvcik7XG4gICAgfVxuICAgIGlzTGVmdEFuY2hvcigpIHtcbiAgICAgICAgcmV0dXJuIGdldEJpdCh0aGlzLm1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNMZWZ0QW5jaG9yKTtcbiAgICB9XG4gICAgaXNJbXBvcnRhbnQoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaXQodGhpcy5tYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzSW1wb3J0YW50KTtcbiAgICB9XG4gICAgaXNGdWxsUmVnZXgoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaXQodGhpcy5tYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzRnVsbFJlZ2V4KTtcbiAgICB9XG4gICAgaXNSZWdleCgpIHtcbiAgICAgICAgcmV0dXJuIChnZXRCaXQodGhpcy5tYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzUmVnZXgpIHx8XG4gICAgICAgICAgICBnZXRCaXQodGhpcy5tYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzRnVsbFJlZ2V4KSk7XG4gICAgfVxuICAgIGlzUGxhaW4oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc1JlZ2V4KCk7XG4gICAgfVxuICAgIGlzQ1NQKCkge1xuICAgICAgICByZXR1cm4gZ2V0Qml0KHRoaXMubWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc0NTUCk7XG4gICAgfVxuICAgIGlzRWxlbUhpZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU3BlY2lmaWNIaWRlKCkgJiYgdGhpcy5pc0dlbmVyaWNIaWRlKCk7XG4gICAgfVxuICAgIGlzU3BlY2lmaWNIaWRlKCkge1xuICAgICAgICByZXR1cm4gZ2V0Qml0KHRoaXMubWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5pc1NwZWNpZmljSGlkZSk7XG4gICAgfVxuICAgIGlzR2VuZXJpY0hpZGUoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaXQodGhpcy5tYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzR2VuZXJpY0hpZGUpO1xuICAgIH1cbiAgICBpc0JhZEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIGdldEJpdCh0aGlzLm1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suaXNCYWRGaWx0ZXIpO1xuICAgIH1cbiAgICBpc1VuaWNvZGUoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaXQodGhpcy5tYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmlzVW5pY29kZSk7XG4gICAgfVxuICAgIGZyb21BbnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENwdE1hc2soKSA9PT0gRlJPTV9BTlk7XG4gICAgfVxuICAgIHRoaXJkUGFydHkoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaXQodGhpcy5tYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLnRoaXJkUGFydHkpO1xuICAgIH1cbiAgICBmaXJzdFBhcnR5KCkge1xuICAgICAgICByZXR1cm4gZ2V0Qml0KHRoaXMubWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5maXJzdFBhcnR5KTtcbiAgICB9XG4gICAgZnJvbUltYWdlKCkge1xuICAgICAgICByZXR1cm4gZ2V0Qml0KHRoaXMubWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5mcm9tSW1hZ2UpO1xuICAgIH1cbiAgICBmcm9tTWVkaWEoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaXQodGhpcy5tYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21NZWRpYSk7XG4gICAgfVxuICAgIGZyb21PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaXQodGhpcy5tYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21PYmplY3QpO1xuICAgIH1cbiAgICBmcm9tT3RoZXIoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaXQodGhpcy5tYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21PdGhlcik7XG4gICAgfVxuICAgIGZyb21QaW5nKCkge1xuICAgICAgICByZXR1cm4gZ2V0Qml0KHRoaXMubWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5mcm9tUGluZyk7XG4gICAgfVxuICAgIGZyb21TY3JpcHQoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaXQodGhpcy5tYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21TY3JpcHQpO1xuICAgIH1cbiAgICBmcm9tU3R5bGVzaGVldCgpIHtcbiAgICAgICAgcmV0dXJuIGdldEJpdCh0aGlzLm1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suZnJvbVN0eWxlc2hlZXQpO1xuICAgIH1cbiAgICBmcm9tRG9jdW1lbnQoKSB7XG4gICAgICAgIHJldHVybiBnZXRCaXQodGhpcy5tYXNrLCBORVRXT1JLX0ZJTFRFUl9NQVNLLmZyb21Eb2N1bWVudCk7XG4gICAgfVxuICAgIGZyb21TdWJkb2N1bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIGdldEJpdCh0aGlzLm1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suZnJvbVN1YmRvY3VtZW50KTtcbiAgICB9XG4gICAgZnJvbVdlYnNvY2tldCgpIHtcbiAgICAgICAgcmV0dXJuIGdldEJpdCh0aGlzLm1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suZnJvbVdlYnNvY2tldCk7XG4gICAgfVxuICAgIGZyb21IdHRwKCkge1xuICAgICAgICByZXR1cm4gZ2V0Qml0KHRoaXMubWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5mcm9tSHR0cCk7XG4gICAgfVxuICAgIGZyb21IdHRwcygpIHtcbiAgICAgICAgcmV0dXJuIGdldEJpdCh0aGlzLm1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suZnJvbUh0dHBzKTtcbiAgICB9XG4gICAgZnJvbVhtbEh0dHBSZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4gZ2V0Qml0KHRoaXMubWFzaywgTkVUV09SS19GSUxURVJfTUFTSy5mcm9tWG1sSHR0cFJlcXVlc3QpO1xuICAgIH1cbiAgICBmcm9tRm9udCgpIHtcbiAgICAgICAgcmV0dXJuIGdldEJpdCh0aGlzLm1hc2ssIE5FVFdPUktfRklMVEVSX01BU0suZnJvbUZvbnQpO1xuICAgIH1cbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRmlsdGVyIHBhcnNpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gc2V0TmV0d29ya01hc2sobWFzaywgbSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHNldEJpdChtYXNrLCBtKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsZWFyQml0KG1hc2ssIG0pO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgc3ViLXN0cmluZyBjb250YWluZWQgYmV0d2VlbiB0aGUgaW5kaWNlcyBzdGFydCBhbmQgZW5kIGlzIGFcbiAqIHJlZ2V4IGZpbHRlciAoaXQgY29udGFpbnMgYSAnKicgb3IgJ14nIGNoYXIpLlxuICovXG5mdW5jdGlvbiBjaGVja0lzUmVnZXgoZmlsdGVyLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgaW5kZXhPZlNlcGFyYXRvciA9IGZpbHRlci5pbmRleE9mKCdeJywgc3RhcnQpO1xuICAgIGlmIChpbmRleE9mU2VwYXJhdG9yICE9PSAtMSAmJiBpbmRleE9mU2VwYXJhdG9yIDwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBpbmRleE9mV2lsZGNhcmQgPSBmaWx0ZXIuaW5kZXhPZignKicsIHN0YXJ0KTtcbiAgICByZXR1cm4gaW5kZXhPZldpbGRjYXJkICE9PSAtMSAmJiBpbmRleE9mV2lsZGNhcmQgPCBlbmQ7XG59XG4vKipcbiAqIEhhbmRsZSBob3N0bmFtZSBhbmNob3JlZCBmaWx0ZXJzLCBnaXZlbiAnaG9zdG5hbWUnIGZyb20gfHxob3N0bmFtZSBhbmRcbiAqIHJlcXVlc3QncyBob3N0bmFtZSwgY2hlY2sgaWYgdGhlcmUgaXMgYSBtYXRjaC4gVGhpcyBpcyB0cmlja3kgYmVjYXVzZVxuICogZmlsdGVycyBhdXRob3JzIHJlbHkgYW5kIGRpZmZlcmVudCBhc3N1bXB0aW9ucy4gV2UgY2FuIGhhdmUgcHJlZml4IG9mIHN1ZmZpeFxuICogbWF0Y2hlcyBvZiBhbmNob3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FuY2hvcmVkQnlIb3N0bmFtZShmaWx0ZXJIb3N0bmFtZSwgaG9zdG5hbWUsIGlzRm9sbG93ZWRCeVdpbGRjYXJkKSB7XG4gICAgLy8gQ29ybmVyLWNhc2UsIGlmIGBmaWx0ZXJIb3N0bmFtZWAgaXMgZW1wdHksIHRoZW4gaXQncyBhIG1hdGNoXG4gICAgaWYgKGZpbHRlckhvc3RuYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gYGZpbHRlckhvc3RuYW1lYCBjYW5ub3QgYmUgbG9uZ2VyIHRoYW4gYWN0dWFsIGhvc3RuYW1lXG4gICAgaWYgKGZpbHRlckhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIElmIHRoZXkgaGF2ZSB0aGUgc2FtZSBsZW5ndGgsIHRoZXkgc2hvdWxkIGJlIGVxdWFsXG4gICAgaWYgKGZpbHRlckhvc3RuYW1lLmxlbmd0aCA9PT0gaG9zdG5hbWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJIb3N0bmFtZSA9PT0gaG9zdG5hbWU7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIGBmaWx0ZXJIb3N0bmFtZWAgYXBwZWFycyBhbnl3aGVyZSBpbiBgaG9zdG5hbWVgXG4gICAgY29uc3QgbWF0Y2hJbmRleCA9IGhvc3RuYW1lLmluZGV4T2YoZmlsdGVySG9zdG5hbWUpO1xuICAgIC8vIE5vIG1hdGNoXG4gICAgaWYgKG1hdGNoSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gYGZpbHRlckhvc3RuYW1lYCBpcyBhIHByZWZpeCBvZiBgaG9zdG5hbWVgIGFuZCBuZWVkcyB0byBtYXRjaCBmdWxsIGEgbGFiZWwuXG4gICAgLy9cbiAgICAvLyBFeGFtcGxlcyAoZmlsdGVySG9zdG5hbWUsIGhvc3RuYW1lKTpcbiAgICAvLyAgICogKGZvbywgZm9vLmNvbSlcbiAgICAvLyAgICogKHN1Yi5mb28sIHN1Yi5mb28uY29tKVxuICAgIGlmIChtYXRjaEluZGV4ID09PSAwKSB7XG4gICAgICAgIHJldHVybiAoaXNGb2xsb3dlZEJ5V2lsZGNhcmQgPT09IHRydWUgfHxcbiAgICAgICAgICAgIGhvc3RuYW1lLmNoYXJDb2RlQXQoZmlsdGVySG9zdG5hbWUubGVuZ3RoKSA9PT0gNDYgLyogJy4nICovIHx8XG4gICAgICAgICAgICBmaWx0ZXJIb3N0bmFtZS5jaGFyQ29kZUF0KGZpbHRlckhvc3RuYW1lLmxlbmd0aCAtIDEpID09PSA0NiAvKiAnLicgKi8pO1xuICAgIH1cbiAgICAvLyBgZmlsdGVySG9zdG5hbWVgIGlzIGEgc3VmZml4IG9mIGBob3N0bmFtZWAuXG4gICAgLy9cbiAgICAvLyBFeGFtcGxlcyAoZmlsdGVySG9zdG5hbWUsIGhvc3RuYW1lKTpcbiAgICAvLyAgICAqIChmb28uY29tLCBzdWIuZm9vLmNvbSlcbiAgICAvLyAgICAqIChjb20sIGZvby5jb20pXG4gICAgaWYgKGhvc3RuYW1lLmxlbmd0aCA9PT0gbWF0Y2hJbmRleCArIGZpbHRlckhvc3RuYW1lLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gKGhvc3RuYW1lLmNoYXJDb2RlQXQobWF0Y2hJbmRleCAtIDEpID09PSA0NiAvKiAnLicgKi8gfHxcbiAgICAgICAgICAgIGZpbHRlckhvc3RuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qICcuJyAqLyk7XG4gICAgfVxuICAgIC8vIGBmaWx0ZXJIb3N0bmFtZWAgaXMgaW5maXggb2YgYGhvc3RuYW1lYCBhbmQgbmVlZHMgbWF0Y2ggZnVsbCBsYWJlbHNcbiAgICByZXR1cm4gKChpc0ZvbGxvd2VkQnlXaWxkY2FyZCA9PT0gdHJ1ZSB8fFxuICAgICAgICBob3N0bmFtZS5jaGFyQ29kZUF0KGZpbHRlckhvc3RuYW1lLmxlbmd0aCkgPT09IDQ2IC8qICcuJyAqLyB8fFxuICAgICAgICBmaWx0ZXJIb3N0bmFtZS5jaGFyQ29kZUF0KGZpbHRlckhvc3RuYW1lLmxlbmd0aCAtIDEpID09PSA0NikgLyogJy4nICovICYmXG4gICAgICAgIChob3N0bmFtZS5jaGFyQ29kZUF0KG1hdGNoSW5kZXggLSAxKSA9PT0gNDYgfHwgZmlsdGVySG9zdG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gNDYpKTtcbn1cbi8qKlxuICogU3BlY2lhbGl6ZSBhIG5ldHdvcmsgZmlsdGVyIGRlcGVuZGluZyBvbiBpdHMgdHlwZS4gSXQgYWxsb3dzIGZvciBtb3JlXG4gKiBlZmZpY2llbnQgbWF0Y2hpbmcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUGF0dGVybihmaWx0ZXIsIHJlcXVlc3QpIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gZmlsdGVyLmdldEZpbHRlcigpO1xuICAgIGNvbnN0IHVybCA9IHJlcXVlc3Qubm9ybWFsaXplZFVybDtcbiAgICBpZiAoZmlsdGVyLmlzSG9zdG5hbWVBbmNob3IoKSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgcmVxdWVzdCBpcyBhbmNob3JlZCBieSBob3N0bmFtZSBiZWZvcmUgcHJvY2VlZGluZyB0byBtYXRjaGluZ1xuICAgICAgICBjb25zdCBmaWx0ZXJIb3N0bmFtZSA9IGZpbHRlci5nZXRIb3N0bmFtZSgpO1xuICAgICAgICBpZiAoaXNBbmNob3JlZEJ5SG9zdG5hbWUoZmlsdGVySG9zdG5hbWUsIHJlcXVlc3QuaG9zdG5hbWUsIGZpbHRlci5maWx0ZXIgIT09IHVuZGVmaW5lZCAmJiBmaWx0ZXIuZmlsdGVyLmNoYXJDb2RlQXQoMCkgPT09IDQyIC8qICcqJyAqLykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBrbm93IHJlcXVlc3QgaXMgaG9zdG5hbWUgYW5jaG9yZWQgc28gd2UgbWF0Y2ggdGhlIHJlc3Qgb2YgdGhlIGZpbHRlci5cbiAgICAgICAgaWYgKGZpbHRlci5pc1JlZ2V4KCkpIHtcbiAgICAgICAgICAgIC8vIHx8cGF0dGVybipeXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyXG4gICAgICAgICAgICAgICAgLmdldFJlZ2V4KClcbiAgICAgICAgICAgICAgICAudGVzdCh1cmwuc2xpY2UodXJsLmluZGV4T2YoZmlsdGVySG9zdG5hbWUpICsgZmlsdGVySG9zdG5hbWUubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlsdGVyLmlzUmlnaHRBbmNob3IoKSAmJiBmaWx0ZXIuaXNMZWZ0QW5jaG9yKCkpIHtcbiAgICAgICAgICAgIC8vIHx8fHBhdHRlcm58XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIG5vdCBhIHJlZ2V4LCB0aGUgZmlsdGVyIHBhdHRlcm4gbXVzdCBmb2xsb3cgdGhlIGhvc3RuYW1lXG4gICAgICAgICAgICAvLyB3aXRoIG5vdGhpbmcgaW4gYmV0d2Vlbi4gU28gd2UgZXh0cmFjdCB0aGUgcGFydCBvZiB0aGUgVVJMIGZvbGxvd2luZ1xuICAgICAgICAgICAgLy8gYWZ0ZXIgaG9zdG5hbWUgYW5kIHdpbGwgcGVyZm9ybSB0aGUgbWF0Y2hpbmcgb24gaXQuXG4gICAgICAgICAgICBjb25zdCB1cmxBZnRlckhvc3RuYW1lID0gdXJsLnNsaWNlKHVybC5pbmRleE9mKGZpbHRlckhvc3RuYW1lKSArIGZpbHRlckhvc3RuYW1lLmxlbmd0aCk7XG4gICAgICAgICAgICAvLyBTaW5jZSBpdCBtdXN0IGZvbGxvdyBpbW1lZGlhdGx5IGFmdGVyIHRoZSBob3N0bmFtZSBhbmQgYmUgYSBzdWZmaXggb2ZcbiAgICAgICAgICAgIC8vIHRoZSBVUkwsIHdlIGNvbmNsdWRlIHRoYXQgZmlsdGVyIG11c3QgYmUgZXF1YWwgdG8gdGhlIHBhcnQgb2YgdGhlXG4gICAgICAgICAgICAvLyB1cmwgZm9sbG93aW5nIHRoZSBob3N0bmFtZS5cbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuID09PSB1cmxBZnRlckhvc3RuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbHRlci5pc1JpZ2h0QW5jaG9yKCkpIHtcbiAgICAgICAgICAgIC8vIHx8cGF0dGVybnxcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RIb3N0bmFtZSA9IHJlcXVlc3QuaG9zdG5hbWU7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmhhc0ZpbHRlcigpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgc3BlY2lmaWMgY2FzZSBpdCBtZWFucyB0aGF0IHRoZSBzcGVjaWZpZWQgaG9zdG5hbWUgc2hvdWxkIG1hdGNoXG4gICAgICAgICAgICAgICAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgaG9zdG5hbWUgb2YgdGhlIHJlcXVlc3QuIFRoaXMgYWxsb3dzIHRvIHByZXZlbnQgZmFsc2VcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGl2ZSBsaWtlIHx8Zm9vLmJhciB3aGljaCB3b3VsZCBtYXRjaCBodHRwczovL2Zvby5iYXIuYmF6IHdoZXJlXG4gICAgICAgICAgICAgICAgLy8gfHxmb28uYmFyXiB3b3VsZCBub3QuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChmaWx0ZXJIb3N0bmFtZS5sZW5ndGggPT09IHJlcXVlc3RIb3N0bmFtZS5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhvc3RuYW1lLmVuZHNXaXRoKGZpbHRlckhvc3RuYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBwYXR0ZXJufFxuICAgICAgICAgICAgICAgIHJldHVybiB1cmwuZW5kc1dpdGgocGF0dGVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlsdGVyLmlzTGVmdEFuY2hvcigpKSB7XG4gICAgICAgICAgICAvLyB8fHBhdHRlcm4gKyBsZWZ0LWFuY2hvciA9PiBUaGlzIG1lYW5zIHRoYXQgYSBwbGFpbiBwYXR0ZXJuIG5lZWRzIHRvIGFwcGVhclxuICAgICAgICAgICAgLy8gZXhhY3RseSBhZnRlciB0aGUgaG9zdG5hbWUsIHdpdGggbm90aGluZyBpbiBiZXR3ZWVuLlxuICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBub3QgYSByZWdleCwgdGhlIGZpbHRlciBwYXR0ZXJuIG11c3QgZm9sbG93IHRoZSBob3N0bmFtZVxuICAgICAgICAgICAgLy8gd2l0aCBub3RoaW5nIGluIGJldHdlZW4uIFNvIHdlIGV4dHJhY3QgdGhlIHBhcnQgb2YgdGhlIFVSTCBmb2xsb3dpbmdcbiAgICAgICAgICAgIC8vIGFmdGVyIGhvc3RuYW1lIGFuZCB3aWxsIHBlcmZvcm0gdGhlIG1hdGNoaW5nIG9uIGl0LlxuICAgICAgICAgICAgcmV0dXJuIHVybC5zdGFydHNXaXRoKHBhdHRlcm4sIHVybC5pbmRleE9mKGZpbHRlckhvc3RuYW1lKSArIGZpbHRlckhvc3RuYW1lLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlci5oYXNGaWx0ZXIoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGNvbnNpZGVyIHRoaXMgYSBtYXRjaCBpZiB0aGUgcGxhaW4gcGF0dGVyIChpLmUuOiBmaWx0ZXIpIGFwcGVhcnMgYW55d2hlcmUuXG4gICAgICAgIHJldHVybiB1cmwuaW5kZXhPZihwYXR0ZXJuLCB1cmwuaW5kZXhPZihmaWx0ZXJIb3N0bmFtZSkgKyBmaWx0ZXJIb3N0bmFtZS5sZW5ndGgpICE9PSAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlsdGVyLmlzUmVnZXgoKSkge1xuICAgICAgICAvLyBwYXR0ZXJuKl5cbiAgICAgICAgcmV0dXJuIGZpbHRlci5nZXRSZWdleCgpLnRlc3QodXJsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlsdGVyLmlzTGVmdEFuY2hvcigpICYmIGZpbHRlci5pc1JpZ2h0QW5jaG9yKCkpIHtcbiAgICAgICAgLy8gfHBhdHRlcm58XG4gICAgICAgIHJldHVybiB1cmwgPT09IHBhdHRlcm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbHRlci5pc0xlZnRBbmNob3IoKSkge1xuICAgICAgICAvLyB8cGF0dGVyblxuICAgICAgICByZXR1cm4gdXJsLnN0YXJ0c1dpdGgocGF0dGVybik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbHRlci5pc1JpZ2h0QW5jaG9yKCkpIHtcbiAgICAgICAgLy8gcGF0dGVybnxcbiAgICAgICAgcmV0dXJuIHVybC5lbmRzV2l0aChwYXR0ZXJuKTtcbiAgICB9XG4gICAgLy8gcGF0dGVyblxuICAgIGlmIChmaWx0ZXIuaGFzRmlsdGVyKCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdXJsLmluZGV4T2YocGF0dGVybikgIT09IC0xO1xufVxuZnVuY3Rpb24gY2hlY2tPcHRpb25zKGZpbHRlciwgcmVxdWVzdCkge1xuICAgIC8vIFdlIGZpcnN0IGRpc2NhcmQgcmVxdWVzdHMgYmFzZWQgb24gdHlwZSwgcHJvdG9jb2wgYW5kIHBhcnR5LiBUaGlzIGlzIHJlYWxseVxuICAgIC8vIGNoZWFwIGFuZCBzaG91bGQgYmUgZG9uZSBmaXJzdC5cbiAgICBpZiAoZmlsdGVyLmlzQ3B0QWxsb3dlZChyZXF1ZXN0LnR5cGUpID09PSBmYWxzZSB8fFxuICAgICAgICAocmVxdWVzdC5pc0h0dHBzID09PSB0cnVlICYmIGZpbHRlci5mcm9tSHR0cHMoKSA9PT0gZmFsc2UpIHx8XG4gICAgICAgIChyZXF1ZXN0LmlzSHR0cCA9PT0gdHJ1ZSAmJiBmaWx0ZXIuZnJvbUh0dHAoKSA9PT0gZmFsc2UpIHx8XG4gICAgICAgIChmaWx0ZXIuZmlyc3RQYXJ0eSgpID09PSBmYWxzZSAmJiByZXF1ZXN0LmlzRmlyc3RQYXJ0eSA9PT0gdHJ1ZSkgfHxcbiAgICAgICAgKGZpbHRlci50aGlyZFBhcnR5KCkgPT09IGZhbHNlICYmIHJlcXVlc3QuaXNUaGlyZFBhcnR5ID09PSB0cnVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIElmIGBzb3VyY2VIb3N0bmFtZWAgaXMgKm5vdCogbWF0Y2hlZCBieSBgZG9tYWluYCB0aGVuIHRoZSByZXF1ZXN0IHNob3VsZCBiZSBhbGxvd2VkLlxuICAgIGlmIChmaWx0ZXIuZG9tYWlucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGZpbHRlci5kb21haW5zLm1hdGNoKHJlcXVlc3Quc291cmNlSG9zdG5hbWVIYXNoZXMsIHJlcXVlc3Quc291cmNlRW50aXR5SGFzaGVzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBJZiBgaG9zdG5hbWVgIGlzIG1hdGNoZWQgYnkgYGRlbnlhbGxvd2AgdGhlbiB0aGUgcmVxdWVzdCBzaG91bGQgYmUgYWxsb3dlZC5cbiAgICBpZiAoZmlsdGVyLmRlbnlhbGxvdyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGZpbHRlci5kZW55YWxsb3cubWF0Y2gocmVxdWVzdC5nZXRIb3N0bmFtZUhhc2hlcygpLCByZXF1ZXN0LmdldEVudGl0eUhhc2hlcygpKSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29yay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/network.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/html-filtering.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/html-filtering.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StreamingHtmlFilter),\n/* harmony export */   extractHTMLSelectorFromRule: () => (/* binding */ extractHTMLSelectorFromRule),\n/* harmony export */   extractSelectorsFromRules: () => (/* binding */ extractSelectorsFromRules),\n/* harmony export */   extractTagsFromHtml: () => (/* binding */ extractTagsFromHtml),\n/* harmony export */   removeTagsFromHtml: () => (/* binding */ removeTagsFromHtml),\n/* harmony export */   selectTagsToRemove: () => (/* binding */ selectTagsToRemove)\n/* harmony export */ });\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nfunction extractHTMLSelectorFromRule(rule) {\n    if (rule.startsWith('^script') === false) {\n        return undefined;\n    }\n    const prefix = ':has-text(';\n    const selectors = [];\n    let index = 7;\n    // ^script:has-text\n    //        ^ 7\n    // Prepare for finding one or more ':has-text(' selectors in a row\n    while (rule.startsWith(prefix, index)) {\n        index += prefix.length;\n        let currentParsingDepth = 1;\n        const startOfSelectorIndex = index;\n        let prev = -1; // previous character\n        for (; index < rule.length && currentParsingDepth !== 0; index += 1) {\n            const code = rule.charCodeAt(index);\n            if (prev !== 92 /* '\\' */) {\n                if (code === 40 /* '(' */) {\n                    currentParsingDepth += 1;\n                }\n                if (code === 41 /* ')' */) {\n                    currentParsingDepth -= 1;\n                }\n            }\n            prev = code;\n        }\n        selectors.push(rule.slice(startOfSelectorIndex, index - 1));\n    }\n    if (index !== rule.length) {\n        return undefined;\n    }\n    return ['script', selectors];\n}\nfunction extractTagsFromHtml(html, tag) {\n    const tags = [];\n    const prefix = `<${tag}`;\n    const suffix = `</${tag}>`;\n    // Keep track of the beginning of current identified tag\n    let index = html.indexOf(prefix);\n    // Keep tracks of index immediately following last extracted tag\n    let endOfLastTag = 0;\n    while (index !== -1) {\n        // Find index of end of current tag. If we do not find it, it could be\n        // because it will come in the next chunk and we should try parsing it\n        // again then.\n        const endOfTagIndex = html.indexOf('>', index + prefix.length);\n        if (endOfTagIndex === -1) {\n            return [tags, html.slice(0, index), html.slice(index)];\n        }\n        // Handle short tag form <tag/> which will not have a closing tag.\n        if (html.charCodeAt(endOfTagIndex - 1) === 47 /* '/' */) {\n            endOfLastTag = endOfTagIndex + 1;\n            tags.push([index, html.slice(index, endOfLastTag)]);\n        }\n        else {\n            // Find index of closing tag '</tag>'. If we do not find it, again, it\n            // could mean that it will come in next chunk and we need to try parsing\n            // it again with more input.\n            const indexOfClosingTag = html.indexOf(suffix, endOfTagIndex);\n            if (indexOfClosingTag === -1) {\n                return [tags, html.slice(0, index), html.slice(index)];\n            }\n            tags.push([index, html.slice(index, indexOfClosingTag + suffix.length)]);\n            endOfLastTag = indexOfClosingTag + suffix.length;\n        }\n        index = html.indexOf(prefix, endOfLastTag);\n    }\n    // Make sure we consume as much input as possible so that we do not parse the\n    // same portion of HTML again next time and we can stream chunks as early as\n    // possible.\n    //\n    // We check if there is at least one '<' char after the end of the last\n    // extracted tag; this would indicate that the next chunk might contain the\n    // remaining of a valid tag. We then look up to N characters after this '<'\n    // character, where N is the size of 'prefix'. The rational is that if we\n    // reached this part of the code, then it cannot be a match otherwise we\n    // would have returned earlier (from the loop).\n    let lastClosingTagIndex = html.lastIndexOf('>');\n    if (lastClosingTagIndex === -1) {\n        lastClosingTagIndex = endOfLastTag;\n    }\n    const indexOfNextTag = html.indexOf('<', lastClosingTagIndex);\n    // If no '<' in the remaining of input, then it means we can count this chunk\n    // as fully parsed (i.e.: next chunk can be parsed independently without\n    // missing a tag which would start in this one).\n    if (indexOfNextTag === -1) {\n        return [tags, html, ''];\n    }\n    // In case of a partial tag ending this 'html' chunk. Then check if we have\n    // enough information to discard it already based on the kind of tags we are\n    // looking for.\n    if (html.length - indexOfNextTag >= prefix.length ||\n        prefix.startsWith(html.slice(indexOfNextTag)) === false) {\n        return [tags, html, ''];\n    }\n    return [tags, html.slice(0, indexOfNextTag), html.slice(indexOfNextTag)];\n}\nfunction extractSelectorsFromRules(filter) {\n    const patterns = [];\n    for (const [type, selectors] of filter) {\n        if (type !== 'script') {\n            continue;\n        }\n        const plainPatterns = [];\n        const regexpPatterns = [];\n        for (const selector of selectors) {\n            if (selector.charCodeAt(0) === 47 /* '/' */) {\n                if (selector.endsWith('/')) {\n                    regexpPatterns.push(new RegExp(selector.slice(1, -1)));\n                }\n                else if (selector.endsWith('/i')) {\n                    regexpPatterns.push(new RegExp(selector.slice(1, -2), 'i'));\n                }\n            }\n            else {\n                plainPatterns.push(selector);\n            }\n        }\n        if (plainPatterns.length !== 0 || regexpPatterns.length !== 0) {\n            patterns.push([plainPatterns, regexpPatterns]);\n        }\n    }\n    return patterns;\n}\n/**\n * Check if `tag` should be removed from HTML based on `plainPatterns` and\n * `regexpPatterns`. For a tag to be removed, all elements from `plainPatterns`\n * and `regexpPatterns` must match.\n */\nfunction tagShouldBeRemoved(tag, plainPatterns, regexpPatterns) {\n    for (const pattern of plainPatterns) {\n        if (tag.indexOf(pattern) === -1) {\n            return false;\n        }\n    }\n    for (const pattern of regexpPatterns) {\n        if (pattern.test(tag) === false) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction selectTagsToRemove(patterns, tags) {\n    const toRemove = [];\n    for (const tag of tags) {\n        for (const [plainPatterns, regexpPatterns] of patterns) {\n            if (tagShouldBeRemoved(tag[1], plainPatterns, regexpPatterns)) {\n                toRemove.push(tag);\n                break;\n            }\n        }\n    }\n    return toRemove;\n}\nfunction removeTagsFromHtml(html, toRemove) {\n    if (toRemove.length === 0) {\n        return html;\n    }\n    let filteredHtml = html;\n    toRemove.reverse(); // make sure to remove from last to first tag (preserve indices)\n    for (const [index, tag] of toRemove) {\n        filteredHtml = filteredHtml.slice(0, index) + filteredHtml.slice(index + tag.length);\n    }\n    return filteredHtml;\n}\nfunction applyModifiersToHtml(html, modifiers) {\n    if (modifiers.length === 0) {\n        return html;\n    }\n    for (const [regexp, replacement] of modifiers) {\n        html = html.replace(regexp, replacement);\n    }\n    return html;\n}\nclass StreamingHtmlFilter {\n    constructor(selectors) {\n        this.buffer = '';\n        const modifiers = [];\n        const rules = [];\n        for (const selector of selectors) {\n            if (selector[0] === 'replace') {\n                modifiers.push(selector[1]);\n            }\n            else if (selector[0] === 'script') {\n                rules.push(selector);\n            }\n        }\n        this.patterns = extractSelectorsFromRules(rules);\n        this.modifiers = modifiers;\n    }\n    flush(applyHTMLFiltering = true) {\n        let out = this.buffer;\n        if (applyHTMLFiltering === true) {\n            // If there's a modifier\n            if (this.modifiers.length !== 0) {\n                // If there's a pattern, process in priority.\n                if (this.patterns.length !== 0) {\n                    const [tags, parsed, rest] = extractTagsFromHtml(this.buffer, 'script');\n                    out = removeTagsFromHtml(parsed, selectTagsToRemove(this.patterns, tags)) + rest;\n                }\n                out = applyModifiersToHtml(out, this.modifiers);\n            }\n        }\n        this.buffer = '';\n        return out;\n    }\n    write(chunk) {\n        // If given an empty string, abort.\n        if (chunk.length === 0) {\n            return chunk;\n        }\n        // If there's a modifier, buffer all.\n        if (this.modifiers.length !== 0) {\n            this.buffer += chunk;\n            return '';\n        }\n        // If there's no pattern, proxy.\n        if (this.patterns.length === 0) {\n            return chunk;\n        }\n        // Accumulate buffer + new data\n        this.buffer += chunk;\n        // Parse tags from `this.buffer`\n        const [tags, parsed, rest] = extractTagsFromHtml(this.buffer, 'script');\n        this.buffer = rest;\n        // If no tags were found, just return the parsed version\n        if (tags.length === 0) {\n            return parsed;\n        }\n        // Perform tags filtering using `this.patterns` and `this.regexps`.\n        return removeTagsFromHtml(parsed, selectTagsToRemove(this.patterns, tags));\n    }\n}\n//# sourceMappingURL=html-filtering.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9odG1sLWZpbHRlcmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsZUFBZSxrREFBa0Q7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHVCQUF1QixJQUFJO0FBQzNCLHdCQUF3QixJQUFJO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9odG1sLWZpbHRlcmluZy5qcz82ODkxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQgR2hvc3RlcnkgR21iSC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RIVE1MU2VsZWN0b3JGcm9tUnVsZShydWxlKSB7XG4gICAgaWYgKHJ1bGUuc3RhcnRzV2l0aCgnXnNjcmlwdCcpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXggPSAnOmhhcy10ZXh0KCc7XG4gICAgY29uc3Qgc2VsZWN0b3JzID0gW107XG4gICAgbGV0IGluZGV4ID0gNztcbiAgICAvLyBec2NyaXB0Omhhcy10ZXh0XG4gICAgLy8gICAgICAgIF4gN1xuICAgIC8vIFByZXBhcmUgZm9yIGZpbmRpbmcgb25lIG9yIG1vcmUgJzpoYXMtdGV4dCgnIHNlbGVjdG9ycyBpbiBhIHJvd1xuICAgIHdoaWxlIChydWxlLnN0YXJ0c1dpdGgocHJlZml4LCBpbmRleCkpIHtcbiAgICAgICAgaW5kZXggKz0gcHJlZml4Lmxlbmd0aDtcbiAgICAgICAgbGV0IGN1cnJlbnRQYXJzaW5nRGVwdGggPSAxO1xuICAgICAgICBjb25zdCBzdGFydE9mU2VsZWN0b3JJbmRleCA9IGluZGV4O1xuICAgICAgICBsZXQgcHJldiA9IC0xOyAvLyBwcmV2aW91cyBjaGFyYWN0ZXJcbiAgICAgICAgZm9yICg7IGluZGV4IDwgcnVsZS5sZW5ndGggJiYgY3VycmVudFBhcnNpbmdEZXB0aCAhPT0gMDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHJ1bGUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICBpZiAocHJldiAhPT0gOTIgLyogJ1xcJyAqLykge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSA0MCAvKiAnKCcgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcnNpbmdEZXB0aCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gNDEgLyogJyknICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJzaW5nRGVwdGggLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gY29kZTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3RvcnMucHVzaChydWxlLnNsaWNlKHN0YXJ0T2ZTZWxlY3RvckluZGV4LCBpbmRleCAtIDEpKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSBydWxlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gWydzY3JpcHQnLCBzZWxlY3RvcnNdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RUYWdzRnJvbUh0bWwoaHRtbCwgdGFnKSB7XG4gICAgY29uc3QgdGFncyA9IFtdO1xuICAgIGNvbnN0IHByZWZpeCA9IGA8JHt0YWd9YDtcbiAgICBjb25zdCBzdWZmaXggPSBgPC8ke3RhZ30+YDtcbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBiZWdpbm5pbmcgb2YgY3VycmVudCBpZGVudGlmaWVkIHRhZ1xuICAgIGxldCBpbmRleCA9IGh0bWwuaW5kZXhPZihwcmVmaXgpO1xuICAgIC8vIEtlZXAgdHJhY2tzIG9mIGluZGV4IGltbWVkaWF0ZWx5IGZvbGxvd2luZyBsYXN0IGV4dHJhY3RlZCB0YWdcbiAgICBsZXQgZW5kT2ZMYXN0VGFnID0gMDtcbiAgICB3aGlsZSAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIC8vIEZpbmQgaW5kZXggb2YgZW5kIG9mIGN1cnJlbnQgdGFnLiBJZiB3ZSBkbyBub3QgZmluZCBpdCwgaXQgY291bGQgYmVcbiAgICAgICAgLy8gYmVjYXVzZSBpdCB3aWxsIGNvbWUgaW4gdGhlIG5leHQgY2h1bmsgYW5kIHdlIHNob3VsZCB0cnkgcGFyc2luZyBpdFxuICAgICAgICAvLyBhZ2FpbiB0aGVuLlxuICAgICAgICBjb25zdCBlbmRPZlRhZ0luZGV4ID0gaHRtbC5pbmRleE9mKCc+JywgaW5kZXggKyBwcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgaWYgKGVuZE9mVGFnSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RhZ3MsIGh0bWwuc2xpY2UoMCwgaW5kZXgpLCBodG1sLnNsaWNlKGluZGV4KV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHNob3J0IHRhZyBmb3JtIDx0YWcvPiB3aGljaCB3aWxsIG5vdCBoYXZlIGEgY2xvc2luZyB0YWcuXG4gICAgICAgIGlmIChodG1sLmNoYXJDb2RlQXQoZW5kT2ZUYWdJbmRleCAtIDEpID09PSA0NyAvKiAnLycgKi8pIHtcbiAgICAgICAgICAgIGVuZE9mTGFzdFRhZyA9IGVuZE9mVGFnSW5kZXggKyAxO1xuICAgICAgICAgICAgdGFncy5wdXNoKFtpbmRleCwgaHRtbC5zbGljZShpbmRleCwgZW5kT2ZMYXN0VGFnKV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRmluZCBpbmRleCBvZiBjbG9zaW5nIHRhZyAnPC90YWc+Jy4gSWYgd2UgZG8gbm90IGZpbmQgaXQsIGFnYWluLCBpdFxuICAgICAgICAgICAgLy8gY291bGQgbWVhbiB0aGF0IGl0IHdpbGwgY29tZSBpbiBuZXh0IGNodW5rIGFuZCB3ZSBuZWVkIHRvIHRyeSBwYXJzaW5nXG4gICAgICAgICAgICAvLyBpdCBhZ2FpbiB3aXRoIG1vcmUgaW5wdXQuXG4gICAgICAgICAgICBjb25zdCBpbmRleE9mQ2xvc2luZ1RhZyA9IGh0bWwuaW5kZXhPZihzdWZmaXgsIGVuZE9mVGFnSW5kZXgpO1xuICAgICAgICAgICAgaWYgKGluZGV4T2ZDbG9zaW5nVGFnID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdGFncywgaHRtbC5zbGljZSgwLCBpbmRleCksIGh0bWwuc2xpY2UoaW5kZXgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhZ3MucHVzaChbaW5kZXgsIGh0bWwuc2xpY2UoaW5kZXgsIGluZGV4T2ZDbG9zaW5nVGFnICsgc3VmZml4Lmxlbmd0aCldKTtcbiAgICAgICAgICAgIGVuZE9mTGFzdFRhZyA9IGluZGV4T2ZDbG9zaW5nVGFnICsgc3VmZml4Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IGh0bWwuaW5kZXhPZihwcmVmaXgsIGVuZE9mTGFzdFRhZyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBjb25zdW1lIGFzIG11Y2ggaW5wdXQgYXMgcG9zc2libGUgc28gdGhhdCB3ZSBkbyBub3QgcGFyc2UgdGhlXG4gICAgLy8gc2FtZSBwb3J0aW9uIG9mIEhUTUwgYWdhaW4gbmV4dCB0aW1lIGFuZCB3ZSBjYW4gc3RyZWFtIGNodW5rcyBhcyBlYXJseSBhc1xuICAgIC8vIHBvc3NpYmxlLlxuICAgIC8vXG4gICAgLy8gV2UgY2hlY2sgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lICc8JyBjaGFyIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGxhc3RcbiAgICAvLyBleHRyYWN0ZWQgdGFnOyB0aGlzIHdvdWxkIGluZGljYXRlIHRoYXQgdGhlIG5leHQgY2h1bmsgbWlnaHQgY29udGFpbiB0aGVcbiAgICAvLyByZW1haW5pbmcgb2YgYSB2YWxpZCB0YWcuIFdlIHRoZW4gbG9vayB1cCB0byBOIGNoYXJhY3RlcnMgYWZ0ZXIgdGhpcyAnPCdcbiAgICAvLyBjaGFyYWN0ZXIsIHdoZXJlIE4gaXMgdGhlIHNpemUgb2YgJ3ByZWZpeCcuIFRoZSByYXRpb25hbCBpcyB0aGF0IGlmIHdlXG4gICAgLy8gcmVhY2hlZCB0aGlzIHBhcnQgb2YgdGhlIGNvZGUsIHRoZW4gaXQgY2Fubm90IGJlIGEgbWF0Y2ggb3RoZXJ3aXNlIHdlXG4gICAgLy8gd291bGQgaGF2ZSByZXR1cm5lZCBlYXJsaWVyIChmcm9tIHRoZSBsb29wKS5cbiAgICBsZXQgbGFzdENsb3NpbmdUYWdJbmRleCA9IGh0bWwubGFzdEluZGV4T2YoJz4nKTtcbiAgICBpZiAobGFzdENsb3NpbmdUYWdJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgbGFzdENsb3NpbmdUYWdJbmRleCA9IGVuZE9mTGFzdFRhZztcbiAgICB9XG4gICAgY29uc3QgaW5kZXhPZk5leHRUYWcgPSBodG1sLmluZGV4T2YoJzwnLCBsYXN0Q2xvc2luZ1RhZ0luZGV4KTtcbiAgICAvLyBJZiBubyAnPCcgaW4gdGhlIHJlbWFpbmluZyBvZiBpbnB1dCwgdGhlbiBpdCBtZWFucyB3ZSBjYW4gY291bnQgdGhpcyBjaHVua1xuICAgIC8vIGFzIGZ1bGx5IHBhcnNlZCAoaS5lLjogbmV4dCBjaHVuayBjYW4gYmUgcGFyc2VkIGluZGVwZW5kZW50bHkgd2l0aG91dFxuICAgIC8vIG1pc3NpbmcgYSB0YWcgd2hpY2ggd291bGQgc3RhcnQgaW4gdGhpcyBvbmUpLlxuICAgIGlmIChpbmRleE9mTmV4dFRhZyA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFt0YWdzLCBodG1sLCAnJ107XG4gICAgfVxuICAgIC8vIEluIGNhc2Ugb2YgYSBwYXJ0aWFsIHRhZyBlbmRpbmcgdGhpcyAnaHRtbCcgY2h1bmsuIFRoZW4gY2hlY2sgaWYgd2UgaGF2ZVxuICAgIC8vIGVub3VnaCBpbmZvcm1hdGlvbiB0byBkaXNjYXJkIGl0IGFscmVhZHkgYmFzZWQgb24gdGhlIGtpbmQgb2YgdGFncyB3ZSBhcmVcbiAgICAvLyBsb29raW5nIGZvci5cbiAgICBpZiAoaHRtbC5sZW5ndGggLSBpbmRleE9mTmV4dFRhZyA+PSBwcmVmaXgubGVuZ3RoIHx8XG4gICAgICAgIHByZWZpeC5zdGFydHNXaXRoKGh0bWwuc2xpY2UoaW5kZXhPZk5leHRUYWcpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIFt0YWdzLCBodG1sLCAnJ107XG4gICAgfVxuICAgIHJldHVybiBbdGFncywgaHRtbC5zbGljZSgwLCBpbmRleE9mTmV4dFRhZyksIGh0bWwuc2xpY2UoaW5kZXhPZk5leHRUYWcpXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0U2VsZWN0b3JzRnJvbVJ1bGVzKGZpbHRlcikge1xuICAgIGNvbnN0IHBhdHRlcm5zID0gW107XG4gICAgZm9yIChjb25zdCBbdHlwZSwgc2VsZWN0b3JzXSBvZiBmaWx0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGUgIT09ICdzY3JpcHQnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGFpblBhdHRlcm5zID0gW107XG4gICAgICAgIGNvbnN0IHJlZ2V4cFBhdHRlcm5zID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc2VsZWN0b3Igb2Ygc2VsZWN0b3JzKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0b3IuY2hhckNvZGVBdCgwKSA9PT0gNDcgLyogJy8nICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnZXhwUGF0dGVybnMucHVzaChuZXcgUmVnRXhwKHNlbGVjdG9yLnNsaWNlKDEsIC0xKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxlY3Rvci5lbmRzV2l0aCgnL2knKSkge1xuICAgICAgICAgICAgICAgICAgICByZWdleHBQYXR0ZXJucy5wdXNoKG5ldyBSZWdFeHAoc2VsZWN0b3Iuc2xpY2UoMSwgLTIpLCAnaScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwbGFpblBhdHRlcm5zLnB1c2goc2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwbGFpblBhdHRlcm5zLmxlbmd0aCAhPT0gMCB8fCByZWdleHBQYXR0ZXJucy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHBhdHRlcm5zLnB1c2goW3BsYWluUGF0dGVybnMsIHJlZ2V4cFBhdHRlcm5zXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm5zO1xufVxuLyoqXG4gKiBDaGVjayBpZiBgdGFnYCBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIEhUTUwgYmFzZWQgb24gYHBsYWluUGF0dGVybnNgIGFuZFxuICogYHJlZ2V4cFBhdHRlcm5zYC4gRm9yIGEgdGFnIHRvIGJlIHJlbW92ZWQsIGFsbCBlbGVtZW50cyBmcm9tIGBwbGFpblBhdHRlcm5zYFxuICogYW5kIGByZWdleHBQYXR0ZXJuc2AgbXVzdCBtYXRjaC5cbiAqL1xuZnVuY3Rpb24gdGFnU2hvdWxkQmVSZW1vdmVkKHRhZywgcGxhaW5QYXR0ZXJucywgcmVnZXhwUGF0dGVybnMpIHtcbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGxhaW5QYXR0ZXJucykge1xuICAgICAgICBpZiAodGFnLmluZGV4T2YocGF0dGVybikgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHJlZ2V4cFBhdHRlcm5zKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuLnRlc3QodGFnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RUYWdzVG9SZW1vdmUocGF0dGVybnMsIHRhZ3MpIHtcbiAgICBjb25zdCB0b1JlbW92ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBbcGxhaW5QYXR0ZXJucywgcmVnZXhwUGF0dGVybnNdIG9mIHBhdHRlcm5zKSB7XG4gICAgICAgICAgICBpZiAodGFnU2hvdWxkQmVSZW1vdmVkKHRhZ1sxXSwgcGxhaW5QYXR0ZXJucywgcmVnZXhwUGF0dGVybnMpKSB7XG4gICAgICAgICAgICAgICAgdG9SZW1vdmUucHVzaCh0YWcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b1JlbW92ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVUYWdzRnJvbUh0bWwoaHRtbCwgdG9SZW1vdmUpIHtcbiAgICBpZiAodG9SZW1vdmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICBsZXQgZmlsdGVyZWRIdG1sID0gaHRtbDtcbiAgICB0b1JlbW92ZS5yZXZlcnNlKCk7IC8vIG1ha2Ugc3VyZSB0byByZW1vdmUgZnJvbSBsYXN0IHRvIGZpcnN0IHRhZyAocHJlc2VydmUgaW5kaWNlcylcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgdGFnXSBvZiB0b1JlbW92ZSkge1xuICAgICAgICBmaWx0ZXJlZEh0bWwgPSBmaWx0ZXJlZEh0bWwuc2xpY2UoMCwgaW5kZXgpICsgZmlsdGVyZWRIdG1sLnNsaWNlKGluZGV4ICsgdGFnLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZEh0bWw7XG59XG5mdW5jdGlvbiBhcHBseU1vZGlmaWVyc1RvSHRtbChodG1sLCBtb2RpZmllcnMpIHtcbiAgICBpZiAobW9kaWZpZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbcmVnZXhwLCByZXBsYWNlbWVudF0gb2YgbW9kaWZpZXJzKSB7XG4gICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UocmVnZXhwLCByZXBsYWNlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyZWFtaW5nSHRtbEZpbHRlciB7XG4gICAgY29uc3RydWN0b3Ioc2VsZWN0b3JzKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gJyc7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVycyA9IFtdO1xuICAgICAgICBjb25zdCBydWxlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHNlbGVjdG9yIG9mIHNlbGVjdG9ycykge1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yWzBdID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMucHVzaChzZWxlY3RvclsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3RvclswXSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgICAgICAgICBydWxlcy5wdXNoKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdHRlcm5zID0gZXh0cmFjdFNlbGVjdG9yc0Zyb21SdWxlcyhydWxlcyk7XG4gICAgICAgIHRoaXMubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICAgIH1cbiAgICBmbHVzaChhcHBseUhUTUxGaWx0ZXJpbmcgPSB0cnVlKSB7XG4gICAgICAgIGxldCBvdXQgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgaWYgKGFwcGx5SFRNTEZpbHRlcmluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIG1vZGlmaWVyXG4gICAgICAgICAgICBpZiAodGhpcy5tb2RpZmllcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHBhdHRlcm4sIHByb2Nlc3MgaW4gcHJpb3JpdHkuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGF0dGVybnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFt0YWdzLCBwYXJzZWQsIHJlc3RdID0gZXh0cmFjdFRhZ3NGcm9tSHRtbCh0aGlzLmJ1ZmZlciwgJ3NjcmlwdCcpO1xuICAgICAgICAgICAgICAgICAgICBvdXQgPSByZW1vdmVUYWdzRnJvbUh0bWwocGFyc2VkLCBzZWxlY3RUYWdzVG9SZW1vdmUodGhpcy5wYXR0ZXJucywgdGFncykpICsgcmVzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ID0gYXBwbHlNb2RpZmllcnNUb0h0bWwob3V0LCB0aGlzLm1vZGlmaWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSAnJztcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgLy8gSWYgZ2l2ZW4gYW4gZW1wdHkgc3RyaW5nLCBhYm9ydC5cbiAgICAgICAgaWYgKGNodW5rLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYSBtb2RpZmllciwgYnVmZmVyIGFsbC5cbiAgICAgICAgaWYgKHRoaXMubW9kaWZpZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgKz0gY2h1bms7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBwYXR0ZXJuLCBwcm94eS5cbiAgICAgICAgaWYgKHRoaXMucGF0dGVybnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2h1bms7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWNjdW11bGF0ZSBidWZmZXIgKyBuZXcgZGF0YVxuICAgICAgICB0aGlzLmJ1ZmZlciArPSBjaHVuaztcbiAgICAgICAgLy8gUGFyc2UgdGFncyBmcm9tIGB0aGlzLmJ1ZmZlcmBcbiAgICAgICAgY29uc3QgW3RhZ3MsIHBhcnNlZCwgcmVzdF0gPSBleHRyYWN0VGFnc0Zyb21IdG1sKHRoaXMuYnVmZmVyLCAnc2NyaXB0Jyk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gcmVzdDtcbiAgICAgICAgLy8gSWYgbm8gdGFncyB3ZXJlIGZvdW5kLCBqdXN0IHJldHVybiB0aGUgcGFyc2VkIHZlcnNpb25cbiAgICAgICAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBlcmZvcm0gdGFncyBmaWx0ZXJpbmcgdXNpbmcgYHRoaXMucGF0dGVybnNgIGFuZCBgdGhpcy5yZWdleHBzYC5cbiAgICAgICAgcmV0dXJuIHJlbW92ZVRhZ3NGcm9tSHRtbChwYXJzZWQsIHNlbGVjdFRhZ3NUb1JlbW92ZSh0aGlzLnBhdHRlcm5zLCB0YWdzKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHRtbC1maWx0ZXJpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/html-filtering.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Config: () => (/* reexport safe */ _config_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   CosmeticFilter: () => (/* reexport safe */ _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   ENGINE_VERSION: () => (/* reexport safe */ _engine_engine_js__WEBPACK_IMPORTED_MODULE_0__.ENGINE_VERSION),\n/* harmony export */   FilterType: () => (/* reexport safe */ _lists_js__WEBPACK_IMPORTED_MODULE_6__.FilterType),\n/* harmony export */   FiltersEngine: () => (/* reexport safe */ _engine_engine_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   NetworkFilter: () => (/* reexport safe */ _filters_network_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   Preprocessor: () => (/* reexport safe */ _preprocessor_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   Request: () => (/* reexport safe */ _request_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   Resources: () => (/* reexport safe */ _resources_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]),\n/* harmony export */   ReverseIndex: () => (/* reexport safe */ _engine_reverse_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   StreamingHtmlFilter: () => (/* reexport safe */ _html_filtering_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"]),\n/* harmony export */   adsAndTrackingLists: () => (/* reexport safe */ _fetch_js__WEBPACK_IMPORTED_MODULE_7__.adsAndTrackingLists),\n/* harmony export */   adsLists: () => (/* reexport safe */ _fetch_js__WEBPACK_IMPORTED_MODULE_7__.adsLists),\n/* harmony export */   detectFilterType: () => (/* reexport safe */ _lists_js__WEBPACK_IMPORTED_MODULE_6__.detectFilterType),\n/* harmony export */   f: () => (/* reexport safe */ _lists_js__WEBPACK_IMPORTED_MODULE_6__.f),\n/* harmony export */   fetchLists: () => (/* reexport safe */ _fetch_js__WEBPACK_IMPORTED_MODULE_7__.fetchLists),\n/* harmony export */   fetchResources: () => (/* reexport safe */ _fetch_js__WEBPACK_IMPORTED_MODULE_7__.fetchResources),\n/* harmony export */   fetchWithRetry: () => (/* reexport safe */ _fetch_js__WEBPACK_IMPORTED_MODULE_7__.fetchWithRetry),\n/* harmony export */   fullLists: () => (/* reexport safe */ _fetch_js__WEBPACK_IMPORTED_MODULE_7__.fullLists),\n/* harmony export */   generateDiff: () => (/* reexport safe */ _lists_js__WEBPACK_IMPORTED_MODULE_6__.generateDiff),\n/* harmony export */   getHostnameHashesFromLabelsBackward: () => (/* reexport safe */ _request_js__WEBPACK_IMPORTED_MODULE_2__.getHostnameHashesFromLabelsBackward),\n/* harmony export */   getLinesWithFilters: () => (/* reexport safe */ _lists_js__WEBPACK_IMPORTED_MODULE_6__.getLinesWithFilters),\n/* harmony export */   hasUnicode: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_8__.hasUnicode),\n/* harmony export */   isUTF8: () => (/* reexport safe */ _encoding_js__WEBPACK_IMPORTED_MODULE_9__.isUTF8),\n/* harmony export */   makeRequest: () => (/* reexport safe */ _request_js__WEBPACK_IMPORTED_MODULE_2__.makeRequest),\n/* harmony export */   mergeDiffs: () => (/* reexport safe */ _lists_js__WEBPACK_IMPORTED_MODULE_6__.mergeDiffs),\n/* harmony export */   parseFilter: () => (/* reexport safe */ _lists_js__WEBPACK_IMPORTED_MODULE_6__.parseFilter),\n/* harmony export */   parseFilters: () => (/* reexport safe */ _lists_js__WEBPACK_IMPORTED_MODULE_6__.parseFilters),\n/* harmony export */   tokenize: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_8__.tokenizeNoSkip)\n/* harmony export */ });\n/* harmony import */ var _engine_engine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./engine/engine.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/engine.js\");\n/* harmony import */ var _engine_reverse_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./engine/reverse-index.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/engine/reverse-index.js\");\n/* harmony import */ var _request_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./request.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/request.js\");\n/* harmony import */ var _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filters/cosmetic.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/cosmetic.js\");\n/* harmony import */ var _filters_network_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filters/network.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/network.js\");\n/* harmony import */ var _preprocessor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./preprocessor.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/preprocessor.js\");\n/* harmony import */ var _lists_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lists.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/lists.js\");\n/* harmony import */ var _fetch_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./fetch.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/fetch.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/utils.js\");\n/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./encoding.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/encoding.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./config.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/config.js\");\n/* harmony import */ var _resources_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./resources.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/resources.js\");\n/* harmony import */ var _html_filtering_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./html-filtering.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/html-filtering.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4RTtBQUNWO0FBQ2lDO0FBQ25DO0FBQ0Y7QUFDSjtBQUM0RTtBQUM3RztBQUN5QztBQUM3QjtBQUNTO0FBQ007QUFDZTtBQUNyRSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXIvZGlzdC9lc20vaW5kZXguanM/MmQ4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50IEdob3N0ZXJ5IEdtYkguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmV4cG9ydCB7IGRlZmF1bHQgYXMgRmlsdGVyc0VuZ2luZSwgRU5HSU5FX1ZFUlNJT04gfSBmcm9tICcuL2VuZ2luZS9lbmdpbmUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZXZlcnNlSW5kZXggfSBmcm9tICcuL2VuZ2luZS9yZXZlcnNlLWluZGV4LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmVxdWVzdCwgbWFrZVJlcXVlc3QsIGdldEhvc3RuYW1lSGFzaGVzRnJvbUxhYmVsc0JhY2t3YXJkLCB9IGZyb20gJy4vcmVxdWVzdC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENvc21ldGljRmlsdGVyIH0gZnJvbSAnLi9maWx0ZXJzL2Nvc21ldGljLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTmV0d29ya0ZpbHRlciB9IGZyb20gJy4vZmlsdGVycy9uZXR3b3JrLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHJlcHJvY2Vzc29yIH0gZnJvbSAnLi9wcmVwcm9jZXNzb3IuanMnO1xuZXhwb3J0IHsgRmlsdGVyVHlwZSwgZGV0ZWN0RmlsdGVyVHlwZSwgZiwgZ2VuZXJhdGVEaWZmLCBnZXRMaW5lc1dpdGhGaWx0ZXJzLCBtZXJnZURpZmZzLCBwYXJzZUZpbHRlciwgcGFyc2VGaWx0ZXJzLCB9IGZyb20gJy4vbGlzdHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9mZXRjaC5qcyc7XG5leHBvcnQgeyBoYXNVbmljb2RlLCB0b2tlbml6ZU5vU2tpcCBhcyB0b2tlbml6ZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuZXhwb3J0IHsgaXNVVEY4IH0gZnJvbSAnLi9lbmNvZGluZy5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbmZpZyB9IGZyb20gJy4vY29uZmlnLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmVzb3VyY2VzIH0gZnJvbSAnLi9yZXNvdXJjZXMuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdHJlYW1pbmdIdG1sRmlsdGVyIH0gZnJvbSAnLi9odG1sLWZpbHRlcmluZy5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/lists.js":
/*!************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/lists.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FilterType: () => (/* binding */ FilterType),\n/* harmony export */   detectFilterType: () => (/* binding */ detectFilterType),\n/* harmony export */   f: () => (/* binding */ f),\n/* harmony export */   generateDiff: () => (/* binding */ generateDiff),\n/* harmony export */   getLinesWithFilters: () => (/* binding */ getLinesWithFilters),\n/* harmony export */   mergeDiffs: () => (/* binding */ mergeDiffs),\n/* harmony export */   parseFilter: () => (/* binding */ parseFilter),\n/* harmony export */   parseFilters: () => (/* binding */ parseFilters)\n/* harmony export */ });\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/config.js\");\n/* harmony import */ var _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./filters/cosmetic.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/cosmetic.js\");\n/* harmony import */ var _filters_network_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filters/network.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/filters/network.js\");\n/* harmony import */ var _preprocessor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./preprocessor.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/preprocessor.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\nvar FilterType;\n(function (FilterType) {\n    FilterType[FilterType[\"NOT_SUPPORTED\"] = 0] = \"NOT_SUPPORTED\";\n    FilterType[FilterType[\"NETWORK\"] = 1] = \"NETWORK\";\n    FilterType[FilterType[\"COSMETIC\"] = 2] = \"COSMETIC\";\n    // available only with `extendedNonSupportedTypes` option for #detectFilterType\n    FilterType[FilterType[\"NOT_SUPPORTED_EMPTY\"] = 100] = \"NOT_SUPPORTED_EMPTY\";\n    FilterType[FilterType[\"NOT_SUPPORTED_COMMENT\"] = 101] = \"NOT_SUPPORTED_COMMENT\";\n    FilterType[FilterType[\"NOT_SUPPORTED_ADGUARD\"] = 102] = \"NOT_SUPPORTED_ADGUARD\";\n})(FilterType || (FilterType = {}));\n/**\n * Given a single line (string), checks if this would likely be a cosmetic\n * filter, a network filter or something that is not supported. This check is\n * performed before calling a more specific parser to create an instance of\n * `NetworkFilter` or `CosmeticFilter`.\n */\nfunction detectFilterType(line, { extendedNonSupportedTypes = false } = {}) {\n    // Ignore empty line\n    if (line.length === 0 || line.length === 1) {\n        if (extendedNonSupportedTypes) {\n            return FilterType.NOT_SUPPORTED_EMPTY;\n        }\n        return FilterType.NOT_SUPPORTED;\n    }\n    // Ignore comments\n    const firstCharCode = line.charCodeAt(0);\n    const secondCharCode = line.charCodeAt(1);\n    if (firstCharCode === 33 /* '!' */ ||\n        (firstCharCode === 35 /* '#' */ && secondCharCode <= 32) ||\n        (firstCharCode === 91 /* '[' */ && line.startsWith('[Adblock'))) {\n        if (extendedNonSupportedTypes) {\n            return FilterType.NOT_SUPPORTED_COMMENT;\n        }\n        return FilterType.NOT_SUPPORTED;\n    }\n    // Fast heuristics to detect network filters\n    const lastCharCode = line.charCodeAt(line.length - 1);\n    if ((firstCharCode === 36 /* '$' */ &&\n        secondCharCode !== 36 &&\n        secondCharCode !== 64) /* $$ and $@ as those may be Adguard HTML filtering rules */ ||\n        firstCharCode === 38 /* '&' */ ||\n        firstCharCode === 42 /* '*' */ ||\n        firstCharCode === 45 /* '-' */ ||\n        firstCharCode === 46 /* '.' */ ||\n        firstCharCode === 47 /* '/' */ ||\n        firstCharCode === 58 /* ':' */ ||\n        firstCharCode === 61 /* '=' */ ||\n        firstCharCode === 63 /* '?' */ ||\n        firstCharCode === 64 /* '@' */ ||\n        firstCharCode === 95 /* '_' */ ||\n        firstCharCode === 124 /* '|' */ ||\n        lastCharCode === 124 /* '|' */) {\n        return FilterType.NETWORK;\n    }\n    // Ignore Adguard cosmetics\n    // `$$` = HTML filtering rules\n    const dollarIndex = line.indexOf('$');\n    if (dollarIndex !== -1 && dollarIndex !== line.length - 1) {\n        const afterDollarIndex = dollarIndex + 1;\n        const afterDollarCharCode = line.charCodeAt(afterDollarIndex);\n        // Ignore Adguard HTML rewrite rules\n        if (afterDollarCharCode === 36 /* '$' */ ||\n            (afterDollarCharCode === 64 /* '@' */ && line.startsWith(/* $@$ */ '@$', afterDollarIndex))) {\n            if (extendedNonSupportedTypes) {\n                return FilterType.NOT_SUPPORTED_ADGUARD;\n            }\n            return FilterType.NOT_SUPPORTED;\n        }\n    }\n    // Check if filter is cosmetics\n    const sharpIndex = line.indexOf('#');\n    if (sharpIndex !== -1 && sharpIndex !== line.length - 1) {\n        const afterSharpIndex = sharpIndex + 1;\n        const afterSharpCharCode = line.charCodeAt(afterSharpIndex);\n        if (afterSharpCharCode === 35 /* '#'*/ ||\n            (afterSharpCharCode === 64 /* '@' */ && line.startsWith(/* #@# */ '@#', afterSharpIndex))\n        // TODO - support ADB/AdGuard extended css selectors\n        // || (afterSharpCharCode === 63 /* '?' */ &&\n        //   line.startsWith(/* #?# */ '?#', afterSharpIndex))\n        ) {\n            // Parse supported cosmetic filter\n            // `##` `#@#`\n            return FilterType.COSMETIC;\n        }\n        else if ((afterSharpCharCode === 64 /* '@'*/ &&\n            (line.startsWith(/* #@$# */ '@$#', afterSharpIndex) ||\n                line.startsWith(/* #@%# */ '@%#', afterSharpIndex) ||\n                line.startsWith(/* #@?# */ '@?#', afterSharpIndex))) ||\n            (afterSharpCharCode === 37 /* '%' */ && line.startsWith(/* #%# */ '%#', afterSharpIndex)) ||\n            (afterSharpCharCode === 36 /* '$' */ &&\n                (line.startsWith(/* #$# */ '$#', afterSharpIndex) ||\n                    line.startsWith(/* #$?# */ '$?#', afterSharpIndex))) ||\n            (afterSharpCharCode === 63 /* '?' */ && line.startsWith(/* #?# */ '?#', afterSharpIndex))) {\n            if (extendedNonSupportedTypes) {\n                return FilterType.NOT_SUPPORTED_ADGUARD;\n            }\n            return FilterType.NOT_SUPPORTED;\n        }\n    }\n    // Everything else is a network filter\n    return FilterType.NETWORK;\n}\nfunction parseFilter(filter) {\n    const filterType = detectFilterType(filter);\n    if (filterType === FilterType.NETWORK) {\n        return _filters_network_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].parse(filter, true);\n    }\n    else if (filterType === FilterType.COSMETIC) {\n        return _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].parse(filter, true);\n    }\n    return null;\n}\nfunction f(strings) {\n    return parseFilter(strings[0]);\n}\nfunction parseFilters(list, config = new _config_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()) {\n    config = new _config_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](config);\n    const networkFilters = [];\n    const cosmeticFilters = [];\n    const notSupportedFilters = [];\n    const lines = list.split('\\n');\n    const preprocessors = [];\n    const preprocessorStack = [];\n    for (let i = 0; i < lines.length; i += 1) {\n        let line = lines[i];\n        // Check if `line` should be left-trimmed\n        if (line.length !== 0 && line.charCodeAt(0) <= 32) {\n            line = line.trim();\n        }\n        // Handle continuations\n        if (line.length > 2) {\n            while (i < lines.length - 1 &&\n                line.charCodeAt(line.length - 1) === 92 &&\n                line.charCodeAt(line.length - 2) === 32) {\n                line = line.slice(0, -2);\n                const nextLine = lines[i + 1];\n                if (nextLine.length > 4 &&\n                    nextLine.charCodeAt(0) === 32 &&\n                    nextLine.charCodeAt(1) === 32 &&\n                    nextLine.charCodeAt(2) === 32 &&\n                    nextLine.charCodeAt(3) === 32 &&\n                    nextLine.charCodeAt(4) !== 32) {\n                    line += nextLine.slice(4);\n                    i += 1;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        // Check if `line` should be right-trimmed\n        if (line.length !== 0 && line.charCodeAt(line.length - 1) <= 32) {\n            line = line.trim();\n        }\n        // Detect if filter is supported, network or cosmetic\n        const filterType = detectFilterType(line, { extendedNonSupportedTypes: true });\n        if (filterType === FilterType.NETWORK && config.loadNetworkFilters === true) {\n            const filter = _filters_network_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].parse(line, config.debug);\n            if (filter !== null) {\n                networkFilters.push(filter);\n                if (preprocessorStack.length > 0) {\n                    preprocessorStack[preprocessorStack.length - 1].filterIDs.add(filter.getId());\n                }\n            }\n            else {\n                notSupportedFilters.push({\n                    lineNumber: i,\n                    filter: line,\n                    filterType,\n                });\n            }\n        }\n        else if (filterType === FilterType.COSMETIC && config.loadCosmeticFilters === true) {\n            const filter = _filters_cosmetic_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].parse(line, config.debug);\n            if (filter !== null) {\n                if (config.loadGenericCosmeticsFilters === true || filter.isGenericHide() === false) {\n                    cosmeticFilters.push(filter);\n                    if (preprocessorStack.length > 0) {\n                        preprocessorStack[preprocessorStack.length - 1].filterIDs.add(filter.getId());\n                    }\n                }\n            }\n            else {\n                notSupportedFilters.push({\n                    lineNumber: i,\n                    filter: line,\n                    filterType: FilterType.COSMETIC,\n                });\n            }\n        }\n        else if (config.loadPreprocessors) {\n            const preprocessorToken = (0,_preprocessor_js__WEBPACK_IMPORTED_MODULE_3__.detectPreprocessor)(line);\n            if (preprocessorToken === _preprocessor_js__WEBPACK_IMPORTED_MODULE_3__.PreprocessorTokens.BEGIF) {\n                if (preprocessorStack.length > 0) {\n                    preprocessorStack.push(new _preprocessor_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n                        condition: `(${preprocessorStack[preprocessorStack.length - 1].condition})&&(${_preprocessor_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getCondition(line)})`,\n                    }));\n                }\n                else {\n                    preprocessorStack.push(_preprocessor_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].parse(line));\n                }\n            }\n            else if ((preprocessorToken === _preprocessor_js__WEBPACK_IMPORTED_MODULE_3__.PreprocessorTokens.ENDIF ||\n                preprocessorToken === _preprocessor_js__WEBPACK_IMPORTED_MODULE_3__.PreprocessorTokens.ELSE) &&\n                preprocessorStack.length > 0) {\n                const lastPreprocessor = preprocessorStack.pop();\n                preprocessors.push(lastPreprocessor);\n                if (preprocessorToken === _preprocessor_js__WEBPACK_IMPORTED_MODULE_3__.PreprocessorTokens.ELSE) {\n                    preprocessorStack.push(new _preprocessor_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n                        condition: `!(${lastPreprocessor.condition})`,\n                    }));\n                }\n            }\n            else if (filterType === FilterType.NOT_SUPPORTED_ADGUARD) {\n                notSupportedFilters.push({\n                    lineNumber: i,\n                    filter: line,\n                    filterType,\n                });\n            }\n        }\n        else if (filterType === FilterType.NOT_SUPPORTED_ADGUARD) {\n            notSupportedFilters.push({\n                lineNumber: i,\n                filter: line,\n                filterType,\n            });\n        }\n    }\n    return {\n        networkFilters,\n        cosmeticFilters,\n        preprocessors: preprocessors.filter((preprocessor) => preprocessor.filterIDs.size > 0),\n        notSupportedFilters,\n    };\n}\nfunction getFilters(list, config) {\n    const { networkFilters, cosmeticFilters, preprocessors } = parseFilters(list, config);\n    const filters = [];\n    return {\n        filters: filters.concat(networkFilters).concat(cosmeticFilters),\n        preprocessors,\n    };\n}\n/**\n * Helper used to return a set of lines as strings where each line is\n * guaranteed to be a valid filter (i.e.: comments, empty lines and\n * un-supported filters are dropped).\n */\nfunction getLinesWithFilters(list, config = new _config_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()) {\n    // Set config to `debug` so that we keep track of raw lines for each filter\n    return new Set(getFilters(list, new _config_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](Object.assign({}, config, { debug: true }))).filters.map(({ rawLine }) => rawLine));\n}\n/**\n * Given two versions of the same subscription (e.g.: EasyList) as a string,\n * generate a raw diff (i.e.: a list of filters added and filters removed, in\n * their raw string form).\n */\nfunction generateDiff(prevRevision, newRevision, config = new _config_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()) {\n    // Set config to `debug` so that we keep track of raw lines for each filter\n    const debugConfig = new _config_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](Object.assign({}, config, { debug: true }));\n    const prevRevisionData = getFilters(prevRevision, debugConfig);\n    const prevRevisionIds = new Set(prevRevisionData.filters.map((filter) => filter.getId()));\n    const newRevisionData = getFilters(newRevision, debugConfig);\n    const newRevisionIds = new Set(newRevisionData.filters.map((filter) => filter.getId()));\n    // Check which filters were added, based on ID\n    const added = new Set();\n    for (const filter of newRevisionData.filters) {\n        if (!prevRevisionIds.has(filter.getId())) {\n            added.add(filter.rawLine);\n        }\n    }\n    // Check which filters were removed, based on ID\n    const removed = new Set();\n    for (const filter of prevRevisionData.filters) {\n        if (!newRevisionIds.has(filter.getId())) {\n            removed.add(filter.rawLine);\n        }\n    }\n    // Fast exit if we don't want to handle preprocessors.\n    if (!config.loadPreprocessors) {\n        return {\n            added: Array.from(added),\n            removed: Array.from(removed),\n            preprocessors: {},\n        };\n    }\n    const index = new Map();\n    for (const filter of newRevisionData.filters) {\n        index.set(filter.getId(), filter.rawLine);\n    }\n    for (const filter of prevRevisionData.filters) {\n        index.set(filter.getId(), filter.rawLine);\n    }\n    // Create preprocessor diffs\n    const preprocessors = {};\n    // Get the diff of preprocessors\n    for (const preprocessor of prevRevisionData.preprocessors) {\n        // Find the same preprocessor in `newRevisionData`\n        const newPreprocessor = newRevisionData.preprocessors.find((newPreprocessor) => newPreprocessor.condition === preprocessor.condition);\n        // If the preprocessor in the revision is not found, it means the whole block was removed\n        if (!newPreprocessor) {\n            const removedInScope = new Set();\n            // Remove all filters\n            for (const filterID of preprocessor.filterIDs) {\n                removedInScope.add(index.get(filterID));\n            }\n            preprocessors[preprocessor.condition] = {\n                added: [],\n                removed: Array.from(removedInScope),\n            };\n            continue;\n        }\n        // If the preprocessor in the revision is found, it means the block was updated\n        // Create subsets\n        const scope = {\n            added: new Set(),\n            removed: new Set(),\n        };\n        for (const filterID of preprocessor.filterIDs) {\n            if (!newPreprocessor.filterIDs.has(filterID)) {\n                scope.removed.add(index.get(filterID));\n            }\n        }\n        for (const filterID of newPreprocessor.filterIDs) {\n            if (!preprocessor.filterIDs.has(filterID)) {\n                scope.added.add(index.get(filterID));\n            }\n        }\n        preprocessors[preprocessor.condition] = {\n            added: Array.from(scope.added),\n            removed: Array.from(scope.removed),\n        };\n    }\n    // Iterate over only \"added\" preprocessors\n    for (const preprocessor of newRevisionData.preprocessors) {\n        // If the preprocessor in the previous revision was not found, it means the whole block was added\n        if (!preprocessors[preprocessor.condition]) {\n            const addedInScope = new Set();\n            // Remove all filters\n            for (const filterID of preprocessor.filterIDs) {\n                addedInScope.add(index.get(filterID));\n            }\n            preprocessors[preprocessor.condition] = {\n                added: Array.from(addedInScope),\n                removed: [],\n            };\n        }\n    }\n    for (const [condition, { added, removed }] of Object.entries(preprocessors)) {\n        if (added.length === 0 && removed.length === 0) {\n            delete preprocessors[condition];\n        }\n    }\n    return {\n        added: Array.from(added),\n        removed: Array.from(removed),\n        // For the filters under `preprocessors` property, it doesn't mean those are \"filters\".\n        // Those are \"a list of filters affected by preprocessors\" not the \"filters\" itself.\n        // Therefore, they shouldn't be treated as filters.\n        // Instead, we put \"filters\" in `added` and `removed` properties.\n        // This provides backward-compatibility and simplicity.\n        preprocessors,\n    };\n}\n/**\n * Merge several raw diffs into one, taking care of accumulating added and\n * removed filters, even if several diffs add/remove the same ones.\n */\nfunction mergeDiffs(diffs) {\n    const addedCumul = new Set();\n    const removedCumul = new Set();\n    const preprocessorsCumul = {};\n    for (const { added, removed, preprocessors } of diffs) {\n        if (added !== undefined) {\n            for (const str of added) {\n                if (removedCumul.has(str)) {\n                    removedCumul.delete(str);\n                }\n                addedCumul.add(str);\n            }\n        }\n        if (removed !== undefined) {\n            for (const str of removed) {\n                if (addedCumul.has(str)) {\n                    addedCumul.delete(str);\n                }\n                removedCumul.add(str);\n            }\n        }\n        if (!preprocessors) {\n            continue;\n        }\n        for (const [condition, details] of Object.entries(preprocessors)) {\n            if (!preprocessorsCumul[condition]) {\n                preprocessorsCumul[condition] = {\n                    added: details.added !== undefined ? new Set(details.added) : new Set(),\n                    removed: details.removed !== undefined ? new Set(details.removed) : new Set(),\n                };\n            }\n            else {\n                if (details.added !== undefined) {\n                    for (const str of details.added) {\n                        if (preprocessorsCumul[condition].removed.has(str)) {\n                            preprocessorsCumul[condition].removed.delete(str);\n                        }\n                        preprocessorsCumul[condition].added.add(str);\n                    }\n                }\n                if (details.removed !== undefined) {\n                    for (const str of details.removed) {\n                        if (preprocessorsCumul[condition].added.has(str)) {\n                            preprocessorsCumul[condition].added.delete(str);\n                        }\n                        preprocessorsCumul[condition].removed.add(str);\n                    }\n                }\n            }\n        }\n    }\n    return {\n        added: Array.from(addedCumul),\n        removed: Array.from(removedCumul),\n        preprocessors: Object.fromEntries(Object.entries(preprocessorsCumul).map(([condition, details]) => [\n            condition,\n            {\n                added: Array.from(details.added),\n                removed: Array.from(details.removed),\n            },\n        ])),\n    };\n}\n//# sourceMappingURL=lists.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9saXN0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQztBQUNrQjtBQUNGO0FBQ3dDO0FBQ2xGO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyxvQ0FBb0MsSUFBSTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGVBQWUsMkRBQWE7QUFDNUI7QUFDQTtBQUNBLGVBQWUsNERBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ08seUNBQXlDLGtEQUFNO0FBQ3RELGlCQUFpQixrREFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlDQUFpQztBQUNyRjtBQUNBLDJCQUEyQiwyREFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0VBQWtCO0FBQ3hELHNDQUFzQyxnRUFBa0I7QUFDeEQ7QUFDQSwrQ0FBK0Msd0RBQVk7QUFDM0QsdUNBQXVDLDBEQUEwRCxNQUFNLHdEQUFZLG9CQUFvQjtBQUN2SSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDJDQUEyQyx3REFBWTtBQUN2RDtBQUNBO0FBQ0EsNENBQTRDLGdFQUFrQjtBQUM5RCxzQ0FBc0MsZ0VBQWtCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnRUFBa0I7QUFDNUQsK0NBQStDLHdEQUFZO0FBQzNELHdDQUF3QywyQkFBMkI7QUFDbkUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpREFBaUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGdEQUFnRCxrREFBTTtBQUM3RDtBQUNBLHdDQUF3QyxrREFBTSxpQkFBaUIsWUFBWSxhQUFhLG1CQUFtQixTQUFTO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDhEQUE4RCxrREFBTTtBQUMzRTtBQUNBLDRCQUE0QixrREFBTSxpQkFBaUIsWUFBWSxhQUFhO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXIvZGlzdC9lc20vbGlzdHMuanM/ZGZlOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50IEdob3N0ZXJ5IEdtYkguIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHBzOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKi9cbmltcG9ydCBDb25maWcgZnJvbSAnLi9jb25maWcuanMnO1xuaW1wb3J0IENvc21ldGljRmlsdGVyIGZyb20gJy4vZmlsdGVycy9jb3NtZXRpYy5qcyc7XG5pbXBvcnQgTmV0d29ya0ZpbHRlciBmcm9tICcuL2ZpbHRlcnMvbmV0d29yay5qcyc7XG5pbXBvcnQgUHJlcHJvY2Vzc29yLCB7IFByZXByb2Nlc3NvclRva2VucywgZGV0ZWN0UHJlcHJvY2Vzc29yIH0gZnJvbSAnLi9wcmVwcm9jZXNzb3IuanMnO1xuZXhwb3J0IHZhciBGaWx0ZXJUeXBlO1xuKGZ1bmN0aW9uIChGaWx0ZXJUeXBlKSB7XG4gICAgRmlsdGVyVHlwZVtGaWx0ZXJUeXBlW1wiTk9UX1NVUFBPUlRFRFwiXSA9IDBdID0gXCJOT1RfU1VQUE9SVEVEXCI7XG4gICAgRmlsdGVyVHlwZVtGaWx0ZXJUeXBlW1wiTkVUV09SS1wiXSA9IDFdID0gXCJORVRXT1JLXCI7XG4gICAgRmlsdGVyVHlwZVtGaWx0ZXJUeXBlW1wiQ09TTUVUSUNcIl0gPSAyXSA9IFwiQ09TTUVUSUNcIjtcbiAgICAvLyBhdmFpbGFibGUgb25seSB3aXRoIGBleHRlbmRlZE5vblN1cHBvcnRlZFR5cGVzYCBvcHRpb24gZm9yICNkZXRlY3RGaWx0ZXJUeXBlXG4gICAgRmlsdGVyVHlwZVtGaWx0ZXJUeXBlW1wiTk9UX1NVUFBPUlRFRF9FTVBUWVwiXSA9IDEwMF0gPSBcIk5PVF9TVVBQT1JURURfRU1QVFlcIjtcbiAgICBGaWx0ZXJUeXBlW0ZpbHRlclR5cGVbXCJOT1RfU1VQUE9SVEVEX0NPTU1FTlRcIl0gPSAxMDFdID0gXCJOT1RfU1VQUE9SVEVEX0NPTU1FTlRcIjtcbiAgICBGaWx0ZXJUeXBlW0ZpbHRlclR5cGVbXCJOT1RfU1VQUE9SVEVEX0FER1VBUkRcIl0gPSAxMDJdID0gXCJOT1RfU1VQUE9SVEVEX0FER1VBUkRcIjtcbn0pKEZpbHRlclR5cGUgfHwgKEZpbHRlclR5cGUgPSB7fSkpO1xuLyoqXG4gKiBHaXZlbiBhIHNpbmdsZSBsaW5lIChzdHJpbmcpLCBjaGVja3MgaWYgdGhpcyB3b3VsZCBsaWtlbHkgYmUgYSBjb3NtZXRpY1xuICogZmlsdGVyLCBhIG5ldHdvcmsgZmlsdGVyIG9yIHNvbWV0aGluZyB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQuIFRoaXMgY2hlY2sgaXNcbiAqIHBlcmZvcm1lZCBiZWZvcmUgY2FsbGluZyBhIG1vcmUgc3BlY2lmaWMgcGFyc2VyIHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZlxuICogYE5ldHdvcmtGaWx0ZXJgIG9yIGBDb3NtZXRpY0ZpbHRlcmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RGaWx0ZXJUeXBlKGxpbmUsIHsgZXh0ZW5kZWROb25TdXBwb3J0ZWRUeXBlcyA9IGZhbHNlIH0gPSB7fSkge1xuICAgIC8vIElnbm9yZSBlbXB0eSBsaW5lXG4gICAgaWYgKGxpbmUubGVuZ3RoID09PSAwIHx8IGxpbmUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChleHRlbmRlZE5vblN1cHBvcnRlZFR5cGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gRmlsdGVyVHlwZS5OT1RfU1VQUE9SVEVEX0VNUFRZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGaWx0ZXJUeXBlLk5PVF9TVVBQT1JURUQ7XG4gICAgfVxuICAgIC8vIElnbm9yZSBjb21tZW50c1xuICAgIGNvbnN0IGZpcnN0Q2hhckNvZGUgPSBsaW5lLmNoYXJDb2RlQXQoMCk7XG4gICAgY29uc3Qgc2Vjb25kQ2hhckNvZGUgPSBsaW5lLmNoYXJDb2RlQXQoMSk7XG4gICAgaWYgKGZpcnN0Q2hhckNvZGUgPT09IDMzIC8qICchJyAqLyB8fFxuICAgICAgICAoZmlyc3RDaGFyQ29kZSA9PT0gMzUgLyogJyMnICovICYmIHNlY29uZENoYXJDb2RlIDw9IDMyKSB8fFxuICAgICAgICAoZmlyc3RDaGFyQ29kZSA9PT0gOTEgLyogJ1snICovICYmIGxpbmUuc3RhcnRzV2l0aCgnW0FkYmxvY2snKSkpIHtcbiAgICAgICAgaWYgKGV4dGVuZGVkTm9uU3VwcG9ydGVkVHlwZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBGaWx0ZXJUeXBlLk5PVF9TVVBQT1JURURfQ09NTUVOVDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRmlsdGVyVHlwZS5OT1RfU1VQUE9SVEVEO1xuICAgIH1cbiAgICAvLyBGYXN0IGhldXJpc3RpY3MgdG8gZGV0ZWN0IG5ldHdvcmsgZmlsdGVyc1xuICAgIGNvbnN0IGxhc3RDaGFyQ29kZSA9IGxpbmUuY2hhckNvZGVBdChsaW5lLmxlbmd0aCAtIDEpO1xuICAgIGlmICgoZmlyc3RDaGFyQ29kZSA9PT0gMzYgLyogJyQnICovICYmXG4gICAgICAgIHNlY29uZENoYXJDb2RlICE9PSAzNiAmJlxuICAgICAgICBzZWNvbmRDaGFyQ29kZSAhPT0gNjQpIC8qICQkIGFuZCAkQCBhcyB0aG9zZSBtYXkgYmUgQWRndWFyZCBIVE1MIGZpbHRlcmluZyBydWxlcyAqLyB8fFxuICAgICAgICBmaXJzdENoYXJDb2RlID09PSAzOCAvKiAnJicgKi8gfHxcbiAgICAgICAgZmlyc3RDaGFyQ29kZSA9PT0gNDIgLyogJyonICovIHx8XG4gICAgICAgIGZpcnN0Q2hhckNvZGUgPT09IDQ1IC8qICctJyAqLyB8fFxuICAgICAgICBmaXJzdENoYXJDb2RlID09PSA0NiAvKiAnLicgKi8gfHxcbiAgICAgICAgZmlyc3RDaGFyQ29kZSA9PT0gNDcgLyogJy8nICovIHx8XG4gICAgICAgIGZpcnN0Q2hhckNvZGUgPT09IDU4IC8qICc6JyAqLyB8fFxuICAgICAgICBmaXJzdENoYXJDb2RlID09PSA2MSAvKiAnPScgKi8gfHxcbiAgICAgICAgZmlyc3RDaGFyQ29kZSA9PT0gNjMgLyogJz8nICovIHx8XG4gICAgICAgIGZpcnN0Q2hhckNvZGUgPT09IDY0IC8qICdAJyAqLyB8fFxuICAgICAgICBmaXJzdENoYXJDb2RlID09PSA5NSAvKiAnXycgKi8gfHxcbiAgICAgICAgZmlyc3RDaGFyQ29kZSA9PT0gMTI0IC8qICd8JyAqLyB8fFxuICAgICAgICBsYXN0Q2hhckNvZGUgPT09IDEyNCAvKiAnfCcgKi8pIHtcbiAgICAgICAgcmV0dXJuIEZpbHRlclR5cGUuTkVUV09SSztcbiAgICB9XG4gICAgLy8gSWdub3JlIEFkZ3VhcmQgY29zbWV0aWNzXG4gICAgLy8gYCQkYCA9IEhUTUwgZmlsdGVyaW5nIHJ1bGVzXG4gICAgY29uc3QgZG9sbGFySW5kZXggPSBsaW5lLmluZGV4T2YoJyQnKTtcbiAgICBpZiAoZG9sbGFySW5kZXggIT09IC0xICYmIGRvbGxhckluZGV4ICE9PSBsaW5lLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY29uc3QgYWZ0ZXJEb2xsYXJJbmRleCA9IGRvbGxhckluZGV4ICsgMTtcbiAgICAgICAgY29uc3QgYWZ0ZXJEb2xsYXJDaGFyQ29kZSA9IGxpbmUuY2hhckNvZGVBdChhZnRlckRvbGxhckluZGV4KTtcbiAgICAgICAgLy8gSWdub3JlIEFkZ3VhcmQgSFRNTCByZXdyaXRlIHJ1bGVzXG4gICAgICAgIGlmIChhZnRlckRvbGxhckNoYXJDb2RlID09PSAzNiAvKiAnJCcgKi8gfHxcbiAgICAgICAgICAgIChhZnRlckRvbGxhckNoYXJDb2RlID09PSA2NCAvKiAnQCcgKi8gJiYgbGluZS5zdGFydHNXaXRoKC8qICRAJCAqLyAnQCQnLCBhZnRlckRvbGxhckluZGV4KSkpIHtcbiAgICAgICAgICAgIGlmIChleHRlbmRlZE5vblN1cHBvcnRlZFR5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZpbHRlclR5cGUuTk9UX1NVUFBPUlRFRF9BREdVQVJEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpbHRlclR5cGUuTk9UX1NVUFBPUlRFRDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGVjayBpZiBmaWx0ZXIgaXMgY29zbWV0aWNzXG4gICAgY29uc3Qgc2hhcnBJbmRleCA9IGxpbmUuaW5kZXhPZignIycpO1xuICAgIGlmIChzaGFycEluZGV4ICE9PSAtMSAmJiBzaGFycEluZGV4ICE9PSBsaW5lLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY29uc3QgYWZ0ZXJTaGFycEluZGV4ID0gc2hhcnBJbmRleCArIDE7XG4gICAgICAgIGNvbnN0IGFmdGVyU2hhcnBDaGFyQ29kZSA9IGxpbmUuY2hhckNvZGVBdChhZnRlclNoYXJwSW5kZXgpO1xuICAgICAgICBpZiAoYWZ0ZXJTaGFycENoYXJDb2RlID09PSAzNSAvKiAnIycqLyB8fFxuICAgICAgICAgICAgKGFmdGVyU2hhcnBDaGFyQ29kZSA9PT0gNjQgLyogJ0AnICovICYmIGxpbmUuc3RhcnRzV2l0aCgvKiAjQCMgKi8gJ0AjJywgYWZ0ZXJTaGFycEluZGV4KSlcbiAgICAgICAgLy8gVE9ETyAtIHN1cHBvcnQgQURCL0FkR3VhcmQgZXh0ZW5kZWQgY3NzIHNlbGVjdG9yc1xuICAgICAgICAvLyB8fCAoYWZ0ZXJTaGFycENoYXJDb2RlID09PSA2MyAvKiAnPycgKi8gJiZcbiAgICAgICAgLy8gICBsaW5lLnN0YXJ0c1dpdGgoLyogIz8jICovICc/IycsIGFmdGVyU2hhcnBJbmRleCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gUGFyc2Ugc3VwcG9ydGVkIGNvc21ldGljIGZpbHRlclxuICAgICAgICAgICAgLy8gYCMjYCBgI0AjYFxuICAgICAgICAgICAgcmV0dXJuIEZpbHRlclR5cGUuQ09TTUVUSUM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGFmdGVyU2hhcnBDaGFyQ29kZSA9PT0gNjQgLyogJ0AnKi8gJiZcbiAgICAgICAgICAgIChsaW5lLnN0YXJ0c1dpdGgoLyogI0AkIyAqLyAnQCQjJywgYWZ0ZXJTaGFycEluZGV4KSB8fFxuICAgICAgICAgICAgICAgIGxpbmUuc3RhcnRzV2l0aCgvKiAjQCUjICovICdAJSMnLCBhZnRlclNoYXJwSW5kZXgpIHx8XG4gICAgICAgICAgICAgICAgbGluZS5zdGFydHNXaXRoKC8qICNAPyMgKi8gJ0A/IycsIGFmdGVyU2hhcnBJbmRleCkpKSB8fFxuICAgICAgICAgICAgKGFmdGVyU2hhcnBDaGFyQ29kZSA9PT0gMzcgLyogJyUnICovICYmIGxpbmUuc3RhcnRzV2l0aCgvKiAjJSMgKi8gJyUjJywgYWZ0ZXJTaGFycEluZGV4KSkgfHxcbiAgICAgICAgICAgIChhZnRlclNoYXJwQ2hhckNvZGUgPT09IDM2IC8qICckJyAqLyAmJlxuICAgICAgICAgICAgICAgIChsaW5lLnN0YXJ0c1dpdGgoLyogIyQjICovICckIycsIGFmdGVyU2hhcnBJbmRleCkgfHxcbiAgICAgICAgICAgICAgICAgICAgbGluZS5zdGFydHNXaXRoKC8qICMkPyMgKi8gJyQ/IycsIGFmdGVyU2hhcnBJbmRleCkpKSB8fFxuICAgICAgICAgICAgKGFmdGVyU2hhcnBDaGFyQ29kZSA9PT0gNjMgLyogJz8nICovICYmIGxpbmUuc3RhcnRzV2l0aCgvKiAjPyMgKi8gJz8jJywgYWZ0ZXJTaGFycEluZGV4KSkpIHtcbiAgICAgICAgICAgIGlmIChleHRlbmRlZE5vblN1cHBvcnRlZFR5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZpbHRlclR5cGUuTk9UX1NVUFBPUlRFRF9BREdVQVJEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZpbHRlclR5cGUuTk9UX1NVUFBPUlRFRDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBFdmVyeXRoaW5nIGVsc2UgaXMgYSBuZXR3b3JrIGZpbHRlclxuICAgIHJldHVybiBGaWx0ZXJUeXBlLk5FVFdPUks7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGaWx0ZXIoZmlsdGVyKSB7XG4gICAgY29uc3QgZmlsdGVyVHlwZSA9IGRldGVjdEZpbHRlclR5cGUoZmlsdGVyKTtcbiAgICBpZiAoZmlsdGVyVHlwZSA9PT0gRmlsdGVyVHlwZS5ORVRXT1JLKSB7XG4gICAgICAgIHJldHVybiBOZXR3b3JrRmlsdGVyLnBhcnNlKGZpbHRlciwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpbHRlclR5cGUgPT09IEZpbHRlclR5cGUuQ09TTUVUSUMpIHtcbiAgICAgICAgcmV0dXJuIENvc21ldGljRmlsdGVyLnBhcnNlKGZpbHRlciwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGYoc3RyaW5ncykge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcihzdHJpbmdzWzBdKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZpbHRlcnMobGlzdCwgY29uZmlnID0gbmV3IENvbmZpZygpKSB7XG4gICAgY29uZmlnID0gbmV3IENvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IG5ldHdvcmtGaWx0ZXJzID0gW107XG4gICAgY29uc3QgY29zbWV0aWNGaWx0ZXJzID0gW107XG4gICAgY29uc3Qgbm90U3VwcG9ydGVkRmlsdGVycyA9IFtdO1xuICAgIGNvbnN0IGxpbmVzID0gbGlzdC5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3QgcHJlcHJvY2Vzc29ycyA9IFtdO1xuICAgIGNvbnN0IHByZXByb2Nlc3NvclN0YWNrID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAvLyBDaGVjayBpZiBgbGluZWAgc2hvdWxkIGJlIGxlZnQtdHJpbW1lZFxuICAgICAgICBpZiAobGluZS5sZW5ndGggIT09IDAgJiYgbGluZS5jaGFyQ29kZUF0KDApIDw9IDMyKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGNvbnRpbnVhdGlvbnNcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBsaW5lcy5sZW5ndGggLSAxICYmXG4gICAgICAgICAgICAgICAgbGluZS5jaGFyQ29kZUF0KGxpbmUubGVuZ3RoIC0gMSkgPT09IDkyICYmXG4gICAgICAgICAgICAgICAgbGluZS5jaGFyQ29kZUF0KGxpbmUubGVuZ3RoIC0gMikgPT09IDMyKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgLTIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRMaW5lID0gbGluZXNbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0TGluZS5sZW5ndGggPiA0ICYmXG4gICAgICAgICAgICAgICAgICAgIG5leHRMaW5lLmNoYXJDb2RlQXQoMCkgPT09IDMyICYmXG4gICAgICAgICAgICAgICAgICAgIG5leHRMaW5lLmNoYXJDb2RlQXQoMSkgPT09IDMyICYmXG4gICAgICAgICAgICAgICAgICAgIG5leHRMaW5lLmNoYXJDb2RlQXQoMikgPT09IDMyICYmXG4gICAgICAgICAgICAgICAgICAgIG5leHRMaW5lLmNoYXJDb2RlQXQoMykgPT09IDMyICYmXG4gICAgICAgICAgICAgICAgICAgIG5leHRMaW5lLmNoYXJDb2RlQXQoNCkgIT09IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgKz0gbmV4dExpbmUuc2xpY2UoNCk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBgbGluZWAgc2hvdWxkIGJlIHJpZ2h0LXRyaW1tZWRcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoICE9PSAwICYmIGxpbmUuY2hhckNvZGVBdChsaW5lLmxlbmd0aCAtIDEpIDw9IDMyKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGV0ZWN0IGlmIGZpbHRlciBpcyBzdXBwb3J0ZWQsIG5ldHdvcmsgb3IgY29zbWV0aWNcbiAgICAgICAgY29uc3QgZmlsdGVyVHlwZSA9IGRldGVjdEZpbHRlclR5cGUobGluZSwgeyBleHRlbmRlZE5vblN1cHBvcnRlZFR5cGVzOiB0cnVlIH0pO1xuICAgICAgICBpZiAoZmlsdGVyVHlwZSA9PT0gRmlsdGVyVHlwZS5ORVRXT1JLICYmIGNvbmZpZy5sb2FkTmV0d29ya0ZpbHRlcnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IE5ldHdvcmtGaWx0ZXIucGFyc2UobGluZSwgY29uZmlnLmRlYnVnKTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXR3b3JrRmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKHByZXByb2Nlc3NvclN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlcHJvY2Vzc29yU3RhY2tbcHJlcHJvY2Vzc29yU3RhY2subGVuZ3RoIC0gMV0uZmlsdGVySURzLmFkZChmaWx0ZXIuZ2V0SWQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm90U3VwcG9ydGVkRmlsdGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogaSxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUeXBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbHRlclR5cGUgPT09IEZpbHRlclR5cGUuQ09TTUVUSUMgJiYgY29uZmlnLmxvYWRDb3NtZXRpY0ZpbHRlcnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IENvc21ldGljRmlsdGVyLnBhcnNlKGxpbmUsIGNvbmZpZy5kZWJ1Zyk7XG4gICAgICAgICAgICBpZiAoZmlsdGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2FkR2VuZXJpY0Nvc21ldGljc0ZpbHRlcnMgPT09IHRydWUgfHwgZmlsdGVyLmlzR2VuZXJpY0hpZGUoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29zbWV0aWNGaWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXByb2Nlc3NvclN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXByb2Nlc3NvclN0YWNrW3ByZXByb2Nlc3NvclN0YWNrLmxlbmd0aCAtIDFdLmZpbHRlcklEcy5hZGQoZmlsdGVyLmdldElkKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm90U3VwcG9ydGVkRmlsdGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogaSxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUeXBlOiBGaWx0ZXJUeXBlLkNPU01FVElDLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5sb2FkUHJlcHJvY2Vzc29ycykge1xuICAgICAgICAgICAgY29uc3QgcHJlcHJvY2Vzc29yVG9rZW4gPSBkZXRlY3RQcmVwcm9jZXNzb3IobGluZSk7XG4gICAgICAgICAgICBpZiAocHJlcHJvY2Vzc29yVG9rZW4gPT09IFByZXByb2Nlc3NvclRva2Vucy5CRUdJRikge1xuICAgICAgICAgICAgICAgIGlmIChwcmVwcm9jZXNzb3JTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXByb2Nlc3NvclN0YWNrLnB1c2gobmV3IFByZXByb2Nlc3Nvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb246IGAoJHtwcmVwcm9jZXNzb3JTdGFja1twcmVwcm9jZXNzb3JTdGFjay5sZW5ndGggLSAxXS5jb25kaXRpb259KSYmKCR7UHJlcHJvY2Vzc29yLmdldENvbmRpdGlvbihsaW5lKX0pYCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlcHJvY2Vzc29yU3RhY2sucHVzaChQcmVwcm9jZXNzb3IucGFyc2UobGluZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChwcmVwcm9jZXNzb3JUb2tlbiA9PT0gUHJlcHJvY2Vzc29yVG9rZW5zLkVORElGIHx8XG4gICAgICAgICAgICAgICAgcHJlcHJvY2Vzc29yVG9rZW4gPT09IFByZXByb2Nlc3NvclRva2Vucy5FTFNFKSAmJlxuICAgICAgICAgICAgICAgIHByZXByb2Nlc3NvclN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UHJlcHJvY2Vzc29yID0gcHJlcHJvY2Vzc29yU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgcHJlcHJvY2Vzc29ycy5wdXNoKGxhc3RQcmVwcm9jZXNzb3IpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVwcm9jZXNzb3JUb2tlbiA9PT0gUHJlcHJvY2Vzc29yVG9rZW5zLkVMU0UpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlcHJvY2Vzc29yU3RhY2sucHVzaChuZXcgUHJlcHJvY2Vzc29yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogYCEoJHtsYXN0UHJlcHJvY2Vzc29yLmNvbmRpdGlvbn0pYCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlclR5cGUgPT09IEZpbHRlclR5cGUuTk9UX1NVUFBPUlRFRF9BREdVQVJEKSB7XG4gICAgICAgICAgICAgICAgbm90U3VwcG9ydGVkRmlsdGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogaSxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUeXBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpbHRlclR5cGUgPT09IEZpbHRlclR5cGUuTk9UX1NVUFBPUlRFRF9BREdVQVJEKSB7XG4gICAgICAgICAgICBub3RTdXBwb3J0ZWRGaWx0ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGksXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBsaW5lLFxuICAgICAgICAgICAgICAgIGZpbHRlclR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBuZXR3b3JrRmlsdGVycyxcbiAgICAgICAgY29zbWV0aWNGaWx0ZXJzLFxuICAgICAgICBwcmVwcm9jZXNzb3JzOiBwcmVwcm9jZXNzb3JzLmZpbHRlcigocHJlcHJvY2Vzc29yKSA9PiBwcmVwcm9jZXNzb3IuZmlsdGVySURzLnNpemUgPiAwKSxcbiAgICAgICAgbm90U3VwcG9ydGVkRmlsdGVycyxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RmlsdGVycyhsaXN0LCBjb25maWcpIHtcbiAgICBjb25zdCB7IG5ldHdvcmtGaWx0ZXJzLCBjb3NtZXRpY0ZpbHRlcnMsIHByZXByb2Nlc3NvcnMgfSA9IHBhcnNlRmlsdGVycyhsaXN0LCBjb25maWcpO1xuICAgIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzLmNvbmNhdChuZXR3b3JrRmlsdGVycykuY29uY2F0KGNvc21ldGljRmlsdGVycyksXG4gICAgICAgIHByZXByb2Nlc3NvcnMsXG4gICAgfTtcbn1cbi8qKlxuICogSGVscGVyIHVzZWQgdG8gcmV0dXJuIGEgc2V0IG9mIGxpbmVzIGFzIHN0cmluZ3Mgd2hlcmUgZWFjaCBsaW5lIGlzXG4gKiBndWFyYW50ZWVkIHRvIGJlIGEgdmFsaWQgZmlsdGVyIChpLmUuOiBjb21tZW50cywgZW1wdHkgbGluZXMgYW5kXG4gKiB1bi1zdXBwb3J0ZWQgZmlsdGVycyBhcmUgZHJvcHBlZCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMaW5lc1dpdGhGaWx0ZXJzKGxpc3QsIGNvbmZpZyA9IG5ldyBDb25maWcoKSkge1xuICAgIC8vIFNldCBjb25maWcgdG8gYGRlYnVnYCBzbyB0aGF0IHdlIGtlZXAgdHJhY2sgb2YgcmF3IGxpbmVzIGZvciBlYWNoIGZpbHRlclxuICAgIHJldHVybiBuZXcgU2V0KGdldEZpbHRlcnMobGlzdCwgbmV3IENvbmZpZyhPYmplY3QuYXNzaWduKHt9LCBjb25maWcsIHsgZGVidWc6IHRydWUgfSkpKS5maWx0ZXJzLm1hcCgoeyByYXdMaW5lIH0pID0+IHJhd0xpbmUpKTtcbn1cbi8qKlxuICogR2l2ZW4gdHdvIHZlcnNpb25zIG9mIHRoZSBzYW1lIHN1YnNjcmlwdGlvbiAoZS5nLjogRWFzeUxpc3QpIGFzIGEgc3RyaW5nLFxuICogZ2VuZXJhdGUgYSByYXcgZGlmZiAoaS5lLjogYSBsaXN0IG9mIGZpbHRlcnMgYWRkZWQgYW5kIGZpbHRlcnMgcmVtb3ZlZCwgaW5cbiAqIHRoZWlyIHJhdyBzdHJpbmcgZm9ybSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZURpZmYocHJldlJldmlzaW9uLCBuZXdSZXZpc2lvbiwgY29uZmlnID0gbmV3IENvbmZpZygpKSB7XG4gICAgLy8gU2V0IGNvbmZpZyB0byBgZGVidWdgIHNvIHRoYXQgd2Uga2VlcCB0cmFjayBvZiByYXcgbGluZXMgZm9yIGVhY2ggZmlsdGVyXG4gICAgY29uc3QgZGVidWdDb25maWcgPSBuZXcgQ29uZmlnKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZywgeyBkZWJ1ZzogdHJ1ZSB9KSk7XG4gICAgY29uc3QgcHJldlJldmlzaW9uRGF0YSA9IGdldEZpbHRlcnMocHJldlJldmlzaW9uLCBkZWJ1Z0NvbmZpZyk7XG4gICAgY29uc3QgcHJldlJldmlzaW9uSWRzID0gbmV3IFNldChwcmV2UmV2aXNpb25EYXRhLmZpbHRlcnMubWFwKChmaWx0ZXIpID0+IGZpbHRlci5nZXRJZCgpKSk7XG4gICAgY29uc3QgbmV3UmV2aXNpb25EYXRhID0gZ2V0RmlsdGVycyhuZXdSZXZpc2lvbiwgZGVidWdDb25maWcpO1xuICAgIGNvbnN0IG5ld1JldmlzaW9uSWRzID0gbmV3IFNldChuZXdSZXZpc2lvbkRhdGEuZmlsdGVycy5tYXAoKGZpbHRlcikgPT4gZmlsdGVyLmdldElkKCkpKTtcbiAgICAvLyBDaGVjayB3aGljaCBmaWx0ZXJzIHdlcmUgYWRkZWQsIGJhc2VkIG9uIElEXG4gICAgY29uc3QgYWRkZWQgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgbmV3UmV2aXNpb25EYXRhLmZpbHRlcnMpIHtcbiAgICAgICAgaWYgKCFwcmV2UmV2aXNpb25JZHMuaGFzKGZpbHRlci5nZXRJZCgpKSkge1xuICAgICAgICAgICAgYWRkZWQuYWRkKGZpbHRlci5yYXdMaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGVjayB3aGljaCBmaWx0ZXJzIHdlcmUgcmVtb3ZlZCwgYmFzZWQgb24gSURcbiAgICBjb25zdCByZW1vdmVkID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHByZXZSZXZpc2lvbkRhdGEuZmlsdGVycykge1xuICAgICAgICBpZiAoIW5ld1JldmlzaW9uSWRzLmhhcyhmaWx0ZXIuZ2V0SWQoKSkpIHtcbiAgICAgICAgICAgIHJlbW92ZWQuYWRkKGZpbHRlci5yYXdMaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGYXN0IGV4aXQgaWYgd2UgZG9uJ3Qgd2FudCB0byBoYW5kbGUgcHJlcHJvY2Vzc29ycy5cbiAgICBpZiAoIWNvbmZpZy5sb2FkUHJlcHJvY2Vzc29ycykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkZWQ6IEFycmF5LmZyb20oYWRkZWQpLFxuICAgICAgICAgICAgcmVtb3ZlZDogQXJyYXkuZnJvbShyZW1vdmVkKSxcbiAgICAgICAgICAgIHByZXByb2Nlc3NvcnM6IHt9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBuZXdSZXZpc2lvbkRhdGEuZmlsdGVycykge1xuICAgICAgICBpbmRleC5zZXQoZmlsdGVyLmdldElkKCksIGZpbHRlci5yYXdMaW5lKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgcHJldlJldmlzaW9uRGF0YS5maWx0ZXJzKSB7XG4gICAgICAgIGluZGV4LnNldChmaWx0ZXIuZ2V0SWQoKSwgZmlsdGVyLnJhd0xpbmUpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgcHJlcHJvY2Vzc29yIGRpZmZzXG4gICAgY29uc3QgcHJlcHJvY2Vzc29ycyA9IHt9O1xuICAgIC8vIEdldCB0aGUgZGlmZiBvZiBwcmVwcm9jZXNzb3JzXG4gICAgZm9yIChjb25zdCBwcmVwcm9jZXNzb3Igb2YgcHJldlJldmlzaW9uRGF0YS5wcmVwcm9jZXNzb3JzKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHNhbWUgcHJlcHJvY2Vzc29yIGluIGBuZXdSZXZpc2lvbkRhdGFgXG4gICAgICAgIGNvbnN0IG5ld1ByZXByb2Nlc3NvciA9IG5ld1JldmlzaW9uRGF0YS5wcmVwcm9jZXNzb3JzLmZpbmQoKG5ld1ByZXByb2Nlc3NvcikgPT4gbmV3UHJlcHJvY2Vzc29yLmNvbmRpdGlvbiA9PT0gcHJlcHJvY2Vzc29yLmNvbmRpdGlvbik7XG4gICAgICAgIC8vIElmIHRoZSBwcmVwcm9jZXNzb3IgaW4gdGhlIHJldmlzaW9uIGlzIG5vdCBmb3VuZCwgaXQgbWVhbnMgdGhlIHdob2xlIGJsb2NrIHdhcyByZW1vdmVkXG4gICAgICAgIGlmICghbmV3UHJlcHJvY2Vzc29yKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkSW5TY29wZSA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgZmlsdGVyc1xuICAgICAgICAgICAgZm9yIChjb25zdCBmaWx0ZXJJRCBvZiBwcmVwcm9jZXNzb3IuZmlsdGVySURzKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZEluU2NvcGUuYWRkKGluZGV4LmdldChmaWx0ZXJJRCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlcHJvY2Vzc29yc1twcmVwcm9jZXNzb3IuY29uZGl0aW9uXSA9IHtcbiAgICAgICAgICAgICAgICBhZGRlZDogW10sXG4gICAgICAgICAgICAgICAgcmVtb3ZlZDogQXJyYXkuZnJvbShyZW1vdmVkSW5TY29wZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHByZXByb2Nlc3NvciBpbiB0aGUgcmV2aXNpb24gaXMgZm91bmQsIGl0IG1lYW5zIHRoZSBibG9jayB3YXMgdXBkYXRlZFxuICAgICAgICAvLyBDcmVhdGUgc3Vic2V0c1xuICAgICAgICBjb25zdCBzY29wZSA9IHtcbiAgICAgICAgICAgIGFkZGVkOiBuZXcgU2V0KCksXG4gICAgICAgICAgICByZW1vdmVkOiBuZXcgU2V0KCksXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgZmlsdGVySUQgb2YgcHJlcHJvY2Vzc29yLmZpbHRlcklEcykge1xuICAgICAgICAgICAgaWYgKCFuZXdQcmVwcm9jZXNzb3IuZmlsdGVySURzLmhhcyhmaWx0ZXJJRCkpIHtcbiAgICAgICAgICAgICAgICBzY29wZS5yZW1vdmVkLmFkZChpbmRleC5nZXQoZmlsdGVySUQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlcklEIG9mIG5ld1ByZXByb2Nlc3Nvci5maWx0ZXJJRHMpIHtcbiAgICAgICAgICAgIGlmICghcHJlcHJvY2Vzc29yLmZpbHRlcklEcy5oYXMoZmlsdGVySUQpKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUuYWRkZWQuYWRkKGluZGV4LmdldChmaWx0ZXJJRCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXByb2Nlc3NvcnNbcHJlcHJvY2Vzc29yLmNvbmRpdGlvbl0gPSB7XG4gICAgICAgICAgICBhZGRlZDogQXJyYXkuZnJvbShzY29wZS5hZGRlZCksXG4gICAgICAgICAgICByZW1vdmVkOiBBcnJheS5mcm9tKHNjb3BlLnJlbW92ZWQpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBJdGVyYXRlIG92ZXIgb25seSBcImFkZGVkXCIgcHJlcHJvY2Vzc29yc1xuICAgIGZvciAoY29uc3QgcHJlcHJvY2Vzc29yIG9mIG5ld1JldmlzaW9uRGF0YS5wcmVwcm9jZXNzb3JzKSB7XG4gICAgICAgIC8vIElmIHRoZSBwcmVwcm9jZXNzb3IgaW4gdGhlIHByZXZpb3VzIHJldmlzaW9uIHdhcyBub3QgZm91bmQsIGl0IG1lYW5zIHRoZSB3aG9sZSBibG9jayB3YXMgYWRkZWRcbiAgICAgICAgaWYgKCFwcmVwcm9jZXNzb3JzW3ByZXByb2Nlc3Nvci5jb25kaXRpb25dKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRlZEluU2NvcGUgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGZpbHRlcnNcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsdGVySUQgb2YgcHJlcHJvY2Vzc29yLmZpbHRlcklEcykge1xuICAgICAgICAgICAgICAgIGFkZGVkSW5TY29wZS5hZGQoaW5kZXguZ2V0KGZpbHRlcklEKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVwcm9jZXNzb3JzW3ByZXByb2Nlc3Nvci5jb25kaXRpb25dID0ge1xuICAgICAgICAgICAgICAgIGFkZGVkOiBBcnJheS5mcm9tKGFkZGVkSW5TY29wZSksXG4gICAgICAgICAgICAgICAgcmVtb3ZlZDogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2NvbmRpdGlvbiwgeyBhZGRlZCwgcmVtb3ZlZCB9XSBvZiBPYmplY3QuZW50cmllcyhwcmVwcm9jZXNzb3JzKSkge1xuICAgICAgICBpZiAoYWRkZWQubGVuZ3RoID09PSAwICYmIHJlbW92ZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgcHJlcHJvY2Vzc29yc1tjb25kaXRpb25dO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZGVkOiBBcnJheS5mcm9tKGFkZGVkKSxcbiAgICAgICAgcmVtb3ZlZDogQXJyYXkuZnJvbShyZW1vdmVkKSxcbiAgICAgICAgLy8gRm9yIHRoZSBmaWx0ZXJzIHVuZGVyIGBwcmVwcm9jZXNzb3JzYCBwcm9wZXJ0eSwgaXQgZG9lc24ndCBtZWFuIHRob3NlIGFyZSBcImZpbHRlcnNcIi5cbiAgICAgICAgLy8gVGhvc2UgYXJlIFwiYSBsaXN0IG9mIGZpbHRlcnMgYWZmZWN0ZWQgYnkgcHJlcHJvY2Vzc29yc1wiIG5vdCB0aGUgXCJmaWx0ZXJzXCIgaXRzZWxmLlxuICAgICAgICAvLyBUaGVyZWZvcmUsIHRoZXkgc2hvdWxkbid0IGJlIHRyZWF0ZWQgYXMgZmlsdGVycy5cbiAgICAgICAgLy8gSW5zdGVhZCwgd2UgcHV0IFwiZmlsdGVyc1wiIGluIGBhZGRlZGAgYW5kIGByZW1vdmVkYCBwcm9wZXJ0aWVzLlxuICAgICAgICAvLyBUaGlzIHByb3ZpZGVzIGJhY2t3YXJkLWNvbXBhdGliaWxpdHkgYW5kIHNpbXBsaWNpdHkuXG4gICAgICAgIHByZXByb2Nlc3NvcnMsXG4gICAgfTtcbn1cbi8qKlxuICogTWVyZ2Ugc2V2ZXJhbCByYXcgZGlmZnMgaW50byBvbmUsIHRha2luZyBjYXJlIG9mIGFjY3VtdWxhdGluZyBhZGRlZCBhbmRcbiAqIHJlbW92ZWQgZmlsdGVycywgZXZlbiBpZiBzZXZlcmFsIGRpZmZzIGFkZC9yZW1vdmUgdGhlIHNhbWUgb25lcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGlmZnMoZGlmZnMpIHtcbiAgICBjb25zdCBhZGRlZEN1bXVsID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHJlbW92ZWRDdW11bCA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBwcmVwcm9jZXNzb3JzQ3VtdWwgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHsgYWRkZWQsIHJlbW92ZWQsIHByZXByb2Nlc3NvcnMgfSBvZiBkaWZmcykge1xuICAgICAgICBpZiAoYWRkZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdHIgb2YgYWRkZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZEN1bXVsLmhhcyhzdHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRDdW11bC5kZWxldGUoc3RyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkZWRDdW11bC5hZGQoc3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtb3ZlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN0ciBvZiByZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZGVkQ3VtdWwuaGFzKHN0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRDdW11bC5kZWxldGUoc3RyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVtb3ZlZEN1bXVsLmFkZChzdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcHJlcHJvY2Vzc29ycykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbY29uZGl0aW9uLCBkZXRhaWxzXSBvZiBPYmplY3QuZW50cmllcyhwcmVwcm9jZXNzb3JzKSkge1xuICAgICAgICAgICAgaWYgKCFwcmVwcm9jZXNzb3JzQ3VtdWxbY29uZGl0aW9uXSkge1xuICAgICAgICAgICAgICAgIHByZXByb2Nlc3NvcnNDdW11bFtjb25kaXRpb25dID0ge1xuICAgICAgICAgICAgICAgICAgICBhZGRlZDogZGV0YWlscy5hZGRlZCAhPT0gdW5kZWZpbmVkID8gbmV3IFNldChkZXRhaWxzLmFkZGVkKSA6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZDogZGV0YWlscy5yZW1vdmVkICE9PSB1bmRlZmluZWQgPyBuZXcgU2V0KGRldGFpbHMucmVtb3ZlZCkgOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkZXRhaWxzLmFkZGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdHIgb2YgZGV0YWlscy5hZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXByb2Nlc3NvcnNDdW11bFtjb25kaXRpb25dLnJlbW92ZWQuaGFzKHN0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVwcm9jZXNzb3JzQ3VtdWxbY29uZGl0aW9uXS5yZW1vdmVkLmRlbGV0ZShzdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlcHJvY2Vzc29yc0N1bXVsW2NvbmRpdGlvbl0uYWRkZWQuYWRkKHN0cik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRldGFpbHMucmVtb3ZlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3RyIG9mIGRldGFpbHMucmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXByb2Nlc3NvcnNDdW11bFtjb25kaXRpb25dLmFkZGVkLmhhcyhzdHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlcHJvY2Vzc29yc0N1bXVsW2NvbmRpdGlvbl0uYWRkZWQuZGVsZXRlKHN0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVwcm9jZXNzb3JzQ3VtdWxbY29uZGl0aW9uXS5yZW1vdmVkLmFkZChzdHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZGVkOiBBcnJheS5mcm9tKGFkZGVkQ3VtdWwpLFxuICAgICAgICByZW1vdmVkOiBBcnJheS5mcm9tKHJlbW92ZWRDdW11bCksXG4gICAgICAgIHByZXByb2Nlc3NvcnM6IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhwcmVwcm9jZXNzb3JzQ3VtdWwpLm1hcCgoW2NvbmRpdGlvbiwgZGV0YWlsc10pID0+IFtcbiAgICAgICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhZGRlZDogQXJyYXkuZnJvbShkZXRhaWxzLmFkZGVkKSxcbiAgICAgICAgICAgICAgICByZW1vdmVkOiBBcnJheS5mcm9tKGRldGFpbHMucmVtb3ZlZCksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKSksXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpc3RzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/lists.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/preprocessor.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/preprocessor.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Env: () => (/* binding */ Env),\n/* harmony export */   PreprocessorTokens: () => (/* binding */ PreprocessorTokens),\n/* harmony export */   \"default\": () => (/* binding */ Preprocessor),\n/* harmony export */   detectPreprocessor: () => (/* binding */ detectPreprocessor),\n/* harmony export */   evaluate: () => (/* binding */ evaluate)\n/* harmony export */ });\n/* harmony import */ var _data_view_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data-view.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/data-view.js\");\n\nclass Env extends Map {\n}\nvar PreprocessorTokens;\n(function (PreprocessorTokens) {\n    PreprocessorTokens[PreprocessorTokens[\"INVALID\"] = 0] = \"INVALID\";\n    PreprocessorTokens[PreprocessorTokens[\"BEGIF\"] = 1] = \"BEGIF\";\n    PreprocessorTokens[PreprocessorTokens[\"ELSE\"] = 2] = \"ELSE\";\n    PreprocessorTokens[PreprocessorTokens[\"ENDIF\"] = 3] = \"ENDIF\";\n})(PreprocessorTokens || (PreprocessorTokens = {}));\nfunction detectPreprocessor(line) {\n    // Minimum size of a valid condition should be 6 for something like: \"!#if x\" or \"!#else\"\n    if (line.length < 6 ||\n        line.charCodeAt(0) !== 33 /* '!' */ ||\n        line.charCodeAt(1) !== 35 /* '#' */) {\n        return PreprocessorTokens.INVALID;\n    }\n    if (line.startsWith('!#if ')) {\n        return PreprocessorTokens.BEGIF;\n    }\n    if (line.startsWith('!#else')) {\n        return PreprocessorTokens.ELSE;\n    }\n    if (line.startsWith('!#endif')) {\n        return PreprocessorTokens.ENDIF;\n    }\n    return PreprocessorTokens.INVALID;\n}\nconst tokenizerPattern = /(!|&&|\\|\\||\\(|\\)|[a-zA-Z0-9_]+)/g;\nconst identifierPattern = /^[a-zA-Z0-9_]+$/;\nconst tokenize = (expression) => expression.match(tokenizerPattern);\nconst isIdentifier = (expression) => identifierPattern.test(expression);\nconst precedence = {\n    '!': 2,\n    '&&': 1,\n    '||': 0,\n};\nconst isOperator = (token) => Object.prototype.hasOwnProperty.call(precedence, token);\nconst testIdentifier = (identifier, env) => {\n    if (identifier === 'true' && !env.has('true')) {\n        return true;\n    }\n    if (identifier === 'false' && !env.has('false')) {\n        return false;\n    }\n    return !!env.get(identifier);\n};\n/// The parsing is done using the [Shunting yard algorithm](https://en.wikipedia.org/wiki/Shunting_yard_algorithm).\n/// This function takes as input a string expression and an environment Map.\n/// The expression is made of constants (identifiers), logical operators\n/// (&&, ||), negations (!constant) and parentheses.\n///\n/// The environment is a simple Map that associates identifiers to boolean values.\n///\n/// The function should return the result of evaluating the expression using\n/// the values from `environment`. The return value of this function is\n/// either `true` or `false`.\nconst evaluate = (expression, env) => {\n    if (expression.length === 0) {\n        return false;\n    }\n    if (isIdentifier(expression)) {\n        if (expression[0] === '!') {\n            return !testIdentifier(expression.slice(1), env);\n        }\n        return testIdentifier(expression, env);\n    }\n    const tokens = tokenize(expression);\n    if (!tokens || tokens.length === 0) {\n        return false;\n    }\n    // Exit if an unallowed character found.\n    // Since we're tokenizing via String.prototype.match function,\n    // the total length of matched tokens will be different in case\n    // unallowed characters were injected.\n    // However, we expect all spaces were already removed in prior step.\n    if (expression.length !== tokens.reduce((partialSum, token) => partialSum + token.length, 0)) {\n        return false;\n    }\n    const output = [];\n    const stack = [];\n    for (const token of tokens) {\n        if (token === '(') {\n            stack.push(token);\n        }\n        else if (token === ')') {\n            while (stack.length !== 0 && stack[stack.length - 1] !== '(') {\n                output.push(stack.pop());\n            }\n            // If the opening parenthesis doesn't exist\n            if (stack.length === 0) {\n                return false;\n            }\n            stack.pop();\n        }\n        else if (isOperator(token)) {\n            while (stack.length &&\n                isOperator(stack[stack.length - 1]) &&\n                precedence[token] <= precedence[stack[stack.length - 1]]) {\n                output.push(stack.pop());\n            }\n            stack.push(token);\n        }\n        else {\n            output.push(testIdentifier(token, env));\n        }\n    }\n    // If there is incomplete parenthesis\n    if (stack[0] === '(' || stack[0] === ')') {\n        return false;\n    }\n    while (stack.length !== 0) {\n        output.push(stack.pop());\n    }\n    for (const token of output) {\n        if (token === true || token === false) {\n            stack.push(token);\n        }\n        else if (token === '!') {\n            stack.push(!stack.pop());\n        }\n        else if (isOperator(token)) {\n            const right = stack.pop();\n            const left = stack.pop();\n            if (token === '&&') {\n                stack.push(left && right);\n            }\n            else {\n                stack.push(left || right);\n            }\n        }\n    }\n    return stack[0] === true;\n};\nclass Preprocessor {\n    static getCondition(line) {\n        return line.slice(5 /* '!#if '.length */).replace(/\\s/g, '');\n    }\n    static parse(line, filterIDs) {\n        return new this({\n            condition: Preprocessor.getCondition(line),\n            filterIDs,\n        });\n    }\n    static deserialize(view) {\n        const condition = view.getUTF8();\n        const filterIDs = new Set();\n        for (let i = 0, l = view.getUint32(); i < l; i++) {\n            filterIDs.add(view.getUint32());\n        }\n        return new this({\n            condition,\n            filterIDs,\n        });\n    }\n    constructor({ condition, filterIDs = new Set(), }) {\n        this.condition = condition;\n        this.filterIDs = filterIDs;\n    }\n    evaluate(env) {\n        return evaluate(this.condition, env);\n    }\n    serialize(view) {\n        view.pushUTF8(this.condition);\n        view.pushUint32(this.filterIDs.size);\n        for (const filterID of this.filterIDs) {\n            view.pushUint32(filterID);\n        }\n    }\n    getSerializedSize() {\n        let estimatedSize = (0,_data_view_js__WEBPACK_IMPORTED_MODULE_0__.sizeOfUTF8)(this.condition);\n        estimatedSize += (1 + this.filterIDs.size) * 4;\n        return estimatedSize;\n    }\n}\n//# sourceMappingURL=preprocessor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9wcmVwcm9jZXNzb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRDO0FBQ3JDO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUMxQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLG1DQUFtQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlEQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvYWRibG9ja2VyL2Rpc3QvZXNtL3ByZXByb2Nlc3Nvci5qcz80MDUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNpemVPZlVURjggfSBmcm9tICcuL2RhdGEtdmlldy5qcyc7XG5leHBvcnQgY2xhc3MgRW52IGV4dGVuZHMgTWFwIHtcbn1cbmV4cG9ydCB2YXIgUHJlcHJvY2Vzc29yVG9rZW5zO1xuKGZ1bmN0aW9uIChQcmVwcm9jZXNzb3JUb2tlbnMpIHtcbiAgICBQcmVwcm9jZXNzb3JUb2tlbnNbUHJlcHJvY2Vzc29yVG9rZW5zW1wiSU5WQUxJRFwiXSA9IDBdID0gXCJJTlZBTElEXCI7XG4gICAgUHJlcHJvY2Vzc29yVG9rZW5zW1ByZXByb2Nlc3NvclRva2Vuc1tcIkJFR0lGXCJdID0gMV0gPSBcIkJFR0lGXCI7XG4gICAgUHJlcHJvY2Vzc29yVG9rZW5zW1ByZXByb2Nlc3NvclRva2Vuc1tcIkVMU0VcIl0gPSAyXSA9IFwiRUxTRVwiO1xuICAgIFByZXByb2Nlc3NvclRva2Vuc1tQcmVwcm9jZXNzb3JUb2tlbnNbXCJFTkRJRlwiXSA9IDNdID0gXCJFTkRJRlwiO1xufSkoUHJlcHJvY2Vzc29yVG9rZW5zIHx8IChQcmVwcm9jZXNzb3JUb2tlbnMgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdFByZXByb2Nlc3NvcihsaW5lKSB7XG4gICAgLy8gTWluaW11bSBzaXplIG9mIGEgdmFsaWQgY29uZGl0aW9uIHNob3VsZCBiZSA2IGZvciBzb21ldGhpbmcgbGlrZTogXCIhI2lmIHhcIiBvciBcIiEjZWxzZVwiXG4gICAgaWYgKGxpbmUubGVuZ3RoIDwgNiB8fFxuICAgICAgICBsaW5lLmNoYXJDb2RlQXQoMCkgIT09IDMzIC8qICchJyAqLyB8fFxuICAgICAgICBsaW5lLmNoYXJDb2RlQXQoMSkgIT09IDM1IC8qICcjJyAqLykge1xuICAgICAgICByZXR1cm4gUHJlcHJvY2Vzc29yVG9rZW5zLklOVkFMSUQ7XG4gICAgfVxuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJyEjaWYgJykpIHtcbiAgICAgICAgcmV0dXJuIFByZXByb2Nlc3NvclRva2Vucy5CRUdJRjtcbiAgICB9XG4gICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnISNlbHNlJykpIHtcbiAgICAgICAgcmV0dXJuIFByZXByb2Nlc3NvclRva2Vucy5FTFNFO1xuICAgIH1cbiAgICBpZiAobGluZS5zdGFydHNXaXRoKCchI2VuZGlmJykpIHtcbiAgICAgICAgcmV0dXJuIFByZXByb2Nlc3NvclRva2Vucy5FTkRJRjtcbiAgICB9XG4gICAgcmV0dXJuIFByZXByb2Nlc3NvclRva2Vucy5JTlZBTElEO1xufVxuY29uc3QgdG9rZW5pemVyUGF0dGVybiA9IC8oIXwmJnxcXHxcXHx8XFwofFxcKXxbYS16QS1aMC05X10rKS9nO1xuY29uc3QgaWRlbnRpZmllclBhdHRlcm4gPSAvXlthLXpBLVowLTlfXSskLztcbmNvbnN0IHRva2VuaXplID0gKGV4cHJlc3Npb24pID0+IGV4cHJlc3Npb24ubWF0Y2godG9rZW5pemVyUGF0dGVybik7XG5jb25zdCBpc0lkZW50aWZpZXIgPSAoZXhwcmVzc2lvbikgPT4gaWRlbnRpZmllclBhdHRlcm4udGVzdChleHByZXNzaW9uKTtcbmNvbnN0IHByZWNlZGVuY2UgPSB7XG4gICAgJyEnOiAyLFxuICAgICcmJic6IDEsXG4gICAgJ3x8JzogMCxcbn07XG5jb25zdCBpc09wZXJhdG9yID0gKHRva2VuKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJlY2VkZW5jZSwgdG9rZW4pO1xuY29uc3QgdGVzdElkZW50aWZpZXIgPSAoaWRlbnRpZmllciwgZW52KSA9PiB7XG4gICAgaWYgKGlkZW50aWZpZXIgPT09ICd0cnVlJyAmJiAhZW52LmhhcygndHJ1ZScpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaWRlbnRpZmllciA9PT0gJ2ZhbHNlJyAmJiAhZW52LmhhcygnZmFsc2UnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAhIWVudi5nZXQoaWRlbnRpZmllcik7XG59O1xuLy8vIFRoZSBwYXJzaW5nIGlzIGRvbmUgdXNpbmcgdGhlIFtTaHVudGluZyB5YXJkIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2h1bnRpbmdfeWFyZF9hbGdvcml0aG0pLlxuLy8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYXMgaW5wdXQgYSBzdHJpbmcgZXhwcmVzc2lvbiBhbmQgYW4gZW52aXJvbm1lbnQgTWFwLlxuLy8vIFRoZSBleHByZXNzaW9uIGlzIG1hZGUgb2YgY29uc3RhbnRzIChpZGVudGlmaWVycyksIGxvZ2ljYWwgb3BlcmF0b3JzXG4vLy8gKCYmLCB8fCksIG5lZ2F0aW9ucyAoIWNvbnN0YW50KSBhbmQgcGFyZW50aGVzZXMuXG4vLy9cbi8vLyBUaGUgZW52aXJvbm1lbnQgaXMgYSBzaW1wbGUgTWFwIHRoYXQgYXNzb2NpYXRlcyBpZGVudGlmaWVycyB0byBib29sZWFuIHZhbHVlcy5cbi8vL1xuLy8vIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIHRoZSByZXN1bHQgb2YgZXZhbHVhdGluZyB0aGUgZXhwcmVzc2lvbiB1c2luZ1xuLy8vIHRoZSB2YWx1ZXMgZnJvbSBgZW52aXJvbm1lbnRgLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gaXNcbi8vLyBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAuXG5leHBvcnQgY29uc3QgZXZhbHVhdGUgPSAoZXhwcmVzc2lvbiwgZW52KSA9PiB7XG4gICAgaWYgKGV4cHJlc3Npb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzSWRlbnRpZmllcihleHByZXNzaW9uKSkge1xuICAgICAgICBpZiAoZXhwcmVzc2lvblswXSA9PT0gJyEnKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRlc3RJZGVudGlmaWVyKGV4cHJlc3Npb24uc2xpY2UoMSksIGVudik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlc3RJZGVudGlmaWVyKGV4cHJlc3Npb24sIGVudik7XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IHRva2VuaXplKGV4cHJlc3Npb24pO1xuICAgIGlmICghdG9rZW5zIHx8IHRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBFeGl0IGlmIGFuIHVuYWxsb3dlZCBjaGFyYWN0ZXIgZm91bmQuXG4gICAgLy8gU2luY2Ugd2UncmUgdG9rZW5pemluZyB2aWEgU3RyaW5nLnByb3RvdHlwZS5tYXRjaCBmdW5jdGlvbixcbiAgICAvLyB0aGUgdG90YWwgbGVuZ3RoIG9mIG1hdGNoZWQgdG9rZW5zIHdpbGwgYmUgZGlmZmVyZW50IGluIGNhc2VcbiAgICAvLyB1bmFsbG93ZWQgY2hhcmFjdGVycyB3ZXJlIGluamVjdGVkLlxuICAgIC8vIEhvd2V2ZXIsIHdlIGV4cGVjdCBhbGwgc3BhY2VzIHdlcmUgYWxyZWFkeSByZW1vdmVkIGluIHByaW9yIHN0ZXAuXG4gICAgaWYgKGV4cHJlc3Npb24ubGVuZ3RoICE9PSB0b2tlbnMucmVkdWNlKChwYXJ0aWFsU3VtLCB0b2tlbikgPT4gcGFydGlhbFN1bSArIHRva2VuLmxlbmd0aCwgMCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gJygnKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gJyknKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoICE9PSAwICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdICE9PSAnKCcpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdGFjay5wb3AoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPcGVyYXRvcih0b2tlbikpIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBpc09wZXJhdG9yKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdKSAmJlxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2VbdG9rZW5dIDw9IHByZWNlZGVuY2Vbc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1dKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCh0ZXN0SWRlbnRpZmllcih0b2tlbiwgZW52KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlcmUgaXMgaW5jb21wbGV0ZSBwYXJlbnRoZXNpc1xuICAgIGlmIChzdGFja1swXSA9PT0gJygnIHx8IHN0YWNrWzBdID09PSAnKScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHN0YWNrLnBvcCgpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiBvdXRwdXQpIHtcbiAgICAgICAgaWYgKHRva2VuID09PSB0cnVlIHx8IHRva2VuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09ICchJykge1xuICAgICAgICAgICAgc3RhY2sucHVzaCghc3RhY2sucG9wKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT3BlcmF0b3IodG9rZW4pKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSAnJiYnKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChsZWZ0ICYmIHJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobGVmdCB8fCByaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrWzBdID09PSB0cnVlO1xufTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByZXByb2Nlc3NvciB7XG4gICAgc3RhdGljIGdldENvbmRpdGlvbihsaW5lKSB7XG4gICAgICAgIHJldHVybiBsaW5lLnNsaWNlKDUgLyogJyEjaWYgJy5sZW5ndGggKi8pLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZShsaW5lLCBmaWx0ZXJJRHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHtcbiAgICAgICAgICAgIGNvbmRpdGlvbjogUHJlcHJvY2Vzc29yLmdldENvbmRpdGlvbihsaW5lKSxcbiAgICAgICAgICAgIGZpbHRlcklEcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZSh2aWV3KSB7XG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHZpZXcuZ2V0VVRGOCgpO1xuICAgICAgICBjb25zdCBmaWx0ZXJJRHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdmlldy5nZXRVaW50MzIoKTsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZmlsdGVySURzLmFkZCh2aWV3LmdldFVpbnQzMigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMoe1xuICAgICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgICAgZmlsdGVySURzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyBjb25kaXRpb24sIGZpbHRlcklEcyA9IG5ldyBTZXQoKSwgfSkge1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy5maWx0ZXJJRHMgPSBmaWx0ZXJJRHM7XG4gICAgfVxuICAgIGV2YWx1YXRlKGVudikge1xuICAgICAgICByZXR1cm4gZXZhbHVhdGUodGhpcy5jb25kaXRpb24sIGVudik7XG4gICAgfVxuICAgIHNlcmlhbGl6ZSh2aWV3KSB7XG4gICAgICAgIHZpZXcucHVzaFVURjgodGhpcy5jb25kaXRpb24pO1xuICAgICAgICB2aWV3LnB1c2hVaW50MzIodGhpcy5maWx0ZXJJRHMuc2l6ZSk7XG4gICAgICAgIGZvciAoY29uc3QgZmlsdGVySUQgb2YgdGhpcy5maWx0ZXJJRHMpIHtcbiAgICAgICAgICAgIHZpZXcucHVzaFVpbnQzMihmaWx0ZXJJRCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2VyaWFsaXplZFNpemUoKSB7XG4gICAgICAgIGxldCBlc3RpbWF0ZWRTaXplID0gc2l6ZU9mVVRGOCh0aGlzLmNvbmRpdGlvbik7XG4gICAgICAgIGVzdGltYXRlZFNpemUgKz0gKDEgKyB0aGlzLmZpbHRlcklEcy5zaXplKSAqIDQ7XG4gICAgICAgIHJldHVybiBlc3RpbWF0ZWRTaXplO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZXByb2Nlc3Nvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/preprocessor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/punycode.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/punycode.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   toASCII: () => (/* binding */ toASCII),\n/* harmony export */   toUnicode: () => (/* binding */ toUnicode),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/*!\n * Copyright Mathias Bynens <https://mathiasbynens.be/>\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n/** Regular expressions */\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\nconst errors = {\n    'invalid-input': 'Invalid input',\n    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n    'overflow': 'Overflow: input needs wider integers to process',\n};\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\n/*--------------------------------------------------------------------------*/\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n    throw new RangeError(errors[type]);\n}\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(str) {\n    const output = [];\n    let counter = 0;\n    const length = str.length;\n    while (counter < length) {\n        const value = str.charCodeAt(counter++);\n        if (value >= 0xd800 && value <= 0xdbff && counter < length) {\n            // It's a high surrogate, and there is a next character.\n            const extra = str.charCodeAt(counter++);\n            if ((extra & 0xfc00) === 0xdc00) {\n                // Low surrogate.\n                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\n            }\n            else {\n                // It's an unmatched surrogate; only append this code unit, in case the\n                // next code unit is the high surrogate of a surrogate pair.\n                output.push(value);\n                counter--;\n            }\n        }\n        else {\n            output.push(value);\n        }\n    }\n    return output;\n}\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nfunction basicToDigit(codePoint) {\n    if (codePoint - 0x30 < 0x0a) {\n        return codePoint - 0x16;\n    }\n    if (codePoint - 0x41 < 0x1a) {\n        return codePoint - 0x41;\n    }\n    if (codePoint - 0x61 < 0x1a) {\n        return codePoint - 0x61;\n    }\n    return base;\n}\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nfunction digitToBasic(digit, flag) {\n    //  0..25 map to ASCII a..z or A..Z\n    // 26..35 map to ASCII 0..9\n    return digit + 22 + 75 * (digit < 26 ? 1 : 0) - ((flag !== 0 ? 1 : 0) << 5);\n}\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nfunction adapt(delta, numPoints, firstTime) {\n    let k = 0;\n    delta = firstTime ? Math.floor(delta / damp) : delta >> 1;\n    delta += Math.floor(delta / numPoints);\n    for (; /* no initialization */ delta > (baseMinusTMin * tMax) >> 1; k += base) {\n        delta = Math.floor(delta / baseMinusTMin);\n    }\n    return Math.floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew));\n}\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nfunction decode(input) {\n    // Don't use UCS-2.\n    const output = [];\n    const inputLength = input.length;\n    let i = 0;\n    let n = initialN;\n    let bias = initialBias;\n    // Handle the basic code points: let `basic` be the number of input code\n    // points before the last delimiter, or `0` if there is none, then copy\n    // the first basic code points to the output.\n    let basic = input.lastIndexOf(delimiter);\n    if (basic < 0) {\n        basic = 0;\n    }\n    for (let j = 0; j < basic; ++j) {\n        // if it's not a basic code point\n        if (input.charCodeAt(j) >= 0x80) {\n            error('not-basic');\n        }\n        output.push(input.charCodeAt(j));\n    }\n    // Main decoding loop: start just after the last delimiter if any basic code\n    // points were copied; start at the beginning otherwise.\n    for (let index = basic > 0 ? basic + 1 : 0; index < inputLength /* no final expression */;) {\n        // `index` is the index of the next character to be consumed.\n        // Decode a generalized variable-length integer into `delta`,\n        // which gets added to `i`. The overflow checking is easier\n        // if we increase `i` as we go, then subtract off its starting\n        // value at the end to obtain `delta`.\n        const oldi = i;\n        for (let w = 1, k = base /* no condition */;; k += base) {\n            if (index >= inputLength) {\n                error('invalid-input');\n            }\n            const digit = basicToDigit(input.charCodeAt(index++));\n            if (digit >= base || digit > Math.floor((maxInt - i) / w)) {\n                error('overflow');\n            }\n            i += digit * w;\n            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n            if (digit < t) {\n                break;\n            }\n            const baseMinusT = base - t;\n            if (w > Math.floor(maxInt / baseMinusT)) {\n                error('overflow');\n            }\n            w *= baseMinusT;\n        }\n        const out = output.length + 1;\n        bias = adapt(i - oldi, out, oldi === 0);\n        // `i` was supposed to wrap around from `out` to `0`,\n        // incrementing `n` each time, so we'll fix that now:\n        if (Math.floor(i / out) > maxInt - n) {\n            error('overflow');\n        }\n        n += Math.floor(i / out);\n        i %= out;\n        // Insert `n` at position `i` of the output.\n        output.splice(i++, 0, n);\n    }\n    return String.fromCodePoint.apply(null, output);\n}\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nfunction encode(str) {\n    const output = [];\n    // Convert the input in UCS-2 to an array of Unicode code points.\n    const input = ucs2decode(str);\n    // Cache the length.\n    const inputLength = input.length;\n    // Initialize the state.\n    let n = initialN;\n    let delta = 0;\n    let bias = initialBias;\n    // Handle the basic code points.\n    for (let i = 0; i < input.length; i += 1) {\n        const currentValue = input[i];\n        if (currentValue < 0x80) {\n            output.push(String.fromCharCode(currentValue));\n        }\n    }\n    const basicLength = output.length;\n    let handledCPCount = basicLength;\n    // `handledCPCount` is the number of code points that have been handled;\n    // `basicLength` is the number of basic code points.\n    // Finish the basic string with a delimiter unless it's empty.\n    if (basicLength) {\n        output.push(delimiter);\n    }\n    // Main encoding loop:\n    while (handledCPCount < inputLength) {\n        // All non-basic code points < n have been handled already. Find the next\n        // larger one:\n        let m = maxInt;\n        for (let i = 0; i < input.length; i += 1) {\n            const currentValue = input[i];\n            if (currentValue >= n && currentValue < m) {\n                m = currentValue;\n            }\n        }\n        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n        // but guard against overflow.\n        const handledCPCountPlusOne = handledCPCount + 1;\n        if (m - n > Math.floor((maxInt - delta) / handledCPCountPlusOne)) {\n            error('overflow');\n        }\n        delta += (m - n) * handledCPCountPlusOne;\n        n = m;\n        for (let i = 0; i < input.length; i += 1) {\n            const currentValue = input[i];\n            if (currentValue < n && ++delta > maxInt) {\n                error('overflow');\n            }\n            if (currentValue === n) {\n                // Represent delta as a generalized variable-length integer.\n                let q = delta;\n                for (let k = base /* no condition */;; k += base) {\n                    const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                    if (q < t) {\n                        break;\n                    }\n                    const qMinusT = q - t;\n                    const baseMinusT = base - t;\n                    output.push(String.fromCharCode(digitToBasic(t + (qMinusT % baseMinusT), 0)));\n                    q = Math.floor(qMinusT / baseMinusT);\n                }\n                output.push(String.fromCharCode(digitToBasic(q, 0)));\n                bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);\n                delta = 0;\n                ++handledCPCount;\n            }\n        }\n        ++delta;\n        ++n;\n    }\n    return output.join('');\n}\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nfunction toUnicode(input) {\n    const labels = input.replace(regexSeparators, '\\x2E').split('.');\n    const encoded = [];\n    for (let i = 0; i < labels.length; i += 1) {\n        encoded.push(labels[i].startsWith('xn--') ? decode(labels[i].slice(4).toLowerCase()) : labels[i]);\n    }\n    return encoded.join('.');\n}\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nfunction toASCII(input) {\n    // Avoid `split(regex)` for IE8 compatibility. See #17.\n    const labels = input.replace(regexSeparators, '\\x2E').split('.');\n    const encoded = [];\n    for (let i = 0; i < labels.length; i += 1) {\n        encoded.push(regexNonASCII.test(labels[i]) ? 'xn--' + encode(labels[i]) : labels[i]);\n    }\n    return encoded.join('.');\n}\n/**\n * A string representing the current Punycode.js version number.\n * @memberOf punycode\n * @type String\n */\nconst version = '2.1.0';\n//# sourceMappingURL=punycode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9wdW55Y29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCO0FBQ0Esb0NBQW9DO0FBQ3BDLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQTZEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLGdEQUFnRCw4Q0FBOEM7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXIvZGlzdC9lc20vcHVueWNvZGUuanM/NWQxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCBNYXRoaWFzIEJ5bmVucyA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlLz5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuICogTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4gKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuLyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuY29uc3QgbWF4SW50ID0gMjE0NzQ4MzY0NzsgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuY29uc3QgYmFzZSA9IDM2O1xuY29uc3QgdE1pbiA9IDE7XG5jb25zdCB0TWF4ID0gMjY7XG5jb25zdCBza2V3ID0gMzg7XG5jb25zdCBkYW1wID0gNzAwO1xuY29uc3QgaW5pdGlhbEJpYXMgPSA3MjtcbmNvbnN0IGluaXRpYWxOID0gMTI4OyAvLyAweDgwXG5jb25zdCBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXHgyRCdcbi8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5jb25zdCByZWdleE5vbkFTQ0lJID0gL1teXFwwLVxceDdFXS87IC8vIG5vbi1BU0NJSSBjaGFyc1xuY29uc3QgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuY29uc3QgZXJyb3JzID0ge1xuICAgICdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnLFxuICAgICdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG4gICAgJ292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcbn07XG4vKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5jb25zdCBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG4gKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG4gKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG4gKiBtYXRjaGluZyBVVEYtMTYuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcbiAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGRlY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cbiAqL1xuZnVuY3Rpb24gdWNzMmRlY29kZShzdHIpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgY29uc3QgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBjb25zdCBleHRyYSA9IHN0ci5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG4gICAgICAgICAgICBpZiAoKGV4dHJhICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTG93IHN1cnJvZ2F0ZS5cbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzZmYpIDw8IDEwKSArIChleHRyYSAmIDB4M2ZmKSArIDB4MTAwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhbiB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0IGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci5cbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY291bnRlci0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cbiAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcbiAgICBpZiAoY29kZVBvaW50IC0gMHgzMCA8IDB4MGEpIHtcbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDB4MTY7XG4gICAgfVxuICAgIGlmIChjb2RlUG9pbnQgLSAweDQxIDwgMHgxYSkge1xuICAgICAgICByZXR1cm4gY29kZVBvaW50IC0gMHg0MTtcbiAgICB9XG4gICAgaWYgKGNvZGVQb2ludCAtIDB4NjEgPCAweDFhKSB7XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSAweDYxO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG4gKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAqL1xuZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG4gICAgLy8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcbiAgICAvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcbiAgICByZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYgPyAxIDogMCkgLSAoKGZsYWcgIT09IDAgPyAxIDogMCkgPDwgNSk7XG59XG4vKipcbiAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG4gICAgbGV0IGsgPSAwO1xuICAgIGRlbHRhID0gZmlyc3RUaW1lID8gTWF0aC5mbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcbiAgICBkZWx0YSArPSBNYXRoLmZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcbiAgICBmb3IgKDsgLyogbm8gaW5pdGlhbGl6YXRpb24gKi8gZGVsdGEgPiAoYmFzZU1pbnVzVE1pbiAqIHRNYXgpID4+IDE7IGsgKz0gYmFzZSkge1xuICAgICAgICBkZWx0YSA9IE1hdGguZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoayArICgoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEpIC8gKGRlbHRhICsgc2tldykpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuICogc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gICAgLy8gRG9uJ3QgdXNlIFVDUy0yLlxuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgIGNvbnN0IGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgbiA9IGluaXRpYWxOO1xuICAgIGxldCBiaWFzID0gaW5pdGlhbEJpYXM7XG4gICAgLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG4gICAgLy8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcbiAgICAvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cbiAgICBsZXQgYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuICAgIGlmIChiYXNpYyA8IDApIHtcbiAgICAgICAgYmFzaWMgPSAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcbiAgICAgICAgLy8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcbiAgICAgICAgICAgIGVycm9yKCdub3QtYmFzaWMnKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcbiAgICB9XG4gICAgLy8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuICAgIC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG4gICAgZm9yIChsZXQgaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoIC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi87KSB7XG4gICAgICAgIC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cbiAgICAgICAgLy8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuICAgICAgICAvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuICAgICAgICAvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuICAgICAgICAvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuICAgICAgICBjb25zdCBvbGRpID0gaTtcbiAgICAgICAgZm9yIChsZXQgdyA9IDEsIGsgPSBiYXNlIC8qIG5vIGNvbmRpdGlvbiAqLzs7IGsgKz0gYmFzZSkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuICAgICAgICAgICAgaWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBNYXRoLmZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ292ZXJmbG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IGRpZ2l0ICogdztcbiAgICAgICAgICAgIGNvbnN0IHQgPSBrIDw9IGJpYXMgPyB0TWluIDogayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcztcbiAgICAgICAgICAgIGlmIChkaWdpdCA8IHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcbiAgICAgICAgICAgIGlmICh3ID4gTWF0aC5mbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuICAgICAgICAgICAgICAgIGVycm9yKCdvdmVyZmxvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdyAqPSBiYXNlTWludXNUO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuICAgICAgICBiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PT0gMCk7XG4gICAgICAgIC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG4gICAgICAgIC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG4gICAgICAgIGlmIChNYXRoLmZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuICAgICAgICAgICAgZXJyb3IoJ292ZXJmbG93Jyk7XG4gICAgICAgIH1cbiAgICAgICAgbiArPSBNYXRoLmZsb29yKGkgLyBvdXQpO1xuICAgICAgICBpICU9IG91dDtcbiAgICAgICAgLy8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dC5cbiAgICAgICAgb3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkobnVsbCwgb3V0cHV0KTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcbiAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShzdHIpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBhbiBhcnJheSBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuICAgIGNvbnN0IGlucHV0ID0gdWNzMmRlY29kZShzdHIpO1xuICAgIC8vIENhY2hlIHRoZSBsZW5ndGguXG4gICAgY29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG4gICAgbGV0IG4gPSBpbml0aWFsTjtcbiAgICBsZXQgZGVsdGEgPSAwO1xuICAgIGxldCBiaWFzID0gaW5pdGlhbEJpYXM7XG4gICAgLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGlucHV0W2ldO1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG4gICAgbGV0IGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7XG4gICAgLy8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG4gICAgLy8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuICAgIC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIHdpdGggYSBkZWxpbWl0ZXIgdW5sZXNzIGl0J3MgZW1wdHkuXG4gICAgaWYgKGJhc2ljTGVuZ3RoKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG4gICAgfVxuICAgIC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcbiAgICB3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuICAgICAgICAvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG4gICAgICAgIC8vIGxhcmdlciBvbmU6XG4gICAgICAgIGxldCBtID0gbWF4SW50O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG4gICAgICAgICAgICAgICAgbSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG4gICAgICAgIC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93LlxuICAgICAgICBjb25zdCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG4gICAgICAgIGlmIChtIC0gbiA+IE1hdGguZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcbiAgICAgICAgICAgIGVycm9yKCdvdmVyZmxvdycpO1xuICAgICAgICB9XG4gICAgICAgIGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG4gICAgICAgIG4gPSBtO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT09IG4pIHtcbiAgICAgICAgICAgICAgICAvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cbiAgICAgICAgICAgICAgICBsZXQgcSA9IGRlbHRhO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSBiYXNlIC8qIG5vIGNvbmRpdGlvbiAqLzs7IGsgKz0gYmFzZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxIDwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcU1pbnVzVCA9IHEgLSB0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyAocU1pbnVzVCAlIGJhc2VNaW51c1QpLCAwKSkpO1xuICAgICAgICAgICAgICAgICAgICBxID0gTWF0aC5mbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG4gICAgICAgICAgICAgICAgYmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09PSBiYXNpY0xlbmd0aCk7XG4gICAgICAgICAgICAgICAgZGVsdGEgPSAwO1xuICAgICAgICAgICAgICAgICsraGFuZGxlZENQQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKytkZWx0YTtcbiAgICAgICAgKytuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG4gKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG4gKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cbiAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG4gKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcbiAqIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuICAgIGNvbnN0IGxhYmVscyA9IGlucHV0LnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IGVuY29kZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBlbmNvZGVkLnB1c2gobGFiZWxzW2ldLnN0YXJ0c1dpdGgoJ3huLS0nKSA/IGRlY29kZShsYWJlbHNbaV0uc2xpY2UoNCkudG9Mb3dlckNhc2UoKSkgOiBsYWJlbHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlZC5qb2luKCcuJyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG4gKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cbiAqIEFTQ0lJLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuICogVW5pY29kZSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG4gKiBlbWFpbCBhZGRyZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuICAgIC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cbiAgICBjb25zdCBsYWJlbHMgPSBpbnB1dC5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJykuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBlbmNvZGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZW5jb2RlZC5wdXNoKHJlZ2V4Tm9uQVNDSUkudGVzdChsYWJlbHNbaV0pID8gJ3huLS0nICsgZW5jb2RlKGxhYmVsc1tpXSkgOiBsYWJlbHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlZC5qb2luKCcuJyk7XG59XG4vKipcbiAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHR5cGUgU3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuMS4wJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1bnljb2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/punycode.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/queue-microtask.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/queue-microtask.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   queueMicrotask: () => (/* binding */ queueMicrotask)\n/* harmony export */ });\n/**\n * The MIT License (MIT)\n *\n * Copyright (c) Feross Aboukhadijeh\n *\n * Originally from: https://github.com/feross/queue-microtask\n */\nlet promise;\nconst queueMicrotask = typeof window !== 'undefined' && typeof window.queueMicrotask === 'function'\n    ? (cb) => window.queueMicrotask(cb)\n    : // reuse resolved promise, and allocate it lazily\n        (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {\n            throw err;\n        }, 0));\n//# sourceMappingURL=queue-microtask.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9xdWV1ZS1taWNyb3Rhc2suanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9xdWV1ZS1taWNyb3Rhc2suanM/Mjk0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgRmVyb3NzIEFib3VraGFkaWplaFxuICpcbiAqIE9yaWdpbmFsbHkgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9xdWV1ZS1taWNyb3Rhc2tcbiAqL1xubGV0IHByb21pc2U7XG5leHBvcnQgY29uc3QgcXVldWVNaWNyb3Rhc2sgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LnF1ZXVlTWljcm90YXNrID09PSAnZnVuY3Rpb24nXG4gICAgPyAoY2IpID0+IHdpbmRvdy5xdWV1ZU1pY3JvdGFzayhjYilcbiAgICA6IC8vIHJldXNlIHJlc29sdmVkIHByb21pc2UsIGFuZCBhbGxvY2F0ZSBpdCBsYXppbHlcbiAgICAgICAgKGNiKSA9PiAocHJvbWlzZSB8fCAocHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpKSkudGhlbihjYikuY2F0Y2goKGVycikgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0sIDApKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXVlLW1pY3JvdGFzay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/queue-microtask.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/request.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/request.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NORMALIZED_TYPE_TOKEN: () => (/* binding */ NORMALIZED_TYPE_TOKEN),\n/* harmony export */   \"default\": () => (/* binding */ Request),\n/* harmony export */   getEntityHashesFromLabelsBackward: () => (/* binding */ getEntityHashesFromLabelsBackward),\n/* harmony export */   getHashesFromLabelsBackward: () => (/* binding */ getHashesFromLabelsBackward),\n/* harmony export */   getHostnameHashesFromLabelsBackward: () => (/* binding */ getHostnameHashesFromLabelsBackward),\n/* harmony export */   getHostnameWithoutPublicSuffix: () => (/* binding */ getHostnameWithoutPublicSuffix),\n/* harmony export */   hashHostnameBackward: () => (/* binding */ hashHostnameBackward),\n/* harmony export */   makeRequest: () => (/* binding */ makeRequest)\n/* harmony export */ });\n/* harmony import */ var _remusao_guess_url_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @remusao/guess-url-type */ \"(rsc)/./node_modules/@remusao/guess-url-type/dist/esm/index.js\");\n/* harmony import */ var tldts_experimental__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tldts-experimental */ \"(rsc)/./node_modules/tldts-experimental/dist/es6/index.js\");\n/* harmony import */ var _data_view_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data-view.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/data-view.js\");\n/* harmony import */ var _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tokens-buffer.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/tokens-buffer.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/utils.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n\n\n\nconst TLDTS_OPTIONS = {\n    extractHostname: true,\n    mixedInputs: false,\n    validateHostname: false,\n};\nconst NORMALIZED_TYPE_TOKEN = {\n    beacon: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:beacon'),\n    cspReport: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:csp'),\n    csp_report: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:csp'),\n    cspviolationreport: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:cspviolationreport'),\n    document: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:document'),\n    eventsource: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:other'),\n    fedcm: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:script'),\n    fetch: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:xhr'),\n    font: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:font'),\n    image: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:image'),\n    imageset: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:image'),\n    json: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:script'),\n    mainFrame: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:document'),\n    main_frame: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:document'),\n    manifest: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:other'),\n    media: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:media'),\n    object: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:object'),\n    object_subrequest: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:object'),\n    other: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:other'),\n    ping: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:ping'),\n    prefetch: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:other'),\n    preflight: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:preflight'),\n    script: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:script'),\n    signedexchange: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:signedexchange'),\n    speculative: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:other'),\n    stylesheet: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:stylesheet'),\n    subFrame: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:subdocument'),\n    sub_frame: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:subdocument'),\n    texttrack: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:other'),\n    webSocket: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:websocket'),\n    web_manifest: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:other'),\n    websocket: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:websocket'),\n    xhr: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:xhr'),\n    xml_dtd: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:other'),\n    xmlhttprequest: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:xhr'),\n    xslt: (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.fastHash)('type:other'),\n};\nfunction hashHostnameBackward(hostname) {\n    let hash = _utils_js__WEBPACK_IMPORTED_MODULE_4__.HASH_SEED;\n    for (let j = hostname.length - 1; j >= 0; j -= 1) {\n        hash = (hash * _utils_js__WEBPACK_IMPORTED_MODULE_4__.HASH_INTERNAL_MULT) ^ hostname.charCodeAt(j);\n    }\n    return hash >>> 0;\n}\nfunction getHashesFromLabelsBackward(hostname, end, startOfDomain) {\n    _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_3__.TOKENS_BUFFER.reset();\n    let hash = _utils_js__WEBPACK_IMPORTED_MODULE_4__.HASH_SEED;\n    // Compute hash backward, label per label\n    for (let i = end - 1; i >= 0; i -= 1) {\n        const code = hostname.charCodeAt(i);\n        // Process label\n        if (code === 46 /* '.' */ && i < startOfDomain) {\n            _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_3__.TOKENS_BUFFER.push(hash >>> 0);\n        }\n        // Update hash\n        hash = (hash * _utils_js__WEBPACK_IMPORTED_MODULE_4__.HASH_INTERNAL_MULT) ^ code;\n    }\n    _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_3__.TOKENS_BUFFER.push(hash >>> 0);\n    return _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_3__.TOKENS_BUFFER.slice();\n}\n/**\n * Given a hostname and its domain, return the hostname without the public\n * suffix. We know that the domain, with one less label on the left, will be a\n * the public suffix; and from there we know which trailing portion of\n * `hostname` we should remove.\n */\nfunction getHostnameWithoutPublicSuffix(hostname, domain) {\n    let hostnameWithoutPublicSuffix = null;\n    const indexOfDot = domain.indexOf('.');\n    if (indexOfDot !== -1) {\n        const publicSuffix = domain.slice(indexOfDot + 1);\n        hostnameWithoutPublicSuffix = hostname.slice(0, -publicSuffix.length - 1);\n    }\n    return hostnameWithoutPublicSuffix;\n}\nfunction getEntityHashesFromLabelsBackward(hostname, domain) {\n    const hostnameWithoutPublicSuffix = getHostnameWithoutPublicSuffix(hostname, domain);\n    if (hostnameWithoutPublicSuffix !== null) {\n        return getHashesFromLabelsBackward(hostnameWithoutPublicSuffix, hostnameWithoutPublicSuffix.length, hostnameWithoutPublicSuffix.length);\n    }\n    return _data_view_js__WEBPACK_IMPORTED_MODULE_2__.EMPTY_UINT32_ARRAY;\n}\nfunction getHostnameHashesFromLabelsBackward(hostname, domain) {\n    return getHashesFromLabelsBackward(hostname, hostname.length, hostname.length - domain.length);\n}\nfunction isThirdParty(hostname, domain, sourceHostname, sourceDomain, type) {\n    if (type === 'main_frame' || type === 'mainFrame') {\n        return false;\n    }\n    else if (domain.length !== 0 && sourceDomain.length !== 0) {\n        return domain !== sourceDomain;\n    }\n    else if (domain.length !== 0 && sourceHostname.length !== 0) {\n        return domain !== sourceHostname;\n    }\n    else if (sourceDomain.length !== 0 && hostname.length !== 0) {\n        return hostname !== sourceDomain;\n    }\n    return false;\n}\nclass Request {\n    /**\n     * Create an instance of `Request` from raw request details.\n     */\n    static fromRawDetails({ requestId = '0', tabId = 0, url = '', hostname, domain, sourceUrl = '', sourceHostname, sourceDomain, type = 'main_frame', _originalRequestDetails, }) {\n        if (hostname === undefined || domain === undefined) {\n            const parsed = (0,tldts_experimental__WEBPACK_IMPORTED_MODULE_1__.parse)(url, TLDTS_OPTIONS);\n            hostname = hostname || parsed.hostname || '';\n            domain = domain || parsed.domain || '';\n        }\n        // Initialize source URL\n        if (sourceHostname === undefined || sourceDomain === undefined) {\n            const parsed = (0,tldts_experimental__WEBPACK_IMPORTED_MODULE_1__.parse)(sourceHostname || sourceDomain || sourceUrl, TLDTS_OPTIONS);\n            sourceHostname = sourceHostname || parsed.hostname || '';\n            sourceDomain = sourceDomain || parsed.domain || sourceHostname || '';\n        }\n        return new Request({\n            requestId,\n            tabId,\n            domain,\n            hostname,\n            url,\n            sourceDomain,\n            sourceHostname,\n            sourceUrl,\n            type,\n            _originalRequestDetails,\n        });\n    }\n    constructor({ requestId, tabId, type, domain, hostname, url, sourceDomain, sourceHostname, _originalRequestDetails, }) {\n        // Lazy attributes\n        this.tokens = undefined;\n        this.hostnameHashes = undefined;\n        this.entityHashes = undefined;\n        this._originalRequestDetails = _originalRequestDetails;\n        this.id = requestId;\n        this.tabId = tabId;\n        this.type = type;\n        this.url = url;\n        this.normalizedUrl = url.toLowerCase();\n        this.hostname = hostname;\n        this.domain = domain;\n        this.sourceHostnameHashes =\n            sourceHostname.length === 0\n                ? _data_view_js__WEBPACK_IMPORTED_MODULE_2__.EMPTY_UINT32_ARRAY\n                : getHostnameHashesFromLabelsBackward(sourceHostname, sourceDomain);\n        this.sourceEntityHashes =\n            sourceHostname.length === 0\n                ? _data_view_js__WEBPACK_IMPORTED_MODULE_2__.EMPTY_UINT32_ARRAY\n                : getEntityHashesFromLabelsBackward(sourceHostname, sourceDomain);\n        // Decide on partiness\n        this.isThirdParty = isThirdParty(hostname, domain, sourceHostname, sourceDomain, type);\n        this.isFirstParty = !this.isThirdParty;\n        // Check protocol\n        this.isSupported = true;\n        if (this.type === 'websocket' || this.url.startsWith('ws:') || this.url.startsWith('wss:')) {\n            this.isHttp = false;\n            this.isHttps = false;\n            this.type = 'websocket';\n            this.isSupported = true;\n        }\n        else if (this.url.startsWith('http:')) {\n            this.isHttp = true;\n            this.isHttps = false;\n        }\n        else if (this.url.startsWith('https:')) {\n            this.isHttps = true;\n            this.isHttp = false;\n        }\n        else if (this.url.startsWith('data:')) {\n            this.isHttp = false;\n            this.isHttps = false;\n            // Only keep prefix of URL\n            const indexOfComa = this.url.indexOf(',');\n            if (indexOfComa !== -1) {\n                this.url = this.url.slice(0, indexOfComa);\n            }\n        }\n        else {\n            this.isHttp = false;\n            this.isHttps = false;\n            this.isSupported = false;\n        }\n    }\n    getHostnameHashes() {\n        if (this.hostnameHashes === undefined) {\n            this.hostnameHashes =\n                this.hostname.length === 0\n                    ? _data_view_js__WEBPACK_IMPORTED_MODULE_2__.EMPTY_UINT32_ARRAY\n                    : getHostnameHashesFromLabelsBackward(this.hostname, this.domain);\n        }\n        return this.hostnameHashes;\n    }\n    getEntityHashes() {\n        if (this.entityHashes === undefined) {\n            this.entityHashes =\n                this.hostname.length === 0\n                    ? _data_view_js__WEBPACK_IMPORTED_MODULE_2__.EMPTY_UINT32_ARRAY\n                    : getEntityHashesFromLabelsBackward(this.hostname, this.domain);\n        }\n        return this.entityHashes;\n    }\n    getTokens() {\n        if (this.tokens === undefined) {\n            _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_3__.TOKENS_BUFFER.reset();\n            for (const hash of this.sourceHostnameHashes) {\n                _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_3__.TOKENS_BUFFER.push(hash);\n            }\n            // Add token corresponding to request type\n            _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_3__.TOKENS_BUFFER.push(NORMALIZED_TYPE_TOKEN[this.type]);\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.tokenizeNoSkipInPlace)(this.normalizedUrl, _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_3__.TOKENS_BUFFER);\n            this.tokens = _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_3__.TOKENS_BUFFER.slice();\n        }\n        return this.tokens;\n    }\n    isMainFrame() {\n        return this.type === 'main_frame' || this.type === 'mainFrame';\n    }\n    isSubFrame() {\n        return this.type === 'sub_frame' || this.type === 'subFrame';\n    }\n    /**\n     * Calling this method will attempt to guess the type of a request based on\n     * information found in `url` only. This can be useful to try and fine-tune\n     * the type of a Request when it is not otherwise available or if it was\n     * inferred as 'other'.\n     */\n    guessTypeOfRequest() {\n        const currentType = this.type;\n        this.type = (0,_remusao_guess_url_type__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.url);\n        if (currentType !== this.type) {\n            this.tokens = undefined;\n        }\n        return this.type;\n    }\n}\n/**\n * Kept for backward compatibility. The recommended way is to call\n * `Request.fromRawDetails` directly.\n */\nfunction makeRequest(details) {\n    return Request.fromRawDetails(details);\n}\n//# sourceMappingURL=request.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9yZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtRDtBQUNSO0FBQ1M7QUFDRDtBQUN5QztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLG1EQUFRO0FBQ3BCLGVBQWUsbURBQVE7QUFDdkIsZ0JBQWdCLG1EQUFRO0FBQ3hCLHdCQUF3QixtREFBUTtBQUNoQyxjQUFjLG1EQUFRO0FBQ3RCLGlCQUFpQixtREFBUTtBQUN6QixXQUFXLG1EQUFRO0FBQ25CLFdBQVcsbURBQVE7QUFDbkIsVUFBVSxtREFBUTtBQUNsQixXQUFXLG1EQUFRO0FBQ25CLGNBQWMsbURBQVE7QUFDdEIsVUFBVSxtREFBUTtBQUNsQixlQUFlLG1EQUFRO0FBQ3ZCLGdCQUFnQixtREFBUTtBQUN4QixjQUFjLG1EQUFRO0FBQ3RCLFdBQVcsbURBQVE7QUFDbkIsWUFBWSxtREFBUTtBQUNwQix1QkFBdUIsbURBQVE7QUFDL0IsV0FBVyxtREFBUTtBQUNuQixVQUFVLG1EQUFRO0FBQ2xCLGNBQWMsbURBQVE7QUFDdEIsZUFBZSxtREFBUTtBQUN2QixZQUFZLG1EQUFRO0FBQ3BCLG9CQUFvQixtREFBUTtBQUM1QixpQkFBaUIsbURBQVE7QUFDekIsZ0JBQWdCLG1EQUFRO0FBQ3hCLGNBQWMsbURBQVE7QUFDdEIsZUFBZSxtREFBUTtBQUN2QixlQUFlLG1EQUFRO0FBQ3ZCLGVBQWUsbURBQVE7QUFDdkIsa0JBQWtCLG1EQUFRO0FBQzFCLGVBQWUsbURBQVE7QUFDdkIsU0FBUyxtREFBUTtBQUNqQixhQUFhLG1EQUFRO0FBQ3JCLG9CQUFvQixtREFBUTtBQUM1QixVQUFVLG1EQUFRO0FBQ2xCO0FBQ087QUFDUCxlQUFlLGdEQUFTO0FBQ3hCLHNDQUFzQyxRQUFRO0FBQzlDLHVCQUF1Qix5REFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLDREQUFhO0FBQ2pCLGVBQWUsZ0RBQVM7QUFDeEI7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUFhO0FBQ3pCO0FBQ0E7QUFDQSx1QkFBdUIseURBQWtCO0FBQ3pDO0FBQ0EsSUFBSSw0REFBYTtBQUNqQixXQUFXLDREQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2REFBa0I7QUFDN0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxSkFBcUo7QUFDakw7QUFDQSwyQkFBMkIseURBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5REFBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLHVHQUF1RztBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZEQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkRBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2REFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2REFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0REFBYTtBQUN6QjtBQUNBLGdCQUFnQiw0REFBYTtBQUM3QjtBQUNBO0FBQ0EsWUFBWSw0REFBYTtBQUN6QixZQUFZLGdFQUFxQixxQkFBcUIsNERBQWE7QUFDbkUsMEJBQTBCLDREQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUVBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXIvZGlzdC9lc20vcmVxdWVzdC5qcz84ODdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQgR2hvc3RlcnkgR21iSC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cHM6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuaW1wb3J0IGd1ZXNzVXJsVHlwZSBmcm9tICdAcmVtdXNhby9ndWVzcy11cmwtdHlwZSc7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJ3RsZHRzLWV4cGVyaW1lbnRhbCc7XG5pbXBvcnQgeyBFTVBUWV9VSU5UMzJfQVJSQVkgfSBmcm9tICcuL2RhdGEtdmlldy5qcyc7XG5pbXBvcnQgeyBUT0tFTlNfQlVGRkVSIH0gZnJvbSAnLi90b2tlbnMtYnVmZmVyLmpzJztcbmltcG9ydCB7IGZhc3RIYXNoLCB0b2tlbml6ZU5vU2tpcEluUGxhY2UsIEhBU0hfU0VFRCwgSEFTSF9JTlRFUk5BTF9NVUxUIH0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCBUTERUU19PUFRJT05TID0ge1xuICAgIGV4dHJhY3RIb3N0bmFtZTogdHJ1ZSxcbiAgICBtaXhlZElucHV0czogZmFsc2UsXG4gICAgdmFsaWRhdGVIb3N0bmFtZTogZmFsc2UsXG59O1xuZXhwb3J0IGNvbnN0IE5PUk1BTElaRURfVFlQRV9UT0tFTiA9IHtcbiAgICBiZWFjb246IGZhc3RIYXNoKCd0eXBlOmJlYWNvbicpLFxuICAgIGNzcFJlcG9ydDogZmFzdEhhc2goJ3R5cGU6Y3NwJyksXG4gICAgY3NwX3JlcG9ydDogZmFzdEhhc2goJ3R5cGU6Y3NwJyksXG4gICAgY3NwdmlvbGF0aW9ucmVwb3J0OiBmYXN0SGFzaCgndHlwZTpjc3B2aW9sYXRpb25yZXBvcnQnKSxcbiAgICBkb2N1bWVudDogZmFzdEhhc2goJ3R5cGU6ZG9jdW1lbnQnKSxcbiAgICBldmVudHNvdXJjZTogZmFzdEhhc2goJ3R5cGU6b3RoZXInKSxcbiAgICBmZWRjbTogZmFzdEhhc2goJ3R5cGU6c2NyaXB0JyksXG4gICAgZmV0Y2g6IGZhc3RIYXNoKCd0eXBlOnhocicpLFxuICAgIGZvbnQ6IGZhc3RIYXNoKCd0eXBlOmZvbnQnKSxcbiAgICBpbWFnZTogZmFzdEhhc2goJ3R5cGU6aW1hZ2UnKSxcbiAgICBpbWFnZXNldDogZmFzdEhhc2goJ3R5cGU6aW1hZ2UnKSxcbiAgICBqc29uOiBmYXN0SGFzaCgndHlwZTpzY3JpcHQnKSxcbiAgICBtYWluRnJhbWU6IGZhc3RIYXNoKCd0eXBlOmRvY3VtZW50JyksXG4gICAgbWFpbl9mcmFtZTogZmFzdEhhc2goJ3R5cGU6ZG9jdW1lbnQnKSxcbiAgICBtYW5pZmVzdDogZmFzdEhhc2goJ3R5cGU6b3RoZXInKSxcbiAgICBtZWRpYTogZmFzdEhhc2goJ3R5cGU6bWVkaWEnKSxcbiAgICBvYmplY3Q6IGZhc3RIYXNoKCd0eXBlOm9iamVjdCcpLFxuICAgIG9iamVjdF9zdWJyZXF1ZXN0OiBmYXN0SGFzaCgndHlwZTpvYmplY3QnKSxcbiAgICBvdGhlcjogZmFzdEhhc2goJ3R5cGU6b3RoZXInKSxcbiAgICBwaW5nOiBmYXN0SGFzaCgndHlwZTpwaW5nJyksXG4gICAgcHJlZmV0Y2g6IGZhc3RIYXNoKCd0eXBlOm90aGVyJyksXG4gICAgcHJlZmxpZ2h0OiBmYXN0SGFzaCgndHlwZTpwcmVmbGlnaHQnKSxcbiAgICBzY3JpcHQ6IGZhc3RIYXNoKCd0eXBlOnNjcmlwdCcpLFxuICAgIHNpZ25lZGV4Y2hhbmdlOiBmYXN0SGFzaCgndHlwZTpzaWduZWRleGNoYW5nZScpLFxuICAgIHNwZWN1bGF0aXZlOiBmYXN0SGFzaCgndHlwZTpvdGhlcicpLFxuICAgIHN0eWxlc2hlZXQ6IGZhc3RIYXNoKCd0eXBlOnN0eWxlc2hlZXQnKSxcbiAgICBzdWJGcmFtZTogZmFzdEhhc2goJ3R5cGU6c3ViZG9jdW1lbnQnKSxcbiAgICBzdWJfZnJhbWU6IGZhc3RIYXNoKCd0eXBlOnN1YmRvY3VtZW50JyksXG4gICAgdGV4dHRyYWNrOiBmYXN0SGFzaCgndHlwZTpvdGhlcicpLFxuICAgIHdlYlNvY2tldDogZmFzdEhhc2goJ3R5cGU6d2Vic29ja2V0JyksXG4gICAgd2ViX21hbmlmZXN0OiBmYXN0SGFzaCgndHlwZTpvdGhlcicpLFxuICAgIHdlYnNvY2tldDogZmFzdEhhc2goJ3R5cGU6d2Vic29ja2V0JyksXG4gICAgeGhyOiBmYXN0SGFzaCgndHlwZTp4aHInKSxcbiAgICB4bWxfZHRkOiBmYXN0SGFzaCgndHlwZTpvdGhlcicpLFxuICAgIHhtbGh0dHByZXF1ZXN0OiBmYXN0SGFzaCgndHlwZTp4aHInKSxcbiAgICB4c2x0OiBmYXN0SGFzaCgndHlwZTpvdGhlcicpLFxufTtcbmV4cG9ydCBmdW5jdGlvbiBoYXNoSG9zdG5hbWVCYWNrd2FyZChob3N0bmFtZSkge1xuICAgIGxldCBoYXNoID0gSEFTSF9TRUVEO1xuICAgIGZvciAobGV0IGogPSBob3N0bmFtZS5sZW5ndGggLSAxOyBqID49IDA7IGogLT0gMSkge1xuICAgICAgICBoYXNoID0gKGhhc2ggKiBIQVNIX0lOVEVSTkFMX01VTFQpIF4gaG9zdG5hbWUuY2hhckNvZGVBdChqKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2ggPj4+IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0SGFzaGVzRnJvbUxhYmVsc0JhY2t3YXJkKGhvc3RuYW1lLCBlbmQsIHN0YXJ0T2ZEb21haW4pIHtcbiAgICBUT0tFTlNfQlVGRkVSLnJlc2V0KCk7XG4gICAgbGV0IGhhc2ggPSBIQVNIX1NFRUQ7XG4gICAgLy8gQ29tcHV0ZSBoYXNoIGJhY2t3YXJkLCBsYWJlbCBwZXIgbGFiZWxcbiAgICBmb3IgKGxldCBpID0gZW5kIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGhvc3RuYW1lLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIFByb2Nlc3MgbGFiZWxcbiAgICAgICAgaWYgKGNvZGUgPT09IDQ2IC8qICcuJyAqLyAmJiBpIDwgc3RhcnRPZkRvbWFpbikge1xuICAgICAgICAgICAgVE9LRU5TX0JVRkZFUi5wdXNoKGhhc2ggPj4+IDApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBoYXNoXG4gICAgICAgIGhhc2ggPSAoaGFzaCAqIEhBU0hfSU5URVJOQUxfTVVMVCkgXiBjb2RlO1xuICAgIH1cbiAgICBUT0tFTlNfQlVGRkVSLnB1c2goaGFzaCA+Pj4gMCk7XG4gICAgcmV0dXJuIFRPS0VOU19CVUZGRVIuc2xpY2UoKTtcbn1cbi8qKlxuICogR2l2ZW4gYSBob3N0bmFtZSBhbmQgaXRzIGRvbWFpbiwgcmV0dXJuIHRoZSBob3N0bmFtZSB3aXRob3V0IHRoZSBwdWJsaWNcbiAqIHN1ZmZpeC4gV2Uga25vdyB0aGF0IHRoZSBkb21haW4sIHdpdGggb25lIGxlc3MgbGFiZWwgb24gdGhlIGxlZnQsIHdpbGwgYmUgYVxuICogdGhlIHB1YmxpYyBzdWZmaXg7IGFuZCBmcm9tIHRoZXJlIHdlIGtub3cgd2hpY2ggdHJhaWxpbmcgcG9ydGlvbiBvZlxuICogYGhvc3RuYW1lYCB3ZSBzaG91bGQgcmVtb3ZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SG9zdG5hbWVXaXRob3V0UHVibGljU3VmZml4KGhvc3RuYW1lLCBkb21haW4pIHtcbiAgICBsZXQgaG9zdG5hbWVXaXRob3V0UHVibGljU3VmZml4ID0gbnVsbDtcbiAgICBjb25zdCBpbmRleE9mRG90ID0gZG9tYWluLmluZGV4T2YoJy4nKTtcbiAgICBpZiAoaW5kZXhPZkRvdCAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgcHVibGljU3VmZml4ID0gZG9tYWluLnNsaWNlKGluZGV4T2ZEb3QgKyAxKTtcbiAgICAgICAgaG9zdG5hbWVXaXRob3V0UHVibGljU3VmZml4ID0gaG9zdG5hbWUuc2xpY2UoMCwgLXB1YmxpY1N1ZmZpeC5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGhvc3RuYW1lV2l0aG91dFB1YmxpY1N1ZmZpeDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnRpdHlIYXNoZXNGcm9tTGFiZWxzQmFja3dhcmQoaG9zdG5hbWUsIGRvbWFpbikge1xuICAgIGNvbnN0IGhvc3RuYW1lV2l0aG91dFB1YmxpY1N1ZmZpeCA9IGdldEhvc3RuYW1lV2l0aG91dFB1YmxpY1N1ZmZpeChob3N0bmFtZSwgZG9tYWluKTtcbiAgICBpZiAoaG9zdG5hbWVXaXRob3V0UHVibGljU3VmZml4ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRIYXNoZXNGcm9tTGFiZWxzQmFja3dhcmQoaG9zdG5hbWVXaXRob3V0UHVibGljU3VmZml4LCBob3N0bmFtZVdpdGhvdXRQdWJsaWNTdWZmaXgubGVuZ3RoLCBob3N0bmFtZVdpdGhvdXRQdWJsaWNTdWZmaXgubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIEVNUFRZX1VJTlQzMl9BUlJBWTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3N0bmFtZUhhc2hlc0Zyb21MYWJlbHNCYWNrd2FyZChob3N0bmFtZSwgZG9tYWluKSB7XG4gICAgcmV0dXJuIGdldEhhc2hlc0Zyb21MYWJlbHNCYWNrd2FyZChob3N0bmFtZSwgaG9zdG5hbWUubGVuZ3RoLCBob3N0bmFtZS5sZW5ndGggLSBkb21haW4ubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGlzVGhpcmRQYXJ0eShob3N0bmFtZSwgZG9tYWluLCBzb3VyY2VIb3N0bmFtZSwgc291cmNlRG9tYWluLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICdtYWluX2ZyYW1lJyB8fCB0eXBlID09PSAnbWFpbkZyYW1lJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvbWFpbi5sZW5ndGggIT09IDAgJiYgc291cmNlRG9tYWluLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZG9tYWluICE9PSBzb3VyY2VEb21haW47XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvbWFpbi5sZW5ndGggIT09IDAgJiYgc291cmNlSG9zdG5hbWUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBkb21haW4gIT09IHNvdXJjZUhvc3RuYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmIChzb3VyY2VEb21haW4ubGVuZ3RoICE9PSAwICYmIGhvc3RuYW1lLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gaG9zdG5hbWUgIT09IHNvdXJjZURvbWFpbjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVxdWVzdCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGBSZXF1ZXN0YCBmcm9tIHJhdyByZXF1ZXN0IGRldGFpbHMuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21SYXdEZXRhaWxzKHsgcmVxdWVzdElkID0gJzAnLCB0YWJJZCA9IDAsIHVybCA9ICcnLCBob3N0bmFtZSwgZG9tYWluLCBzb3VyY2VVcmwgPSAnJywgc291cmNlSG9zdG5hbWUsIHNvdXJjZURvbWFpbiwgdHlwZSA9ICdtYWluX2ZyYW1lJywgX29yaWdpbmFsUmVxdWVzdERldGFpbHMsIH0pIHtcbiAgICAgICAgaWYgKGhvc3RuYW1lID09PSB1bmRlZmluZWQgfHwgZG9tYWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHVybCwgVExEVFNfT1BUSU9OUyk7XG4gICAgICAgICAgICBob3N0bmFtZSA9IGhvc3RuYW1lIHx8IHBhcnNlZC5ob3N0bmFtZSB8fCAnJztcbiAgICAgICAgICAgIGRvbWFpbiA9IGRvbWFpbiB8fCBwYXJzZWQuZG9tYWluIHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluaXRpYWxpemUgc291cmNlIFVSTFxuICAgICAgICBpZiAoc291cmNlSG9zdG5hbWUgPT09IHVuZGVmaW5lZCB8fCBzb3VyY2VEb21haW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2Uoc291cmNlSG9zdG5hbWUgfHwgc291cmNlRG9tYWluIHx8IHNvdXJjZVVybCwgVExEVFNfT1BUSU9OUyk7XG4gICAgICAgICAgICBzb3VyY2VIb3N0bmFtZSA9IHNvdXJjZUhvc3RuYW1lIHx8IHBhcnNlZC5ob3N0bmFtZSB8fCAnJztcbiAgICAgICAgICAgIHNvdXJjZURvbWFpbiA9IHNvdXJjZURvbWFpbiB8fCBwYXJzZWQuZG9tYWluIHx8IHNvdXJjZUhvc3RuYW1lIHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVxdWVzdCh7XG4gICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICB0YWJJZCxcbiAgICAgICAgICAgIGRvbWFpbixcbiAgICAgICAgICAgIGhvc3RuYW1lLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgc291cmNlRG9tYWluLFxuICAgICAgICAgICAgc291cmNlSG9zdG5hbWUsXG4gICAgICAgICAgICBzb3VyY2VVcmwsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgX29yaWdpbmFsUmVxdWVzdERldGFpbHMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IHJlcXVlc3RJZCwgdGFiSWQsIHR5cGUsIGRvbWFpbiwgaG9zdG5hbWUsIHVybCwgc291cmNlRG9tYWluLCBzb3VyY2VIb3N0bmFtZSwgX29yaWdpbmFsUmVxdWVzdERldGFpbHMsIH0pIHtcbiAgICAgICAgLy8gTGF6eSBhdHRyaWJ1dGVzXG4gICAgICAgIHRoaXMudG9rZW5zID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmhvc3RuYW1lSGFzaGVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVudGl0eUhhc2hlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxSZXF1ZXN0RGV0YWlscyA9IF9vcmlnaW5hbFJlcXVlc3REZXRhaWxzO1xuICAgICAgICB0aGlzLmlkID0gcmVxdWVzdElkO1xuICAgICAgICB0aGlzLnRhYklkID0gdGFiSWQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZWRVcmwgPSB1cmwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5ob3N0bmFtZSA9IGhvc3RuYW1lO1xuICAgICAgICB0aGlzLmRvbWFpbiA9IGRvbWFpbjtcbiAgICAgICAgdGhpcy5zb3VyY2VIb3N0bmFtZUhhc2hlcyA9XG4gICAgICAgICAgICBzb3VyY2VIb3N0bmFtZS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICA/IEVNUFRZX1VJTlQzMl9BUlJBWVxuICAgICAgICAgICAgICAgIDogZ2V0SG9zdG5hbWVIYXNoZXNGcm9tTGFiZWxzQmFja3dhcmQoc291cmNlSG9zdG5hbWUsIHNvdXJjZURvbWFpbik7XG4gICAgICAgIHRoaXMuc291cmNlRW50aXR5SGFzaGVzID1cbiAgICAgICAgICAgIHNvdXJjZUhvc3RuYW1lLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgICAgID8gRU1QVFlfVUlOVDMyX0FSUkFZXG4gICAgICAgICAgICAgICAgOiBnZXRFbnRpdHlIYXNoZXNGcm9tTGFiZWxzQmFja3dhcmQoc291cmNlSG9zdG5hbWUsIHNvdXJjZURvbWFpbik7XG4gICAgICAgIC8vIERlY2lkZSBvbiBwYXJ0aW5lc3NcbiAgICAgICAgdGhpcy5pc1RoaXJkUGFydHkgPSBpc1RoaXJkUGFydHkoaG9zdG5hbWUsIGRvbWFpbiwgc291cmNlSG9zdG5hbWUsIHNvdXJjZURvbWFpbiwgdHlwZSk7XG4gICAgICAgIHRoaXMuaXNGaXJzdFBhcnR5ID0gIXRoaXMuaXNUaGlyZFBhcnR5O1xuICAgICAgICAvLyBDaGVjayBwcm90b2NvbFxuICAgICAgICB0aGlzLmlzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3dlYnNvY2tldCcgfHwgdGhpcy51cmwuc3RhcnRzV2l0aCgnd3M6JykgfHwgdGhpcy51cmwuc3RhcnRzV2l0aCgnd3NzOicpKSB7XG4gICAgICAgICAgICB0aGlzLmlzSHR0cCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc0h0dHBzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAnd2Vic29ja2V0JztcbiAgICAgICAgICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudXJsLnN0YXJ0c1dpdGgoJ2h0dHA6JykpIHtcbiAgICAgICAgICAgIHRoaXMuaXNIdHRwID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaXNIdHRwcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOicpKSB7XG4gICAgICAgICAgICB0aGlzLmlzSHR0cHMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pc0h0dHAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnVybC5zdGFydHNXaXRoKCdkYXRhOicpKSB7XG4gICAgICAgICAgICB0aGlzLmlzSHR0cCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc0h0dHBzID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBPbmx5IGtlZXAgcHJlZml4IG9mIFVSTFxuICAgICAgICAgICAgY29uc3QgaW5kZXhPZkNvbWEgPSB0aGlzLnVybC5pbmRleE9mKCcsJyk7XG4gICAgICAgICAgICBpZiAoaW5kZXhPZkNvbWEgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cmwgPSB0aGlzLnVybC5zbGljZSgwLCBpbmRleE9mQ29tYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzSHR0cCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc0h0dHBzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0SG9zdG5hbWVIYXNoZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmhvc3RuYW1lSGFzaGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWVIYXNoZXMgPVxuICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgICAgID8gRU1QVFlfVUlOVDMyX0FSUkFZXG4gICAgICAgICAgICAgICAgICAgIDogZ2V0SG9zdG5hbWVIYXNoZXNGcm9tTGFiZWxzQmFja3dhcmQodGhpcy5ob3N0bmFtZSwgdGhpcy5kb21haW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhvc3RuYW1lSGFzaGVzO1xuICAgIH1cbiAgICBnZXRFbnRpdHlIYXNoZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmVudGl0eUhhc2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVudGl0eUhhc2hlcyA9XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBFTVBUWV9VSU5UMzJfQVJSQVlcbiAgICAgICAgICAgICAgICAgICAgOiBnZXRFbnRpdHlIYXNoZXNGcm9tTGFiZWxzQmFja3dhcmQodGhpcy5ob3N0bmFtZSwgdGhpcy5kb21haW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVudGl0eUhhc2hlcztcbiAgICB9XG4gICAgZ2V0VG9rZW5zKCkge1xuICAgICAgICBpZiAodGhpcy50b2tlbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgVE9LRU5TX0JVRkZFUi5yZXNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBoYXNoIG9mIHRoaXMuc291cmNlSG9zdG5hbWVIYXNoZXMpIHtcbiAgICAgICAgICAgICAgICBUT0tFTlNfQlVGRkVSLnB1c2goaGFzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdG9rZW4gY29ycmVzcG9uZGluZyB0byByZXF1ZXN0IHR5cGVcbiAgICAgICAgICAgIFRPS0VOU19CVUZGRVIucHVzaChOT1JNQUxJWkVEX1RZUEVfVE9LRU5bdGhpcy50eXBlXSk7XG4gICAgICAgICAgICB0b2tlbml6ZU5vU2tpcEluUGxhY2UodGhpcy5ub3JtYWxpemVkVXJsLCBUT0tFTlNfQlVGRkVSKTtcbiAgICAgICAgICAgIHRoaXMudG9rZW5zID0gVE9LRU5TX0JVRkZFUi5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VucztcbiAgICB9XG4gICAgaXNNYWluRnJhbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdtYWluX2ZyYW1lJyB8fCB0aGlzLnR5cGUgPT09ICdtYWluRnJhbWUnO1xuICAgIH1cbiAgICBpc1N1YkZyYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnc3ViX2ZyYW1lJyB8fCB0aGlzLnR5cGUgPT09ICdzdWJGcmFtZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxpbmcgdGhpcyBtZXRob2Qgd2lsbCBhdHRlbXB0IHRvIGd1ZXNzIHRoZSB0eXBlIG9mIGEgcmVxdWVzdCBiYXNlZCBvblxuICAgICAqIGluZm9ybWF0aW9uIGZvdW5kIGluIGB1cmxgIG9ubHkuIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byB0cnkgYW5kIGZpbmUtdHVuZVxuICAgICAqIHRoZSB0eXBlIG9mIGEgUmVxdWVzdCB3aGVuIGl0IGlzIG5vdCBvdGhlcndpc2UgYXZhaWxhYmxlIG9yIGlmIGl0IHdhc1xuICAgICAqIGluZmVycmVkIGFzICdvdGhlcicuXG4gICAgICovXG4gICAgZ3Vlc3NUeXBlT2ZSZXF1ZXN0KCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgdGhpcy50eXBlID0gZ3Vlc3NVcmxUeXBlKHRoaXMudXJsKTtcbiAgICAgICAgaWYgKGN1cnJlbnRUeXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5zID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfVxufVxuLyoqXG4gKiBLZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBUaGUgcmVjb21tZW5kZWQgd2F5IGlzIHRvIGNhbGxcbiAqIGBSZXF1ZXN0LmZyb21SYXdEZXRhaWxzYCBkaXJlY3RseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VSZXF1ZXN0KGRldGFpbHMpIHtcbiAgICByZXR1cm4gUmVxdWVzdC5mcm9tUmF3RGV0YWlscyhkZXRhaWxzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/resources.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/resources.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Resources)\n/* harmony export */ });\n/* harmony import */ var _remusao_small__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @remusao/small */ \"(rsc)/./node_modules/@remusao/small/dist/esm/index.js\");\n/* harmony import */ var _data_view_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data-view.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/data-view.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\n\n// Polyfill for `btoa`\nfunction btoaPolyfill(buffer) {\n    if (typeof btoa !== 'undefined') {\n        return btoa(buffer);\n    }\n    else if (typeof Buffer !== 'undefined') {\n        return Buffer.from(buffer).toString('base64');\n    }\n    return buffer;\n}\nfunction isResourceValid(resource) {\n    if (resource === null) {\n        return false;\n    }\n    if (typeof resource !== 'object') {\n        return false;\n    }\n    const { name, aliases, body, contentType } = resource;\n    if (typeof name !== 'string') {\n        return false;\n    }\n    if (!Array.isArray(aliases) || !aliases.every((alias) => typeof alias === 'string')) {\n        return false;\n    }\n    if (typeof body !== 'string') {\n        return false;\n    }\n    if (typeof contentType !== 'string') {\n        return false;\n    }\n    return true;\n}\nfunction isScriptletValid(scriptlet) {\n    if (scriptlet === null) {\n        return false;\n    }\n    if (typeof scriptlet !== 'object') {\n        return false;\n    }\n    const { name, aliases, body, dependencies, executionWorld, requiresTrust } = scriptlet;\n    if (typeof name !== 'string') {\n        return false;\n    }\n    if (!Array.isArray(aliases) || !aliases.every((alias) => typeof alias === 'string')) {\n        return false;\n    }\n    if (typeof body !== 'string') {\n        return false;\n    }\n    if (!Array.isArray(dependencies) ||\n        !dependencies.every((depencency) => typeof depencency === 'string')) {\n        return false;\n    }\n    if (typeof executionWorld !== 'undefined' &&\n        executionWorld !== 'MAIN' &&\n        executionWorld !== 'ISOLATED') {\n        return false;\n    }\n    if (typeof requiresTrust !== 'undefined' && typeof requiresTrust !== 'boolean') {\n        return false;\n    }\n    return true;\n}\n// TODO - support empty resource body\nconst assembleScript = (script, dependencies = []) => [\n    `if (typeof scriptletGlobals === 'undefined') { var scriptletGlobals = {}; }`,\n    ...dependencies,\n    `(${script})(...[\\`{{1}}\\`,\\`{{2}}\\`,\\`{{3}}\\`,\\`{{4}}\\`,\\`{{5}}\\`,\\`{{6}}\\`,\\`{{7}}\\`,\\`{{8}}\\`,\\`{{9}}\\`,\\`{{10}}\\`].filter((a,i) => a !== '{{'+(i+1)+'}}').map((a) => decodeURIComponent(a)))`,\n].join(';');\n/**\n * Abstraction on top of resources.txt used for redirections as well as script\n * injections. It contains logic to parse, serialize and get resources by name\n * for use in the engine.\n */\nclass Resources {\n    static deserialize(buffer) {\n        const checksum = buffer.getASCII();\n        // Deserialize `resources`\n        const resources = [];\n        const scriptlets = [];\n        for (let i = 0, numberOfResources = buffer.getUint16(); i < numberOfResources; i++) {\n            const name = buffer.getASCII();\n            const aliases = [];\n            for (let i = 0, numberOfAliases = buffer.getUint16(); i < numberOfAliases; i++) {\n                aliases.push(buffer.getASCII());\n            }\n            resources.push({\n                name,\n                aliases,\n                body: buffer.getUTF8(),\n                contentType: buffer.getASCII(),\n            });\n        }\n        for (let i = 0, numberOfScriptlets = buffer.getUint16(); i < numberOfScriptlets; i++) {\n            const name = buffer.getASCII();\n            const aliases = [];\n            for (let i = 0, numberOfAliases = buffer.getUint16(); i < numberOfAliases; i++) {\n                aliases.push(buffer.getASCII());\n            }\n            const body = buffer.getUTF8();\n            const hasExecutionWorld = buffer.getBool();\n            const isExecutionWorldIsolated = buffer.getBool();\n            const hasRequiresTrust = buffer.getBool();\n            const requiresTrust = buffer.getBool();\n            const dependencies = [];\n            for (let i = 0, numberOfDependencies = buffer.getUint16(); i < numberOfDependencies; i++) {\n                dependencies.push(buffer.getASCII());\n            }\n            const scriptlet = {\n                name,\n                aliases,\n                body,\n                dependencies,\n            };\n            if (hasExecutionWorld) {\n                scriptlet.executionWorld = isExecutionWorldIsolated === true ? 'ISOLATED' : 'MAIN';\n            }\n            if (hasRequiresTrust) {\n                scriptlet.requiresTrust = requiresTrust;\n            }\n            scriptlets.push(scriptlet);\n        }\n        return new Resources({\n            checksum,\n            scriptlets,\n            resources,\n        });\n    }\n    static parse(data, { checksum }) {\n        const distribution = JSON.parse(data);\n        if (distribution === null || typeof distribution !== 'object') {\n            throw new Error(`Cannot parse resources.json`);\n        }\n        const { scriptlets: rawScriplets, redirects: rawResources } = distribution;\n        const resources = [];\n        if (Array.isArray(rawResources)) {\n            for (const redirect of rawResources) {\n                if (isResourceValid(redirect)) {\n                    resources.push(redirect);\n                }\n                else {\n                    throw new Error(`Cannot parse redirect resource: ${JSON.stringify(redirect)}`);\n                }\n            }\n        }\n        const scriptlets = [];\n        if (Array.isArray(rawScriplets)) {\n            for (const scriptlet of rawScriplets) {\n                if (isScriptletValid(scriptlet)) {\n                    scriptlets.push(scriptlet);\n                }\n                else {\n                    throw new Error(`Cannot parse scriptlet: ${JSON.stringify(scriptlet)}`);\n                }\n            }\n        }\n        return new Resources({\n            checksum,\n            scriptlets,\n            resources,\n        });\n    }\n    static copy(sourceResources) {\n        const checksum = sourceResources.checksum;\n        const resources = [];\n        const scriptlets = [];\n        for (const resource of sourceResources.resources) {\n            resources.push(structuredClone(resource));\n        }\n        for (const scriptlet of sourceResources.scriptlets) {\n            scriptlets.push(structuredClone(scriptlet));\n        }\n        return new this({\n            checksum,\n            resources,\n            scriptlets,\n        });\n    }\n    constructor({ checksum = '', resources = [], scriptlets = [] } = {}) {\n        this.checksum = checksum;\n        this.resources = resources;\n        this.scriptlets = scriptlets;\n        this.scriptletsCache = new Map();\n        this.resourcesByName = new Map();\n        this.scriptletsByName = new Map();\n        this.updateAliases();\n    }\n    /**\n     * In case of scriptlet or resource update, you need to clear the populated caches and mappings by calling this method.\n     */\n    updateAliases() {\n        this.scriptletsCache.clear();\n        this.resourcesByName.clear();\n        this.scriptletsByName.clear();\n        for (const resource of this.resources) {\n            for (const name of [resource.name, ...resource.aliases]) {\n                if (this.resourcesByName.has(name)) {\n                    throw new Error(`Resource with a name or alias \"${name}\" already exists`);\n                }\n                this.resourcesByName.set(name, resource);\n            }\n        }\n        for (const scriptlet of this.scriptlets) {\n            for (const name of [scriptlet.name, ...scriptlet.aliases]) {\n                if (this.scriptletsByName.has(name)) {\n                    throw new Error(`Scriptlet with a name or alias \"${name}\" already exists`);\n                }\n                this.scriptletsByName.set(name, scriptlet);\n            }\n        }\n        // iterate the scriptlets again once all dependencies are present in scriptletsByName\n        for (const scriptlet of this.scriptlets) {\n            for (const dependencyName of scriptlet.dependencies) {\n                if (!this.scriptletsByName.has(dependencyName)) {\n                    throw new Error(`Scriptlet with a name or alias \"${scriptlet.name}\" has a missing depencency \"${dependencyName}\"`);\n                }\n            }\n        }\n    }\n    getResource(name) {\n        let resource = this.resourcesByName.get(name);\n        if (resource === undefined) {\n            const extensionIndex = name.lastIndexOf('.');\n            resource = (0,_remusao_small__WEBPACK_IMPORTED_MODULE_0__.getResourceForMime)(extensionIndex === -1 ? name : name.slice(extensionIndex));\n        }\n        const { contentType, body } = resource;\n        let dataUrl;\n        if (resource.contentType.indexOf(';') !== -1) {\n            dataUrl = `data:${contentType},${body}`;\n        }\n        else {\n            dataUrl = `data:${contentType};base64,${btoaPolyfill(body)}`;\n        }\n        return { filename: resource.name, body, contentType, dataUrl };\n    }\n    getScriptlet(name) {\n        const scriptlet = this.getRawScriptlet(name);\n        if (scriptlet === undefined) {\n            return this.getSurrogate(name);\n        }\n        let script = this.scriptletsCache.get(scriptlet.name);\n        if (script !== undefined) {\n            if (script.length === 0) {\n                return undefined;\n            }\n            return script;\n        }\n        const dependencies = this.getScriptletDependencies(scriptlet);\n        script = assembleScript(scriptlet.body, dependencies);\n        this.scriptletsCache.set(scriptlet.name, script);\n        return script;\n    }\n    getSurrogate(name) {\n        const resource = this.resourcesByName.get(name.endsWith('.js') ? name : `${name}.js`);\n        if (resource === undefined || resource.contentType !== 'application/javascript') {\n            return undefined;\n        }\n        return resource.body;\n    }\n    getScriptletCanonicalName(name) {\n        var _a;\n        return (_a = this.getRawScriptlet(name)) === null || _a === void 0 ? void 0 : _a.name;\n    }\n    getRawScriptlet(name) {\n        // Scriptlets with names ending with `.fn` are always treated as dependencies\n        if (name.endsWith('.fn')) {\n            return undefined;\n        }\n        return this.scriptletsByName.get(name.endsWith('.js') ? name : `${name}.js`);\n    }\n    getScriptletDependencies(scriptlet) {\n        const dependencies = new Map();\n        const queue = [...scriptlet.dependencies];\n        while (queue.length > 0) {\n            const dependencyName = queue.pop();\n            if (dependencies.has(dependencyName)) {\n                continue;\n            }\n            // dependecy is there as presence is enforced by the updateAliases\n            const dependency = this.scriptletsByName.get(dependencyName);\n            dependencies.set(dependencyName, dependency.body);\n            queue.push(...dependency.dependencies);\n        }\n        return Array.from(dependencies.values());\n    }\n    getSerializedSize() {\n        let estimatedSize = (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfASCII)(this.checksum); // resources.size\n        estimatedSize += 2 * (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfByte)();\n        for (const { name, aliases, body: content, contentType } of this.resources) {\n            estimatedSize += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfASCII)(name);\n            estimatedSize += aliases.reduce((state, alias) => state + (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfASCII)(alias), 2 * (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfByte)());\n            estimatedSize += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(content);\n            estimatedSize += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfASCII)(contentType);\n        }\n        estimatedSize += 2 * (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfByte)();\n        for (const { name, aliases, body: content, dependencies } of this.scriptlets) {\n            estimatedSize += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfASCII)(name);\n            estimatedSize += aliases.reduce((state, alias) => state + (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfASCII)(alias), 2 * (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfByte)());\n            estimatedSize += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfUTF8)(content);\n            estimatedSize += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfBool)(); // executionWorld present\n            estimatedSize += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfBool)(); // executionWorld\n            estimatedSize += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfBool)(); // requiresTrust present\n            estimatedSize += (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfBool)(); // requiresTrust\n            estimatedSize += dependencies.reduce((state, dependency) => state + (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfASCII)(dependency), 2 * (0,_data_view_js__WEBPACK_IMPORTED_MODULE_1__.sizeOfByte)());\n        }\n        return estimatedSize;\n    }\n    serialize(buffer) {\n        // Serialize `checksum`\n        buffer.pushASCII(this.checksum);\n        // Serialize `resources`\n        buffer.pushUint16(this.resources.length);\n        for (const { name, aliases, body: content, contentType } of this.resources) {\n            buffer.pushASCII(name);\n            buffer.pushUint16(aliases.length);\n            for (const alias of aliases) {\n                buffer.pushASCII(alias);\n            }\n            buffer.pushUTF8(content);\n            buffer.pushASCII(contentType);\n        }\n        // Serialize `scriptlets`\n        buffer.pushUint16(this.scriptlets.length);\n        for (const { name, aliases, body: content, dependencies, executionWorld, requiresTrust, } of this.scriptlets) {\n            buffer.pushASCII(name);\n            buffer.pushUint16(aliases.length);\n            for (const alias of aliases) {\n                buffer.pushASCII(alias);\n            }\n            buffer.pushUTF8(content);\n            buffer.pushBool(executionWorld !== undefined);\n            buffer.pushBool(executionWorld === 'ISOLATED');\n            buffer.pushBool(requiresTrust !== undefined);\n            buffer.pushBool(requiresTrust === true);\n            buffer.pushUint16(dependencies.length);\n            dependencies.forEach((dependency) => buffer.pushASCII(dependency));\n        }\n    }\n}\n//# sourceMappingURL=resources.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS9yZXNvdXJjZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0Q7QUFDNkI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUVBQW1FO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDRCQUE0QjtBQUNoRjtBQUNBLFFBQVEsT0FBTyxVQUFVLEdBQUcsT0FBTyxHQUFHLE9BQU8sR0FBRyxPQUFPLEdBQUcsT0FBTyxHQUFHLE9BQU8sR0FBRyxPQUFPLEdBQUcsT0FBTyxHQUFHLE9BQU8sR0FBRyxPQUFPLElBQUksNkJBQTZCLFdBQVc7QUFDL0osU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsdUJBQXVCO0FBQ3ZGO0FBQ0E7QUFDQSxrRUFBa0UscUJBQXFCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUVBQWlFLHdCQUF3QjtBQUN6RjtBQUNBO0FBQ0Esa0VBQWtFLHFCQUFxQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLDBCQUEwQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQW9EO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHlCQUF5QjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCwwQkFBMEI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLGlEQUFpRCxJQUFJO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxLQUFLO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLEtBQUs7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxlQUFlLDhCQUE4QixlQUFlO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0VBQWtCO0FBQ3pDO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBLDJDQUEyQztBQUMzQyw4QkFBOEIsWUFBWSxHQUFHLEtBQUs7QUFDbEQ7QUFDQTtBQUNBLDhCQUE4QixhQUFhLFNBQVMsbUJBQW1CO0FBQ3ZFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLEtBQUs7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxLQUFLO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMERBQVcsaUJBQWlCO0FBQ3hELDZCQUE2Qix5REFBVTtBQUN2QyxxQkFBcUIsNENBQTRDO0FBQ2pFLDZCQUE2QiwwREFBVztBQUN4QyxzRUFBc0UsMERBQVcsYUFBYSx5REFBVTtBQUN4Ryw2QkFBNkIseURBQVU7QUFDdkMsNkJBQTZCLDBEQUFXO0FBQ3hDO0FBQ0EsNkJBQTZCLHlEQUFVO0FBQ3ZDLHFCQUFxQiw2Q0FBNkM7QUFDbEUsNkJBQTZCLDBEQUFXO0FBQ3hDLHNFQUFzRSwwREFBVyxhQUFhLHlEQUFVO0FBQ3hHLDZCQUE2Qix5REFBVTtBQUN2Qyw2QkFBNkIseURBQVUsSUFBSTtBQUMzQyw2QkFBNkIseURBQVUsSUFBSTtBQUMzQyw2QkFBNkIseURBQVUsSUFBSTtBQUMzQyw2QkFBNkIseURBQVUsSUFBSTtBQUMzQyxnRkFBZ0YsMERBQVcsa0JBQWtCLHlEQUFVO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQTRDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZFQUE2RTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS9hZGJsb2NrZXIvZGlzdC9lc20vcmVzb3VyY2VzLmpzPzI1MjciXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCBHaG9zdGVyeSBHbWJILiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgeyBnZXRSZXNvdXJjZUZvck1pbWUgfSBmcm9tICdAcmVtdXNhby9zbWFsbCc7XG5pbXBvcnQgeyBzaXplT2ZVVEY4LCBzaXplT2ZBU0NJSSwgc2l6ZU9mQm9vbCwgc2l6ZU9mQnl0ZSB9IGZyb20gJy4vZGF0YS12aWV3LmpzJztcbi8vIFBvbHlmaWxsIGZvciBgYnRvYWBcbmZ1bmN0aW9uIGJ0b2FQb2x5ZmlsbChidWZmZXIpIHtcbiAgICBpZiAodHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBidG9hKGJ1ZmZlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShidWZmZXIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGlzUmVzb3VyY2VWYWxpZChyZXNvdXJjZSkge1xuICAgIGlmIChyZXNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBuYW1lLCBhbGlhc2VzLCBib2R5LCBjb250ZW50VHlwZSB9ID0gcmVzb3VyY2U7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShhbGlhc2VzKSB8fCAhYWxpYXNlcy5ldmVyeSgoYWxpYXMpID0+IHR5cGVvZiBhbGlhcyA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBib2R5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29udGVudFR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc1NjcmlwdGxldFZhbGlkKHNjcmlwdGxldCkge1xuICAgIGlmIChzY3JpcHRsZXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNjcmlwdGxldCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IG5hbWUsIGFsaWFzZXMsIGJvZHksIGRlcGVuZGVuY2llcywgZXhlY3V0aW9uV29ybGQsIHJlcXVpcmVzVHJ1c3QgfSA9IHNjcmlwdGxldDtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFsaWFzZXMpIHx8ICFhbGlhc2VzLmV2ZXJ5KChhbGlhcykgPT4gdHlwZW9mIGFsaWFzID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJvZHkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRlcGVuZGVuY2llcykgfHxcbiAgICAgICAgIWRlcGVuZGVuY2llcy5ldmVyeSgoZGVwZW5jZW5jeSkgPT4gdHlwZW9mIGRlcGVuY2VuY3kgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXhlY3V0aW9uV29ybGQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIGV4ZWN1dGlvbldvcmxkICE9PSAnTUFJTicgJiZcbiAgICAgICAgZXhlY3V0aW9uV29ybGQgIT09ICdJU09MQVRFRCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlcXVpcmVzVHJ1c3QgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiByZXF1aXJlc1RydXN0ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIFRPRE8gLSBzdXBwb3J0IGVtcHR5IHJlc291cmNlIGJvZHlcbmNvbnN0IGFzc2VtYmxlU2NyaXB0ID0gKHNjcmlwdCwgZGVwZW5kZW5jaWVzID0gW10pID0+IFtcbiAgICBgaWYgKHR5cGVvZiBzY3JpcHRsZXRHbG9iYWxzID09PSAndW5kZWZpbmVkJykgeyB2YXIgc2NyaXB0bGV0R2xvYmFscyA9IHt9OyB9YCxcbiAgICAuLi5kZXBlbmRlbmNpZXMsXG4gICAgYCgke3NjcmlwdH0pKC4uLltcXGB7ezF9fVxcYCxcXGB7ezJ9fVxcYCxcXGB7ezN9fVxcYCxcXGB7ezR9fVxcYCxcXGB7ezV9fVxcYCxcXGB7ezZ9fVxcYCxcXGB7ezd9fVxcYCxcXGB7ezh9fVxcYCxcXGB7ezl9fVxcYCxcXGB7ezEwfX1cXGBdLmZpbHRlcigoYSxpKSA9PiBhICE9PSAne3snKyhpKzEpKyd9fScpLm1hcCgoYSkgPT4gZGVjb2RlVVJJQ29tcG9uZW50KGEpKSlgLFxuXS5qb2luKCc7Jyk7XG4vKipcbiAqIEFic3RyYWN0aW9uIG9uIHRvcCBvZiByZXNvdXJjZXMudHh0IHVzZWQgZm9yIHJlZGlyZWN0aW9ucyBhcyB3ZWxsIGFzIHNjcmlwdFxuICogaW5qZWN0aW9ucy4gSXQgY29udGFpbnMgbG9naWMgdG8gcGFyc2UsIHNlcmlhbGl6ZSBhbmQgZ2V0IHJlc291cmNlcyBieSBuYW1lXG4gKiBmb3IgdXNlIGluIHRoZSBlbmdpbmUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc291cmNlcyB7XG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBjaGVja3N1bSA9IGJ1ZmZlci5nZXRBU0NJSSgpO1xuICAgICAgICAvLyBEZXNlcmlhbGl6ZSBgcmVzb3VyY2VzYFxuICAgICAgICBjb25zdCByZXNvdXJjZXMgPSBbXTtcbiAgICAgICAgY29uc3Qgc2NyaXB0bGV0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbnVtYmVyT2ZSZXNvdXJjZXMgPSBidWZmZXIuZ2V0VWludDE2KCk7IGkgPCBudW1iZXJPZlJlc291cmNlczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYnVmZmVyLmdldEFTQ0lJKCk7XG4gICAgICAgICAgICBjb25zdCBhbGlhc2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbnVtYmVyT2ZBbGlhc2VzID0gYnVmZmVyLmdldFVpbnQxNigpOyBpIDwgbnVtYmVyT2ZBbGlhc2VzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhbGlhc2VzLnB1c2goYnVmZmVyLmdldEFTQ0lJKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb3VyY2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgYWxpYXNlcyxcbiAgICAgICAgICAgICAgICBib2R5OiBidWZmZXIuZ2V0VVRGOCgpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBidWZmZXIuZ2V0QVNDSUkoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBudW1iZXJPZlNjcmlwdGxldHMgPSBidWZmZXIuZ2V0VWludDE2KCk7IGkgPCBudW1iZXJPZlNjcmlwdGxldHM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGJ1ZmZlci5nZXRBU0NJSSgpO1xuICAgICAgICAgICAgY29uc3QgYWxpYXNlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG51bWJlck9mQWxpYXNlcyA9IGJ1ZmZlci5nZXRVaW50MTYoKTsgaSA8IG51bWJlck9mQWxpYXNlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYWxpYXNlcy5wdXNoKGJ1ZmZlci5nZXRBU0NJSSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBidWZmZXIuZ2V0VVRGOCgpO1xuICAgICAgICAgICAgY29uc3QgaGFzRXhlY3V0aW9uV29ybGQgPSBidWZmZXIuZ2V0Qm9vbCgpO1xuICAgICAgICAgICAgY29uc3QgaXNFeGVjdXRpb25Xb3JsZElzb2xhdGVkID0gYnVmZmVyLmdldEJvb2woKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1JlcXVpcmVzVHJ1c3QgPSBidWZmZXIuZ2V0Qm9vbCgpO1xuICAgICAgICAgICAgY29uc3QgcmVxdWlyZXNUcnVzdCA9IGJ1ZmZlci5nZXRCb29sKCk7XG4gICAgICAgICAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBudW1iZXJPZkRlcGVuZGVuY2llcyA9IGJ1ZmZlci5nZXRVaW50MTYoKTsgaSA8IG51bWJlck9mRGVwZW5kZW5jaWVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChidWZmZXIuZ2V0QVNDSUkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzY3JpcHRsZXQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBhbGlhc2VzLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChoYXNFeGVjdXRpb25Xb3JsZCkge1xuICAgICAgICAgICAgICAgIHNjcmlwdGxldC5leGVjdXRpb25Xb3JsZCA9IGlzRXhlY3V0aW9uV29ybGRJc29sYXRlZCA9PT0gdHJ1ZSA/ICdJU09MQVRFRCcgOiAnTUFJTic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzUmVxdWlyZXNUcnVzdCkge1xuICAgICAgICAgICAgICAgIHNjcmlwdGxldC5yZXF1aXJlc1RydXN0ID0gcmVxdWlyZXNUcnVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjcmlwdGxldHMucHVzaChzY3JpcHRsZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2VzKHtcbiAgICAgICAgICAgIGNoZWNrc3VtLFxuICAgICAgICAgICAgc2NyaXB0bGV0cyxcbiAgICAgICAgICAgIHJlc291cmNlcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZShkYXRhLCB7IGNoZWNrc3VtIH0pIHtcbiAgICAgICAgY29uc3QgZGlzdHJpYnV0aW9uID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgaWYgKGRpc3RyaWJ1dGlvbiA9PT0gbnVsbCB8fCB0eXBlb2YgZGlzdHJpYnV0aW9uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgcmVzb3VyY2VzLmpzb25gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNjcmlwdGxldHM6IHJhd1NjcmlwbGV0cywgcmVkaXJlY3RzOiByYXdSZXNvdXJjZXMgfSA9IGRpc3RyaWJ1dGlvbjtcbiAgICAgICAgY29uc3QgcmVzb3VyY2VzID0gW107XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd1Jlc291cmNlcykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVkaXJlY3Qgb2YgcmF3UmVzb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzb3VyY2VWYWxpZChyZWRpcmVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzLnB1c2gocmVkaXJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgcmVkaXJlY3QgcmVzb3VyY2U6ICR7SlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3JpcHRsZXRzID0gW107XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd1NjcmlwbGV0cykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2NyaXB0bGV0IG9mIHJhd1NjcmlwbGV0cykge1xuICAgICAgICAgICAgICAgIGlmIChpc1NjcmlwdGxldFZhbGlkKHNjcmlwdGxldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0bGV0cy5wdXNoKHNjcmlwdGxldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSBzY3JpcHRsZXQ6ICR7SlNPTi5zdHJpbmdpZnkoc2NyaXB0bGV0KX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZXMoe1xuICAgICAgICAgICAgY2hlY2tzdW0sXG4gICAgICAgICAgICBzY3JpcHRsZXRzLFxuICAgICAgICAgICAgcmVzb3VyY2VzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGNvcHkoc291cmNlUmVzb3VyY2VzKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrc3VtID0gc291cmNlUmVzb3VyY2VzLmNoZWNrc3VtO1xuICAgICAgICBjb25zdCByZXNvdXJjZXMgPSBbXTtcbiAgICAgICAgY29uc3Qgc2NyaXB0bGV0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIHNvdXJjZVJlc291cmNlcy5yZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIHJlc291cmNlcy5wdXNoKHN0cnVjdHVyZWRDbG9uZShyZXNvdXJjZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc2NyaXB0bGV0IG9mIHNvdXJjZVJlc291cmNlcy5zY3JpcHRsZXRzKSB7XG4gICAgICAgICAgICBzY3JpcHRsZXRzLnB1c2goc3RydWN0dXJlZENsb25lKHNjcmlwdGxldCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh7XG4gICAgICAgICAgICBjaGVja3N1bSxcbiAgICAgICAgICAgIHJlc291cmNlcyxcbiAgICAgICAgICAgIHNjcmlwdGxldHMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IGNoZWNrc3VtID0gJycsIHJlc291cmNlcyA9IFtdLCBzY3JpcHRsZXRzID0gW10gfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuY2hlY2tzdW0gPSBjaGVja3N1bTtcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMgPSByZXNvdXJjZXM7XG4gICAgICAgIHRoaXMuc2NyaXB0bGV0cyA9IHNjcmlwdGxldHM7XG4gICAgICAgIHRoaXMuc2NyaXB0bGV0c0NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlc291cmNlc0J5TmFtZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zY3JpcHRsZXRzQnlOYW1lID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUFsaWFzZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBvZiBzY3JpcHRsZXQgb3IgcmVzb3VyY2UgdXBkYXRlLCB5b3UgbmVlZCB0byBjbGVhciB0aGUgcG9wdWxhdGVkIGNhY2hlcyBhbmQgbWFwcGluZ3MgYnkgY2FsbGluZyB0aGlzIG1ldGhvZC5cbiAgICAgKi9cbiAgICB1cGRhdGVBbGlhc2VzKCkge1xuICAgICAgICB0aGlzLnNjcmlwdGxldHNDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLnJlc291cmNlc0J5TmFtZS5jbGVhcigpO1xuICAgICAgICB0aGlzLnNjcmlwdGxldHNCeU5hbWUuY2xlYXIoKTtcbiAgICAgICAgZm9yIChjb25zdCByZXNvdXJjZSBvZiB0aGlzLnJlc291cmNlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIFtyZXNvdXJjZS5uYW1lLCAuLi5yZXNvdXJjZS5hbGlhc2VzXSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc291cmNlc0J5TmFtZS5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXNvdXJjZSB3aXRoIGEgbmFtZSBvciBhbGlhcyBcIiR7bmFtZX1cIiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlc0J5TmFtZS5zZXQobmFtZSwgcmVzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc2NyaXB0bGV0IG9mIHRoaXMuc2NyaXB0bGV0cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIFtzY3JpcHRsZXQubmFtZSwgLi4uc2NyaXB0bGV0LmFsaWFzZXNdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NyaXB0bGV0c0J5TmFtZS5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTY3JpcHRsZXQgd2l0aCBhIG5hbWUgb3IgYWxpYXMgXCIke25hbWV9XCIgYWxyZWFkeSBleGlzdHNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JpcHRsZXRzQnlOYW1lLnNldChuYW1lLCBzY3JpcHRsZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGl0ZXJhdGUgdGhlIHNjcmlwdGxldHMgYWdhaW4gb25jZSBhbGwgZGVwZW5kZW5jaWVzIGFyZSBwcmVzZW50IGluIHNjcmlwdGxldHNCeU5hbWVcbiAgICAgICAgZm9yIChjb25zdCBzY3JpcHRsZXQgb2YgdGhpcy5zY3JpcHRsZXRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3lOYW1lIG9mIHNjcmlwdGxldC5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2NyaXB0bGV0c0J5TmFtZS5oYXMoZGVwZW5kZW5jeU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2NyaXB0bGV0IHdpdGggYSBuYW1lIG9yIGFsaWFzIFwiJHtzY3JpcHRsZXQubmFtZX1cIiBoYXMgYSBtaXNzaW5nIGRlcGVuY2VuY3kgXCIke2RlcGVuZGVuY3lOYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJlc291cmNlKG5hbWUpIHtcbiAgICAgICAgbGV0IHJlc291cmNlID0gdGhpcy5yZXNvdXJjZXNCeU5hbWUuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAocmVzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uSW5kZXggPSBuYW1lLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICAgICAgICByZXNvdXJjZSA9IGdldFJlc291cmNlRm9yTWltZShleHRlbnNpb25JbmRleCA9PT0gLTEgPyBuYW1lIDogbmFtZS5zbGljZShleHRlbnNpb25JbmRleCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY29udGVudFR5cGUsIGJvZHkgfSA9IHJlc291cmNlO1xuICAgICAgICBsZXQgZGF0YVVybDtcbiAgICAgICAgaWYgKHJlc291cmNlLmNvbnRlbnRUeXBlLmluZGV4T2YoJzsnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGRhdGFVcmwgPSBgZGF0YToke2NvbnRlbnRUeXBlfSwke2JvZHl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFVcmwgPSBgZGF0YToke2NvbnRlbnRUeXBlfTtiYXNlNjQsJHtidG9hUG9seWZpbGwoYm9keSl9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmaWxlbmFtZTogcmVzb3VyY2UubmFtZSwgYm9keSwgY29udGVudFR5cGUsIGRhdGFVcmwgfTtcbiAgICB9XG4gICAgZ2V0U2NyaXB0bGV0KG5hbWUpIHtcbiAgICAgICAgY29uc3Qgc2NyaXB0bGV0ID0gdGhpcy5nZXRSYXdTY3JpcHRsZXQobmFtZSk7XG4gICAgICAgIGlmIChzY3JpcHRsZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3Vycm9nYXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY3JpcHQgPSB0aGlzLnNjcmlwdGxldHNDYWNoZS5nZXQoc2NyaXB0bGV0Lm5hbWUpO1xuICAgICAgICBpZiAoc2NyaXB0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChzY3JpcHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzY3JpcHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gdGhpcy5nZXRTY3JpcHRsZXREZXBlbmRlbmNpZXMoc2NyaXB0bGV0KTtcbiAgICAgICAgc2NyaXB0ID0gYXNzZW1ibGVTY3JpcHQoc2NyaXB0bGV0LmJvZHksIGRlcGVuZGVuY2llcyk7XG4gICAgICAgIHRoaXMuc2NyaXB0bGV0c0NhY2hlLnNldChzY3JpcHRsZXQubmFtZSwgc2NyaXB0KTtcbiAgICAgICAgcmV0dXJuIHNjcmlwdDtcbiAgICB9XG4gICAgZ2V0U3Vycm9nYXRlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSB0aGlzLnJlc291cmNlc0J5TmFtZS5nZXQobmFtZS5lbmRzV2l0aCgnLmpzJykgPyBuYW1lIDogYCR7bmFtZX0uanNgKTtcbiAgICAgICAgaWYgKHJlc291cmNlID09PSB1bmRlZmluZWQgfHwgcmVzb3VyY2UuY29udGVudFR5cGUgIT09ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb3VyY2UuYm9keTtcbiAgICB9XG4gICAgZ2V0U2NyaXB0bGV0Q2Fub25pY2FsTmFtZShuYW1lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuZ2V0UmF3U2NyaXB0bGV0KG5hbWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZTtcbiAgICB9XG4gICAgZ2V0UmF3U2NyaXB0bGV0KG5hbWUpIHtcbiAgICAgICAgLy8gU2NyaXB0bGV0cyB3aXRoIG5hbWVzIGVuZGluZyB3aXRoIGAuZm5gIGFyZSBhbHdheXMgdHJlYXRlZCBhcyBkZXBlbmRlbmNpZXNcbiAgICAgICAgaWYgKG5hbWUuZW5kc1dpdGgoJy5mbicpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmlwdGxldHNCeU5hbWUuZ2V0KG5hbWUuZW5kc1dpdGgoJy5qcycpID8gbmFtZSA6IGAke25hbWV9LmpzYCk7XG4gICAgfVxuICAgIGdldFNjcmlwdGxldERlcGVuZGVuY2llcyhzY3JpcHRsZXQpIHtcbiAgICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBxdWV1ZSA9IFsuLi5zY3JpcHRsZXQuZGVwZW5kZW5jaWVzXTtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGRlcGVuZGVuY3lOYW1lID0gcXVldWUucG9wKCk7XG4gICAgICAgICAgICBpZiAoZGVwZW5kZW5jaWVzLmhhcyhkZXBlbmRlbmN5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlcGVuZGVjeSBpcyB0aGVyZSBhcyBwcmVzZW5jZSBpcyBlbmZvcmNlZCBieSB0aGUgdXBkYXRlQWxpYXNlc1xuICAgICAgICAgICAgY29uc3QgZGVwZW5kZW5jeSA9IHRoaXMuc2NyaXB0bGV0c0J5TmFtZS5nZXQoZGVwZW5kZW5jeU5hbWUpO1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnNldChkZXBlbmRlbmN5TmFtZSwgZGVwZW5kZW5jeS5ib2R5KTtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goLi4uZGVwZW5kZW5jeS5kZXBlbmRlbmNpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGRlcGVuZGVuY2llcy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIGdldFNlcmlhbGl6ZWRTaXplKCkge1xuICAgICAgICBsZXQgZXN0aW1hdGVkU2l6ZSA9IHNpemVPZkFTQ0lJKHRoaXMuY2hlY2tzdW0pOyAvLyByZXNvdXJjZXMuc2l6ZVxuICAgICAgICBlc3RpbWF0ZWRTaXplICs9IDIgKiBzaXplT2ZCeXRlKCk7XG4gICAgICAgIGZvciAoY29uc3QgeyBuYW1lLCBhbGlhc2VzLCBib2R5OiBjb250ZW50LCBjb250ZW50VHlwZSB9IG9mIHRoaXMucmVzb3VyY2VzKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZWRTaXplICs9IHNpemVPZkFTQ0lJKG5hbWUpO1xuICAgICAgICAgICAgZXN0aW1hdGVkU2l6ZSArPSBhbGlhc2VzLnJlZHVjZSgoc3RhdGUsIGFsaWFzKSA9PiBzdGF0ZSArIHNpemVPZkFTQ0lJKGFsaWFzKSwgMiAqIHNpemVPZkJ5dGUoKSk7XG4gICAgICAgICAgICBlc3RpbWF0ZWRTaXplICs9IHNpemVPZlVURjgoY29udGVudCk7XG4gICAgICAgICAgICBlc3RpbWF0ZWRTaXplICs9IHNpemVPZkFTQ0lJKGNvbnRlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlc3RpbWF0ZWRTaXplICs9IDIgKiBzaXplT2ZCeXRlKCk7XG4gICAgICAgIGZvciAoY29uc3QgeyBuYW1lLCBhbGlhc2VzLCBib2R5OiBjb250ZW50LCBkZXBlbmRlbmNpZXMgfSBvZiB0aGlzLnNjcmlwdGxldHMpIHtcbiAgICAgICAgICAgIGVzdGltYXRlZFNpemUgKz0gc2l6ZU9mQVNDSUkobmFtZSk7XG4gICAgICAgICAgICBlc3RpbWF0ZWRTaXplICs9IGFsaWFzZXMucmVkdWNlKChzdGF0ZSwgYWxpYXMpID0+IHN0YXRlICsgc2l6ZU9mQVNDSUkoYWxpYXMpLCAyICogc2l6ZU9mQnl0ZSgpKTtcbiAgICAgICAgICAgIGVzdGltYXRlZFNpemUgKz0gc2l6ZU9mVVRGOChjb250ZW50KTtcbiAgICAgICAgICAgIGVzdGltYXRlZFNpemUgKz0gc2l6ZU9mQm9vbCgpOyAvLyBleGVjdXRpb25Xb3JsZCBwcmVzZW50XG4gICAgICAgICAgICBlc3RpbWF0ZWRTaXplICs9IHNpemVPZkJvb2woKTsgLy8gZXhlY3V0aW9uV29ybGRcbiAgICAgICAgICAgIGVzdGltYXRlZFNpemUgKz0gc2l6ZU9mQm9vbCgpOyAvLyByZXF1aXJlc1RydXN0IHByZXNlbnRcbiAgICAgICAgICAgIGVzdGltYXRlZFNpemUgKz0gc2l6ZU9mQm9vbCgpOyAvLyByZXF1aXJlc1RydXN0XG4gICAgICAgICAgICBlc3RpbWF0ZWRTaXplICs9IGRlcGVuZGVuY2llcy5yZWR1Y2UoKHN0YXRlLCBkZXBlbmRlbmN5KSA9PiBzdGF0ZSArIHNpemVPZkFTQ0lJKGRlcGVuZGVuY3kpLCAyICogc2l6ZU9mQnl0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXN0aW1hdGVkU2l6ZTtcbiAgICB9XG4gICAgc2VyaWFsaXplKGJ1ZmZlcikge1xuICAgICAgICAvLyBTZXJpYWxpemUgYGNoZWNrc3VtYFxuICAgICAgICBidWZmZXIucHVzaEFTQ0lJKHRoaXMuY2hlY2tzdW0pO1xuICAgICAgICAvLyBTZXJpYWxpemUgYHJlc291cmNlc2BcbiAgICAgICAgYnVmZmVyLnB1c2hVaW50MTYodGhpcy5yZXNvdXJjZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChjb25zdCB7IG5hbWUsIGFsaWFzZXMsIGJvZHk6IGNvbnRlbnQsIGNvbnRlbnRUeXBlIH0gb2YgdGhpcy5yZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoQVNDSUkobmFtZSk7XG4gICAgICAgICAgICBidWZmZXIucHVzaFVpbnQxNihhbGlhc2VzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGFsaWFzZXMpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaEFTQ0lJKGFsaWFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoVVRGOChjb250ZW50KTtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoQVNDSUkoY29udGVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlcmlhbGl6ZSBgc2NyaXB0bGV0c2BcbiAgICAgICAgYnVmZmVyLnB1c2hVaW50MTYodGhpcy5zY3JpcHRsZXRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAoY29uc3QgeyBuYW1lLCBhbGlhc2VzLCBib2R5OiBjb250ZW50LCBkZXBlbmRlbmNpZXMsIGV4ZWN1dGlvbldvcmxkLCByZXF1aXJlc1RydXN0LCB9IG9mIHRoaXMuc2NyaXB0bGV0cykge1xuICAgICAgICAgICAgYnVmZmVyLnB1c2hBU0NJSShuYW1lKTtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoVWludDE2KGFsaWFzZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWxpYXMgb2YgYWxpYXNlcykge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoQVNDSUkoYWxpYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnB1c2hVVEY4KGNvbnRlbnQpO1xuICAgICAgICAgICAgYnVmZmVyLnB1c2hCb29sKGV4ZWN1dGlvbldvcmxkICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgYnVmZmVyLnB1c2hCb29sKGV4ZWN1dGlvbldvcmxkID09PSAnSVNPTEFURUQnKTtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoQm9vbChyZXF1aXJlc1RydXN0ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgYnVmZmVyLnB1c2hCb29sKHJlcXVpcmVzVHJ1c3QgPT09IHRydWUpO1xuICAgICAgICAgICAgYnVmZmVyLnB1c2hVaW50MTYoZGVwZW5kZW5jaWVzLmxlbmd0aCk7XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMuZm9yRWFjaCgoZGVwZW5kZW5jeSkgPT4gYnVmZmVyLnB1c2hBU0NJSShkZXBlbmRlbmN5KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvdXJjZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/resources.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/tokens-buffer.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/tokens-buffer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TOKENS_BUFFER: () => (/* binding */ TOKENS_BUFFER),\n/* harmony export */   TokensBuffer: () => (/* binding */ TokensBuffer)\n/* harmony export */ });\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/**\n * Thin abstraction around a Uint32Array which allows to push tokens\n * whithout caring for the offset. It is used as a way to avoid multiple\n * allocations while calling tokenization (mostly beneficitial for\n * `NetworkFilter.getTokens()`).\n */\nclass TokensBuffer {\n    constructor(size) {\n        this.pos = 0;\n        this.buffer = new Uint32Array(size);\n    }\n    reset() {\n        this.pos = 0;\n    }\n    slice() {\n        return this.buffer.slice(0, this.pos);\n    }\n    push(token) {\n        this.buffer[this.pos++] = token;\n    }\n    empty() {\n        return this.pos === 0;\n    }\n    full() {\n        return this.pos === this.buffer.length;\n    }\n    remaining() {\n        return this.buffer.length - this.pos;\n    }\n}\nconst TOKENS_BUFFER = new TokensBuffer(1024);\n//# sourceMappingURL=tokens-buffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS90b2tlbnMtYnVmZmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS90b2tlbnMtYnVmZmVyLmpzP2ZhZjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCBHaG9zdGVyeSBHbWJILiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG4vKipcbiAqIFRoaW4gYWJzdHJhY3Rpb24gYXJvdW5kIGEgVWludDMyQXJyYXkgd2hpY2ggYWxsb3dzIHRvIHB1c2ggdG9rZW5zXG4gKiB3aGl0aG91dCBjYXJpbmcgZm9yIHRoZSBvZmZzZXQuIEl0IGlzIHVzZWQgYXMgYSB3YXkgdG8gYXZvaWQgbXVsdGlwbGVcbiAqIGFsbG9jYXRpb25zIHdoaWxlIGNhbGxpbmcgdG9rZW5pemF0aW9uIChtb3N0bHkgYmVuZWZpY2l0aWFsIGZvclxuICogYE5ldHdvcmtGaWx0ZXIuZ2V0VG9rZW5zKClgKS5cbiAqL1xuZXhwb3J0IGNsYXNzIFRva2Vuc0J1ZmZlciB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KHNpemUpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICBzbGljZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNsaWNlKDAsIHRoaXMucG9zKTtcbiAgICB9XG4gICAgcHVzaCh0b2tlbikge1xuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvcysrXSA9IHRva2VuO1xuICAgIH1cbiAgICBlbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID09PSAwO1xuICAgIH1cbiAgICBmdWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgPT09IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgcmVtYWluaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RoIC0gdGhpcy5wb3M7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IFRPS0VOU19CVUZGRVIgPSBuZXcgVG9rZW5zQnVmZmVyKDEwMjQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9rZW5zLWJ1ZmZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/tokens-buffer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/adblocker/dist/esm/utils.js":
/*!************************************************************!*\
  !*** ./node_modules/@ghostery/adblocker/dist/esm/utils.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HASH_INTERNAL_MULT: () => (/* binding */ HASH_INTERNAL_MULT),\n/* harmony export */   HASH_SEED: () => (/* binding */ HASH_SEED),\n/* harmony export */   binLookup: () => (/* binding */ binLookup),\n/* harmony export */   binSearch: () => (/* binding */ binSearch),\n/* harmony export */   bitCount: () => (/* binding */ bitCount),\n/* harmony export */   clearBit: () => (/* binding */ clearBit),\n/* harmony export */   fastHash: () => (/* binding */ fastHash),\n/* harmony export */   fastHashBetween: () => (/* binding */ fastHashBetween),\n/* harmony export */   findLastIndexOfUnescapedCharacter: () => (/* binding */ findLastIndexOfUnescapedCharacter),\n/* harmony export */   getBit: () => (/* binding */ getBit),\n/* harmony export */   hasUnicode: () => (/* binding */ hasUnicode),\n/* harmony export */   hashStrings: () => (/* binding */ hashStrings),\n/* harmony export */   isAlpha: () => (/* binding */ isAlpha),\n/* harmony export */   isDigit: () => (/* binding */ isDigit),\n/* harmony export */   setBit: () => (/* binding */ setBit),\n/* harmony export */   tokenize: () => (/* binding */ tokenize),\n/* harmony export */   tokenizeInPlace: () => (/* binding */ tokenizeInPlace),\n/* harmony export */   tokenizeNoSkip: () => (/* binding */ tokenizeNoSkip),\n/* harmony export */   tokenizeNoSkipInPlace: () => (/* binding */ tokenizeNoSkipInPlace),\n/* harmony export */   tokenizeRegexInPlace: () => (/* binding */ tokenizeRegexInPlace),\n/* harmony export */   tokenizeWithWildcards: () => (/* binding */ tokenizeWithWildcards),\n/* harmony export */   tokenizeWithWildcardsInPlace: () => (/* binding */ tokenizeWithWildcardsInPlace)\n/* harmony export */ });\n/* harmony import */ var _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tokens-buffer.js */ \"(rsc)/./node_modules/@ghostery/adblocker/dist/esm/tokens-buffer.js\");\n/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n\nconst HASH_INTERNAL_MULT = 37;\nconst HASH_SEED = 5011;\n/***************************************************************************\n *  Bitwise helpers\n * ************************************************************************* */\n// From: https://stackoverflow.com/a/43122214/1185079\nfunction bitCount(n) {\n    n = n - ((n >> 1) & 0x55555555);\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n    return (((n + (n >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n}\nfunction getBit(n, mask) {\n    return !!(n & mask);\n}\nfunction setBit(n, mask) {\n    return (n | mask) >>> 0;\n}\nfunction clearBit(n, mask) {\n    return (n & ~mask) >>> 0;\n}\nfunction fastHashBetween(str, begin, end) {\n    let hash = HASH_SEED;\n    for (let i = begin; i < end; i += 1) {\n        hash = (hash * HASH_INTERNAL_MULT) ^ str.charCodeAt(i);\n    }\n    return hash >>> 0;\n}\nfunction fastHash(str) {\n    if (typeof str !== 'string') {\n        return HASH_SEED;\n    }\n    if (str.length === 0) {\n        return HASH_SEED;\n    }\n    return fastHashBetween(str, 0, str.length);\n}\nfunction hashStrings(strings) {\n    const result = new Uint32Array(strings.length);\n    let index = 0;\n    for (const str of strings) {\n        result[index++] = fastHash(str);\n    }\n    return result;\n}\nfunction isDigit(ch) {\n    // 48 == '0'\n    // 57 == '9'\n    return ch >= 48 && ch <= 57;\n}\nfunction isAlpha(ch) {\n    // 65 == 'A'\n    // 90 == 'Z'\n    // 97 == 'a'\n    // 122 === 'z'\n    return (ch >= 97 && ch <= 122) || (ch >= 65 && ch <= 90);\n}\nfunction isAlphaExtended(ch) {\n    // 192 -> 450\n    //                                                 \n    //                                                 \n    //                                                 \n    //                                                 \n    //                                                 \n    //                                                 \n    //                                                 \n    //                                                 \n    //                                                 \n    //                                                 \n    //                 \n    return ch >= 192 && ch <= 450;\n}\nfunction isCyrillic(ch) {\n    // 1024 -> 1279\n    //                                      \n    //                                      \n    //                                    \n    //                                          \n    //                                     \n    //                                      \n    //                           \n    return ch >= 1024 && ch <= 1279;\n}\nfunction isAllowedCode(ch) {\n    return (isAlpha(ch) || isDigit(ch) || ch === 37 /* '%' */ || isAlphaExtended(ch) || isCyrillic(ch));\n}\nfunction tokenizeWithWildcardsInPlace(pattern, skipFirstToken, skipLastToken, buffer) {\n    // TODO maybe better to check if buffer is full?\n    // Otherwise we are under-using the space.\n    const len = Math.min(pattern.length, buffer.remaining() * 2);\n    let inside = false;\n    let precedingCh = 0;\n    let start = 0;\n    let hash = HASH_SEED;\n    for (let i = 0; i < len; i += 1) {\n        const ch = pattern.charCodeAt(i);\n        if (isAllowedCode(ch) === true) {\n            if (inside === false) {\n                hash = HASH_SEED;\n                inside = true;\n                start = i;\n            }\n            hash = (hash * HASH_INTERNAL_MULT) ^ ch;\n        }\n        else {\n            if (inside === true) {\n                inside = false;\n                if (i - start > 1 && // Ignore tokens of 1 character\n                    ch !== 42 && // Ignore tokens followed by a '*'\n                    precedingCh !== 42 && // Ignore tokens preceeded by a '*'\n                    (skipFirstToken === false || start !== 0)) {\n                    buffer.push(hash >>> 0);\n                }\n            }\n            precedingCh = ch;\n        }\n    }\n    if (skipLastToken === false &&\n        inside === true &&\n        precedingCh !== 42 && // Ignore tokens preceeded by a '*'\n        pattern.length - start > 1 && // Ignore tokens of 1 character\n        buffer.full() === false) {\n        buffer.push(hash >>> 0);\n    }\n}\nfunction tokenizeInPlace(pattern, skipFirstToken, skipLastToken, buffer) {\n    const len = Math.min(pattern.length, buffer.remaining() * 2);\n    let inside = false;\n    let start = 0;\n    let hash = HASH_SEED;\n    for (let i = 0; i < len; i += 1) {\n        const ch = pattern.charCodeAt(i);\n        if (isAllowedCode(ch) === true) {\n            if (inside === false) {\n                hash = HASH_SEED;\n                inside = true;\n                start = i;\n            }\n            hash = (hash * HASH_INTERNAL_MULT) ^ ch;\n        }\n        else if (inside === true) {\n            inside = false;\n            if (i - start > 1 && // Ignore tokens of 1 character\n                (skipFirstToken === false || start !== 0)) {\n                buffer.push(hash >>> 0);\n            }\n        }\n    }\n    if (inside === true &&\n        skipLastToken === false &&\n        pattern.length - start > 1 && // Ignore tokens of 1 character\n        buffer.full() === false) {\n        buffer.push(hash >>> 0);\n    }\n}\nfunction tokenizeNoSkipInPlace(pattern, buffer) {\n    const len = Math.min(pattern.length, buffer.remaining() * 2);\n    let inside = false;\n    let start = 0;\n    let hash = HASH_SEED;\n    for (let i = 0; i < len; i += 1) {\n        const ch = pattern.charCodeAt(i);\n        if (isAllowedCode(ch) === true) {\n            if (inside === false) {\n                hash = HASH_SEED;\n                inside = true;\n                start = i;\n            }\n            hash = (hash * HASH_INTERNAL_MULT) ^ ch;\n        }\n        else if (inside === true) {\n            inside = false;\n            if (i - start > 1) {\n                buffer.push(hash >>> 0);\n            }\n        }\n    }\n    if (inside === true && pattern.length - start > 1 && buffer.full() === false) {\n        buffer.push(hash >>> 0);\n    }\n}\nfunction tokenizeNoSkip(pattern) {\n    _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_0__.TOKENS_BUFFER.reset();\n    tokenizeNoSkipInPlace(pattern, _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_0__.TOKENS_BUFFER);\n    return _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_0__.TOKENS_BUFFER.slice();\n}\nfunction tokenizeWithWildcards(pattern, skipFirstToken, skipLastToken) {\n    _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_0__.TOKENS_BUFFER.reset();\n    tokenizeWithWildcardsInPlace(pattern, skipFirstToken, skipLastToken, _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_0__.TOKENS_BUFFER);\n    return _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_0__.TOKENS_BUFFER.slice();\n}\nfunction tokenize(pattern, skipFirstToken, skipLastToken) {\n    _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_0__.TOKENS_BUFFER.reset();\n    tokenizeInPlace(pattern, skipFirstToken, skipLastToken, _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_0__.TOKENS_BUFFER);\n    return _tokens_buffer_js__WEBPACK_IMPORTED_MODULE_0__.TOKENS_BUFFER.slice();\n}\nfunction tokenizeRegexInPlace(selector, tokens) {\n    let end = selector.length - 1;\n    let begin = 1;\n    let prev = 0;\n    // Try to find the longest safe *prefix* that we can tokenize\n    for (; begin < end; begin += 1) {\n        const code = selector.charCodeAt(begin);\n        // If we encounter '|' before any other opening bracket, then it's not safe\n        // to tokenize this filter (e.g.: 'foo|bar'). Instead we abort tokenization\n        // to be safe.\n        if (code === 124 /* '|' */) {\n            return;\n        }\n        if (code === 40 /* '(' */ ||\n            code === 42 /* '*' */ ||\n            code === 43 /* '+' */ ||\n            code === 63 /* '?' */ ||\n            code === 91 /* '[' */ ||\n            code === 123 /* '{' */ ||\n            (code === 46 /* '.' */ && prev !== 92) /* '\\' */ ||\n            (code === 92 /* '\\' */ && isAlpha(selector.charCodeAt(begin + 1)))) {\n            break;\n        }\n        prev = code;\n    }\n    // Try to find the longest safe *suffix* that we can tokenize\n    prev = 0;\n    for (; end >= begin; end -= 1) {\n        const code = selector.charCodeAt(end);\n        // If we encounter '|' before any other opening bracket, then it's not safe\n        // to tokenize this filter (e.g.: 'foo|bar'). Instead we abort tokenization\n        // to be safe.\n        if (code === 124 /* '|' */) {\n            return;\n        }\n        if (code === 41 /* ')' */ ||\n            code === 42 /* '*' */ ||\n            code === 43 /* '+' */ ||\n            code === 63 /* '?' */ ||\n            code === 93 /* ']' */ ||\n            code === 125 /* '}' */ ||\n            (code === 46 /* '.' */ && selector.charCodeAt(end - 1) !== 92) /* '\\' */ ||\n            (code === 92 /* '\\' */ && isAlpha(prev))) {\n            break;\n        }\n        prev = code;\n    }\n    if (end < begin) {\n        // Full selector is safe\n        const skipFirstToken = selector.charCodeAt(1) !== 94; /* '^' */\n        const skipLastToken = selector.charCodeAt(selector.length - 1) !== 36; /* '$' */\n        tokenizeInPlace(selector.slice(1, selector.length - 1), skipFirstToken, skipLastToken, tokens);\n    }\n    else {\n        // Tokenize prefix\n        if (begin > 1) {\n            tokenizeInPlace(selector.slice(1, begin), selector.charCodeAt(1) !== 94 /* '^' */, // skipFirstToken\n            true, tokens);\n        }\n        // Tokenize suffix\n        if (end < selector.length - 1) {\n            tokenizeInPlace(selector.slice(end + 1, selector.length - 1), true, selector.charCodeAt(selector.length - 1) !== 94 /* '^' */, // skipLastToken\n            tokens);\n        }\n    }\n}\nfunction binSearch(arr, elt) {\n    if (arr.length === 0) {\n        return -1;\n    }\n    let low = 0;\n    let high = arr.length - 1;\n    while (low <= high) {\n        const mid = (low + high) >>> 1;\n        const midVal = arr[mid];\n        if (midVal < elt) {\n            low = mid + 1;\n        }\n        else if (midVal > elt) {\n            high = mid - 1;\n        }\n        else {\n            return mid;\n        }\n    }\n    return -1;\n}\nfunction binLookup(arr, elt) {\n    return binSearch(arr, elt) !== -1;\n}\n// eslint-disable-next-line no-control-regex\nconst hasUnicodeRe = /[^\\u0000-\\u00ff]/;\nfunction hasUnicode(str) {\n    return hasUnicodeRe.test(str);\n}\n/**\n * Finds the last index of an unescaped character in the given string.\n * This function tries to find the match from the backward.\n * When this function sees an escaping character, it will jump to the next index.\n */\nfunction findLastIndexOfUnescapedCharacter(text, character) {\n    let lastIndex = text.lastIndexOf(character);\n    if (lastIndex === -1) {\n        return -1;\n    }\n    while (lastIndex > 0 && text.charCodeAt(lastIndex - 1) === 92 /* '\\\\' */) {\n        lastIndex = text.lastIndexOf(character, lastIndex - 1);\n    }\n    return lastIndex;\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L2FkYmxvY2tlci9kaXN0L2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ21EO0FBQzVDO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksNERBQWE7QUFDakIsbUNBQW1DLDREQUFhO0FBQ2hELFdBQVcsNERBQWE7QUFDeEI7QUFDTztBQUNQLElBQUksNERBQWE7QUFDakIseUVBQXlFLDREQUFhO0FBQ3RGLFdBQVcsNERBQWE7QUFDeEI7QUFDTztBQUNQLElBQUksNERBQWE7QUFDakIsNERBQTRELDREQUFhO0FBQ3pFLFdBQVcsNERBQWE7QUFDeEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvYWRibG9ja2VyL2Rpc3QvZXNtL3V0aWxzLmpzPzIzNjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCBHaG9zdGVyeSBHbWJILiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwczovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICovXG5pbXBvcnQgeyBUT0tFTlNfQlVGRkVSIH0gZnJvbSAnLi90b2tlbnMtYnVmZmVyLmpzJztcbmV4cG9ydCBjb25zdCBIQVNIX0lOVEVSTkFMX01VTFQgPSAzNztcbmV4cG9ydCBjb25zdCBIQVNIX1NFRUQgPSA1MDExO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIEJpdHdpc2UgaGVscGVyc1xuICogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gRnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQzMTIyMjE0LzExODUwNzlcbmV4cG9ydCBmdW5jdGlvbiBiaXRDb3VudChuKSB7XG4gICAgbiA9IG4gLSAoKG4gPj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgICBuID0gKG4gJiAweDMzMzMzMzMzKSArICgobiA+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICAgIHJldHVybiAoKChuICsgKG4gPj4gNCkpICYgMHhmMGYwZjBmKSAqIDB4MTAxMDEwMSkgPj4gMjQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Qml0KG4sIG1hc2spIHtcbiAgICByZXR1cm4gISEobiAmIG1hc2spO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldEJpdChuLCBtYXNrKSB7XG4gICAgcmV0dXJuIChuIHwgbWFzaykgPj4+IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gY2xlYXJCaXQobiwgbWFzaykge1xuICAgIHJldHVybiAobiAmIH5tYXNrKSA+Pj4gMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmYXN0SGFzaEJldHdlZW4oc3RyLCBiZWdpbiwgZW5kKSB7XG4gICAgbGV0IGhhc2ggPSBIQVNIX1NFRUQ7XG4gICAgZm9yIChsZXQgaSA9IGJlZ2luOyBpIDwgZW5kOyBpICs9IDEpIHtcbiAgICAgICAgaGFzaCA9IChoYXNoICogSEFTSF9JTlRFUk5BTF9NVUxUKSBeIHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmYXN0SGFzaChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIEhBU0hfU0VFRDtcbiAgICB9XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEhBU0hfU0VFRDtcbiAgICB9XG4gICAgcmV0dXJuIGZhc3RIYXNoQmV0d2VlbihzdHIsIDAsIHN0ci5sZW5ndGgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hTdHJpbmdzKHN0cmluZ3MpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDMyQXJyYXkoc3RyaW5ncy5sZW5ndGgpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBzdHIgb2Ygc3RyaW5ncykge1xuICAgICAgICByZXN1bHRbaW5kZXgrK10gPSBmYXN0SGFzaChzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRGlnaXQoY2gpIHtcbiAgICAvLyA0OCA9PSAnMCdcbiAgICAvLyA1NyA9PSAnOSdcbiAgICByZXR1cm4gY2ggPj0gNDggJiYgY2ggPD0gNTc7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBbHBoYShjaCkge1xuICAgIC8vIDY1ID09ICdBJ1xuICAgIC8vIDkwID09ICdaJ1xuICAgIC8vIDk3ID09ICdhJ1xuICAgIC8vIDEyMiA9PT0gJ3onXG4gICAgcmV0dXJuIChjaCA+PSA5NyAmJiBjaCA8PSAxMjIpIHx8IChjaCA+PSA2NSAmJiBjaCA8PSA5MCk7XG59XG5mdW5jdGlvbiBpc0FscGhhRXh0ZW5kZWQoY2gpIHtcbiAgICAvLyAxOTIgLT4gNDUwXG4gICAgLy8gw4AgIMOBICDDgiAgw4MgIMOEICDDhSAgw4YgIMOHICDDiCAgw4kgIMOKICDDiyAgw4wgIMONICDDjiAgw48gIMOQICDDkSAgw5IgIMOTICDDlCAgw5UgIMOWICDDlyAgw5hcbiAgICAvLyDDmSAgw5ogIMObICDDnCAgw50gIMOeICDDnyAgw6AgIMOhICDDoiAgw6MgIMOkICDDpSAgw6YgIMOnICDDqCAgw6kgIMOqICDDqyAgw6wgIMOtICDDriAgw68gIMOwICDDsVxuICAgIC8vIMOyICDDsyAgw7QgIMO1ICDDtiAgw7cgIMO4ICDDuSAgw7ogIMO7ICDDvCAgw70gIMO+ICDDvyAgxIAgIMSBICDEgiAgxIMgIMSEICDEhSAgxIYgIMSHICDEiCAgxIkgIMSKXG4gICAgLy8gxIsgIMSMICDEjSAgxI4gIMSPICDEkCAgxJEgIMSSICDEkyAgxJQgIMSVICDEliAgxJcgIMSYICDEmSAgxJogIMSbICDEnCAgxJ0gIMSeICDEnyAgxKAgIMShICDEoiAgxKNcbiAgICAvLyDEpCAgxKUgIMSmICDEpyAgxKggIMSpICDEqiAgxKsgIMSsICDErSAgxK4gIMSvICDEsCAgxLEgIMSyICDEsyAgxLQgIMS1ICDEtiAgxLcgIMS4ICDEuSAgxLogIMS7ICDEvFxuICAgIC8vIMS9ICDEviAgxL8gIMWAICDFgSAgxYIgIMWDICDFhCAgxYUgIMWGICDFhyAgxYggIMWJICDFiiAgxYsgIMWMICDFjSAgxY4gIMWPICDFkCAgxZEgIMWSICDFkyAgxZQgIMWVXG4gICAgLy8gxZYgIMWXICDFmCAgxZkgIMWaICDFmyAgxZwgIMWdICDFniAgxZ8gIMWgICDFoSAgxaIgIMWjICDFpCAgxaUgIMWmICDFpyAgxaggIMWpICDFqiAgxasgIMWsICDFrSAgxa5cbiAgICAvLyDFryAgxbAgIMWxICDFsiAgxbMgIMW0ICDFtSAgxbYgIMW3ICDFuCAgxbkgIMW6ICDFuyAgxbwgIMW9ICDFviAgxb8gIMaAICDGgSAgxoIgIMaDICDGhCAgxoUgIMaGICDGh1xuICAgIC8vIMaIICDGiSAgxoogIMaLICDGjCAgxo0gIMaOICDGjyAgxpAgIMaRICDGkiAgxpMgIMaUICDGlSAgxpYgIMaXICDGmCAgxpkgIMaaICDGmyAgxpwgIMadICDGniAgxp8gIMagXG4gICAgLy8gxqEgIMaiICDGoyAgxqQgIMalICDGpiAgxqcgIMaoICDGqSAgxqogIMarICDGrCAgxq0gIMauICDGryAgxrAgIMaxICDGsiAgxrMgIMa0ICDGtSAgxrYgIMa3ICDGuCAgxrlcbiAgICAvLyDGuiAgxrsgIMa8ICDGvSAgxr4gIMa/ICDHgCAgx4EgIMeCXG4gICAgcmV0dXJuIGNoID49IDE5MiAmJiBjaCA8PSA0NTA7XG59XG5mdW5jdGlvbiBpc0N5cmlsbGljKGNoKSB7XG4gICAgLy8gMTAyNCAtPiAxMjc5XG4gICAgLy8g0IAg0IEg0IIg0IMg0IQg0IUg0IYg0Icg0Igg0Ikg0Iog0Isg0Iwg0I0g0I4g0I8g0JAg0JEg0JIg0JMg0JQg0JUg0JYg0Jcg0Jgg0Jkg0Jog0Jsg0Jwg0J0g0J4g0J8g0KAg0KEg0KIg0KMg0KQg0KVcbiAgICAvLyDQpiDQpyDQqCDQqSDQqiDQqyDQrCDQrSDQriDQryDQsCDQsSDQsiDQsyDQtCDQtSDQtiDQtyDQuCDQuSDQuiDQuyDQvCDQvSDQviDQvyDRgCDRgSDRgiDRgyDRhCDRhSDRhiDRhyDRiCDRiSDRiiDRi1xuICAgIC8vINGMINGNINGOINGPINGQINGRINGSINGTINGUINGVINGWINGXINGYINGZINGaINGbINGcINGdINGeINGfINGgINGhINGiINGjINGkINGlINGmINGnINGoINGpINGqINGrINGsINGtINGuINGvXG4gICAgLy8g0bAg0bEg0bIg0bMg0bQg0bUg0bYg0bcg0bgg0bkg0bog0bsg0bwg0b0g0b4g0b8g0oAg0oEg0oIg0oMg0oQg0oUg0oYg0ocg0ogg0okg0oog0osg0owg0o0g0o4g0o8g0pAg0pEg0pIg0pMg0pQg0pUg0pYg0pcg0pgg0plcbiAgICAvLyDSmiDSmyDSnCDSnSDSniDSnyDSoCDSoSDSoiDSoyDSpCDSpSDSpiDSpyDSqCDSqSDSqiDSqyDSrCDSrSDSriDSryDSsCDSsSDSsiDSsyDStCDStSDStiDStyDSuCDSuSDSuiDSuyDSvCDSvSDSvlxuICAgIC8vINK/INOAINOBINOCINODINOEINOFINOGINOHINOIINOJINOKINOLINOMINONINOOINOPINOQINORINOSINOTINOUINOVINOWINOXINOYINOZINOaINObINOcINOdINOeINOfINOgINOhINOiINOjINOkXG4gICAgLy8g06Ug06Yg06cg06gg06kg06og06sg06wg060g064g068g07Ag07Eg07Ig07Mg07Qg07Ug07Yg07cg07gg07kg07og07sg07wg070g074g079cbiAgICByZXR1cm4gY2ggPj0gMTAyNCAmJiBjaCA8PSAxMjc5O1xufVxuZnVuY3Rpb24gaXNBbGxvd2VkQ29kZShjaCkge1xuICAgIHJldHVybiAoaXNBbHBoYShjaCkgfHwgaXNEaWdpdChjaCkgfHwgY2ggPT09IDM3IC8qICclJyAqLyB8fCBpc0FscGhhRXh0ZW5kZWQoY2gpIHx8IGlzQ3lyaWxsaWMoY2gpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b2tlbml6ZVdpdGhXaWxkY2FyZHNJblBsYWNlKHBhdHRlcm4sIHNraXBGaXJzdFRva2VuLCBza2lwTGFzdFRva2VuLCBidWZmZXIpIHtcbiAgICAvLyBUT0RPIG1heWJlIGJldHRlciB0byBjaGVjayBpZiBidWZmZXIgaXMgZnVsbD9cbiAgICAvLyBPdGhlcndpc2Ugd2UgYXJlIHVuZGVyLXVzaW5nIHRoZSBzcGFjZS5cbiAgICBjb25zdCBsZW4gPSBNYXRoLm1pbihwYXR0ZXJuLmxlbmd0aCwgYnVmZmVyLnJlbWFpbmluZygpICogMik7XG4gICAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICAgIGxldCBwcmVjZWRpbmdDaCA9IDA7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgaGFzaCA9IEhBU0hfU0VFRDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNoID0gcGF0dGVybi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoaXNBbGxvd2VkQ29kZShjaCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChpbnNpZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaGFzaCA9IEhBU0hfU0VFRDtcbiAgICAgICAgICAgICAgICBpbnNpZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhc2ggPSAoaGFzaCAqIEhBU0hfSU5URVJOQUxfTVVMVCkgXiBjaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbnNpZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaSAtIHN0YXJ0ID4gMSAmJiAvLyBJZ25vcmUgdG9rZW5zIG9mIDEgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgIGNoICE9PSA0MiAmJiAvLyBJZ25vcmUgdG9rZW5zIGZvbGxvd2VkIGJ5IGEgJyonXG4gICAgICAgICAgICAgICAgICAgIHByZWNlZGluZ0NoICE9PSA0MiAmJiAvLyBJZ25vcmUgdG9rZW5zIHByZWNlZWRlZCBieSBhICcqJ1xuICAgICAgICAgICAgICAgICAgICAoc2tpcEZpcnN0VG9rZW4gPT09IGZhbHNlIHx8IHN0YXJ0ICE9PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaChoYXNoID4+PiAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVjZWRpbmdDaCA9IGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChza2lwTGFzdFRva2VuID09PSBmYWxzZSAmJlxuICAgICAgICBpbnNpZGUgPT09IHRydWUgJiZcbiAgICAgICAgcHJlY2VkaW5nQ2ggIT09IDQyICYmIC8vIElnbm9yZSB0b2tlbnMgcHJlY2VlZGVkIGJ5IGEgJyonXG4gICAgICAgIHBhdHRlcm4ubGVuZ3RoIC0gc3RhcnQgPiAxICYmIC8vIElnbm9yZSB0b2tlbnMgb2YgMSBjaGFyYWN0ZXJcbiAgICAgICAgYnVmZmVyLmZ1bGwoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goaGFzaCA+Pj4gMCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHRva2VuaXplSW5QbGFjZShwYXR0ZXJuLCBza2lwRmlyc3RUb2tlbiwgc2tpcExhc3RUb2tlbiwgYnVmZmVyKSB7XG4gICAgY29uc3QgbGVuID0gTWF0aC5taW4ocGF0dGVybi5sZW5ndGgsIGJ1ZmZlci5yZW1haW5pbmcoKSAqIDIpO1xuICAgIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBoYXNoID0gSEFTSF9TRUVEO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY2ggPSBwYXR0ZXJuLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChpc0FsbG93ZWRDb2RlKGNoKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGluc2lkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBoYXNoID0gSEFTSF9TRUVEO1xuICAgICAgICAgICAgICAgIGluc2lkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFzaCA9IChoYXNoICogSEFTSF9JTlRFUk5BTF9NVUxUKSBeIGNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluc2lkZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaW5zaWRlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaSAtIHN0YXJ0ID4gMSAmJiAvLyBJZ25vcmUgdG9rZW5zIG9mIDEgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgKHNraXBGaXJzdFRva2VuID09PSBmYWxzZSB8fCBzdGFydCAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaChoYXNoID4+PiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5zaWRlID09PSB0cnVlICYmXG4gICAgICAgIHNraXBMYXN0VG9rZW4gPT09IGZhbHNlICYmXG4gICAgICAgIHBhdHRlcm4ubGVuZ3RoIC0gc3RhcnQgPiAxICYmIC8vIElnbm9yZSB0b2tlbnMgb2YgMSBjaGFyYWN0ZXJcbiAgICAgICAgYnVmZmVyLmZ1bGwoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goaGFzaCA+Pj4gMCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHRva2VuaXplTm9Ta2lwSW5QbGFjZShwYXR0ZXJuLCBidWZmZXIpIHtcbiAgICBjb25zdCBsZW4gPSBNYXRoLm1pbihwYXR0ZXJuLmxlbmd0aCwgYnVmZmVyLnJlbWFpbmluZygpICogMik7XG4gICAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGhhc2ggPSBIQVNIX1NFRUQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBjaCA9IHBhdHRlcm4uY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGlzQWxsb3dlZENvZGUoY2gpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoaW5zaWRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGhhc2ggPSBIQVNIX1NFRUQ7XG4gICAgICAgICAgICAgICAgaW5zaWRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXNoID0gKGhhc2ggKiBIQVNIX0lOVEVSTkFMX01VTFQpIF4gY2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5zaWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpIC0gc3RhcnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnB1c2goaGFzaCA+Pj4gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluc2lkZSA9PT0gdHJ1ZSAmJiBwYXR0ZXJuLmxlbmd0aCAtIHN0YXJ0ID4gMSAmJiBidWZmZXIuZnVsbCgpID09PSBmYWxzZSkge1xuICAgICAgICBidWZmZXIucHVzaChoYXNoID4+PiAwKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdG9rZW5pemVOb1NraXAocGF0dGVybikge1xuICAgIFRPS0VOU19CVUZGRVIucmVzZXQoKTtcbiAgICB0b2tlbml6ZU5vU2tpcEluUGxhY2UocGF0dGVybiwgVE9LRU5TX0JVRkZFUik7XG4gICAgcmV0dXJuIFRPS0VOU19CVUZGRVIuc2xpY2UoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b2tlbml6ZVdpdGhXaWxkY2FyZHMocGF0dGVybiwgc2tpcEZpcnN0VG9rZW4sIHNraXBMYXN0VG9rZW4pIHtcbiAgICBUT0tFTlNfQlVGRkVSLnJlc2V0KCk7XG4gICAgdG9rZW5pemVXaXRoV2lsZGNhcmRzSW5QbGFjZShwYXR0ZXJuLCBza2lwRmlyc3RUb2tlbiwgc2tpcExhc3RUb2tlbiwgVE9LRU5TX0JVRkZFUik7XG4gICAgcmV0dXJuIFRPS0VOU19CVUZGRVIuc2xpY2UoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b2tlbml6ZShwYXR0ZXJuLCBza2lwRmlyc3RUb2tlbiwgc2tpcExhc3RUb2tlbikge1xuICAgIFRPS0VOU19CVUZGRVIucmVzZXQoKTtcbiAgICB0b2tlbml6ZUluUGxhY2UocGF0dGVybiwgc2tpcEZpcnN0VG9rZW4sIHNraXBMYXN0VG9rZW4sIFRPS0VOU19CVUZGRVIpO1xuICAgIHJldHVybiBUT0tFTlNfQlVGRkVSLnNsaWNlKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9rZW5pemVSZWdleEluUGxhY2Uoc2VsZWN0b3IsIHRva2Vucykge1xuICAgIGxldCBlbmQgPSBzZWxlY3Rvci5sZW5ndGggLSAxO1xuICAgIGxldCBiZWdpbiA9IDE7XG4gICAgbGV0IHByZXYgPSAwO1xuICAgIC8vIFRyeSB0byBmaW5kIHRoZSBsb25nZXN0IHNhZmUgKnByZWZpeCogdGhhdCB3ZSBjYW4gdG9rZW5pemVcbiAgICBmb3IgKDsgYmVnaW4gPCBlbmQ7IGJlZ2luICs9IDEpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHNlbGVjdG9yLmNoYXJDb2RlQXQoYmVnaW4pO1xuICAgICAgICAvLyBJZiB3ZSBlbmNvdW50ZXIgJ3wnIGJlZm9yZSBhbnkgb3RoZXIgb3BlbmluZyBicmFja2V0LCB0aGVuIGl0J3Mgbm90IHNhZmVcbiAgICAgICAgLy8gdG8gdG9rZW5pemUgdGhpcyBmaWx0ZXIgKGUuZy46ICdmb298YmFyJykuIEluc3RlYWQgd2UgYWJvcnQgdG9rZW5pemF0aW9uXG4gICAgICAgIC8vIHRvIGJlIHNhZmUuXG4gICAgICAgIGlmIChjb2RlID09PSAxMjQgLyogJ3wnICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGUgPT09IDQwIC8qICcoJyAqLyB8fFxuICAgICAgICAgICAgY29kZSA9PT0gNDIgLyogJyonICovIHx8XG4gICAgICAgICAgICBjb2RlID09PSA0MyAvKiAnKycgKi8gfHxcbiAgICAgICAgICAgIGNvZGUgPT09IDYzIC8qICc/JyAqLyB8fFxuICAgICAgICAgICAgY29kZSA9PT0gOTEgLyogJ1snICovIHx8XG4gICAgICAgICAgICBjb2RlID09PSAxMjMgLyogJ3snICovIHx8XG4gICAgICAgICAgICAoY29kZSA9PT0gNDYgLyogJy4nICovICYmIHByZXYgIT09IDkyKSAvKiAnXFwnICovIHx8XG4gICAgICAgICAgICAoY29kZSA9PT0gOTIgLyogJ1xcJyAqLyAmJiBpc0FscGhhKHNlbGVjdG9yLmNoYXJDb2RlQXQoYmVnaW4gKyAxKSkpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gY29kZTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgdGhlIGxvbmdlc3Qgc2FmZSAqc3VmZml4KiB0aGF0IHdlIGNhbiB0b2tlbml6ZVxuICAgIHByZXYgPSAwO1xuICAgIGZvciAoOyBlbmQgPj0gYmVnaW47IGVuZCAtPSAxKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBzZWxlY3Rvci5jaGFyQ29kZUF0KGVuZCk7XG4gICAgICAgIC8vIElmIHdlIGVuY291bnRlciAnfCcgYmVmb3JlIGFueSBvdGhlciBvcGVuaW5nIGJyYWNrZXQsIHRoZW4gaXQncyBub3Qgc2FmZVxuICAgICAgICAvLyB0byB0b2tlbml6ZSB0aGlzIGZpbHRlciAoZS5nLjogJ2Zvb3xiYXInKS4gSW5zdGVhZCB3ZSBhYm9ydCB0b2tlbml6YXRpb25cbiAgICAgICAgLy8gdG8gYmUgc2FmZS5cbiAgICAgICAgaWYgKGNvZGUgPT09IDEyNCAvKiAnfCcgKi8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZSA9PT0gNDEgLyogJyknICovIHx8XG4gICAgICAgICAgICBjb2RlID09PSA0MiAvKiAnKicgKi8gfHxcbiAgICAgICAgICAgIGNvZGUgPT09IDQzIC8qICcrJyAqLyB8fFxuICAgICAgICAgICAgY29kZSA9PT0gNjMgLyogJz8nICovIHx8XG4gICAgICAgICAgICBjb2RlID09PSA5MyAvKiAnXScgKi8gfHxcbiAgICAgICAgICAgIGNvZGUgPT09IDEyNSAvKiAnfScgKi8gfHxcbiAgICAgICAgICAgIChjb2RlID09PSA0NiAvKiAnLicgKi8gJiYgc2VsZWN0b3IuY2hhckNvZGVBdChlbmQgLSAxKSAhPT0gOTIpIC8qICdcXCcgKi8gfHxcbiAgICAgICAgICAgIChjb2RlID09PSA5MiAvKiAnXFwnICovICYmIGlzQWxwaGEocHJldikpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gY29kZTtcbiAgICB9XG4gICAgaWYgKGVuZCA8IGJlZ2luKSB7XG4gICAgICAgIC8vIEZ1bGwgc2VsZWN0b3IgaXMgc2FmZVxuICAgICAgICBjb25zdCBza2lwRmlyc3RUb2tlbiA9IHNlbGVjdG9yLmNoYXJDb2RlQXQoMSkgIT09IDk0OyAvKiAnXicgKi9cbiAgICAgICAgY29uc3Qgc2tpcExhc3RUb2tlbiA9IHNlbGVjdG9yLmNoYXJDb2RlQXQoc2VsZWN0b3IubGVuZ3RoIC0gMSkgIT09IDM2OyAvKiAnJCcgKi9cbiAgICAgICAgdG9rZW5pemVJblBsYWNlKHNlbGVjdG9yLnNsaWNlKDEsIHNlbGVjdG9yLmxlbmd0aCAtIDEpLCBza2lwRmlyc3RUb2tlbiwgc2tpcExhc3RUb2tlbiwgdG9rZW5zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRva2VuaXplIHByZWZpeFxuICAgICAgICBpZiAoYmVnaW4gPiAxKSB7XG4gICAgICAgICAgICB0b2tlbml6ZUluUGxhY2Uoc2VsZWN0b3Iuc2xpY2UoMSwgYmVnaW4pLCBzZWxlY3Rvci5jaGFyQ29kZUF0KDEpICE9PSA5NCAvKiAnXicgKi8sIC8vIHNraXBGaXJzdFRva2VuXG4gICAgICAgICAgICB0cnVlLCB0b2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRva2VuaXplIHN1ZmZpeFxuICAgICAgICBpZiAoZW5kIDwgc2VsZWN0b3IubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdG9rZW5pemVJblBsYWNlKHNlbGVjdG9yLnNsaWNlKGVuZCArIDEsIHNlbGVjdG9yLmxlbmd0aCAtIDEpLCB0cnVlLCBzZWxlY3Rvci5jaGFyQ29kZUF0KHNlbGVjdG9yLmxlbmd0aCAtIDEpICE9PSA5NCAvKiAnXicgKi8sIC8vIHNraXBMYXN0VG9rZW5cbiAgICAgICAgICAgIHRva2Vucyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYmluU2VhcmNoKGFyciwgZWx0KSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBsZXQgbG93ID0gMDtcbiAgICBsZXQgaGlnaCA9IGFyci5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgICBjb25zdCBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDE7XG4gICAgICAgIGNvbnN0IG1pZFZhbCA9IGFyclttaWRdO1xuICAgICAgICBpZiAobWlkVmFsIDwgZWx0KSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1pZFZhbCA+IGVsdCkge1xuICAgICAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBiaW5Mb29rdXAoYXJyLCBlbHQpIHtcbiAgICByZXR1cm4gYmluU2VhcmNoKGFyciwgZWx0KSAhPT0gLTE7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuY29uc3QgaGFzVW5pY29kZVJlID0gL1teXFx1MDAwMC1cXHUwMGZmXS87XG5leHBvcnQgZnVuY3Rpb24gaGFzVW5pY29kZShzdHIpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZVJlLnRlc3Qoc3RyKTtcbn1cbi8qKlxuICogRmluZHMgdGhlIGxhc3QgaW5kZXggb2YgYW4gdW5lc2NhcGVkIGNoYXJhY3RlciBpbiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICogVGhpcyBmdW5jdGlvbiB0cmllcyB0byBmaW5kIHRoZSBtYXRjaCBmcm9tIHRoZSBiYWNrd2FyZC5cbiAqIFdoZW4gdGhpcyBmdW5jdGlvbiBzZWVzIGFuIGVzY2FwaW5nIGNoYXJhY3RlciwgaXQgd2lsbCBqdW1wIHRvIHRoZSBuZXh0IGluZGV4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZExhc3RJbmRleE9mVW5lc2NhcGVkQ2hhcmFjdGVyKHRleHQsIGNoYXJhY3Rlcikge1xuICAgIGxldCBsYXN0SW5kZXggPSB0ZXh0Lmxhc3RJbmRleE9mKGNoYXJhY3Rlcik7XG4gICAgaWYgKGxhc3RJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICB3aGlsZSAobGFzdEluZGV4ID4gMCAmJiB0ZXh0LmNoYXJDb2RlQXQobGFzdEluZGV4IC0gMSkgPT09IDkyIC8qICdcXFxcJyAqLykge1xuICAgICAgICBsYXN0SW5kZXggPSB0ZXh0Lmxhc3RJbmRleE9mKGNoYXJhY3RlciwgbGFzdEluZGV4IC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBsYXN0SW5kZXg7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/adblocker/dist/esm/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/url-parser/dist/esm/const.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ghostery/url-parser/dist/esm/const.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CODE_AMPERSAND: () => (/* binding */ CODE_AMPERSAND),\n/* harmony export */   CODE_AT: () => (/* binding */ CODE_AT),\n/* harmony export */   CODE_COLON: () => (/* binding */ CODE_COLON),\n/* harmony export */   CODE_EQUALS: () => (/* binding */ CODE_EQUALS),\n/* harmony export */   CODE_FORWARD_SLASH: () => (/* binding */ CODE_FORWARD_SLASH),\n/* harmony export */   CODE_HASH: () => (/* binding */ CODE_HASH),\n/* harmony export */   CODE_PERCENT: () => (/* binding */ CODE_PERCENT),\n/* harmony export */   CODE_PLUS: () => (/* binding */ CODE_PLUS),\n/* harmony export */   CODE_QUESTION_MARK: () => (/* binding */ CODE_QUESTION_MARK),\n/* harmony export */   CODE_SEMICOLON: () => (/* binding */ CODE_SEMICOLON),\n/* harmony export */   CODE_SPACE: () => (/* binding */ CODE_SPACE),\n/* harmony export */   CODE_SQUARE_BRACKET_CLOSE: () => (/* binding */ CODE_SQUARE_BRACKET_CLOSE),\n/* harmony export */   CODE_SQUARE_BRACKET_OPEN: () => (/* binding */ CODE_SQUARE_BRACKET_OPEN)\n/* harmony export */ });\nconst CODE_SPACE = 32;\nconst CODE_HASH = 35;\nconst CODE_PERCENT = 37;\nconst CODE_AMPERSAND = 38;\nconst CODE_PLUS = 43;\nconst CODE_FORWARD_SLASH = 47;\nconst CODE_COLON = 58;\nconst CODE_SEMICOLON = 59;\nconst CODE_EQUALS = 61;\nconst CODE_QUESTION_MARK = 63;\nconst CODE_AT = 64;\nconst CODE_SQUARE_BRACKET_OPEN = 91;\nconst CODE_SQUARE_BRACKET_CLOSE = 93;\n//# sourceMappingURL=const.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L3VybC1wYXJzZXIvZGlzdC9lc20vY29uc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvdXJsLXBhcnNlci9kaXN0L2VzbS9jb25zdC5qcz9kNDZlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBDT0RFX1NQQUNFID0gMzI7XG5leHBvcnQgY29uc3QgQ09ERV9IQVNIID0gMzU7XG5leHBvcnQgY29uc3QgQ09ERV9QRVJDRU5UID0gMzc7XG5leHBvcnQgY29uc3QgQ09ERV9BTVBFUlNBTkQgPSAzODtcbmV4cG9ydCBjb25zdCBDT0RFX1BMVVMgPSA0MztcbmV4cG9ydCBjb25zdCBDT0RFX0ZPUldBUkRfU0xBU0ggPSA0NztcbmV4cG9ydCBjb25zdCBDT0RFX0NPTE9OID0gNTg7XG5leHBvcnQgY29uc3QgQ09ERV9TRU1JQ09MT04gPSA1OTtcbmV4cG9ydCBjb25zdCBDT0RFX0VRVUFMUyA9IDYxO1xuZXhwb3J0IGNvbnN0IENPREVfUVVFU1RJT05fTUFSSyA9IDYzO1xuZXhwb3J0IGNvbnN0IENPREVfQVQgPSA2NDtcbmV4cG9ydCBjb25zdCBDT0RFX1NRVUFSRV9CUkFDS0VUX09QRU4gPSA5MTtcbmV4cG9ydCBjb25zdCBDT0RFX1NRVUFSRV9CUkFDS0VUX0NMT1NFID0gOTM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/url-parser/dist/esm/const.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/url-parser/dist/esm/immutable-url.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ghostery/url-parser/dist/esm/immutable-url.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tldts_experimental__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tldts-experimental */ \"(rsc)/./node_modules/tldts-experimental/dist/es6/index.js\");\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.js */ \"(rsc)/./node_modules/@ghostery/url-parser/dist/esm/const.js\");\n/* harmony import */ var _url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-search-params.js */ \"(rsc)/./node_modules/@ghostery/url-parser/dist/esm/url-search-params.js\");\n\n\n\nconst BREAK_HOST_ON = [_const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_FORWARD_SLASH, _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_HASH, _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_QUESTION_MARK];\nfunction isValidProtocolChar(code) {\n    return ((code >= 65 && code <= 90) || // A-Z\n        (code >= 97 && code <= 122) || // a-z\n        (code >= 48 && code <= 57) || // 0-9\n        code === 45 || // -\n        code === 43); // +\n}\n/**\n * A Fast implementation of url parsing, mostly API-compatible with the standard URL class while\n * being on average 2-3 times faster. Evaluation of URL components is lazy, so this implementation\n * should be fast for all use-cases.\n *\n * Known differences to standard URL:\n *  * Parameters returned via `URL.searchParams.entries()` are decoded only with\n *    `decodeURIComponent`. This differs to standards parsing in some subtle ways.\n *  * You can iterate a URL parameters array directly via `URL.searchParams.params`. This is around\n *    20% faster than using an iterator.\n *  * Parameter strings are parsed, and accessible via `URL.parameters`.\n *  * Domain parsing with tldts is built in. The `URL.domainInfo` attribute returns output from tldts'\n *    `parseHost` method.\n *  * Hostname validation is not done on initial parse. The `isValidHost()` method is provided for\n *    this purpose.\n *  * Some extra helper methods.\n *\n * See also for common API: https://developer.mozilla.org/en-US/docs/Web/API/URL\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (class {\n    constructor(url) {\n        this.parse(url);\n    }\n    get protocol() {\n        return this._protocol;\n    }\n    get username() {\n        return this._username;\n    }\n    get password() {\n        return this._password;\n    }\n    get hostname() {\n        return this._hostname;\n    }\n    get host() {\n        return this._host;\n    }\n    get port() {\n        return this._port;\n    }\n    get pathname() {\n        return this._pathname;\n    }\n    /**\n     * The query string component of the URL, including the preceding `?` character.\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/search\n     */\n    get search() {\n        if (!this._search) {\n            this._extractParams();\n        }\n        return this._search;\n    }\n    /**\n     * Parsed query string parameters, as a `URLSearchParams` object.\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams\n     */\n    get searchParams() {\n        if (!this.isQueryParsed) {\n            this._extractSearchParams();\n        }\n        return this._query;\n    }\n    /**\n     * Parsed parameter string from the url. These are `;` separated key/values appearing in the URL\n     * path, before the query string.\n     */\n    get parameters() {\n        if (!this.isQueryParsed) {\n            this._extractSearchParams();\n        }\n        return this._parameters;\n    }\n    /**\n     * Check if the URL has a parameter string\n     * @returns true iff `;` occurs in the URL path before a `?`.\n     */\n    hasParameterString() {\n        return this.parameterStartIndex > 0;\n    }\n    /**\n     * URL hash or fragment component.\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/hash\n     */\n    get hash() {\n        if (!this._search && !this._hash) {\n            this._extractParams();\n        }\n        return this._hash;\n    }\n    get href() {\n        return this._href;\n    }\n    /**\n     * Returns the url (post parsing).\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/toString\n     */\n    toString() {\n        return this.href;\n    }\n    /**\n     * JSONified URL (== toString)\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/toJSON\n     */\n    toJSON() {\n        return this.href;\n    }\n    /**\n     * Get parsed domainInfo from the hostname.\n     * @returns parsed domain, from tldts `parse` method.\n     */\n    get domainInfo() {\n        if (!this._domainInfo) {\n            this._domainInfo = (0,tldts_experimental__WEBPACK_IMPORTED_MODULE_0__.parse)(this.hostname, {\n                extractHostname: false,\n            });\n        }\n        return this._domainInfo;\n    }\n    /**\n     * Returns true iff the hostname of this url is an IP address. False otherwise.\n     */\n    get hostIsIp() {\n        return this.domainInfo.isIp;\n    }\n    /**\n     * Returns the hostname of the URL after parsing by tldts. This includes some error correction.\n     */\n    get domain() {\n        return this.domainInfo.hostname || this.hostname;\n    }\n    /**\n     * Get eTLD+1 of the hostname.\n     */\n    get generalDomain() {\n        return this.domainInfo.domain || this.hostname;\n    }\n    /**\n     * Legacy attribute for `pathname`.\n     */\n    get path() {\n        return this.pathname || '/';\n    }\n    /**\n     * Scheme = protocol without a trailing ':'.\n     */\n    get scheme() {\n        return this.protocol.slice(0, -1);\n    }\n    /**\n     * Check if the hostname of the URL is valid, i.e.\n     *  * it is an IP address, or\n     *  * it is a valid hostname with a known public suffix.\n     * @returns true if host is valid, otherwise false.\n     */\n    isValidHost() {\n        // if tldts was able to parse it, it's valid\n        return this.hostIsIp || this.generalDomain !== null;\n    }\n    /**\n     * Non-standard params extractor.\n     *\n     * Returns search params from parameter string and query params with more aggessive extraction\n     * than the standard URL implementation. Extra extraction features are:\n     *  * `;` separated parameters - used by multi trackers\n     * @returns URLSearchParams\n     */\n    extractKeyValues() {\n        if (this.parsedParameters) {\n            return this.parsedParameters;\n        }\n        this.parsedParameters = new _url_search_params_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        if (this.queryStartIndex === 0 && this.parameterStartIndex === 0) {\n            return this.parsedParameters;\n        }\n        const start = this.parameterStartIndex || this.queryStartIndex;\n        const end = this.href.length - 1;\n        let index = start;\n        if (this.href.charCodeAt(index) === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_SEMICOLON) {\n            // parameter string starts here\n            index = this._extractParamTuples(index + 1, end, this.parsedParameters, [_const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_SEMICOLON], _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_EQUALS, [_const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_QUESTION_MARK, _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_HASH]);\n        }\n        if (this.href.charCodeAt(index) === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_QUESTION_MARK) {\n            // query string starts here\n            index = this._extractParamTuples(index + 1, end, this.parsedParameters, [_const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_AMPERSAND, _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_SEMICOLON], // allow '&' or ';' as separators\n            _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_EQUALS, [_const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_HASH]);\n        }\n        return this.parsedParameters;\n    }\n    _extractHostname(start, end) {\n        let portIndex = 0;\n        let stopped = false;\n        let i = start;\n        let ipv6 = false;\n        let hasUpper = false;\n        // this is a IPv6 address - ignore everything until the closing bracket\n        if (this._href.charCodeAt(i) === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_SQUARE_BRACKET_OPEN) {\n            ipv6 = true;\n            for (; i <= end; i += 1) {\n                const code = this._href.charCodeAt(i);\n                if (code === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_SQUARE_BRACKET_CLOSE) {\n                    // after closed brackets can only be ':' or '/'\n                    const nextCode = this._href.charCodeAt(i + 1);\n                    if (nextCode === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_COLON) {\n                        portIndex = i + 1;\n                        i += 1;\n                        stopped = true;\n                    }\n                    else if (nextCode === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_FORWARD_SLASH) {\n                        i += 1;\n                        stopped = true;\n                    }\n                    else if (i !== end) {\n                        throw new TypeError('expected `:` or `/` after IPv6 address');\n                    }\n                    break;\n                }\n            }\n        }\n        if (!ipv6) {\n            for (; i <= end; i += 1) {\n                const code = this._href.charCodeAt(i);\n                if (code === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_COLON) {\n                    portIndex = i;\n                    stopped = true;\n                    break;\n                }\n                else if (code === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_AT) {\n                    // username without password\n                    this._username = this._href.slice(start, i);\n                    this._password = '';\n                    return this._extractHostname(i + 1, end);\n                }\n                if (BREAK_HOST_ON.indexOf(code) !== -1) {\n                    stopped = true;\n                    break;\n                }\n                else if (code <= 0x20) {\n                    throw new TypeError(`Invalid character '${this.href[i]}' in hostname`);\n                }\n                else if (code >= 65 && code <= 90) {\n                    hasUpper = true;\n                }\n            }\n        }\n        const hostnameEnd = !stopped ? i + 1 : i;\n        if (hasUpper) {\n            this._href = `${this._href.slice(0, start)}${this._href\n                .slice(start, hostnameEnd)\n                .toLowerCase()}${this._href.slice(hostnameEnd)}`;\n        }\n        this._hostname = this._href.slice(start, hostnameEnd);\n        if (portIndex > 0) {\n            i += 1;\n            const portStart = i;\n            let nonNumeric = false;\n            for (; i <= end; i += 1) {\n                const code = this._href.charCodeAt(i);\n                if (BREAK_HOST_ON.indexOf(code) !== -1) {\n                    this._port = this._href.slice(portStart, i);\n                    break;\n                }\n                else if (code === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_AT) {\n                    // this was actually a username and password - extract user:pass, then\n                    // parse the rest as a plain hostname\n                    this._username = this._href.slice(start, portIndex || i);\n                    this._password = this._href.slice(portIndex + 1, i);\n                    return this._extractHostname(i + 1, end);\n                }\n                else if (code < 48 || code > 57) {\n                    // non numeric character in port\n                    nonNumeric = true;\n                }\n            }\n            if (!this._port) {\n                this._port = this.href.slice(portStart, i);\n            }\n            // validate port - cannot contain non-numeric characters\n            if (nonNumeric) {\n                throw new TypeError('Invalid URL: port contains non numeric character');\n            }\n            // cannot be greater than 65535\n            if (this._port.length >= 5 && +this._port > 65535) {\n                throw new TypeError('Invalid URL: invalid port number');\n            }\n        }\n        this._host = this._href.slice(start, !stopped ? i + 1 : i);\n        this.origin = `${this._protocol}//${this._host}`;\n        return !stopped ? i + 1 : i;\n    }\n    _extractParams() {\n        if (this.queryStartIndex > 0) {\n            let index = this.queryStartIndex;\n            const end = this.href.length - 1;\n            if (this.href.charCodeAt(index) === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_QUESTION_MARK) {\n                let broken = false;\n                for (; index <= end; index += 1) {\n                    if (this.href.charCodeAt(index) === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_HASH) {\n                        broken = true;\n                        break;\n                    }\n                }\n                this._search = this.href.slice(this.queryStartIndex, broken ? index : end + 1);\n                if (this._search.length === 1) {\n                    this._search = '';\n                }\n            }\n            if (this.href.charCodeAt(index) === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_HASH) {\n                this._hash = this.href.slice(index, end + 1);\n            }\n        }\n    }\n    _extractSearchParams() {\n        this.isQueryParsed = true;\n        if (this.queryStartIndex === 0 && this.parameterStartIndex === 0) {\n            return;\n        }\n        const start = this.parameterStartIndex || this.queryStartIndex;\n        const end = this.href.length - 1;\n        let index = start;\n        if (this.href.charCodeAt(index) === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_SEMICOLON) {\n            // parameter string starts here\n            index = this._extractParamTuples(index + 1, end, this._parameters, [_const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_SEMICOLON], _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_EQUALS, [_const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_QUESTION_MARK, _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_HASH]);\n        }\n        if (this.href.charCodeAt(index) === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_QUESTION_MARK) {\n            // query string starts here\n            const searchStart = index;\n            index = this._extractParamTuples(index + 1, end, this._query, [_const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_AMPERSAND], _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_EQUALS, [_const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_HASH]);\n            this._search = this.href.slice(searchStart, index);\n            if (this._search.length === 1) {\n                this._search = '';\n            }\n        }\n        if (this.href.charCodeAt(index) === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_HASH) {\n            this._hash = this.href.slice(index, end + 1);\n        }\n    }\n    _extractParamTuples(start, end, params, separators, equals, breakCodes) {\n        return (0,_url_search_params_js__WEBPACK_IMPORTED_MODULE_2__.extractParams)(this.href, start, end, params, separators, equals, breakCodes);\n    }\n    parse(url) {\n        if (typeof url !== 'string' || url.length === 0) {\n            throw new TypeError(`${url} is not a valid URL`);\n        }\n        this._protocol = '';\n        this._hostname = '';\n        this._host = '';\n        this._port = '';\n        this._pathname = '';\n        this._username = '';\n        this._password = '';\n        this._search = '';\n        this._hash = '';\n        this.parameterStartIndex = 0;\n        this.queryStartIndex = 0;\n        this.isQueryParsed = false;\n        this._parameters = new _url_search_params_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        this._query = new _url_search_params_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        this._domainInfo = null;\n        this.parsedParameters = null;\n        let index = 0;\n        // end is within bound of url\n        let end = url.length - 1;\n        // cut whitespace from the beginning and end of url\n        while (url.charCodeAt(index) <= 0x20) {\n            index += 1;\n        }\n        while (url.charCodeAt(end) <= 0x20) {\n            end -= 1;\n        }\n        this._href = url.slice(index, end + 1);\n        end = this._href.length - 1;\n        let hasUpper = false;\n        // Parse protocol\n        for (; index <= end; index += 1) {\n            const code = this._href.charCodeAt(index);\n            if (code === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_COLON) {\n                this._protocol = this._href.slice(0, index + 1);\n                if (hasUpper) {\n                    this._protocol = this._protocol.toLowerCase();\n                    this._href = `${this._protocol}${this._href.slice(index + 1)}`;\n                }\n                break;\n            }\n            else if (!isValidProtocolChar(code)) {\n                // non alphabet character in protocol - not a valid protocol\n                throw new TypeError('Invalid URL protocol');\n            }\n            else if (code >= 65 && code <= 90) {\n                hasUpper = true;\n            }\n        }\n        if (index >= end) {\n            throw new TypeError('No protocol');\n        }\n        // skip '/' after ':'\n        this.slashes = '';\n        for (index += 1; index < end; index += 1) {\n            if (this._href.charCodeAt(index) !== _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_FORWARD_SLASH) {\n                break;\n            }\n            else {\n                this.slashes += '/';\n            }\n        }\n        if (this.slashes.length >= 2) {\n            // Two slashes: Authority is included\n            index = this._extractHostname(index, end);\n        }\n        else {\n            // No authority\n            this._host = '';\n            this._hostname = '';\n            this.origin = 'null';\n        }\n        if (index >= end) {\n            // add trailing slash if missing\n            if (this._href.charCodeAt(end) !== _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_FORWARD_SLASH) {\n                this._href += '/';\n            }\n            this._pathname = '/';\n        }\n        else {\n            const pathStart = index;\n            for (; index <= end; index += 1) {\n                const code = this._href.charCodeAt(index);\n                if (code === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_SEMICOLON && !this.parameterStartIndex) {\n                    this.parameterStartIndex = index;\n                }\n                else if (code === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_QUESTION_MARK || code === _const_js__WEBPACK_IMPORTED_MODULE_1__.CODE_HASH) {\n                    this.queryStartIndex = index;\n                    break;\n                }\n            }\n            this._pathname =\n                this.href.slice(pathStart, this.queryStartIndex !== 0 ? this.queryStartIndex : end + 1) || '/';\n        }\n    }\n});\n//# sourceMappingURL=immutable-url.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L3VybC1wYXJzZXIvZGlzdC9lc20vaW1tdXRhYmxlLXVybC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTJDO0FBQzRKO0FBQy9IO0FBQ3hFLHVCQUF1Qix5REFBa0IsRUFBRSxnREFBUyxFQUFFLHlEQUFrQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5REFBSztBQUNwQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDZEQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxxREFBYztBQUMxRDtBQUNBLHFGQUFxRixxREFBYyxHQUFHLGtEQUFXLEdBQUcseURBQWtCLEVBQUUsZ0RBQVM7QUFDako7QUFDQSw0Q0FBNEMseURBQWtCO0FBQzlEO0FBQ0EscUZBQXFGLHFEQUFjLEVBQUUscURBQWMscUJBQXFCO0FBQ3hJLFlBQVksa0RBQVcsR0FBRyxnREFBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywrREFBd0I7QUFDakU7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLDZCQUE2QixnRUFBeUI7QUFDdEQ7QUFDQTtBQUNBLHFDQUFxQyxpREFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx5REFBa0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0EsNkJBQTZCLGlEQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhDQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGFBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkIsRUFBRTtBQUN6RDtBQUNBLCtCQUErQixFQUFFLDhCQUE4QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhDQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlLElBQUksV0FBVztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseURBQWtCO0FBQ2xFO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckMsd0RBQXdELGdEQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnREFBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscURBQWM7QUFDMUQ7QUFDQSxnRkFBZ0YscURBQWMsR0FBRyxrREFBVyxHQUFHLHlEQUFrQixFQUFFLGdEQUFTO0FBQzVJO0FBQ0EsNENBQTRDLHlEQUFrQjtBQUM5RDtBQUNBO0FBQ0EsMkVBQTJFLHFEQUFjLEdBQUcsa0RBQVcsR0FBRyxnREFBUztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdEQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvRUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2REFBZTtBQUM5QywwQkFBMEIsNkRBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQSx5QkFBeUIsaURBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWUsRUFBRSw0QkFBNEI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QyxpREFBaUQseURBQWtCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx5REFBa0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQSw2QkFBNkIscURBQWM7QUFDM0M7QUFDQTtBQUNBLGtDQUFrQyx5REFBa0IsYUFBYSxnREFBUztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JpZGxpdGUvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L3VybC1wYXJzZXIvZGlzdC9lc20vaW1tdXRhYmxlLXVybC5qcz81Y2M3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlIH0gZnJvbSAndGxkdHMtZXhwZXJpbWVudGFsJztcbmltcG9ydCB7IENPREVfQU1QRVJTQU5ELCBDT0RFX0FULCBDT0RFX0NPTE9OLCBDT0RFX0VRVUFMUywgQ09ERV9GT1JXQVJEX1NMQVNILCBDT0RFX0hBU0gsIENPREVfUVVFU1RJT05fTUFSSywgQ09ERV9TRU1JQ09MT04sIENPREVfU1FVQVJFX0JSQUNLRVRfQ0xPU0UsIENPREVfU1FVQVJFX0JSQUNLRVRfT1BFTiwgfSBmcm9tICcuL2NvbnN0LmpzJztcbmltcG9ydCBVUkxTZWFyY2hQYXJhbXMsIHsgZXh0cmFjdFBhcmFtcyB9IGZyb20gJy4vdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuY29uc3QgQlJFQUtfSE9TVF9PTiA9IFtDT0RFX0ZPUldBUkRfU0xBU0gsIENPREVfSEFTSCwgQ09ERV9RVUVTVElPTl9NQVJLXTtcbmZ1bmN0aW9uIGlzVmFsaWRQcm90b2NvbENoYXIoY29kZSkge1xuICAgIHJldHVybiAoKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkgfHwgLy8gQS1aXG4gICAgICAgIChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTIyKSB8fCAvLyBhLXpcbiAgICAgICAgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHwgLy8gMC05XG4gICAgICAgIGNvZGUgPT09IDQ1IHx8IC8vIC1cbiAgICAgICAgY29kZSA9PT0gNDMpOyAvLyArXG59XG4vKipcbiAqIEEgRmFzdCBpbXBsZW1lbnRhdGlvbiBvZiB1cmwgcGFyc2luZywgbW9zdGx5IEFQSS1jb21wYXRpYmxlIHdpdGggdGhlIHN0YW5kYXJkIFVSTCBjbGFzcyB3aGlsZVxuICogYmVpbmcgb24gYXZlcmFnZSAyLTMgdGltZXMgZmFzdGVyLiBFdmFsdWF0aW9uIG9mIFVSTCBjb21wb25lbnRzIGlzIGxhenksIHNvIHRoaXMgaW1wbGVtZW50YXRpb25cbiAqIHNob3VsZCBiZSBmYXN0IGZvciBhbGwgdXNlLWNhc2VzLlxuICpcbiAqIEtub3duIGRpZmZlcmVuY2VzIHRvIHN0YW5kYXJkIFVSTDpcbiAqICAqIFBhcmFtZXRlcnMgcmV0dXJuZWQgdmlhIGBVUkwuc2VhcmNoUGFyYW1zLmVudHJpZXMoKWAgYXJlIGRlY29kZWQgb25seSB3aXRoXG4gKiAgICBgZGVjb2RlVVJJQ29tcG9uZW50YC4gVGhpcyBkaWZmZXJzIHRvIHN0YW5kYXJkcyBwYXJzaW5nIGluIHNvbWUgc3VidGxlIHdheXMuXG4gKiAgKiBZb3UgY2FuIGl0ZXJhdGUgYSBVUkwgcGFyYW1ldGVycyBhcnJheSBkaXJlY3RseSB2aWEgYFVSTC5zZWFyY2hQYXJhbXMucGFyYW1zYC4gVGhpcyBpcyBhcm91bmRcbiAqICAgIDIwJSBmYXN0ZXIgdGhhbiB1c2luZyBhbiBpdGVyYXRvci5cbiAqICAqIFBhcmFtZXRlciBzdHJpbmdzIGFyZSBwYXJzZWQsIGFuZCBhY2Nlc3NpYmxlIHZpYSBgVVJMLnBhcmFtZXRlcnNgLlxuICogICogRG9tYWluIHBhcnNpbmcgd2l0aCB0bGR0cyBpcyBidWlsdCBpbi4gVGhlIGBVUkwuZG9tYWluSW5mb2AgYXR0cmlidXRlIHJldHVybnMgb3V0cHV0IGZyb20gdGxkdHMnXG4gKiAgICBgcGFyc2VIb3N0YCBtZXRob2QuXG4gKiAgKiBIb3N0bmFtZSB2YWxpZGF0aW9uIGlzIG5vdCBkb25lIG9uIGluaXRpYWwgcGFyc2UuIFRoZSBgaXNWYWxpZEhvc3QoKWAgbWV0aG9kIGlzIHByb3ZpZGVkIGZvclxuICogICAgdGhpcyBwdXJwb3NlLlxuICogICogU29tZSBleHRyYSBoZWxwZXIgbWV0aG9kcy5cbiAqXG4gKiBTZWUgYWxzbyBmb3IgY29tbW9uIEFQSTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgICAgIHRoaXMucGFyc2UodXJsKTtcbiAgICB9XG4gICAgZ2V0IHByb3RvY29sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2w7XG4gICAgfVxuICAgIGdldCB1c2VybmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJuYW1lO1xuICAgIH1cbiAgICBnZXQgcGFzc3dvcmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXNzd29yZDtcbiAgICB9XG4gICAgZ2V0IGhvc3RuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faG9zdG5hbWU7XG4gICAgfVxuICAgIGdldCBob3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faG9zdDtcbiAgICB9XG4gICAgZ2V0IHBvcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3J0O1xuICAgIH1cbiAgICBnZXQgcGF0aG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXRobmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHF1ZXJ5IHN0cmluZyBjb21wb25lbnQgb2YgdGhlIFVSTCwgaW5jbHVkaW5nIHRoZSBwcmVjZWRpbmcgYD9gIGNoYXJhY3Rlci5cbiAgICAgKiBTZWUgYWxzbzogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9zZWFyY2hcbiAgICAgKi9cbiAgICBnZXQgc2VhcmNoKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3NlYXJjaCkge1xuICAgICAgICAgICAgdGhpcy5fZXh0cmFjdFBhcmFtcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWFyY2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlZCBxdWVyeSBzdHJpbmcgcGFyYW1ldGVycywgYXMgYSBgVVJMU2VhcmNoUGFyYW1zYCBvYmplY3QuXG4gICAgICogU2VlIGFsc286IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9VUkwvc2VhcmNoUGFyYW1zXG4gICAgICovXG4gICAgZ2V0IHNlYXJjaFBhcmFtcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUXVlcnlQYXJzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2V4dHJhY3RTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlZCBwYXJhbWV0ZXIgc3RyaW5nIGZyb20gdGhlIHVybC4gVGhlc2UgYXJlIGA7YCBzZXBhcmF0ZWQga2V5L3ZhbHVlcyBhcHBlYXJpbmcgaW4gdGhlIFVSTFxuICAgICAqIHBhdGgsIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nLlxuICAgICAqL1xuICAgIGdldCBwYXJhbWV0ZXJzKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNRdWVyeVBhcnNlZCkge1xuICAgICAgICAgICAgdGhpcy5fZXh0cmFjdFNlYXJjaFBhcmFtcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgVVJMIGhhcyBhIHBhcmFtZXRlciBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmZiBgO2Agb2NjdXJzIGluIHRoZSBVUkwgcGF0aCBiZWZvcmUgYSBgP2AuXG4gICAgICovXG4gICAgaGFzUGFyYW1ldGVyU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbWV0ZXJTdGFydEluZGV4ID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVVJMIGhhc2ggb3IgZnJhZ21lbnQgY29tcG9uZW50LlxuICAgICAqIFNlZSBhbHNvOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJML2hhc2hcbiAgICAgKi9cbiAgICBnZXQgaGFzaCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zZWFyY2ggJiYgIXRoaXMuX2hhc2gpIHtcbiAgICAgICAgICAgIHRoaXMuX2V4dHJhY3RQYXJhbXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faGFzaDtcbiAgICB9XG4gICAgZ2V0IGhyZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ocmVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1cmwgKHBvc3QgcGFyc2luZykuXG4gICAgICogU2VlIGFsc286IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9VUkwvdG9TdHJpbmdcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHJlZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSlNPTmlmaWVkIFVSTCAoPT0gdG9TdHJpbmcpXG4gICAgICogU2VlIGFsc286IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9VUkwvdG9KU09OXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ocmVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgcGFyc2VkIGRvbWFpbkluZm8gZnJvbSB0aGUgaG9zdG5hbWUuXG4gICAgICogQHJldHVybnMgcGFyc2VkIGRvbWFpbiwgZnJvbSB0bGR0cyBgcGFyc2VgIG1ldGhvZC5cbiAgICAgKi9cbiAgICBnZXQgZG9tYWluSW5mbygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kb21haW5JbmZvKSB7XG4gICAgICAgICAgICB0aGlzLl9kb21haW5JbmZvID0gcGFyc2UodGhpcy5ob3N0bmFtZSwge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RIb3N0bmFtZTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZG9tYWluSW5mbztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmZiB0aGUgaG9zdG5hbWUgb2YgdGhpcyB1cmwgaXMgYW4gSVAgYWRkcmVzcy4gRmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGdldCBob3N0SXNJcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tYWluSW5mby5pc0lwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBob3N0bmFtZSBvZiB0aGUgVVJMIGFmdGVyIHBhcnNpbmcgYnkgdGxkdHMuIFRoaXMgaW5jbHVkZXMgc29tZSBlcnJvciBjb3JyZWN0aW9uLlxuICAgICAqL1xuICAgIGdldCBkb21haW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbWFpbkluZm8uaG9zdG5hbWUgfHwgdGhpcy5ob3N0bmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGVUTEQrMSBvZiB0aGUgaG9zdG5hbWUuXG4gICAgICovXG4gICAgZ2V0IGdlbmVyYWxEb21haW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbWFpbkluZm8uZG9tYWluIHx8IHRoaXMuaG9zdG5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlZ2FjeSBhdHRyaWJ1dGUgZm9yIGBwYXRobmFtZWAuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGhuYW1lIHx8ICcvJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NoZW1lID0gcHJvdG9jb2wgd2l0aG91dCBhIHRyYWlsaW5nICc6Jy5cbiAgICAgKi9cbiAgICBnZXQgc2NoZW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm90b2NvbC5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBob3N0bmFtZSBvZiB0aGUgVVJMIGlzIHZhbGlkLCBpLmUuXG4gICAgICogICogaXQgaXMgYW4gSVAgYWRkcmVzcywgb3JcbiAgICAgKiAgKiBpdCBpcyBhIHZhbGlkIGhvc3RuYW1lIHdpdGggYSBrbm93biBwdWJsaWMgc3VmZml4LlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgaG9zdCBpcyB2YWxpZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqL1xuICAgIGlzVmFsaWRIb3N0KCkge1xuICAgICAgICAvLyBpZiB0bGR0cyB3YXMgYWJsZSB0byBwYXJzZSBpdCwgaXQncyB2YWxpZFxuICAgICAgICByZXR1cm4gdGhpcy5ob3N0SXNJcCB8fCB0aGlzLmdlbmVyYWxEb21haW4gIT09IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vbi1zdGFuZGFyZCBwYXJhbXMgZXh0cmFjdG9yLlxuICAgICAqXG4gICAgICogUmV0dXJucyBzZWFyY2ggcGFyYW1zIGZyb20gcGFyYW1ldGVyIHN0cmluZyBhbmQgcXVlcnkgcGFyYW1zIHdpdGggbW9yZSBhZ2dlc3NpdmUgZXh0cmFjdGlvblxuICAgICAqIHRoYW4gdGhlIHN0YW5kYXJkIFVSTCBpbXBsZW1lbnRhdGlvbi4gRXh0cmEgZXh0cmFjdGlvbiBmZWF0dXJlcyBhcmU6XG4gICAgICogICogYDtgIHNlcGFyYXRlZCBwYXJhbWV0ZXJzIC0gdXNlZCBieSBtdWx0aSB0cmFja2Vyc1xuICAgICAqIEByZXR1cm5zIFVSTFNlYXJjaFBhcmFtc1xuICAgICAqL1xuICAgIGV4dHJhY3RLZXlWYWx1ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlZFBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlZFBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJzZWRQYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAodGhpcy5xdWVyeVN0YXJ0SW5kZXggPT09IDAgJiYgdGhpcy5wYXJhbWV0ZXJTdGFydEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRQYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5wYXJhbWV0ZXJTdGFydEluZGV4IHx8IHRoaXMucXVlcnlTdGFydEluZGV4O1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLmhyZWYubGVuZ3RoIC0gMTtcbiAgICAgICAgbGV0IGluZGV4ID0gc3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLmhyZWYuY2hhckNvZGVBdChpbmRleCkgPT09IENPREVfU0VNSUNPTE9OKSB7XG4gICAgICAgICAgICAvLyBwYXJhbWV0ZXIgc3RyaW5nIHN0YXJ0cyBoZXJlXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuX2V4dHJhY3RQYXJhbVR1cGxlcyhpbmRleCArIDEsIGVuZCwgdGhpcy5wYXJzZWRQYXJhbWV0ZXJzLCBbQ09ERV9TRU1JQ09MT05dLCBDT0RFX0VRVUFMUywgW0NPREVfUVVFU1RJT05fTUFSSywgQ09ERV9IQVNIXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaHJlZi5jaGFyQ29kZUF0KGluZGV4KSA9PT0gQ09ERV9RVUVTVElPTl9NQVJLKSB7XG4gICAgICAgICAgICAvLyBxdWVyeSBzdHJpbmcgc3RhcnRzIGhlcmVcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5fZXh0cmFjdFBhcmFtVHVwbGVzKGluZGV4ICsgMSwgZW5kLCB0aGlzLnBhcnNlZFBhcmFtZXRlcnMsIFtDT0RFX0FNUEVSU0FORCwgQ09ERV9TRU1JQ09MT05dLCAvLyBhbGxvdyAnJicgb3IgJzsnIGFzIHNlcGFyYXRvcnNcbiAgICAgICAgICAgIENPREVfRVFVQUxTLCBbQ09ERV9IQVNIXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkUGFyYW1ldGVycztcbiAgICB9XG4gICAgX2V4dHJhY3RIb3N0bmFtZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGxldCBwb3J0SW5kZXggPSAwO1xuICAgICAgICBsZXQgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgaSA9IHN0YXJ0O1xuICAgICAgICBsZXQgaXB2NiA9IGZhbHNlO1xuICAgICAgICBsZXQgaGFzVXBwZXIgPSBmYWxzZTtcbiAgICAgICAgLy8gdGhpcyBpcyBhIElQdjYgYWRkcmVzcyAtIGlnbm9yZSBldmVyeXRoaW5nIHVudGlsIHRoZSBjbG9zaW5nIGJyYWNrZXRcbiAgICAgICAgaWYgKHRoaXMuX2hyZWYuY2hhckNvZGVBdChpKSA9PT0gQ09ERV9TUVVBUkVfQlJBQ0tFVF9PUEVOKSB7XG4gICAgICAgICAgICBpcHY2ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoOyBpIDw9IGVuZDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2hyZWYuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gQ09ERV9TUVVBUkVfQlJBQ0tFVF9DTE9TRSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZnRlciBjbG9zZWQgYnJhY2tldHMgY2FuIG9ubHkgYmUgJzonIG9yICcvJ1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q29kZSA9IHRoaXMuX2hyZWYuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q29kZSA9PT0gQ09ERV9DT0xPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydEluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0Q29kZSA9PT0gQ09ERV9GT1JXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpICE9PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGA6YCBvciBgL2AgYWZ0ZXIgSVB2NiBhZGRyZXNzJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXB2Nikge1xuICAgICAgICAgICAgZm9yICg7IGkgPD0gZW5kOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5faHJlZi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBDT0RFX0NPTE9OKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcnRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29kZSA9PT0gQ09ERV9BVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2VybmFtZSB3aXRob3V0IHBhc3N3b3JkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VzZXJuYW1lID0gdGhpcy5faHJlZi5zbGljZShzdGFydCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Bhc3N3b3JkID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHRyYWN0SG9zdG5hbWUoaSArIDEsIGVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChCUkVBS19IT1NUX09OLmluZGV4T2YoY29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29kZSA8PSAweDIwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY2hhcmFjdGVyICcke3RoaXMuaHJlZltpXX0nIGluIGhvc3RuYW1lYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkge1xuICAgICAgICAgICAgICAgICAgICBoYXNVcHBlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvc3RuYW1lRW5kID0gIXN0b3BwZWQgPyBpICsgMSA6IGk7XG4gICAgICAgIGlmIChoYXNVcHBlcikge1xuICAgICAgICAgICAgdGhpcy5faHJlZiA9IGAke3RoaXMuX2hyZWYuc2xpY2UoMCwgc3RhcnQpfSR7dGhpcy5faHJlZlxuICAgICAgICAgICAgICAgIC5zbGljZShzdGFydCwgaG9zdG5hbWVFbmQpXG4gICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCl9JHt0aGlzLl9ocmVmLnNsaWNlKGhvc3RuYW1lRW5kKX1gO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hvc3RuYW1lID0gdGhpcy5faHJlZi5zbGljZShzdGFydCwgaG9zdG5hbWVFbmQpO1xuICAgICAgICBpZiAocG9ydEluZGV4ID4gMCkge1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgY29uc3QgcG9ydFN0YXJ0ID0gaTtcbiAgICAgICAgICAgIGxldCBub25OdW1lcmljID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKDsgaSA8PSBlbmQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLl9ocmVmLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKEJSRUFLX0hPU1RfT04uaW5kZXhPZihjb2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9ydCA9IHRoaXMuX2hyZWYuc2xpY2UocG9ydFN0YXJ0LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPT09IENPREVfQVQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgYWN0dWFsbHkgYSB1c2VybmFtZSBhbmQgcGFzc3dvcmQgLSBleHRyYWN0IHVzZXI6cGFzcywgdGhlblxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJzZSB0aGUgcmVzdCBhcyBhIHBsYWluIGhvc3RuYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VzZXJuYW1lID0gdGhpcy5faHJlZi5zbGljZShzdGFydCwgcG9ydEluZGV4IHx8IGkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXNzd29yZCA9IHRoaXMuX2hyZWYuc2xpY2UocG9ydEluZGV4ICsgMSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHRyYWN0SG9zdG5hbWUoaSArIDEsIGVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9uIG51bWVyaWMgY2hhcmFjdGVyIGluIHBvcnRcbiAgICAgICAgICAgICAgICAgICAgbm9uTnVtZXJpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9wb3J0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9ydCA9IHRoaXMuaHJlZi5zbGljZShwb3J0U3RhcnQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdmFsaWRhdGUgcG9ydCAtIGNhbm5vdCBjb250YWluIG5vbi1udW1lcmljIGNoYXJhY3RlcnNcbiAgICAgICAgICAgIGlmIChub25OdW1lcmljKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBVUkw6IHBvcnQgY29udGFpbnMgbm9uIG51bWVyaWMgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIDY1NTM1XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9ydC5sZW5ndGggPj0gNSAmJiArdGhpcy5fcG9ydCA+IDY1NTM1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBVUkw6IGludmFsaWQgcG9ydCBudW1iZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ob3N0ID0gdGhpcy5faHJlZi5zbGljZShzdGFydCwgIXN0b3BwZWQgPyBpICsgMSA6IGkpO1xuICAgICAgICB0aGlzLm9yaWdpbiA9IGAke3RoaXMuX3Byb3RvY29sfS8vJHt0aGlzLl9ob3N0fWA7XG4gICAgICAgIHJldHVybiAhc3RvcHBlZCA/IGkgKyAxIDogaTtcbiAgICB9XG4gICAgX2V4dHJhY3RQYXJhbXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5U3RhcnRJbmRleCA+IDApIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMucXVlcnlTdGFydEluZGV4O1xuICAgICAgICAgICAgY29uc3QgZW5kID0gdGhpcy5ocmVmLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAodGhpcy5ocmVmLmNoYXJDb2RlQXQoaW5kZXgpID09PSBDT0RFX1FVRVNUSU9OX01BUkspIHtcbiAgICAgICAgICAgICAgICBsZXQgYnJva2VuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICg7IGluZGV4IDw9IGVuZDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ocmVmLmNoYXJDb2RlQXQoaW5kZXgpID09PSBDT0RFX0hBU0gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9zZWFyY2ggPSB0aGlzLmhyZWYuc2xpY2UodGhpcy5xdWVyeVN0YXJ0SW5kZXgsIGJyb2tlbiA/IGluZGV4IDogZW5kICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlYXJjaC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VhcmNoID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaHJlZi5jaGFyQ29kZUF0KGluZGV4KSA9PT0gQ09ERV9IQVNIKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzaCA9IHRoaXMuaHJlZi5zbGljZShpbmRleCwgZW5kICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2V4dHJhY3RTZWFyY2hQYXJhbXMoKSB7XG4gICAgICAgIHRoaXMuaXNRdWVyeVBhcnNlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5U3RhcnRJbmRleCA9PT0gMCAmJiB0aGlzLnBhcmFtZXRlclN0YXJ0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMucGFyYW1ldGVyU3RhcnRJbmRleCB8fCB0aGlzLnF1ZXJ5U3RhcnRJbmRleDtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5ocmVmLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCBpbmRleCA9IHN0YXJ0O1xuICAgICAgICBpZiAodGhpcy5ocmVmLmNoYXJDb2RlQXQoaW5kZXgpID09PSBDT0RFX1NFTUlDT0xPTikge1xuICAgICAgICAgICAgLy8gcGFyYW1ldGVyIHN0cmluZyBzdGFydHMgaGVyZVxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9leHRyYWN0UGFyYW1UdXBsZXMoaW5kZXggKyAxLCBlbmQsIHRoaXMuX3BhcmFtZXRlcnMsIFtDT0RFX1NFTUlDT0xPTl0sIENPREVfRVFVQUxTLCBbQ09ERV9RVUVTVElPTl9NQVJLLCBDT0RFX0hBU0hdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ocmVmLmNoYXJDb2RlQXQoaW5kZXgpID09PSBDT0RFX1FVRVNUSU9OX01BUkspIHtcbiAgICAgICAgICAgIC8vIHF1ZXJ5IHN0cmluZyBzdGFydHMgaGVyZVxuICAgICAgICAgICAgY29uc3Qgc2VhcmNoU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5fZXh0cmFjdFBhcmFtVHVwbGVzKGluZGV4ICsgMSwgZW5kLCB0aGlzLl9xdWVyeSwgW0NPREVfQU1QRVJTQU5EXSwgQ09ERV9FUVVBTFMsIFtDT0RFX0hBU0hdKTtcbiAgICAgICAgICAgIHRoaXMuX3NlYXJjaCA9IHRoaXMuaHJlZi5zbGljZShzZWFyY2hTdGFydCwgaW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NlYXJjaC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWFyY2ggPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ocmVmLmNoYXJDb2RlQXQoaW5kZXgpID09PSBDT0RFX0hBU0gpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc2ggPSB0aGlzLmhyZWYuc2xpY2UoaW5kZXgsIGVuZCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9leHRyYWN0UGFyYW1UdXBsZXMoc3RhcnQsIGVuZCwgcGFyYW1zLCBzZXBhcmF0b3JzLCBlcXVhbHMsIGJyZWFrQ29kZXMpIHtcbiAgICAgICAgcmV0dXJuIGV4dHJhY3RQYXJhbXModGhpcy5ocmVmLCBzdGFydCwgZW5kLCBwYXJhbXMsIHNlcGFyYXRvcnMsIGVxdWFscywgYnJlYWtDb2Rlcyk7XG4gICAgfVxuICAgIHBhcnNlKHVybCkge1xuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycgfHwgdXJsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt1cmx9IGlzIG5vdCBhIHZhbGlkIFVSTGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Byb3RvY29sID0gJyc7XG4gICAgICAgIHRoaXMuX2hvc3RuYW1lID0gJyc7XG4gICAgICAgIHRoaXMuX2hvc3QgPSAnJztcbiAgICAgICAgdGhpcy5fcG9ydCA9ICcnO1xuICAgICAgICB0aGlzLl9wYXRobmFtZSA9ICcnO1xuICAgICAgICB0aGlzLl91c2VybmFtZSA9ICcnO1xuICAgICAgICB0aGlzLl9wYXNzd29yZCA9ICcnO1xuICAgICAgICB0aGlzLl9zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5faGFzaCA9ICcnO1xuICAgICAgICB0aGlzLnBhcmFtZXRlclN0YXJ0SW5kZXggPSAwO1xuICAgICAgICB0aGlzLnF1ZXJ5U3RhcnRJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuaXNRdWVyeVBhcnNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICB0aGlzLl9xdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgdGhpcy5fZG9tYWluSW5mbyA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyc2VkUGFyYW1ldGVycyA9IG51bGw7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIC8vIGVuZCBpcyB3aXRoaW4gYm91bmQgb2YgdXJsXG4gICAgICAgIGxldCBlbmQgPSB1cmwubGVuZ3RoIC0gMTtcbiAgICAgICAgLy8gY3V0IHdoaXRlc3BhY2UgZnJvbSB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdXJsXG4gICAgICAgIHdoaWxlICh1cmwuY2hhckNvZGVBdChpbmRleCkgPD0gMHgyMCkge1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodXJsLmNoYXJDb2RlQXQoZW5kKSA8PSAweDIwKSB7XG4gICAgICAgICAgICBlbmQgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ocmVmID0gdXJsLnNsaWNlKGluZGV4LCBlbmQgKyAxKTtcbiAgICAgICAgZW5kID0gdGhpcy5faHJlZi5sZW5ndGggLSAxO1xuICAgICAgICBsZXQgaGFzVXBwZXIgPSBmYWxzZTtcbiAgICAgICAgLy8gUGFyc2UgcHJvdG9jb2xcbiAgICAgICAgZm9yICg7IGluZGV4IDw9IGVuZDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2hyZWYuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gQ09ERV9DT0xPTikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sID0gdGhpcy5faHJlZi5zbGljZSgwLCBpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNVcHBlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbCA9IHRoaXMuX3Byb3RvY29sLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hyZWYgPSBgJHt0aGlzLl9wcm90b2NvbH0ke3RoaXMuX2hyZWYuc2xpY2UoaW5kZXggKyAxKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1ZhbGlkUHJvdG9jb2xDaGFyKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9uIGFscGhhYmV0IGNoYXJhY3RlciBpbiBwcm90b2NvbCAtIG5vdCBhIHZhbGlkIHByb3RvY29sXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBVUkwgcHJvdG9jb2wnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkge1xuICAgICAgICAgICAgICAgIGhhc1VwcGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPj0gZW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBwcm90b2NvbCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgJy8nIGFmdGVyICc6J1xuICAgICAgICB0aGlzLnNsYXNoZXMgPSAnJztcbiAgICAgICAgZm9yIChpbmRleCArPSAxOyBpbmRleCA8IGVuZDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hyZWYuY2hhckNvZGVBdChpbmRleCkgIT09IENPREVfRk9SV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zbGFzaGVzICs9ICcvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zbGFzaGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAvLyBUd28gc2xhc2hlczogQXV0aG9yaXR5IGlzIGluY2x1ZGVkXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuX2V4dHJhY3RIb3N0bmFtZShpbmRleCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIGF1dGhvcml0eVxuICAgICAgICAgICAgdGhpcy5faG9zdCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5faG9zdG5hbWUgPSAnJztcbiAgICAgICAgICAgIHRoaXMub3JpZ2luID0gJ251bGwnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+PSBlbmQpIHtcbiAgICAgICAgICAgIC8vIGFkZCB0cmFpbGluZyBzbGFzaCBpZiBtaXNzaW5nXG4gICAgICAgICAgICBpZiAodGhpcy5faHJlZi5jaGFyQ29kZUF0KGVuZCkgIT09IENPREVfRk9SV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hyZWYgKz0gJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGF0aG5hbWUgPSAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgIGZvciAoOyBpbmRleCA8PSBlbmQ7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5faHJlZi5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gQ09ERV9TRU1JQ09MT04gJiYgIXRoaXMucGFyYW1ldGVyU3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlclN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29kZSA9PT0gQ09ERV9RVUVTVElPTl9NQVJLIHx8IGNvZGUgPT09IENPREVfSEFTSCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5U3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wYXRobmFtZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5ocmVmLnNsaWNlKHBhdGhTdGFydCwgdGhpcy5xdWVyeVN0YXJ0SW5kZXggIT09IDAgPyB0aGlzLnF1ZXJ5U3RhcnRJbmRleCA6IGVuZCArIDEpIHx8ICcvJztcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltbXV0YWJsZS11cmwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/url-parser/dist/esm/immutable-url.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/url-parser/dist/esm/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ghostery/url-parser/dist/esm/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImmutableURL: () => (/* reexport safe */ _immutable_url_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   URL: () => (/* reexport safe */ _url_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   URLSearchParams: () => (/* reexport safe */ _url_search_params_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   getPunycodeEncoded: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_3__.getPunycodeEncoded)\n/* harmony export */ });\n/* harmony import */ var _url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url.js */ \"(rsc)/./node_modules/@ghostery/url-parser/dist/esm/url.js\");\n/* harmony import */ var _immutable_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./immutable-url.js */ \"(rsc)/./node_modules/@ghostery/url-parser/dist/esm/immutable-url.js\");\n/* harmony import */ var _url_search_params_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-search-params.js */ \"(rsc)/./node_modules/@ghostery/url-parser/dist/esm/url-search-params.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@ghostery/url-parser/dist/esm/utils.js\");\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L3VybC1wYXJzZXIvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMEM7QUFDbUI7QUFDTztBQUNwQjtBQUNoRCIsInNvdXJjZXMiOlsid2VicGFjazovL2dyaWRsaXRlLy4vbm9kZV9tb2R1bGVzL0BnaG9zdGVyeS91cmwtcGFyc2VyL2Rpc3QvZXNtL2luZGV4LmpzP2RjZDkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCBhcyBVUkwgfSBmcm9tICcuL3VybC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEltbXV0YWJsZVVSTCB9IGZyb20gJy4vaW1tdXRhYmxlLXVybC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFVSTFNlYXJjaFBhcmFtcyB9IGZyb20gJy4vdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuZXhwb3J0IHsgZ2V0UHVueWNvZGVFbmNvZGVkIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/url-parser/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/url-parser/dist/esm/search-params-wrapper.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ghostery/url-parser/dist/esm/search-params-wrapper.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ URLSearchParamsWrapper)\n/* harmony export */ });\n/* harmony import */ var _url_search_params_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url-search-params.js */ \"(rsc)/./node_modules/@ghostery/url-parser/dist/esm/url-search-params.js\");\n\n/**\n * Wraps URLSearchParams and pushes changes in search string to a parent\n * URL instance.\n */\nclass URLSearchParamsWrapper extends _url_search_params_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(url, init) {\n        super();\n        this.url = url;\n        this.params = init.params;\n    }\n    append(name, value) {\n        super.append(name, value);\n        this.url.search = this.toString();\n    }\n    delete(name) {\n        super.delete(name);\n        this.url.search = this.toString();\n    }\n    set(name, value) {\n        super.set(name, value);\n        this.url.search = this.toString();\n    }\n    sort() {\n        super.sort();\n        this.url.search = this.toString();\n    }\n}\n//# sourceMappingURL=search-params-wrapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L3VybC1wYXJzZXIvZGlzdC9lc20vc2VhcmNoLXBhcmFtcy13cmFwcGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ2UscUNBQXFDLDZEQUFlO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvdXJsLXBhcnNlci9kaXN0L2VzbS9zZWFyY2gtcGFyYW1zLXdyYXBwZXIuanM/ZWJiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVVJMU2VhcmNoUGFyYW1zIGZyb20gJy4vdXJsLXNlYXJjaC1wYXJhbXMuanMnO1xuLyoqXG4gKiBXcmFwcyBVUkxTZWFyY2hQYXJhbXMgYW5kIHB1c2hlcyBjaGFuZ2VzIGluIHNlYXJjaCBzdHJpbmcgdG8gYSBwYXJlbnRcbiAqIFVSTCBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVVJMU2VhcmNoUGFyYW1zV3JhcHBlciBleHRlbmRzIFVSTFNlYXJjaFBhcmFtcyB7XG4gICAgY29uc3RydWN0b3IodXJsLCBpbml0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IGluaXQucGFyYW1zO1xuICAgIH1cbiAgICBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoID0gdGhpcy50b1N0cmluZygpO1xuICAgIH1cbiAgICBkZWxldGUobmFtZSkge1xuICAgICAgICBzdXBlci5kZWxldGUobmFtZSk7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaCA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaCA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgc29ydCgpIHtcbiAgICAgICAgc3VwZXIuc29ydCgpO1xuICAgICAgICB0aGlzLnVybC5zZWFyY2ggPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VhcmNoLXBhcmFtcy13cmFwcGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/url-parser/dist/esm/search-params-wrapper.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/url-parser/dist/esm/url-search-params.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@ghostery/url-parser/dist/esm/url-search-params.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SearchParams),\n/* harmony export */   extractParams: () => (/* binding */ extractParams)\n/* harmony export */ });\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const.js */ \"(rsc)/./node_modules/@ghostery/url-parser/dist/esm/const.js\");\n\nclass SearchParams {\n    get [Symbol.toStringTag]() {\n        return 'URLSearchParams';\n    }\n    constructor(init) {\n        this.isEncoded = false;\n        this.params = [];\n        if (typeof init === 'string') {\n            extractParams(init, init[0] === '?' ? 1 : 0, init.length, this, [_const_js__WEBPACK_IMPORTED_MODULE_0__.CODE_AMPERSAND], _const_js__WEBPACK_IMPORTED_MODULE_0__.CODE_EQUALS, [], {\n                encode: true,\n            });\n        }\n        else if (Array.isArray(init)) {\n            init.forEach((kv) => {\n                this.append(kv[0], kv[1]);\n            });\n        }\n        else if (typeof init === 'object') {\n            Object.keys(init).forEach((key) => {\n                this.append(key, init[key]);\n            });\n        }\n    }\n    *entries() {\n        for (let i = 0; i < this.params.length; i += 1) {\n            yield [\n                optionalDecode(this.params[i][0]),\n                optionalDecode(this.params[i][1]),\n            ];\n        }\n    }\n    append(name, value) {\n        this.params.push([encodeParameter(name), encodeParameter(value)]);\n    }\n    delete(name) {\n        this.params = this.params.filter(([key]) => optionalDecode(key) !== name);\n    }\n    forEach(callback) {\n        this.params.forEach(([key, value]) => {\n            callback(optionalDecode(value), optionalDecode(key), this);\n        });\n    }\n    get(name) {\n        const entry = this.params.find(([k]) => optionalDecode(k) === name);\n        if (entry) {\n            return optionalDecode(entry[1]);\n        }\n        return null;\n    }\n    getAll(name) {\n        return this.params\n            .filter(([key]) => optionalDecode(key) === name)\n            .map((kv) => kv[1]);\n    }\n    has(name) {\n        return this.get(name) !== null;\n    }\n    *keys() {\n        for (let i = 0; i < this.params.length; i += 1) {\n            yield optionalDecode(this.params[i][0]);\n        }\n    }\n    /**\n     * The set() method of the URLSearchParams interface sets the value associated with a given\n     * search parameter to the given value. If there were several matching values, this method\n     * deletes the others. If the search parameter doesn't exist, this method creates it.\n     * @param name\n     * @param value\n     */\n    set(name, value) {\n        const firstIndex = this.params.findIndex(([k]) => optionalDecode(k) === name);\n        if (firstIndex === -1) {\n            this.append(name, value);\n            return;\n        }\n        this.delete(name);\n        this.params.splice(firstIndex, 0, [\n            encodeParameter(name),\n            encodeParameter(value),\n        ]);\n    }\n    sort() {\n        this.params = this.params.sort((a, b) => a[0].localeCompare(b[0]));\n    }\n    toString() {\n        return this.params.map(([k, v]) => `${k}=${v}`).join('&');\n    }\n    *values() {\n        for (let i = 0; i < this.params.length; i += 1) {\n            yield optionalDecode(this.params[i][1]);\n        }\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    get size() {\n        return this.params.length;\n    }\n}\nfunction extractParams(urlString, start, end, params, separators, equals, breakCodes, { encode } = { encode: false }) {\n    let index = start;\n    let keyStart = index;\n    let keyEnd = 0;\n    let valStart = 0;\n    const appendParams = encode\n        ? params.append.bind(params)\n        : (n, v) => params.params.push([n, v]);\n    for (; index <= end; index += 1) {\n        const code = urlString.charCodeAt(index);\n        if (code === equals && keyEnd === 0) {\n            keyEnd = index;\n            valStart = index + 1;\n        }\n        else if (separators.indexOf(code) !== -1) {\n            // don't add if key and value are empty\n            if (index > keyStart) {\n                // push directly to the params array to skip encoding step\n                appendParams(urlString.slice(keyStart, keyEnd || index), urlString.slice(valStart || index, index));\n            }\n            keyStart = index + 1;\n            keyEnd = 0;\n            valStart = 0;\n        }\n        else if (breakCodes.indexOf(code) !== -1) {\n            break;\n        }\n    }\n    // push last key-value\n    if (index !== keyStart) {\n        appendParams(urlString.slice(keyStart, keyEnd || index), urlString.slice(valStart || index, index));\n    }\n    return index;\n}\nfunction optionalDecode(s) {\n    if (s.indexOf('%') !== -1) {\n        try {\n            return decodeURIComponent(s.replace(/\\+/g, ' '));\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        }\n        catch (_e) {\n            return s;\n        }\n    }\n    else {\n        return s;\n    }\n}\nfunction encodeParameter(_s) {\n    const s = '' + _s;\n    let encoded = '';\n    for (let i = 0; i < s.length; i++) {\n        if (s.charCodeAt(i) === _const_js__WEBPACK_IMPORTED_MODULE_0__.CODE_SPACE) {\n            encoded += '+';\n        }\n        else {\n            encoded += encodeURIComponent(s[i]);\n        }\n    }\n    return encoded;\n}\n//# sourceMappingURL=url-search-params.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L3VybC1wYXJzZXIvZGlzdC9lc20vdXJsLXNlYXJjaC1wYXJhbXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFFO0FBQ3REO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUscURBQWMsR0FBRyxrREFBVztBQUN6RztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEVBQUUsR0FBRyxFQUFFO0FBQ3JEO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0ZBQXdGLFNBQVMsSUFBSSxlQUFlO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDLGdDQUFnQyxpREFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvdXJsLXBhcnNlci9kaXN0L2VzbS91cmwtc2VhcmNoLXBhcmFtcy5qcz82NmQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENPREVfQU1QRVJTQU5ELCBDT0RFX0VRVUFMUywgQ09ERV9TUEFDRSB9IGZyb20gJy4vY29uc3QuanMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoUGFyYW1zIHtcbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiAnVVJMU2VhcmNoUGFyYW1zJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaW5pdCkge1xuICAgICAgICB0aGlzLmlzRW5jb2RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtdO1xuICAgICAgICBpZiAodHlwZW9mIGluaXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBleHRyYWN0UGFyYW1zKGluaXQsIGluaXRbMF0gPT09ICc/JyA/IDEgOiAwLCBpbml0Lmxlbmd0aCwgdGhpcywgW0NPREVfQU1QRVJTQU5EXSwgQ09ERV9FUVVBTFMsIFtdLCB7XG4gICAgICAgICAgICAgICAgZW5jb2RlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbml0KSkge1xuICAgICAgICAgICAgaW5pdC5mb3JFYWNoKChrdikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKGt2WzBdLCBrdlsxXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5pdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGluaXQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKGtleSwgaW5pdFtrZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgICplbnRyaWVzKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFyYW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB5aWVsZCBbXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxEZWNvZGUodGhpcy5wYXJhbXNbaV1bMF0pLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsRGVjb2RlKHRoaXMucGFyYW1zW2ldWzFdKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMucGFyYW1zLnB1c2goW2VuY29kZVBhcmFtZXRlcihuYW1lKSwgZW5jb2RlUGFyYW1ldGVyKHZhbHVlKV0pO1xuICAgIH1cbiAgICBkZWxldGUobmFtZSkge1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHRoaXMucGFyYW1zLmZpbHRlcigoW2tleV0pID0+IG9wdGlvbmFsRGVjb2RlKGtleSkgIT09IG5hbWUpO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucGFyYW1zLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2sob3B0aW9uYWxEZWNvZGUodmFsdWUpLCBvcHRpb25hbERlY29kZShrZXkpLCB0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldChuYW1lKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5wYXJhbXMuZmluZCgoW2tdKSA9PiBvcHRpb25hbERlY29kZShrKSA9PT0gbmFtZSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbmFsRGVjb2RlKGVudHJ5WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0QWxsKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zXG4gICAgICAgICAgICAuZmlsdGVyKChba2V5XSkgPT4gb3B0aW9uYWxEZWNvZGUoa2V5KSA9PT0gbmFtZSlcbiAgICAgICAgICAgIC5tYXAoKGt2KSA9PiBrdlsxXSk7XG4gICAgfVxuICAgIGhhcyhuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChuYW1lKSAhPT0gbnVsbDtcbiAgICB9XG4gICAgKmtleXMoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJhbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHlpZWxkIG9wdGlvbmFsRGVjb2RlKHRoaXMucGFyYW1zW2ldWzBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2V0KCkgbWV0aG9kIG9mIHRoZSBVUkxTZWFyY2hQYXJhbXMgaW50ZXJmYWNlIHNldHMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuXG4gICAgICogc2VhcmNoIHBhcmFtZXRlciB0byB0aGUgZ2l2ZW4gdmFsdWUuIElmIHRoZXJlIHdlcmUgc2V2ZXJhbCBtYXRjaGluZyB2YWx1ZXMsIHRoaXMgbWV0aG9kXG4gICAgICogZGVsZXRlcyB0aGUgb3RoZXJzLiBJZiB0aGUgc2VhcmNoIHBhcmFtZXRlciBkb2Vzbid0IGV4aXN0LCB0aGlzIG1ldGhvZCBjcmVhdGVzIGl0LlxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0SW5kZXggPSB0aGlzLnBhcmFtcy5maW5kSW5kZXgoKFtrXSkgPT4gb3B0aW9uYWxEZWNvZGUoaykgPT09IG5hbWUpO1xuICAgICAgICBpZiAoZmlyc3RJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgdGhpcy5wYXJhbXMuc3BsaWNlKGZpcnN0SW5kZXgsIDAsIFtcbiAgICAgICAgICAgIGVuY29kZVBhcmFtZXRlcihuYW1lKSxcbiAgICAgICAgICAgIGVuY29kZVBhcmFtZXRlcih2YWx1ZSksXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBzb3J0KCkge1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHRoaXMucGFyYW1zLnNvcnQoKGEsIGIpID0+IGFbMF0ubG9jYWxlQ29tcGFyZShiWzBdKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMubWFwKChbaywgdl0pID0+IGAke2t9PSR7dn1gKS5qb2luKCcmJyk7XG4gICAgfVxuICAgICp2YWx1ZXMoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJhbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHlpZWxkIG9wdGlvbmFsRGVjb2RlKHRoaXMucGFyYW1zW2ldWzFdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmxlbmd0aDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhcmFtcyh1cmxTdHJpbmcsIHN0YXJ0LCBlbmQsIHBhcmFtcywgc2VwYXJhdG9ycywgZXF1YWxzLCBicmVha0NvZGVzLCB7IGVuY29kZSB9ID0geyBlbmNvZGU6IGZhbHNlIH0pIHtcbiAgICBsZXQgaW5kZXggPSBzdGFydDtcbiAgICBsZXQga2V5U3RhcnQgPSBpbmRleDtcbiAgICBsZXQga2V5RW5kID0gMDtcbiAgICBsZXQgdmFsU3RhcnQgPSAwO1xuICAgIGNvbnN0IGFwcGVuZFBhcmFtcyA9IGVuY29kZVxuICAgICAgICA/IHBhcmFtcy5hcHBlbmQuYmluZChwYXJhbXMpXG4gICAgICAgIDogKG4sIHYpID0+IHBhcmFtcy5wYXJhbXMucHVzaChbbiwgdl0pO1xuICAgIGZvciAoOyBpbmRleCA8PSBlbmQ7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHVybFN0cmluZy5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgaWYgKGNvZGUgPT09IGVxdWFscyAmJiBrZXlFbmQgPT09IDApIHtcbiAgICAgICAgICAgIGtleUVuZCA9IGluZGV4O1xuICAgICAgICAgICAgdmFsU3RhcnQgPSBpbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VwYXJhdG9ycy5pbmRleE9mKGNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gZG9uJ3QgYWRkIGlmIGtleSBhbmQgdmFsdWUgYXJlIGVtcHR5XG4gICAgICAgICAgICBpZiAoaW5kZXggPiBrZXlTdGFydCkge1xuICAgICAgICAgICAgICAgIC8vIHB1c2ggZGlyZWN0bHkgdG8gdGhlIHBhcmFtcyBhcnJheSB0byBza2lwIGVuY29kaW5nIHN0ZXBcbiAgICAgICAgICAgICAgICBhcHBlbmRQYXJhbXModXJsU3RyaW5nLnNsaWNlKGtleVN0YXJ0LCBrZXlFbmQgfHwgaW5kZXgpLCB1cmxTdHJpbmcuc2xpY2UodmFsU3RhcnQgfHwgaW5kZXgsIGluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXlTdGFydCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgIGtleUVuZCA9IDA7XG4gICAgICAgICAgICB2YWxTdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnJlYWtDb2Rlcy5pbmRleE9mKGNvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcHVzaCBsYXN0IGtleS12YWx1ZVxuICAgIGlmIChpbmRleCAhPT0ga2V5U3RhcnQpIHtcbiAgICAgICAgYXBwZW5kUGFyYW1zKHVybFN0cmluZy5zbGljZShrZXlTdGFydCwga2V5RW5kIHx8IGluZGV4KSwgdXJsU3RyaW5nLnNsaWNlKHZhbFN0YXJ0IHx8IGluZGV4LCBpbmRleCkpO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBvcHRpb25hbERlY29kZShzKSB7XG4gICAgaWYgKHMuaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG59XG5mdW5jdGlvbiBlbmNvZGVQYXJhbWV0ZXIoX3MpIHtcbiAgICBjb25zdCBzID0gJycgKyBfcztcbiAgICBsZXQgZW5jb2RlZCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocy5jaGFyQ29kZUF0KGkpID09PSBDT0RFX1NQQUNFKSB7XG4gICAgICAgICAgICBlbmNvZGVkICs9ICcrJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuY29kZWQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsLXNlYXJjaC1wYXJhbXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/url-parser/dist/esm/url-search-params.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/url-parser/dist/esm/url.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ghostery/url-parser/dist/esm/url.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const.js */ \"(rsc)/./node_modules/@ghostery/url-parser/dist/esm/const.js\");\n/* harmony import */ var _immutable_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./immutable-url.js */ \"(rsc)/./node_modules/@ghostery/url-parser/dist/esm/immutable-url.js\");\n/* harmony import */ var _search_params_wrapper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./search-params-wrapper.js */ \"(rsc)/./node_modules/@ghostery/url-parser/dist/esm/search-params-wrapper.js\");\n\n\n\nfunction mutate(url, changes) {\n    const self = {\n        hash: changes.hash !== undefined ? changes.hash : url.hash,\n        host: changes.host !== undefined ? changes.host : url.host,\n        hostname: changes.hostname !== undefined ? changes.hostname : url.hostname,\n        password: changes.password !== undefined ? changes.password : url.password,\n        pathname: changes.pathname !== undefined ? changes.pathname : url.pathname,\n        port: changes.port !== undefined ? changes.port : url.port,\n        protocol: changes.protocol !== undefined ? changes.protocol : url.protocol,\n        search: changes.search !== undefined ? changes.search : url.search,\n        username: changes.username !== undefined ? changes.username : url.username,\n    };\n    if (changes.hostname || changes.port) {\n        if (self.protocol === 'https:' && self.port === '443') {\n            self.port = '';\n        }\n        else if (self.protocol === 'http:' && self.port === '80') {\n            self.port = '';\n        }\n        self.host = `${self.hostname}${self.port ? ':' : ''}${self.port}`;\n    }\n    const user = self.username\n        ? self.password\n            ? `${self.username}:${self.password}@`\n            : `${self.username}@`\n        : self.password\n            ? `:${self.password}@`\n            : '';\n    return new _immutable_url_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](`${self.protocol}${url.slashes}${user}${self.host}${self.pathname}${self.search}${self.hash}`);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (class {\n    get [Symbol.toStringTag]() {\n        return 'URL';\n    }\n    constructor(url) {\n        this.url = new _immutable_url_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](url);\n    }\n    get protocol() {\n        return this.url.protocol;\n    }\n    set protocol(value) {\n        const previousProtocol = this.url.protocol;\n        const colon = value.endsWith(':') ? '' : ':';\n        const href = `${value}${colon}${this.href.slice(previousProtocol.length)}`;\n        this.url = new _immutable_url_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](href);\n    }\n    get username() {\n        return this.url.username;\n    }\n    set username(value) {\n        this.url = mutate(this, {\n            username: value || '',\n        });\n    }\n    get password() {\n        return this.url.password;\n    }\n    set password(value) {\n        this.url = mutate(this, {\n            password: value || '',\n        });\n    }\n    get hostname() {\n        return this.url.hostname;\n    }\n    set hostname(value) {\n        this.url = mutate(this, {\n            hostname: value || '',\n        });\n    }\n    get host() {\n        return this.url.host;\n    }\n    set host(value) {\n        this.url = mutate(this, {\n            host: value,\n        });\n    }\n    get origin() {\n        return this.url.origin;\n    }\n    get port() {\n        return this.url.port;\n    }\n    set port(value) {\n        this.url = mutate(this, {\n            port: value || '',\n        });\n    }\n    get pathname() {\n        return this.url.pathname;\n    }\n    set pathname(value) {\n        const pathname = value.charCodeAt(0) === _const_js__WEBPACK_IMPORTED_MODULE_0__.CODE_FORWARD_SLASH ? value : `/${value}`;\n        this.url = mutate(this, {\n            pathname,\n        });\n    }\n    /**\n     * The query string component of the URL, including the preceding `?` character.\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/search\n     */\n    get search() {\n        return this.url.search;\n    }\n    set search(value) {\n        const newQuery = value.charCodeAt(0) === _const_js__WEBPACK_IMPORTED_MODULE_0__.CODE_QUESTION_MARK ? value.slice(1) : value;\n        this.url = mutate(this, {\n            search: newQuery.length > 0 ? `?${newQuery}` : '',\n        });\n    }\n    /**\n     * Parsed query string parameters, as a `URLSearchParams` object.\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams\n     */\n    get searchParams() {\n        return new _search_params_wrapper_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this, this.url.searchParams);\n    }\n    /**\n     * Parsed parameter string from the url. These are `;` separated key/values appearing in the URL\n     * path, before the query string.\n     */\n    get parameters() {\n        return this.url.parameters;\n    }\n    /**\n     * Check if the URL has a parameter string\n     * @returns true iff `;` occurs in the URL path before a `?`.\n     */\n    hasParameterString() {\n        return this.url.hasParameterString();\n    }\n    /**\n     * URL hash or fragment component.\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/hash\n     */\n    get hash() {\n        return this.url.hash;\n    }\n    set hash(value) {\n        const newHash = value.charCodeAt(0) === _const_js__WEBPACK_IMPORTED_MODULE_0__.CODE_HASH ? value.slice(1) : value;\n        this.url = mutate(this, {\n            hash: newHash.length > 0 ? `#${newHash}` : '',\n        });\n    }\n    get href() {\n        return this.url.href;\n    }\n    set href(value) {\n        this.url = new _immutable_url_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](value);\n    }\n    /**\n     * Returns the url (post parsing).\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/toString\n     */\n    toString() {\n        return this.href;\n    }\n    /**\n     * JSONified URL (== toString)\n     * See also: https://developer.mozilla.org/en-US/docs/Web/API/URL/toJSON\n     */\n    toJSON() {\n        return this.href;\n    }\n    /**\n     * Get parsed domainInfo from the hostname.\n     * @returns parsed domain, from tldts `parse` method.\n     */\n    get domainInfo() {\n        return this.url.domainInfo;\n    }\n    /**\n     * Returns true iff the hostname of this url is an IP address. False otherwise.\n     */\n    get hostIsIp() {\n        return this.url.hostIsIp;\n    }\n    /**\n     * Returns the hostname of the URL after parsing by tldts. This includes some error correction.\n     */\n    get domain() {\n        return this.url.domain;\n    }\n    /**\n     * Get eTLD+1 of the hostname.\n     */\n    get generalDomain() {\n        return this.url.generalDomain;\n    }\n    /**\n     * Legacy attribute for `pathname`.\n     */\n    get path() {\n        return this.url.path;\n    }\n    /**\n     * Scheme = protocol without a trailing ':'.\n     */\n    get scheme() {\n        return this.url.scheme;\n    }\n    get slashes() {\n        return this.url.slashes;\n    }\n    /**\n     * Check if the hostname of the URL is valid, i.e.\n     *  * it is an IP address, or\n     *  * it is a valid hostname with a known public suffix.\n     * @returns true if host is valid, otherwise false.\n     */\n    isValidHost() {\n        // if tldts was able to parse it, it's valid\n        return this.url.isValidHost();\n    }\n    /**\n     * Non-standard params extractor.\n     *\n     * Returns search params from parameter string and query params with more aggessive extraction\n     * than the standard URL implementation. Extra extraction features are:\n     *  * `;` separated parameters - used by multi trackers\n     * @returns URLSearchParams\n     */\n    extractKeyValues() {\n        return this.url.extractKeyValues();\n    }\n});\n//# sourceMappingURL=url.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L3VybC1wYXJzZXIvZGlzdC9lc20vdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0U7QUFDakM7QUFDa0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYyxFQUFFLHFCQUFxQixFQUFFLFVBQVU7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWMsR0FBRyxjQUFjO0FBQ2hELGlCQUFpQixjQUFjO0FBQy9CO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQSxlQUFlLHlEQUFZLElBQUksY0FBYyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxZQUFZLEVBQUUsVUFBVTtBQUN4SDtBQUNBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTSxFQUFFLE1BQU0sRUFBRSx5Q0FBeUM7QUFDakYsdUJBQXVCLHlEQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQseURBQWtCLGVBQWUsTUFBTTtBQUN4RjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx5REFBa0I7QUFDbkU7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlFQUFzQjtBQUN6QztBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnREFBUztBQUN6RDtBQUNBLDJDQUEyQyxRQUFRO0FBQ25ELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlEQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvdXJsLXBhcnNlci9kaXN0L2VzbS91cmwuanM/MGNjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDT0RFX0ZPUldBUkRfU0xBU0gsIENPREVfSEFTSCwgQ09ERV9RVUVTVElPTl9NQVJLIH0gZnJvbSAnLi9jb25zdC5qcyc7XG5pbXBvcnQgSW1tdXRhYmxlVVJMIGZyb20gJy4vaW1tdXRhYmxlLXVybC5qcyc7XG5pbXBvcnQgVVJMU2VhcmNoUGFyYW1zV3JhcHBlciBmcm9tICcuL3NlYXJjaC1wYXJhbXMtd3JhcHBlci5qcyc7XG5mdW5jdGlvbiBtdXRhdGUodXJsLCBjaGFuZ2VzKSB7XG4gICAgY29uc3Qgc2VsZiA9IHtcbiAgICAgICAgaGFzaDogY2hhbmdlcy5oYXNoICE9PSB1bmRlZmluZWQgPyBjaGFuZ2VzLmhhc2ggOiB1cmwuaGFzaCxcbiAgICAgICAgaG9zdDogY2hhbmdlcy5ob3N0ICE9PSB1bmRlZmluZWQgPyBjaGFuZ2VzLmhvc3QgOiB1cmwuaG9zdCxcbiAgICAgICAgaG9zdG5hbWU6IGNoYW5nZXMuaG9zdG5hbWUgIT09IHVuZGVmaW5lZCA/IGNoYW5nZXMuaG9zdG5hbWUgOiB1cmwuaG9zdG5hbWUsXG4gICAgICAgIHBhc3N3b3JkOiBjaGFuZ2VzLnBhc3N3b3JkICE9PSB1bmRlZmluZWQgPyBjaGFuZ2VzLnBhc3N3b3JkIDogdXJsLnBhc3N3b3JkLFxuICAgICAgICBwYXRobmFtZTogY2hhbmdlcy5wYXRobmFtZSAhPT0gdW5kZWZpbmVkID8gY2hhbmdlcy5wYXRobmFtZSA6IHVybC5wYXRobmFtZSxcbiAgICAgICAgcG9ydDogY2hhbmdlcy5wb3J0ICE9PSB1bmRlZmluZWQgPyBjaGFuZ2VzLnBvcnQgOiB1cmwucG9ydCxcbiAgICAgICAgcHJvdG9jb2w6IGNoYW5nZXMucHJvdG9jb2wgIT09IHVuZGVmaW5lZCA/IGNoYW5nZXMucHJvdG9jb2wgOiB1cmwucHJvdG9jb2wsXG4gICAgICAgIHNlYXJjaDogY2hhbmdlcy5zZWFyY2ggIT09IHVuZGVmaW5lZCA/IGNoYW5nZXMuc2VhcmNoIDogdXJsLnNlYXJjaCxcbiAgICAgICAgdXNlcm5hbWU6IGNoYW5nZXMudXNlcm5hbWUgIT09IHVuZGVmaW5lZCA/IGNoYW5nZXMudXNlcm5hbWUgOiB1cmwudXNlcm5hbWUsXG4gICAgfTtcbiAgICBpZiAoY2hhbmdlcy5ob3N0bmFtZSB8fCBjaGFuZ2VzLnBvcnQpIHtcbiAgICAgICAgaWYgKHNlbGYucHJvdG9jb2wgPT09ICdodHRwczonICYmIHNlbGYucG9ydCA9PT0gJzQ0MycpIHtcbiAgICAgICAgICAgIHNlbGYucG9ydCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGYucHJvdG9jb2wgPT09ICdodHRwOicgJiYgc2VsZi5wb3J0ID09PSAnODAnKSB7XG4gICAgICAgICAgICBzZWxmLnBvcnQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmhvc3QgPSBgJHtzZWxmLmhvc3RuYW1lfSR7c2VsZi5wb3J0ID8gJzonIDogJyd9JHtzZWxmLnBvcnR9YDtcbiAgICB9XG4gICAgY29uc3QgdXNlciA9IHNlbGYudXNlcm5hbWVcbiAgICAgICAgPyBzZWxmLnBhc3N3b3JkXG4gICAgICAgICAgICA/IGAke3NlbGYudXNlcm5hbWV9OiR7c2VsZi5wYXNzd29yZH1AYFxuICAgICAgICAgICAgOiBgJHtzZWxmLnVzZXJuYW1lfUBgXG4gICAgICAgIDogc2VsZi5wYXNzd29yZFxuICAgICAgICAgICAgPyBgOiR7c2VsZi5wYXNzd29yZH1AYFxuICAgICAgICAgICAgOiAnJztcbiAgICByZXR1cm4gbmV3IEltbXV0YWJsZVVSTChgJHtzZWxmLnByb3RvY29sfSR7dXJsLnNsYXNoZXN9JHt1c2VyfSR7c2VsZi5ob3N0fSR7c2VsZi5wYXRobmFtZX0ke3NlbGYuc2VhcmNofSR7c2VsZi5oYXNofWApO1xufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mge1xuICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgICAgcmV0dXJuICdVUkwnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICAgICAgdGhpcy51cmwgPSBuZXcgSW1tdXRhYmxlVVJMKHVybCk7XG4gICAgfVxuICAgIGdldCBwcm90b2NvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsLnByb3RvY29sO1xuICAgIH1cbiAgICBzZXQgcHJvdG9jb2wodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNQcm90b2NvbCA9IHRoaXMudXJsLnByb3RvY29sO1xuICAgICAgICBjb25zdCBjb2xvbiA9IHZhbHVlLmVuZHNXaXRoKCc6JykgPyAnJyA6ICc6JztcbiAgICAgICAgY29uc3QgaHJlZiA9IGAke3ZhbHVlfSR7Y29sb259JHt0aGlzLmhyZWYuc2xpY2UocHJldmlvdXNQcm90b2NvbC5sZW5ndGgpfWA7XG4gICAgICAgIHRoaXMudXJsID0gbmV3IEltbXV0YWJsZVVSTChocmVmKTtcbiAgICB9XG4gICAgZ2V0IHVzZXJuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cmwudXNlcm5hbWU7XG4gICAgfVxuICAgIHNldCB1c2VybmFtZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybCA9IG11dGF0ZSh0aGlzLCB7XG4gICAgICAgICAgICB1c2VybmFtZTogdmFsdWUgfHwgJycsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgcGFzc3dvcmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybC5wYXNzd29yZDtcbiAgICB9XG4gICAgc2V0IHBhc3N3b3JkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXJsID0gbXV0YXRlKHRoaXMsIHtcbiAgICAgICAgICAgIHBhc3N3b3JkOiB2YWx1ZSB8fCAnJyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBob3N0bmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsLmhvc3RuYW1lO1xuICAgIH1cbiAgICBzZXQgaG9zdG5hbWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy51cmwgPSBtdXRhdGUodGhpcywge1xuICAgICAgICAgICAgaG9zdG5hbWU6IHZhbHVlIHx8ICcnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGhvc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybC5ob3N0O1xuICAgIH1cbiAgICBzZXQgaG9zdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybCA9IG11dGF0ZSh0aGlzLCB7XG4gICAgICAgICAgICBob3N0OiB2YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBvcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybC5vcmlnaW47XG4gICAgfVxuICAgIGdldCBwb3J0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cmwucG9ydDtcbiAgICB9XG4gICAgc2V0IHBvcnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy51cmwgPSBtdXRhdGUodGhpcywge1xuICAgICAgICAgICAgcG9ydDogdmFsdWUgfHwgJycsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgcGF0aG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybC5wYXRobmFtZTtcbiAgICB9XG4gICAgc2V0IHBhdGhuYW1lKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gdmFsdWUuY2hhckNvZGVBdCgwKSA9PT0gQ09ERV9GT1JXQVJEX1NMQVNIID8gdmFsdWUgOiBgLyR7dmFsdWV9YDtcbiAgICAgICAgdGhpcy51cmwgPSBtdXRhdGUodGhpcywge1xuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcXVlcnkgc3RyaW5nIGNvbXBvbmVudCBvZiB0aGUgVVJMLCBpbmNsdWRpbmcgdGhlIHByZWNlZGluZyBgP2AgY2hhcmFjdGVyLlxuICAgICAqIFNlZSBhbHNvOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJML3NlYXJjaFxuICAgICAqL1xuICAgIGdldCBzZWFyY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybC5zZWFyY2g7XG4gICAgfVxuICAgIHNldCBzZWFyY2godmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3UXVlcnkgPSB2YWx1ZS5jaGFyQ29kZUF0KDApID09PSBDT0RFX1FVRVNUSU9OX01BUksgPyB2YWx1ZS5zbGljZSgxKSA6IHZhbHVlO1xuICAgICAgICB0aGlzLnVybCA9IG11dGF0ZSh0aGlzLCB7XG4gICAgICAgICAgICBzZWFyY2g6IG5ld1F1ZXJ5Lmxlbmd0aCA+IDAgPyBgPyR7bmV3UXVlcnl9YCA6ICcnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VkIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzLCBhcyBhIGBVUkxTZWFyY2hQYXJhbXNgIG9iamVjdC5cbiAgICAgKiBTZWUgYWxzbzogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9zZWFyY2hQYXJhbXNcbiAgICAgKi9cbiAgICBnZXQgc2VhcmNoUGFyYW1zKCkge1xuICAgICAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtc1dyYXBwZXIodGhpcywgdGhpcy51cmwuc2VhcmNoUGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VkIHBhcmFtZXRlciBzdHJpbmcgZnJvbSB0aGUgdXJsLiBUaGVzZSBhcmUgYDtgIHNlcGFyYXRlZCBrZXkvdmFsdWVzIGFwcGVhcmluZyBpbiB0aGUgVVJMXG4gICAgICogcGF0aCwgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcuXG4gICAgICovXG4gICAgZ2V0IHBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybC5wYXJhbWV0ZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgVVJMIGhhcyBhIHBhcmFtZXRlciBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmZiBgO2Agb2NjdXJzIGluIHRoZSBVUkwgcGF0aCBiZWZvcmUgYSBgP2AuXG4gICAgICovXG4gICAgaGFzUGFyYW1ldGVyU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cmwuaGFzUGFyYW1ldGVyU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVSTCBoYXNoIG9yIGZyYWdtZW50IGNvbXBvbmVudC5cbiAgICAgKiBTZWUgYWxzbzogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9oYXNoXG4gICAgICovXG4gICAgZ2V0IGhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybC5oYXNoO1xuICAgIH1cbiAgICBzZXQgaGFzaCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBuZXdIYXNoID0gdmFsdWUuY2hhckNvZGVBdCgwKSA9PT0gQ09ERV9IQVNIID8gdmFsdWUuc2xpY2UoMSkgOiB2YWx1ZTtcbiAgICAgICAgdGhpcy51cmwgPSBtdXRhdGUodGhpcywge1xuICAgICAgICAgICAgaGFzaDogbmV3SGFzaC5sZW5ndGggPiAwID8gYCMke25ld0hhc2h9YCA6ICcnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGhyZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybC5ocmVmO1xuICAgIH1cbiAgICBzZXQgaHJlZih2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybCA9IG5ldyBJbW11dGFibGVVUkwodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1cmwgKHBvc3QgcGFyc2luZykuXG4gICAgICogU2VlIGFsc286IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9VUkwvdG9TdHJpbmdcbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaHJlZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSlNPTmlmaWVkIFVSTCAoPT0gdG9TdHJpbmcpXG4gICAgICogU2VlIGFsc286IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9VUkwvdG9KU09OXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ocmVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgcGFyc2VkIGRvbWFpbkluZm8gZnJvbSB0aGUgaG9zdG5hbWUuXG4gICAgICogQHJldHVybnMgcGFyc2VkIGRvbWFpbiwgZnJvbSB0bGR0cyBgcGFyc2VgIG1ldGhvZC5cbiAgICAgKi9cbiAgICBnZXQgZG9tYWluSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsLmRvbWFpbkluZm87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZmYgdGhlIGhvc3RuYW1lIG9mIHRoaXMgdXJsIGlzIGFuIElQIGFkZHJlc3MuIEZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgaG9zdElzSXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybC5ob3N0SXNJcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaG9zdG5hbWUgb2YgdGhlIFVSTCBhZnRlciBwYXJzaW5nIGJ5IHRsZHRzLiBUaGlzIGluY2x1ZGVzIHNvbWUgZXJyb3IgY29ycmVjdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgZG9tYWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cmwuZG9tYWluO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZVRMRCsxIG9mIHRoZSBob3N0bmFtZS5cbiAgICAgKi9cbiAgICBnZXQgZ2VuZXJhbERvbWFpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsLmdlbmVyYWxEb21haW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlZ2FjeSBhdHRyaWJ1dGUgZm9yIGBwYXRobmFtZWAuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybC5wYXRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2hlbWUgPSBwcm90b2NvbCB3aXRob3V0IGEgdHJhaWxpbmcgJzonLlxuICAgICAqL1xuICAgIGdldCBzY2hlbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybC5zY2hlbWU7XG4gICAgfVxuICAgIGdldCBzbGFzaGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cmwuc2xhc2hlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGhvc3RuYW1lIG9mIHRoZSBVUkwgaXMgdmFsaWQsIGkuZS5cbiAgICAgKiAgKiBpdCBpcyBhbiBJUCBhZGRyZXNzLCBvclxuICAgICAqICAqIGl0IGlzIGEgdmFsaWQgaG9zdG5hbWUgd2l0aCBhIGtub3duIHB1YmxpYyBzdWZmaXguXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBob3N0IGlzIHZhbGlkLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICovXG4gICAgaXNWYWxpZEhvc3QoKSB7XG4gICAgICAgIC8vIGlmIHRsZHRzIHdhcyBhYmxlIHRvIHBhcnNlIGl0LCBpdCdzIHZhbGlkXG4gICAgICAgIHJldHVybiB0aGlzLnVybC5pc1ZhbGlkSG9zdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb24tc3RhbmRhcmQgcGFyYW1zIGV4dHJhY3Rvci5cbiAgICAgKlxuICAgICAqIFJldHVybnMgc2VhcmNoIHBhcmFtcyBmcm9tIHBhcmFtZXRlciBzdHJpbmcgYW5kIHF1ZXJ5IHBhcmFtcyB3aXRoIG1vcmUgYWdnZXNzaXZlIGV4dHJhY3Rpb25cbiAgICAgKiB0aGFuIHRoZSBzdGFuZGFyZCBVUkwgaW1wbGVtZW50YXRpb24uIEV4dHJhIGV4dHJhY3Rpb24gZmVhdHVyZXMgYXJlOlxuICAgICAqICAqIGA7YCBzZXBhcmF0ZWQgcGFyYW1ldGVycyAtIHVzZWQgYnkgbXVsdGkgdHJhY2tlcnNcbiAgICAgKiBAcmV0dXJucyBVUkxTZWFyY2hQYXJhbXNcbiAgICAgKi9cbiAgICBleHRyYWN0S2V5VmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cmwuZXh0cmFjdEtleVZhbHVlcygpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/url-parser/dist/esm/url.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ghostery/url-parser/dist/esm/utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ghostery/url-parser/dist/esm/utils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPunycodeEncoded: () => (/* binding */ getPunycodeEncoded)\n/* harmony export */ });\n/* harmony import */ var _url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url.js */ \"(rsc)/./node_modules/@ghostery/url-parser/dist/esm/url.js\");\n\n/**\n * Checks if this URL's hostname is non-ascii, and if so returns a new URL with the hostname\n * punycoded. Otherwise returns itself.\n */\nfunction getPunycodeEncoded(toASCII, url) {\n    const punycodedHost = toASCII(url.hostname);\n    if (punycodedHost !== url.hostname) {\n        return new _url_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](`${url.protocol}${url.slashes}${punycodedHost}${url.pathname}${url.search}${url.hash}`);\n    }\n    return url;\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdob3N0ZXJ5L3VybC1wYXJzZXIvZGlzdC9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxtQkFBbUIsK0NBQVUsSUFBSSxhQUFhLEVBQUUsWUFBWSxFQUFFLGNBQWMsRUFBRSxhQUFhLEVBQUUsV0FBVyxFQUFFLFNBQVM7QUFDbkg7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmlkbGl0ZS8uL25vZGVfbW9kdWxlcy9AZ2hvc3RlcnkvdXJsLXBhcnNlci9kaXN0L2VzbS91dGlscy5qcz80YTdlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNdXRhYmxlVVJMIGZyb20gJy4vdXJsLmpzJztcbi8qKlxuICogQ2hlY2tzIGlmIHRoaXMgVVJMJ3MgaG9zdG5hbWUgaXMgbm9uLWFzY2lpLCBhbmQgaWYgc28gcmV0dXJucyBhIG5ldyBVUkwgd2l0aCB0aGUgaG9zdG5hbWVcbiAqIHB1bnljb2RlZC4gT3RoZXJ3aXNlIHJldHVybnMgaXRzZWxmLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHVueWNvZGVFbmNvZGVkKHRvQVNDSUksIHVybCkge1xuICAgIGNvbnN0IHB1bnljb2RlZEhvc3QgPSB0b0FTQ0lJKHVybC5ob3N0bmFtZSk7XG4gICAgaWYgKHB1bnljb2RlZEhvc3QgIT09IHVybC5ob3N0bmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IE11dGFibGVVUkwoYCR7dXJsLnByb3RvY29sfSR7dXJsLnNsYXNoZXN9JHtwdW55Y29kZWRIb3N0fSR7dXJsLnBhdGhuYW1lfSR7dXJsLnNlYXJjaH0ke3VybC5oYXNofWApO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ghostery/url-parser/dist/esm/utils.js\n");

/***/ })

};
;